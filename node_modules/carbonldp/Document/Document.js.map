{"version":3,"sources":["Document/Document.ts"],"names":[],"mappings":";;AAKA,iDAAgD;AAIhD,0DAAyD;AAUzD,qEAAoE;AAEpE,kCAAoC;AAEpC,uCAAsC;AACtC,2CAA0C;AAC1C,2CAA0C;AAI1C,gFAA+E;AAC/E,0EAAyE;AACzE,oEAAmE;AAEnE,yDAAwD;AA6N3C,QAAA,QAAQ,GAAmB;IACvC,IAAI,EAAE,KAAC,CAAC,QAAQ;IAChB,MAAM,EAAE;QACP,UAAU,EAAE;YACX,KAAK,EAAE,SAAG,CAAC,QAAQ;YACnB,YAAY,EAAE,MAAM;YACpB,OAAO,EAAE,KAAK;SACd;QACD,SAAS,EAAE;YACV,KAAK,EAAE,SAAG,CAAC,MAAM;YACjB,YAAY,EAAE,MAAM;YACpB,OAAO,EAAE,KAAK;SACd;QACD,oBAAoB,EAAE;YACrB,KAAK,EAAE,SAAG,CAAC,kBAAkB;YAC7B,OAAO,EAAE,KAAK;SACd;QACD,oBAAoB,EAAE;YACrB,KAAK,EAAE,SAAG,CAAC,kBAAkB;YAC7B,OAAO,EAAE,KAAK;SACd;QACD,mBAAmB,EAAE;YACpB,KAAK,EAAE,SAAG,CAAC,iBAAiB;YAC5B,OAAO,EAAE,KAAK;SACd;QACD,yBAAyB,EAAE;YAC1B,KAAK,EAAE,SAAG,CAAC,uBAAuB;YAClC,OAAO,EAAE,KAAK;SACd;QACD,SAAS,EAAE;YACV,KAAK,EAAE,KAAC,CAAC,OAAO;YAChB,OAAO,EAAE,SAAG,CAAC,QAAQ;SACrB;QACD,UAAU,EAAE;YACX,KAAK,EAAE,KAAC,CAAC,QAAQ;YACjB,OAAO,EAAE,SAAG,CAAC,QAAQ;SACrB;QACD,yBAAyB,EAAE;YAC1B,KAAK,EAAE,KAAC,CAAC,uBAAuB;YAChC,OAAO,EAAE,KAAK;SACd;QACD,cAAc,EAAE;YACf,KAAK,EAAE,KAAC,CAAC,WAAW;YACpB,OAAO,EAAE,KAAK;YACd,YAAY,EAAE,MAAM;SACpB;KACD;IAED,SAAS,EAAE;QACV,IAAI,iBAAiB,KAAgB,OAAO,EAAE,CAAC,CAAC,CAAC;QAEjD,oBAAoB,EAApB;YACC,IAAI,CAAC,iBAAiB,GAAG,KAAK;iBAC5B,IAAI,CAAE,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAE,CAAC;YAExC,IAAI,CAAC,iBAAiB;iBACpB,OAAO,CAAE,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,cAAc,EAAE,EAAzB,CAAyB,CAAE,CAAC;QACpD,CAAC;QAGD,cAAc,EAAd;YACC,qCAAiB,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAE,IAAI,CAAE,CAAC;YACxD,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC7B,CAAC;QAED,QAAQ,EAAR;YAAA,iBAgBC;YAfA,IAAM,WAAW,GAAW,qCAAiB,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAE,IAAI,CAAE,CAAC;YAC9E,IAAI,WAAW;gBAAG,OAAO,IAAI,CAAC;YAE9B,IAAM,mBAAmB,GAAW,IAAI;iBACtC,iBAAiB;iBACjB,IAAI,CAAE,UAAA,QAAQ,IAAI,OAAA,CAAE,KAAI,CAAC,YAAY,CAAE,QAAQ,CAAC,GAAG,CAAE,EAAnC,CAAmC,CAAE,CAAC;YAC1D,IAAI,mBAAmB;gBAAG,OAAO,IAAI,CAAC;YAEtC,IAAM,eAAe,GAAW,IAAI;iBAClC,iBAAiB,CAAC,MAAM,KAAK,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC;YACzD,IAAI,eAAe;gBAAG,OAAO,IAAI,CAAC;YAElC,OAAO,IAAI;iBACT,iBAAiB;iBACjB,IAAI,CAAE,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,QAAQ,EAAE,EAAnB,CAAmB,CAAE,CAAC;QAC3C,CAAC;QAED,OAAO,EAAP;YAAA,iBAUC;YATA,qCAAiB,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAE,IAAI,CAAE,CAAC;YAEjD,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;YAC7B,IAAI;iBACF,iBAAiB;iBACjB,OAAO,CAAE,UAAA,QAAQ;gBACjB,QAAQ,CAAC,OAAO,EAAE,CAAC;gBACnB,KAAI,CAAC,eAAe,CAAC,GAAG,CAAE,QAAQ,CAAC,KAAK,EAAE,QAAQ,CAAE,CAAC;YACtD,CAAC,CAAE,CAAC;QACN,CAAC;KACD;IAGD,WAAW,EAAX,UAAa,MAAa;QACzB,OAAO,gBAAQ,CAAE,MAAM,CAAE;eACrB,+BAAc;iBACf,iBAAiB,CAAE,gBAAQ,CAAC,SAAS,EAAE,MAAM,CAAE,CAChD;IACH,CAAC;IAED,EAAE,EAAF,UAAI,MAAa;QAChB,OAAO,qCAAiB,CAAC,EAAE,CAAE,MAAM,CAAE;eACjC,yCAAmB,CAAC,WAAW,CAAE,MAAM,CAAE;eACzC,qDAAyB,CAAC,WAAW,CAAE,MAAM,CAAE;eAC/C,+CAAsB,CAAC,WAAW,CAAE,MAAM,CAAE;eAC5C,gBAAQ,CAAC,WAAW,CAAE,MAAM,CAAE,CAChC;IACH,CAAC;IAGD,QAAQ,EAAR,UAA4C,MAAQ;QACnD,IAAI,gBAAQ,CAAC,WAAW,CAAE,MAAM,CAAE;YAAG,OAAO,MAAM,CAAC;QAGnD,IAAM,IAAI,GAAW,MAAM,CAAC,MAAM,CAAE,MAA2B,EAAE;YAChE,iBAAiB,EAAE,mBAAQ;SAC3B,CAAE,CAAC;QAEJ,IAAM,MAAM,GAAsF,+BAAc;aAC9G,gBAAgB,CAAE,IAAI,EAAE,yCAAmB,EAAE,qDAAyB,EAAE,+CAAsB,CAAE,CAAC;QAEnG,OAAO,+BAAc;aACnB,oBAAoB,CAAE,gBAAQ,CAAC,SAAS,EAAE,MAAM,CAAE,CAAC;IACtD,CAAC;IAGD,MAAM,EAAE,qCAAiB,CAAC,MAAM;IAChC,UAAU,EAAE,qCAAiB,CAAC,UAAU;CACxC,CAAC","file":"Document.js","sourcesContent":["import { AccessPoint } from \"../AccessPoint/AccessPoint\";\n\nimport { DocumentsRegistry } from \"../DocumentsRegistry/DocumentsRegistry\";\nimport { DocumentsRepository } from \"../DocumentsRepository/DocumentsRepository\";\n\nimport { Fragment } from \"../Fragment/Fragment\";\n\nimport { GETOptions, RequestOptions } from \"../HTTP/Request\";\n\nimport { ModelDecorator } from \"../Model/ModelDecorator\";\nimport { ModelFactory } from \"../Model/ModelFactory\";\nimport { ModelPrototype } from \"../Model/ModelPrototype\";\nimport { ModelSchema } from \"../Model/ModelSchema\";\nimport { ModelTypeGuard } from \"../Model/ModelTypeGuard\";\n\nimport { QueryDocumentBuilder } from \"../QueryDocuments/QueryDocumentBuilder\";\n\nimport { RegisteredPointer } from \"../Registry/RegisteredPointer\";\nimport { $Registry } from \"../Registry/Registry\";\nimport { ResolvablePointer } from \"../Repository/ResolvablePointer\";\n\nimport { isObject } from \"../Utils\";\n\nimport { C } from \"../Vocabularies/C\";\nimport { LDP } from \"../Vocabularies/LDP\";\nimport { XSD } from \"../Vocabularies/XSD\";\n\nimport { BaseDocument } from \"./BaseDocument\";\n\nimport { EventEmitterDocumentTrait } from \"./Traits/EventEmitterDocumentTrait\";\nimport { QueryableDocumentTrait } from \"./Traits/QueryableDocumentTrait\";\nimport { SPARQLDocumentTrait } from \"./Traits/SPARQLDocumentTrait\";\n\nimport { TransientDocument } from \"./TransientDocument\";\n\n\n/**\n * Required properties for creating a {@link Document} object.\n */\nexport interface BaseResolvableDocument extends BaseDocument {\n\t/**\n\t * Registry where the created {@link Document} will exist.\n\t */\n\t$registry:DocumentsRegistry;\n\t/**\n\t * Repository where the created {@link Document} can manage its data.\n\t */\n\t$repository:DocumentsRepository;\n}\n\n\n/**\n * Model that represents a `c:Document`.\n */\nexport interface Document extends $Registry<Fragment>, QueryableDocumentTrait, SPARQLDocumentTrait, EventEmitterDocumentTrait {\n\t/**\n\t * Registry where the document exists.\n\t */\n\t$registry:DocumentsRegistry;\n\t/**\n\t * Repository where the document can manage its data.\n\t */\n\t$repository:DocumentsRepository;\n\n\n\t/**\n\t * @see {@ink $Registry.$__modelDecorator}\n\t */\n\t$__modelDecorator:ModelDecorator<Fragment>;\n\t/**\n\t * @see {@link $Registry.$__resourcesMap}\n\t */\n\t$__resourcesMap:Map<string, Fragment>;\n\t/**\n\t * Array with the fragments that has been persisted.\n\t */\n\t$__savedFragments:Fragment[];\n\n\n\t/**\n\t * Datetime when the document was persisted.\n\t */\n\tcreated?:Date;\n\t/**\n\t * Last datetime when the document was modified.\n\t */\n\tmodified?:Date;\n\t/**\n\t * Set with the access points of the document.\n\t */\n\taccessPoints?:AccessPoint[];\n\t/**\n\t * Set with the children of the document.\n\t */\n\tcontains?:Document[];\n\n\n\t/**\n\t * @see {@link $Registry.$getPointer}\n\t */\n\t$getPointer( id:string ):RegisteredPointer;\n\t$getPointer( id:string, local:true ):Fragment;\n\n\t/**\n\t * @see {@link $Registry.$getPointers}\n\t */\n\t$getPointers():RegisteredPointer[];\n\t$getPointers( local:true ):Fragment[];\n\n\n\t/**\n\t * Makes all the current fragments in the document as fragments\n\t * that has been persisted in the served.\n\t */\n\t$_syncSavedFragments():void;\n\n\t/**\n\t * @see {@link TransientDocument.$getFragment}\n\t */\n\t$getFragment<T extends object>( id:string ):(T & Fragment) | null;\n\n\t/**\n\t * @see {@link TransientDocument.$getFragments}\n\t */\n\t$getFragments():Fragment[];\n\n\t/**\n\t * @see {@link TransientDocument.$createFragment}\n\t */\n\t$createFragment<T extends object>( object:T, id?:string ):T & Fragment;\n\t$createFragment( slug?:string ):Fragment;\n\n\t/**\n\t * @see {@link TransientDocument.$removeFragment}\n\t */\n\t$removeFragment( slugOrFragment:string | Fragment ):boolean;\n\n\n\t/**\n\t * @see {@link QueryableDocumentTrait.$get}\n\t */\n\t$get<T extends object>( queryBuilderFn:( queryBuilder:QueryDocumentBuilder ) => QueryDocumentBuilder ):Promise<T & Document>;\n\t$get<T extends object>( requestOptions?:GETOptions, queryBuilderFn?:( queryBuilder:QueryDocumentBuilder ) => QueryDocumentBuilder ):Promise<T & Document>;\n\t$get<T extends object>( uri:string, queryBuilderFn:( queryBuilder:QueryDocumentBuilder ) => QueryDocumentBuilder ):Promise<T & Document>;\n\t$get<T extends object>( uri:string, requestOptions?:GETOptions, queryBuilderFn?:( queryBuilder:QueryDocumentBuilder ) => QueryDocumentBuilder ):Promise<T & Document>;\n\t$get<T extends object>( uris:string[], queryBuilderFn:( queryBuilder:QueryDocumentBuilder ) => QueryDocumentBuilder ):Promise<(T & Document)[]>;\n\t$get<T extends object>( uris:string[], requestOptions?:GETOptions, queryBuilderFn?:( queryBuilder:QueryDocumentBuilder ) => QueryDocumentBuilder ):Promise<(T & Document)[]>;\n\n\t/**\n\t * @see {@link QueryableDocumentTrait.$resolve}\n\t */\n\t$resolve<T extends object>( requestOptions?:GETOptions, queryBuilderFn?:( queryBuilder:QueryDocumentBuilder ) => QueryDocumentBuilder ):Promise<T & this & Document>;\n\t$resolve<T extends object>( queryBuilderFn?:( queryBuilder:QueryDocumentBuilder ) => QueryDocumentBuilder ):Promise<T & this & Document>;\n\t$resolve<T extends object>( document:Document, queryBuilderFn:( queryBuilder:QueryDocumentBuilder ) => QueryDocumentBuilder ):Promise<T & Document>;\n\t$resolve<T extends object>( document:Document, requestOptions?:GETOptions, queryBuilderFn?:( queryBuilder:QueryDocumentBuilder ) => QueryDocumentBuilder ):Promise<T & Document>;\n\n\t/**\n\t * Checks if the current document exists.\n\t * @param requestOptions Customizable options for the request.\n\t */\n\t$exists( requestOptions?:RequestOptions ):Promise<boolean>;\n\t/**\n\t * Checks if the document of the specified URI exists.\n\t * @param uri The URI of the document to check its existence.\n\t * @param requestOptions Customizable options for the request.\n\t */\n\t$exists( uri:string, requestOptions?:RequestOptions ):Promise<boolean>;\n\n\n\t/**\n\t * Refreshes with the latest data of the current document.\n\t * If the document was retrieved partially, only the partial properties will be refreshed.\n\t * @param requestOptions Customizable options for the request.\n\t */\n\t$refresh<T extends object>( requestOptions?:RequestOptions ):Promise<T & this>;\n\t/**\n\t * Refreshes with the latest data of the specified document.\n\t * If the document was retrieved partially, only the partial properties will be refreshed.\n\t * @param document The document to be refreshed.\n\t * @param requestOptions Customizable options for the request.\n\t */\n\t$refresh<T extends object>( document:Document, requestOptions?:RequestOptions ):Promise<T & Document>;\n\n\t/**\n\t * Saves the changes of the current document.\n\t * @param requestOptions Customizable options for the request.\n\t */\n\t$save<T extends object>( requestOptions?:RequestOptions ):Promise<T & this>;\n\t/**\n\t * Saves the changes of the specified document.\n\t * @param document The document to be saved.\n\t * @param requestOptions Customizable options for the request.\n\t */\n\t$save<T extends object>( document:Document, requestOptions?:RequestOptions ):Promise<T & Document>;\n\n\t/**\n\t * Saves the changes of the current document and retrieves its latest changes.\n\t * If the document was retrieved partially, only the partial properties will be refreshed.\n\t * @param requestOptions Customizable options for the request.\n\t */\n\t$saveAndRefresh<T extends object>( requestOptions?:RequestOptions ):Promise<T & this>;\n\t/**\n\t * Saves the changes of the specified document and retrieves its latest changes.\n\t * If the document was retrieved partially, only the partial properties will be refreshed.\n\t * @param document The resource to saved and refreshed.\n\t * @param requestOptions Customizable options for the request.\n\t */\n\t$saveAndRefresh<T extends object>( document:Document, requestOptions?:RequestOptions ):Promise<T & Document>;\n\n\n\t/**\n\t * Deletes the current document.\n\t * @param requestOptions Customizable options for the request.\n\t */\n\t$delete( requestOptions?:RequestOptions ):Promise<void>;\n\t/**\n\t * Deletes the document of the specified URI.\n\t * @param uri URI of the document to be deleted.\n\t * @param requestOptions Customizable options for the request.\n\t */\n\t$delete( uri:string, requestOptions?:RequestOptions ):Promise<void>;\n}\n\n\ntype ForcedMembers = Pick<Document,\n\t| \"$__resourcesMap\"\n\t| \"$getPointer\"\n\t| \"$getPointers\"\n\t| \"$getFragment\"\n\t| \"$getFragments\"\n\t| \"$createFragment\"\n\t| \"$removeFragment\"\n\t| never>;\n\nexport type OverriddenMembers =\n\t| \"$_syncSnapshot\"\n\t| \"$isDirty\"\n\t| \"$revert\"\n\t;\n\n/**\n * Factory, decorator and utils for {@link Document} objects.\n */\nexport type DocumentFactory =\n\t& ModelSchema<C[ \"Document\" ]>\n\t& ModelPrototype<Document, SPARQLDocumentTrait & EventEmitterDocumentTrait & QueryableDocumentTrait, OverriddenMembers>\n\t& ModelDecorator<Document, BaseResolvableDocument>\n\t& ModelTypeGuard<Document>\n\t& ModelFactory<TransientDocument, BaseDocument>\n\t;\n\n/**\n * Constant that implements {@link DocumentFactory}.\n */\nexport const Document:DocumentFactory = {\n\tTYPE: C.Document,\n\tSCHEMA: {\n\t\t\"contains\": {\n\t\t\t\"@id\": LDP.contains,\n\t\t\t\"@container\": \"@set\",\n\t\t\t\"@type\": \"@id\",\n\t\t},\n\t\t\"members\": {\n\t\t\t\"@id\": LDP.member,\n\t\t\t\"@container\": \"@set\",\n\t\t\t\"@type\": \"@id\",\n\t\t},\n\t\t\"membershipResource\": {\n\t\t\t\"@id\": LDP.membershipResource,\n\t\t\t\"@type\": \"@id\",\n\t\t},\n\t\t\"isMemberOfRelation\": {\n\t\t\t\"@id\": LDP.isMemberOfRelation,\n\t\t\t\"@type\": \"@id\",\n\t\t},\n\t\t\"hasMemberRelation\": {\n\t\t\t\"@id\": LDP.hasMemberRelation,\n\t\t\t\"@type\": \"@id\",\n\t\t},\n\t\t\"insertedContentRelation\": {\n\t\t\t\"@id\": LDP.insertedContentRelation,\n\t\t\t\"@type\": \"@id\",\n\t\t},\n\t\t\"created\": {\n\t\t\t\"@id\": C.created,\n\t\t\t\"@type\": XSD.dateTime,\n\t\t},\n\t\t\"modified\": {\n\t\t\t\"@id\": C.modified,\n\t\t\t\"@type\": XSD.dateTime,\n\t\t},\n\t\t\"defaultInteractionModel\": {\n\t\t\t\"@id\": C.defaultInteractionModel,\n\t\t\t\"@type\": \"@id\",\n\t\t},\n\t\t\"accessPoints\": {\n\t\t\t\"@id\": C.accessPoint,\n\t\t\t\"@type\": \"@id\",\n\t\t\t\"@container\": \"@set\",\n\t\t},\n\t},\n\n\tPROTOTYPE: {\n\t\tget $__savedFragments():Fragment[] { return []; },\n\n\t\t$_syncSavedFragments( this:Document ):void {\n\t\t\tthis.$__savedFragments = Array\n\t\t\t\t.from( this.$__resourcesMap.values() );\n\n\t\t\tthis.$__savedFragments\n\t\t\t\t.forEach( fragment => fragment.$_syncSnapshot() );\n\t\t},\n\n\n\t\t$_syncSnapshot( this:Document ):void {\n\t\t\tResolvablePointer.PROTOTYPE.$_syncSnapshot.call( this );\n\t\t\tthis.$_syncSavedFragments();\n\t\t},\n\n\t\t$isDirty( this:Document ):boolean {\n\t\t\tconst isSelfDirty:boolean = ResolvablePointer.PROTOTYPE.$isDirty.call( this );\n\t\t\tif( isSelfDirty ) return true;\n\n\t\t\tconst hasRemovedFragments:boolean = this\n\t\t\t\t.$__savedFragments\n\t\t\t\t.some( fragment => ! this.$hasFragment( fragment.$id ) );\n\t\t\tif( hasRemovedFragments ) return true;\n\n\t\t\tconst hasNewFragments:boolean = this\n\t\t\t\t.$__savedFragments.length !== this.$__resourcesMap.size;\n\t\t\tif( hasNewFragments ) return true;\n\n\t\t\treturn this\n\t\t\t\t.$__savedFragments\n\t\t\t\t.some( fragment => fragment.$isDirty() );\n\t\t},\n\n\t\t$revert( this:Document ):void {\n\t\t\tResolvablePointer.PROTOTYPE.$revert.call( this );\n\n\t\t\tthis.$__resourcesMap.clear();\n\t\t\tthis\n\t\t\t\t.$__savedFragments\n\t\t\t\t.forEach( fragment => {\n\t\t\t\t\tfragment.$revert();\n\t\t\t\t\tthis.$__resourcesMap.set( fragment.$slug, fragment );\n\t\t\t\t} );\n\t\t},\n\t},\n\n\n\tisDecorated( object:object ):object is Document {\n\t\treturn isObject( object )\n\t\t\t&& ModelDecorator\n\t\t\t\t.hasPropertiesFrom( Document.PROTOTYPE, object )\n\t\t\t;\n\t},\n\n\tis( object:object ):object is Document {\n\t\treturn TransientDocument.is( object )\n\t\t\t&& SPARQLDocumentTrait.isDecorated( object )\n\t\t\t&& EventEmitterDocumentTrait.isDecorated( object )\n\t\t\t&& QueryableDocumentTrait.isDecorated( object )\n\t\t\t&& Document.isDecorated( object )\n\t\t\t;\n\t},\n\n\n\tdecorate<T extends BaseResolvableDocument>( object:T ):T & Document {\n\t\tif( Document.isDecorated( object ) ) return object;\n\n\t\ttype ForcedT = T & ForcedMembers & Pick<Document, \"$__modelDecorator\">;\n\t\tconst base:ForcedT = Object.assign( object as T & ForcedMembers, {\n\t\t\t$__modelDecorator: Fragment,\n\t\t} );\n\n\t\tconst target:ForcedT & SPARQLDocumentTrait & EventEmitterDocumentTrait & QueryableDocumentTrait = ModelDecorator\n\t\t\t.decorateMultiple( base, SPARQLDocumentTrait, EventEmitterDocumentTrait, QueryableDocumentTrait );\n\n\t\treturn ModelDecorator\n\t\t\t.definePropertiesFrom( Document.PROTOTYPE, target );\n\t},\n\n\n\tcreate: TransientDocument.create,\n\tcreateFrom: TransientDocument.createFrom,\n};\n"],"sourceRoot":"../../src"}