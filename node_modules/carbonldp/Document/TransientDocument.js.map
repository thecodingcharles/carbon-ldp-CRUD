{"version":3,"sources":["Document/TransientDocument.ts"],"names":[],"mappings":"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","file":"TransientDocument.js","sourcesContent":["import { isRelative } from \"sparqler/iri\";\n\nimport { Context } from \"../Context/Context\";\n\nimport { DocumentsRegistry } from \"../DocumentsRegistry/DocumentsRegistry\";\n\nimport { IllegalArgumentError } from \"../Errors/IllegalArgumentError\";\n\nimport { TransientFragment } from \"../Fragment/TransientFragment\";\n\nimport { ModelDecorator } from \"../Model/ModelDecorator\";\nimport { ModelFactoryOptional } from \"../Model/ModelFactoryOptional\";\nimport { ModelPrototype } from \"../Model/ModelPrototype\";\nimport { ModelTypeGuard } from \"../Model/ModelTypeGuard\";\n\nimport { Pointer } from \"../Pointer/Pointer\";\n\nimport { RDFDocument } from \"../RDF/Document\";\nimport { RDFNode } from \"../RDF/Node\";\nimport { URI } from \"../RDF/URI\";\n\nimport { $BaseRegistry } from \"../Registry/BaseRegistry\";\nimport { $Registry, Registry } from \"../Registry/Registry\";\n\nimport { Resource } from \"../Resource/Resource\";\n\nimport { isObject, isPlainObject, isString } from \"../Utils\";\n\nimport { BaseDocument } from \"./BaseDocument\";\n\n\n/**\n * In-memory model that represents a `c:Document`.\n */\nexport interface TransientDocument extends Resource, $Registry<TransientFragment> {\n\t/**\n\t * Registry where the resource will exits.\n\t */\n\t$registry:DocumentsRegistry | undefined;\n\n\t/**\n\t * @see {@link BaseDocument.hasMemberRelation}\n\t */\n\thasMemberRelation?:Pointer;\n\t/**\n\t * @see {@link BaseDocument.hasMemberRelation}\n\t */\n\tisMemberOfRelation?:Pointer;\n\t/**\n\t * @see {@link BaseDocument.isMemberOfRelation}\n\t */\n\tinsertedContentRelation?:Pointer;\n\t/**\n\t * @see {@link BaseDocument.defaultInteractionModel}\n\t */\n\tdefaultInteractionModel?:Pointer;\n\n\n\t/**\n\t * Returns true if the document has a fragment with the ID specified.\n\t * @param id The ID of the fragment to check if exists.\n\t */\n\t$hasFragment( id:string ):boolean;\n\n\t/**\n\t * Returns the fragment with the ID specified.\n\t * If no fragment exists, `null` will be returned.\n\t * @param id The ID of the fragment to look for.\n\t */\n\t$getFragment<T extends object>( id:string ):(T & TransientFragment) | null;\n\n\t/**\n\t * Returns an array with all the fragments in the document.\n\t */\n\t$getFragments():TransientFragment[];\n\n\t/**\n\t * Creates a {@link TransientFragment} from the object and ID specified.\n\t * @param object The object to be converted into a fragment.\n\t * @param id Optional ID to be set for the fragment, if no provided a random BNode label will be assigned.\n\t */\n\t$createFragment<T extends object>( object:T, id?:string ):T & TransientFragment;\n\t/**\n\t * Creates a {@link TransientFragment} with the ID specified.\n\t * @param id Optional ID to be set for the fragment, if no provided a random BNode label will be assigned.\n\t */\n\t$createFragment( id?:string ):TransientFragment;\n\n\t/**\n\t * Removes the fragment provided from the document.\n\t * If a string is provided, it will be used as the ID of the fragment to be removed.\n\t * @param idOrFragment\n\t */\n\t$removeFragment( idOrFragment:string | TransientFragment ):boolean;\n\n\n\t/**\n\t * Search over the document for normal object and converted them into fragments.\n\t * If unused fragments with BNode label as ID are detected, they will be removed from the document.\n\t */\n\t$_normalize():void;\n\n\n\t/**\n\t * @see {@link $Registry.$_getLocalID}\n\t */\n\t$_getLocalID( id:string ):string;\n\n\n\t/**\n\t * Returns the JSON-LD representation of the current document.\n\t * @param contextOrKey A specific context to use for expand the data into JSON-LD instead of the internal one.\n\t */\n\ttoJSON( contextOrKey?:Context | string ):RDFDocument;\n}\n\n\nfunction __getLabelFrom( slug:string ):string {\n\tif( ! isRelative( slug ) || slug.startsWith( \"#\" ) ) return slug;\n\treturn \"#\" + slug;\n}\n\nfunction __getObjectId( object:{ $id?:string, $slug?:string } ):string {\n\tif( \"$id\" in object ) return object.$id!;\n\n\tif( \"$slug\" in object ) return URI.hasFragment( object.$slug! ) ?\n\t\tobject.$slug! : __getLabelFrom( object.$slug! );\n\n\treturn URI.generateBNodeID();\n}\n\nfunction __convertNested( resource:TransientDocument, target:object, tracker:Set<string> = new Set() ):void {\n\tObject\n\t\t.keys( target )\n\t\t.map( key => target[ key ] )\n\t\t.forEach( next => {\n\t\t\tif( Array.isArray( next ) )\n\t\t\t\treturn __convertNested( resource, next, tracker );\n\n\n\t\t\tif( ! isPlainObject( next ) ) return;\n\t\t\tif( TransientDocument.is( next ) ) return;\n\t\t\tif( next._registry && next._registry !== resource ) return;\n\n\n\t\t\tconst idOrSlug:string = __getObjectId( next );\n\t\t\tif( tracker.has( idOrSlug ) ) return;\n\t\t\tif( ! resource.$inScope( idOrSlug, true ) ) return;\n\n\n\t\t\tconst fragment:TransientFragment = resource.$hasPointer( idOrSlug, true ) ?\n\t\t\t\tresource.$getPointer( idOrSlug, true ) :\n\t\t\t\tresource.$createFragment( next, idOrSlug )\n\t\t\t;\n\n\t\t\ttracker.add( fragment.$id );\n\t\t\t__convertNested( resource, fragment, tracker );\n\t\t} )\n\t;\n}\n\nexport type OverriddenMembers =\n\t| \"$registry\"\n\t| \"$_getLocalID\"\n\t| \"$getPointer\"\n\t| \"toJSON\"\n\t;\n\n/**\n * Factory, decorator and utils for {@link TransientDocument} objects.\n */\nexport type TransientDocumentFactory =\n\t& ModelPrototype<TransientDocument, Resource & $Registry<TransientFragment>, OverriddenMembers>\n\t& ModelDecorator<TransientDocument, BaseDocument>\n\t& ModelFactoryOptional<TransientDocument, BaseDocument>\n\t& ModelTypeGuard<TransientDocument>\n\t;\n\n/**\n * Constant that implements {@link TransientDocumentFactory}.\n */\nexport const TransientDocument:TransientDocumentFactory = {\n\tPROTOTYPE: {\n\t\t$registry: void 0,\n\n\t\t$_normalize( this:TransientDocument ):void {\n\t\t\tconst usedFragments:Set<string> = new Set();\n\t\t\t__convertNested( this, this, usedFragments );\n\n\t\t\tthis.$getPointers( true )\n\t\t\t\t.map( Pointer.getID )\n\t\t\t\t.filter( URI.isBNodeID )\n\t\t\t\t.filter( id => ! usedFragments.has( id ) )\n\t\t\t\t.forEach( this.$removePointer, this )\n\t\t\t;\n\t\t},\n\n\n\t\t$_getLocalID( this:TransientDocument, id:string ):string {\n\t\t\tif( URI.isBNodeID( id ) ) return id;\n\n\t\t\tif( URI.isFragmentOf( id, this.$id ) ) return URI.getFragment( id );\n\n\t\t\tthrow new IllegalArgumentError( `\"${id}\" is out of scope.` );\n\t\t},\n\n\t\t$getPointer( this:TransientDocument, id:string, local?:true ):TransientFragment {\n\t\t\tid = URI.resolve( this.$id, id );\n\t\t\treturn Registry.PROTOTYPE.getPointer.call( this, id, local! );\n\t\t},\n\n\n\t\t$hasFragment( this:TransientDocument, id:string ):boolean {\n\t\t\tid = __getLabelFrom( id );\n\t\t\tif( ! this.$inScope( id, true ) ) return false;\n\n\t\t\tconst localID:string = this.$_getLocalID( id );\n\t\t\treturn this.$__resourcesMap.has( localID );\n\t\t},\n\n\t\t$getFragment<T extends object>( this:TransientDocument, id:string ):(T & TransientFragment) | null {\n\t\t\tid = __getLabelFrom( id );\n\t\t\tconst localID:string = this.$_getLocalID( id );\n\n\t\t\tconst resource:TransientFragment | undefined = this.$__resourcesMap.get( localID );\n\t\t\tif( ! resource ) return null;\n\n\t\t\treturn resource as T & TransientFragment;\n\t\t},\n\n\t\t$getFragments( this:TransientDocument ):TransientFragment[] {\n\t\t\treturn this.$getPointers( true );\n\t\t},\n\n\t\t$createFragment<T extends object>( this:TransientDocument, isOrObject?:string | T, id?:string ):T & TransientFragment {\n\t\t\tconst object:T = isObject( isOrObject ) ? isOrObject : {} as T;\n\t\t\tif( isString( isOrObject ) ) id = isOrObject;\n\n\t\t\tconst $id:string = id ? __getLabelFrom( id ) : __getObjectId( object );\n\t\t\tconst fragment:T & TransientFragment = this.$_addPointer( Object\n\t\t\t\t.assign<T, Pointer>( object, { $id } )\n\t\t\t);\n\n\t\t\t__convertNested( this, fragment );\n\t\t\treturn fragment;\n\t\t},\n\n\t\t$removeFragment( this:TransientDocument, fragmentOrSlug:string | TransientFragment ):boolean {\n\t\t\tconst id:string = __getLabelFrom( Pointer.getID( fragmentOrSlug ) );\n\t\t\tif( ! this.$inScope( id, true ) ) return false;\n\n\t\t\treturn this.$removePointer( id );\n\t\t},\n\n\n\t\ttoJSON( this:TransientDocument, contextOrKey:Context | string ):RDFDocument {\n\t\t\tconst nodes:RDFNode[] = [\n\t\t\t\tResource.PROTOTYPE.toJSON.call( this, contextOrKey ),\n\t\t\t\t...this\n\t\t\t\t\t.$getFragments()\n\t\t\t\t\t.map( resource => resource.toJSON( contextOrKey ) ),\n\t\t\t];\n\n\t\t\treturn {\n\t\t\t\t\"@id\": this.$id,\n\t\t\t\t\"@graph\": nodes,\n\t\t\t};\n\t\t},\n\t},\n\n\tisDecorated( object:object ):object is TransientDocument {\n\t\treturn ModelDecorator\n\t\t\t.hasPropertiesFrom( TransientDocument.PROTOTYPE, object );\n\t},\n\n\tdecorate<T extends BaseDocument>( object:T ):T & TransientDocument {\n\t\tif( TransientDocument.isDecorated( object ) ) return object;\n\n\t\ttype Base = T & Pick<$BaseRegistry<TransientFragment>, \"$__modelDecorator\">;\n\t\tconst base:Base = ModelDecorator.definePropertiesFrom<Pick<$BaseRegistry<TransientFragment>, \"$__modelDecorator\">, T>( {\n\t\t\t$__modelDecorator: TransientFragment,\n\t\t}, object );\n\n\t\tconst resource:Base & Resource & $Registry<TransientFragment> = ModelDecorator\n\t\t\t.decorateMultiple( base, Resource, Registry as ModelDecorator<$Registry<TransientFragment>, $BaseRegistry> );\n\n\t\treturn ModelDecorator\n\t\t\t.definePropertiesFrom( TransientDocument.PROTOTYPE, resource )\n\t\t\t;\n\t},\n\n\n\tis: ( value ):value is TransientDocument =>\n\t\tResource.is( value ) &&\n\t\tRegistry.isDecorated( value ) &&\n\t\tTransientDocument.isDecorated( value )\n\t,\n\n\tcreateFrom: <T extends object>( object:T & BaseDocument ) => {\n\t\tif( TransientDocument.is( object ) ) throw new IllegalArgumentError( \"The object provided is already a Document.\" );\n\n\t\tconst document:T & TransientDocument = TransientDocument.decorate<T>( object );\n\n\t\t__convertNested( document, document );\n\t\treturn document;\n\t},\n\n\tcreate: <T extends object>( data?:T & BaseDocument ) => {\n\t\tconst copy:T = Object.assign( {}, data );\n\t\treturn TransientDocument.createFrom( copy );\n\t},\n};\n"],"sourceRoot":"../../src"}