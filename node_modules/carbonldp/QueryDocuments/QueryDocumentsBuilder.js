"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var IllegalArgumentError_1 = require("../Errors/IllegalArgumentError");
var QueryDocumentBuilder_1 = require("./QueryDocumentBuilder");
var QueryDocumentsBuilder = (function (_super) {
    tslib_1.__extends(QueryDocumentsBuilder, _super);
    function QueryDocumentsBuilder(queryContainer, queryProperty) {
        return _super.call(this, queryContainer, queryProperty) || this;
    }
    QueryDocumentsBuilder.prototype.orderBy = function (property, flow) {
        this._queryProperty.setOrder({
            path: property,
            flow: parseFlowString(flow),
        });
        return this;
    };
    QueryDocumentsBuilder.prototype.limit = function (limit) {
        this._queryProperty.setLimit(limit);
        return this;
    };
    QueryDocumentsBuilder.prototype.offset = function (offset) {
        this._queryProperty.setOffset(offset);
        return this;
    };
    return QueryDocumentsBuilder;
}(QueryDocumentBuilder_1.SubQueryDocumentsBuilder));
exports.QueryDocumentsBuilder = QueryDocumentsBuilder;
function parseFlowString(flow) {
    if (flow === void 0)
        return;
    var upperCase = flow
        .toUpperCase();
    switch (upperCase) {
        case "ASC":
        case "DESC":
            return upperCase;
        case "ASCENDING":
        case "DESCENDING":
            return upperCase
                .slice(0, -6);
        default:
            throw new IllegalArgumentError_1.IllegalArgumentError("Invalid flow order.");
    }
}

//# sourceMappingURL=QueryDocumentsBuilder.js.map
