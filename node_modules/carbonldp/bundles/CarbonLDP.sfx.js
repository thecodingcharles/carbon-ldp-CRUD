(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.CarbonLDP = factory());
}(this, function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function isAbsolute(iri) {
        return iri.indexOf(":") !== -1;
    }
    function hasProtocol(iri) {
        return iri.indexOf("://") !== -1;
    }
    function isRelative(iri) {
        return !isAbsolute(iri);
    }
    function isBNodeLabel(label) {
        return /^_:/.test(label);
    }
    function isPrefixed(iri) {
        return /^(?!_:)[^]*?:/.test(iri) && !hasProtocol(iri);
    }

    function hasFunction(object, functionName) {
        return typeof object[functionName] === "function";
    }
    function hasProperty(object, property) {
        if (!object)
            return false;
        return isDefined(object[property]);
    }
    function hasPropertyDefined(object, property) {
        if (!object)
            return false;
        return !!Object.getOwnPropertyDescriptor(object, property);
    }
    function isDefined(value) {
        return void 0 !== value;
    }
    function isNull(value) {
        return value === null;
    }
    function isArray(object) {
        return Array.isArray(object);
    }
    function isString(value) {
        return typeof value === "string" || value instanceof String;
    }
    function isBoolean(value) {
        return typeof value === "boolean";
    }
    function isNumber(value) {
        return typeof value === "number" || value instanceof Number;
    }
    function isInteger(value) {
        if (!isNumber(value))
            return false;
        return value % 1 === 0;
    }
    function isDouble(value) {
        if (!isNumber(value))
            return false;
        return value % 1 !== 0;
    }
    function isDate(date) {
        return date instanceof Date || (typeof date === "object" && Object.prototype.toString.call(date) === "[object Date]");
    }
    function isObject(object) {
        return typeof object === "object" && (!!object);
    }
    function isPlainObject(object) {
        return isObject(object)
            && !isArray(object)
            && !isDate(object)
            && !isMap(object)
            && !(typeof Blob !== "undefined" && object instanceof Blob)
            && !(Object.prototype.toString.call(object) === "[object Set]");
    }
    function isFunction(value) {
        return typeof value === "function";
    }
    function isMap(value) {
        return (isObject(value) &&
            hasFunction(value, "get") &&
            hasFunction(value, "has") &&
            hasProperty(value, "size") &&
            hasFunction(value, "clear") &&
            hasFunction(value, "delete") &&
            hasFunction(value, "entries") &&
            hasFunction(value, "forEach") &&
            hasFunction(value, "get") &&
            hasFunction(value, "has") &&
            hasFunction(value, "keys") &&
            hasFunction(value, "set") &&
            hasFunction(value, "values"));
    }
    function parseBoolean(value) {
        if (!isString(value))
            return false;
        switch (value.toLowerCase()) {
            case "true":
            case "yes":
            case "y":
            case "1":
                return true;
            case "false":
            case "no":
            case "n":
            case "0":
            default:
                return false;
        }
    }
    function promiseMethod(fn) {
        return new Promise(function (resolve) { return resolve(fn ? fn() : void 0); });
    }
    var ArrayUtils = (function () {
        function ArrayUtils() {
        }
        ArrayUtils.from = function (iterator) {
            var array = [];
            var next = iterator.next();
            while (!next.done) {
                array.push(next.value);
                next = iterator.next();
            }
            return array;
        };
        ArrayUtils.joinWithoutDuplicates = function () {
            var arrays = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                arrays[_i] = arguments[_i];
            }
            var result = arrays[0].slice();
            for (var i = 1, length_1 = arrays.length; i < length_1; i++) {
                result = result.concat(arrays[i].filter(function (item) {
                    return result.indexOf(item) < 0;
                }));
            }
            return result;
        };
        return ArrayUtils;
    }());
    var ObjectUtils = (function () {
        function ObjectUtils() {
        }
        ObjectUtils.extend = function (target, source, config) {
            if (config === void 0) { config = { arrays: false, objects: false }; }
            if (!isArray(source) && !isPlainObject(source) || !isArray(target) && !isPlainObject(target))
                return;
            source.__CarbonSDK_circularReferenceFlag = target;
            for (var _i = 0, _a = Object.keys(source); _i < _a.length; _i++) {
                var key = _a[_i];
                if (isFunction(source[key]) || key === "__CarbonSDK_circularReferenceFlag")
                    continue;
                var property = source[key];
                if (isArray(property) && config.arrays || isPlainObject(property) && config.objects) {
                    if ("__CarbonSDK_circularReferenceFlag" in property) {
                        property = property.__CarbonSDK_circularReferenceFlag;
                    }
                    else {
                        property = !(key in target) || target[key].constructor !== property.constructor ?
                            ObjectUtils.clone(property, config) :
                            ObjectUtils.extend(target[key], property, config);
                    }
                }
                if (property === null) {
                    if (target[key])
                        delete target[key];
                    continue;
                }
                target[key] = property;
            }
            delete source.__CarbonSDK_circularReferenceFlag;
            return target;
        };
        ObjectUtils.clone = function (object, config) {
            if (config === void 0) { config = { arrays: false, objects: false }; }
            var isAnArray = isArray(object);
            if (!isAnArray && !isPlainObject(object))
                return;
            var clone = (isAnArray ? [] : Object.create(Object.getPrototypeOf(object)));
            return ObjectUtils.extend(clone, object, config);
        };
        ObjectUtils.areEqual = function (object1, object2, config, ignore) {
            if (config === void 0) { config = { arrays: false, objects: false }; }
            if (ignore === void 0) { ignore = {}; }
            return internalAreEqual(object1, object2, config, [object1], [object2], ignore);
        };
        ObjectUtils.areShallowlyEqual = function (object1, object2) {
            if (object1 === object2)
                return true;
            if (!isObject(object1) || !isObject(object2))
                return false;
            var properties = [];
            for (var propertyName in object1) {
                if (!object1.hasOwnProperty(propertyName))
                    continue;
                if (isFunction(object1[propertyName]))
                    continue;
                if (!(propertyName in object2))
                    return false;
                if (object1[propertyName] !== object2[propertyName])
                    return false;
                properties.push(propertyName);
            }
            for (var propertyName in object2) {
                if (!object2.hasOwnProperty(propertyName))
                    continue;
                if (isFunction(object2[propertyName]))
                    continue;
                if (!(propertyName in object1))
                    return false;
                if (properties.indexOf(propertyName) === -1)
                    return false;
            }
            return true;
        };
        return ObjectUtils;
    }());
    function internalAreEqual(object1, object2, config, stack1, stack2, ignore) {
        if (ignore === void 0) { ignore = {}; }
        if (object1 === object2)
            return true;
        if (!isObject(object1) || !isObject(object2))
            return false;
        if (isDate(object1))
            return object1.getTime() === object2.getTime();
        var keys = ArrayUtils.joinWithoutDuplicates(Object.keys(object1), Object.keys(object2));
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            if (key in ignore)
                continue;
            if (!(key in object1) || !(key in object2))
                return false;
            if (typeof object1[key] !== typeof object2[key])
                return false;
            if (isFunction(object1[key]))
                continue;
            var firstIsPlainObject = isPlainObject(object1[key]);
            if (isArray(object1[key]) && config.arrays ||
                firstIsPlainObject && config.objects ||
                isDate(object1[key])) {
                if (firstIsPlainObject) {
                    var lengthStack = stack1.length;
                    while (lengthStack--) {
                        if (stack1[lengthStack] === object1[key])
                            return stack2[lengthStack] === object2[key];
                    }
                    stack1.push(object1[key]);
                    stack2.push(object2[key]);
                }
                if (!internalAreEqual(object1[key], object2[key], config, stack1, stack2))
                    return false;
                if (firstIsPlainObject) {
                    stack1.pop();
                    stack2.pop();
                }
            }
            else {
                if (object1[key] !== object2[key])
                    return false;
            }
        }
        return true;
    }
    var StringUtils = (function () {
        function StringUtils() {
        }
        StringUtils.startsWith = function (str, substring) {
            return str.lastIndexOf(substring, 0) === 0;
        };
        StringUtils.endsWith = function (str, substring) {
            return str.indexOf(substring, str.length - substring.length) !== -1;
        };
        StringUtils.contains = function (str, substring) {
            return str.indexOf(substring) !== -1;
        };
        return StringUtils;
    }());
    var MapUtils = (function () {
        function MapUtils() {
        }
        MapUtils.from = function (object) {
            var map = new Map();
            for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {
                var name_1 = _a[_i];
                map.set(name_1, object[name_1]);
            }
            return map;
        };
        MapUtils.extend = function (toExtend) {
            var extenders = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                extenders[_i - 1] = arguments[_i];
            }
            for (var _a = 0, extenders_1 = extenders; _a < extenders_1.length; _a++) {
                var extender = extenders_1[_a];
                if (!extender)
                    continue;
                extender.forEach(function (value, key) { return toExtend.set(key, value); });
            }
            return toExtend;
        };
        return MapUtils;
    }());
    var UUIDUtils = (function () {
        function UUIDUtils() {
        }
        UUIDUtils.is = function (uuid) {
            return UUIDUtils.regExp.test(uuid);
        };
        UUIDUtils.generate = function () {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0;
                var v = c === "x" ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        };
        UUIDUtils.regExp = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        return UUIDUtils;
    }());
    function _isExistingValue(value) {
        return value !== null && value !== void 0;
    }

    var Utils = /*#__PURE__*/Object.freeze({
        hasFunction: hasFunction,
        hasProperty: hasProperty,
        hasPropertyDefined: hasPropertyDefined,
        isDefined: isDefined,
        isNull: isNull,
        isArray: isArray,
        isString: isString,
        isBoolean: isBoolean,
        isNumber: isNumber,
        isInteger: isInteger,
        isDouble: isDouble,
        isDate: isDate,
        isObject: isObject,
        isPlainObject: isPlainObject,
        isFunction: isFunction,
        isMap: isMap,
        parseBoolean: parseBoolean,
        promiseMethod: promiseMethod,
        ArrayUtils: ArrayUtils,
        ObjectUtils: ObjectUtils,
        StringUtils: StringUtils,
        MapUtils: MapUtils,
        UUIDUtils: UUIDUtils,
        _isExistingValue: _isExistingValue
    });

    var ModelDecorator = {
        hasPropertiesFrom: function (prototype, object) {
            var prototypeKeys = Object
                .keys(prototype);
            var shouldAddDollar = "$id" in object
                && !prototypeKeys.some(function (key) { return key.startsWith("$"); });
            return prototypeKeys
                .every(function (key) {
                var targetKey = shouldAddDollar ?
                    "$" + key : key;
                var definition = Object
                    .getOwnPropertyDescriptor(prototype, key);
                if (!definition)
                    return false;
                var targetDefinition = Object
                    .getOwnPropertyDescriptor(object, targetKey);
                if (!targetDefinition)
                    return false;
                if (isFunction(definition.value))
                    return isFunction(targetDefinition.value);
                return !targetDefinition.enumerable;
            });
        },
        definePropertiesFrom: function (prototype, object) {
            var prototypeKeys = Object
                .keys(prototype);
            var shouldAddDollar = "$id" in object
                && !prototypeKeys.some(function (key) { return key.startsWith("$"); });
            prototypeKeys
                .forEach(function (key) {
                var targetKey = shouldAddDollar ?
                    "$" + key : key;
                var definition = Object
                    .getOwnPropertyDescriptor(prototype, key);
                var descriptor = {
                    enumerable: false,
                    configurable: true,
                };
                if (isFunction(definition.value)) {
                    descriptor.writable = false;
                    descriptor.value = definition.value;
                }
                else if (!definition.set) {
                    descriptor.writable = true;
                    descriptor.value = object.hasOwnProperty(targetKey) ?
                        object[targetKey] : definition.get ?
                        definition.get() : definition.value;
                }
                else {
                    descriptor.get = definition.get;
                    descriptor.set = definition.set;
                }
                Object.defineProperty(object, targetKey, descriptor);
            });
            return object;
        },
        decorateMultiple: function (object) {
            var models = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                models[_i - 1] = arguments[_i];
            }
            models.forEach(function (model) { return model.decorate(object); });
            return object;
        },
    };

    var AbstractError = (function (_super) {
        __extends(AbstractError, _super);
        function AbstractError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            Object.setPrototypeOf(_this, _newTarget.prototype);
            "captureStackTrace" in Error && Error.captureStackTrace(_this, _this.constructor);
            return _this;
        }
        Object.defineProperty(AbstractError.prototype, "name", {
            get: function () { return "AbstractError"; },
            enumerable: true,
            configurable: true
        });
        return AbstractError;
    }(Error));

    var IllegalArgumentError = (function (_super) {
        __extends(IllegalArgumentError, _super);
        function IllegalArgumentError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IllegalArgumentError.prototype, "name", {
            get: function () { return "IllegalArgumentError"; },
            enumerable: true,
            configurable: true
        });
        return IllegalArgumentError;
    }(AbstractError));

    var URI = {
        hasFragment: function (uri) {
            return uri.indexOf("#") !== -1;
        },
        hasQuery: function (uri) {
            return uri.indexOf("?") !== -1;
        },
        hasProtocol: function (uri) {
            return StringUtils.startsWith(uri, "https://") || StringUtils.startsWith(uri, "http://");
        },
        isAbsolute: function (uri) {
            return StringUtils.startsWith(uri, "http://")
                || StringUtils.startsWith(uri, "https://")
                || StringUtils.startsWith(uri, "://");
        },
        isRelative: function (uri) {
            return !URI.isAbsolute(uri);
        },
        isBNodeID: function (uri) {
            return StringUtils.startsWith(uri, "_:");
        },
        generateBNodeID: function () {
            return "_:" + UUIDUtils.generate();
        },
        isPrefixed: function (uri) {
            return !URI.isAbsolute(uri) && !URI.isBNodeID(uri) && StringUtils.contains(uri, ":");
        },
        isFragmentOf: function (fragmentURI, uri) {
            if (!URI.hasFragment(fragmentURI))
                return false;
            var documentURI = URI.getDocumentURI(fragmentURI);
            return documentURI === "" || documentURI === uri;
        },
        isBaseOf: function (baseURI, uri) {
            if (baseURI === uri)
                return true;
            if (baseURI === "")
                return true;
            if (URI.isRelative(uri) && !URI.isPrefixed(uri))
                return true;
            if (uri.startsWith(baseURI)) {
                if (StringUtils.endsWith(baseURI, "/") || StringUtils.endsWith(baseURI, "#"))
                    return true;
                var relativeURI = uri.substring(baseURI.length);
                if (StringUtils.startsWith(relativeURI, "/") || StringUtils.startsWith(relativeURI, "#"))
                    return true;
            }
            return false;
        },
        getRelativeURI: function (absoluteURI, base) {
            if (!absoluteURI.startsWith(base))
                return absoluteURI;
            return absoluteURI.substring(base.length);
        },
        getDocumentURI: function (uri) {
            var parts = uri.split("#");
            if (parts.length > 2)
                throw new IllegalArgumentError("The URI provided has more than one # sign.");
            return parts[0];
        },
        getFragment: function (uri) {
            var parts = uri.split("#");
            if (parts.length < 2)
                throw new IllegalArgumentError("The URI provided hasn't a # sign.");
            if (parts.length > 2)
                throw new IllegalArgumentError("The URI provided has more than one # sign.");
            return parts[1];
        },
        getSlug: function (uri) {
            var uriParts = uri.split("#");
            if (uriParts.length === 2)
                return URI.getSlug(uriParts[1]);
            if (uriParts.length > 2)
                throw new IllegalArgumentError("Invalid URI: The uri contains two '#' symbols.");
            uri = uriParts[0];
            if (uri === "")
                return uri;
            if (uri === "/")
                return "";
            var parts = uri.split("/");
            if (parts[parts.length - 1] === "") {
                return parts[parts.length - 2];
            }
            else {
                return parts[parts.length - 1];
            }
        },
        getParameters: function (uri) {
            var parameters = new Map();
            if (!URI.hasQuery(uri))
                return parameters;
            uri.replace(/^.*\?/, "").split("&").forEach(function (param) {
                var parts = param
                    .replace(/\+/g, " ")
                    .split("=");
                var key = parts.shift();
                var val = parts.length > 0 ? parts.join("=") : "";
                if (!parameters.has(key)) {
                    parameters.set(key, val);
                }
                else {
                    parameters.set(key, new Array().concat(parameters.get(key), val));
                }
            });
            return parameters;
        },
        resolve: function (parentURI, childURI) {
            if (!parentURI || URI.isAbsolute(childURI) || URI.isBNodeID(childURI) || URI.isPrefixed(childURI))
                return childURI;
            var protocol = parentURI.substr(0, parentURI.indexOf("://") + 3);
            var path = parentURI.substr(parentURI.indexOf("://") + 3, parentURI.length - 1);
            if (path.lastIndexOf("/") === -1)
                path += "/";
            if (StringUtils.startsWith(childURI, "?") || StringUtils.startsWith(childURI, "#")) {
                if (URI.hasQuery(path))
                    path = path.substr(0, path.indexOf("?"));
                if (URI.hasFragment(path) && (!StringUtils.startsWith(childURI, "?") || StringUtils.endsWith(path, "#")))
                    path = URI.getDocumentURI(path);
            }
            else {
                path = path.substr(0, path.lastIndexOf("/") + 1);
                if (!StringUtils.endsWith(path, "?") && !StringUtils.endsWith(path, "#") && !StringUtils.endsWith(path, "/"))
                    path += "/";
            }
            if (StringUtils.startsWith(childURI, "/")) {
                childURI = childURI.substr(1, childURI.length);
            }
            return protocol + path + childURI;
        },
        removeProtocol: function (uri) {
            if (!URI.hasProtocol(uri))
                return uri;
            return uri.substring(uri.indexOf("://") + 3);
        },
        prefix: function (uri, prefixOrObjectSchema, prefixURI) {
            if (!isString(prefixOrObjectSchema))
                return prefixWithObjectSchema(uri, prefixOrObjectSchema);
            var prefix = prefixOrObjectSchema;
            if (URI.isPrefixed(uri) || !uri.startsWith(prefixURI))
                return uri;
            return prefix + ":" + uri.substring(prefixURI.length);
        },
    };
    function prefixWithObjectSchema(uri, objectSchema) {
        var prefixEntries = objectSchema.prefixes.entries();
        while (true) {
            var result = prefixEntries.next();
            if (result.done)
                return uri;
            var _a = result.value, prefix = _a[0], prefixURI = _a[1];
            if (!URI.isAbsolute(prefixURI))
                continue;
            if (!uri.startsWith(prefixURI))
                continue;
            return URI.prefix(uri, prefix, prefixURI);
        }
    }

    var IDAlreadyInUseError = (function (_super) {
        __extends(IDAlreadyInUseError, _super);
        function IDAlreadyInUseError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IDAlreadyInUseError.prototype, "name", {
            get: function () { return "IDAlreadyInUseError"; },
            enumerable: true,
            configurable: true
        });
        return IDAlreadyInUseError;
    }(AbstractError));

    var Pointer = {
        PROTOTYPE: {
            get $id() { return ""; },
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(Pointer.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (Pointer.isDecorated(object))
                return object;
            return ModelDecorator
                .definePropertiesFrom(Pointer.PROTOTYPE, object);
        },
        is: function (value) {
            return isObject(value)
                && Pointer.isDecorated(value);
        },
        create: function (data) {
            var clone = Object.assign({}, data);
            return Pointer.createFrom(clone);
        },
        createFrom: function (object) {
            return Pointer.decorate(object);
        },
        areEqual: function (pointer1, pointer2) {
            return pointer1.$id === pointer2.$id;
        },
        getIDs: function (pointers) {
            return pointers
                .map(function (pointer) { return pointer.$id; });
        },
        getID: function (pointerOrIRI) {
            return isObject(pointerOrIRI) ? pointerOrIRI.$id : pointerOrIRI;
        },
    };

    var BiModelDecorator = {
        hasPropertiesFrom: function (prototype, object) {
            return ModelDecorator.hasPropertiesFrom(prototype, object);
        },
        definePropertiesFrom: function (prototype, object) {
            if ("$id" in object)
                Pointer
                    .decorate(object);
            return ModelDecorator
                .definePropertiesFrom(prototype, object);
        },
        decorateMultiple: ModelDecorator.decorateMultiple,
    };

    function __getResourcesMaps(registry) {
        return "$id" in registry ? registry.$__resourcesMap : registry.__resourcesMap;
    }
    function __getParentResource(registry) {
        return "$id" in registry ? registry.$registry : registry.registry;
    }
    function __getDecorator(registry) {
        return "$id" in registry ?
            registry.$__modelDecorator : registry.__modelDecorator;
    }
    function __getLocalID(registry, id) {
        return "$id" in registry ?
            registry.$_getLocalID(id) : registry._getLocalID(id);
    }
    function __addPointer(registry, pointer) {
        return "$id" in registry ?
            registry.$_addPointer(pointer) : registry._addPointer(pointer);
    }
    function __inScope(idOrPointer, local) {
        if (!this)
            return false;
        try {
            var id = Pointer.getID(idOrPointer);
            __getLocalID(this, id);
            return true;
        }
        catch (_a) {
            if (local === true)
                return false;
            var parentRegistry = __getParentResource(this);
            return __inScope.call(parentRegistry, idOrPointer);
        }
    }
    function __hasPointer(id, local) {
        if (!this)
            return false;
        if (__inScope.call(this, id, true)) {
            var localID = __getLocalID(this, id);
            var resourcesMap = __getResourcesMaps(this);
            if (resourcesMap.has(localID))
                return true;
        }
        if (local === true)
            return false;
        var parentRegistry = __getParentResource(this);
        return __hasPointer.call(parentRegistry, id);
    }
    function __getPointer(id, local) {
        var parentRegistry = __getParentResource(this);
        if (!__inScope.call(this, id, true)) {
            if (local === true || !parentRegistry)
                throw new IllegalArgumentError("\"" + id + "\" is out of scope.");
            return __getPointer.call(parentRegistry, id);
        }
        var localID = __getLocalID(this, id);
        var resourcesMap = __getResourcesMaps(this);
        if (resourcesMap.has(localID))
            return resourcesMap.get(localID);
        if (local !== true && __hasPointer.call(parentRegistry, id))
            return __getPointer.call(parentRegistry, id);
        return __addPointer(this, { $id: id });
    }
    function __getPointers(local) {
        var resourcesMap = __getResourcesMaps(this);
        var pointers = Array.from(resourcesMap.values());
        var parentRegistry = __getParentResource(this);
        if (local === true || !parentRegistry)
            return pointers;
        return __getPointers.call(parentRegistry).concat(pointers);
    }
    function __removePointer(idOrPointer, local) {
        if (!this)
            return false;
        var id = Pointer.getID(idOrPointer);
        if (__inScope.call(this, id, true)) {
            var localID = __getLocalID(this, id);
            var resourcesMap = __getResourcesMaps(this);
            if (resourcesMap.delete(localID))
                return true;
        }
        if (local === true)
            return false;
        var parentRegistry = __getParentResource(this);
        return __removePointer.call(parentRegistry, idOrPointer);
    }
    var Registry = {
        PROTOTYPE: {
            registry: void 0,
            get __modelDecorator() {
                throw new IllegalArgumentError("Property \"__modelDecorator\" is required");
            },
            get __resourcesMap() { return new Map(); },
            inScope: __inScope,
            hasPointer: __hasPointer,
            getPointer: __getPointer,
            getPointers: __getPointers,
            removePointer: __removePointer,
            _addPointer: function (pointer) {
                if (!pointer.$id)
                    throw new IllegalArgumentError("The pointer $id cannot be empty.");
                var localID = __getLocalID(this, pointer.$id);
                var resourcesMap = __getResourcesMaps(this);
                if (resourcesMap.has(localID))
                    throw new IDAlreadyInUseError("\"" + pointer.$id + "\" is already being used.");
                var resource = __getDecorator(this)
                    .decorate(Object.assign(pointer, {
                    $registry: this,
                }));
                resourcesMap.set(localID, resource);
                return resource;
            },
            _getLocalID: function (id) {
                return id;
            },
        },
        isDecorated: function (object) {
            return BiModelDecorator
                .hasPropertiesFrom(Registry.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (Registry.isDecorated(object))
                return object;
            return BiModelDecorator
                .definePropertiesFrom(Registry.PROTOTYPE, object);
        },
    };

    var ContainerType;
    (function (ContainerType) {
        ContainerType[ContainerType["SET"] = 0] = "SET";
        ContainerType[ContainerType["LIST"] = 1] = "LIST";
        ContainerType[ContainerType["LANGUAGE"] = 2] = "LANGUAGE";
    })(ContainerType || (ContainerType = {}));

    function _getPointer(pointerLibrary, id) {
        return "$id" in pointerLibrary ?
            pointerLibrary.$getPointer(id) :
            pointerLibrary.getPointer(id);
    }

    var RDFList = {
        is: function (value) {
            return hasPropertyDefined(value, "@list");
        },
    };

    function pad(value) {
        var paddedValue = String(value);
        if (paddedValue.length === 1)
            paddedValue = "0" + paddedValue;
        return paddedValue;
    }
    var notNumberError = "The value is not a number.";
    var DateSerializer = (function () {
        function DateSerializer() {
        }
        DateSerializer.prototype.serialize = function (value) {
            if (!isDate(value))
                throw new IllegalArgumentError("The value is not a Date object.");
            return value.getUTCFullYear() + "-" + pad((value.getUTCMonth() + 1)) + "-" + pad(value.getUTCDate());
        };
        return DateSerializer;
    }());
    var dateSerializer = new DateSerializer();
    var DateTimeSerializer = (function () {
        function DateTimeSerializer() {
        }
        DateTimeSerializer.prototype.serialize = function (value) {
            if (!isDate(value))
                throw new IllegalArgumentError("The value is not a Date object.");
            return value.toISOString();
        };
        return DateTimeSerializer;
    }());
    var dateTimeSerializer = new DateTimeSerializer();
    var TimeSerializer = (function () {
        function TimeSerializer() {
        }
        TimeSerializer.prototype.serialize = function (value) {
            if (!isDate(value))
                throw new IllegalArgumentError("The value is not a Date object.");
            return pad(value.getUTCHours())
                + ":" + pad(value.getUTCMinutes())
                + ":" + pad(value.getUTCSeconds())
                + "." + String((value.getUTCMilliseconds() / 1000).toFixed(3)).slice(2, 5)
                + "Z";
        };
        return TimeSerializer;
    }());
    var timeSerializer = new TimeSerializer();
    var IntegerSerializer = (function () {
        function IntegerSerializer() {
        }
        IntegerSerializer.prototype.serialize = function (value) {
            if (!isNumber(value))
                throw new IllegalArgumentError(notNumberError);
            return (~~value).toString();
        };
        return IntegerSerializer;
    }());
    var integerSerializer = new IntegerSerializer();
    var LongSerializer = (function () {
        function LongSerializer() {
        }
        LongSerializer.prototype.serialize = function (value) {
            if (!isNumber(value))
                throw new IllegalArgumentError(notNumberError);
            if (value === Number.POSITIVE_INFINITY)
                return "0";
            if (value === Number.NEGATIVE_INFINITY)
                return "0";
            if (Number.isNaN(value))
                return "0";
            return Math.trunc(value).toString();
        };
        return LongSerializer;
    }());
    var longSerializer = new LongSerializer();
    var UnsignedIntegerSerializer = (function (_super) {
        __extends(UnsignedIntegerSerializer, _super);
        function UnsignedIntegerSerializer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UnsignedIntegerSerializer.prototype.serialize = function (value) {
            var stringValue = _super.prototype.serialize.call(this, value);
            stringValue = StringUtils.startsWith(stringValue, "-") ? stringValue.substring(1) : stringValue;
            return stringValue;
        };
        return UnsignedIntegerSerializer;
    }(IntegerSerializer));
    var unsignedIntegerSerializer = new UnsignedIntegerSerializer();
    var UnsignedLongSerializer = (function () {
        function UnsignedLongSerializer() {
        }
        UnsignedLongSerializer.prototype.serialize = function (value) {
            if (!isNumber(value))
                throw new IllegalArgumentError(notNumberError);
            if (value === Number.POSITIVE_INFINITY)
                return "0";
            if (value === Number.NEGATIVE_INFINITY)
                return "0";
            if (Number.isNaN(value))
                return "0";
            return Math.trunc(Math.abs(value)).toString();
        };
        return UnsignedLongSerializer;
    }());
    var unsignedLongSerializer = new UnsignedLongSerializer();
    var FloatSerializer = (function () {
        function FloatSerializer() {
        }
        FloatSerializer.prototype.serialize = function (value) {
            if (value === Number.POSITIVE_INFINITY)
                return "INF";
            if (value === Number.NEGATIVE_INFINITY)
                return "-INF";
            if (!isNumber(value))
                throw new IllegalArgumentError(notNumberError);
            return value.toString();
        };
        return FloatSerializer;
    }());
    var floatSerializer = new FloatSerializer();
    var BooleanSerializer = (function () {
        function BooleanSerializer() {
        }
        BooleanSerializer.prototype.serialize = function (value) {
            return (!!value).toString();
        };
        return BooleanSerializer;
    }());
    var booleanSerializer = new BooleanSerializer();
    var StringSerializer = (function () {
        function StringSerializer() {
        }
        StringSerializer.prototype.serialize = function (value) {
            return String(value);
        };
        return StringSerializer;
    }());
    var stringSerializer = new StringSerializer();

    var XSD = {
        namespace: "http://www.w3.org/2001/XMLSchema#",
        boolean: "http://www.w3.org/2001/XMLSchema#boolean",
        byte: "http://www.w3.org/2001/XMLSchema#byte",
        date: "http://www.w3.org/2001/XMLSchema#date",
        dateTime: "http://www.w3.org/2001/XMLSchema#dateTime",
        decimal: "http://www.w3.org/2001/XMLSchema#decimal",
        double: "http://www.w3.org/2001/XMLSchema#double",
        duration: "http://www.w3.org/2001/XMLSchema#duration",
        float: "http://www.w3.org/2001/XMLSchema#float",
        gDay: "http://www.w3.org/2001/XMLSchema#gDay",
        gMonth: "http://www.w3.org/2001/XMLSchema#gMonth",
        gMonthDay: "http://www.w3.org/2001/XMLSchema#gMonthDay",
        gYear: "http://www.w3.org/2001/XMLSchema#gYear",
        gYearMonth: "http://www.w3.org/2001/XMLSchema#gYearMonth",
        int: "http://www.w3.org/2001/XMLSchema#int",
        integer: "http://www.w3.org/2001/XMLSchema#integer",
        long: "http://www.w3.org/2001/XMLSchema#long",
        negativeInteger: "http://www.w3.org/2001/XMLSchema#negativeInteger",
        nonNegativeInteger: "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
        nonPositiveInteger: "http://www.w3.org/2001/XMLSchema#nonPositiveInteger",
        object: "http://www.w3.org/2001/XMLSchema#object",
        positiveInteger: "http://www.w3.org/2001/XMLSchema#positiveInteger",
        short: "http://www.w3.org/2001/XMLSchema#short",
        string: "http://www.w3.org/2001/XMLSchema#string",
        time: "http://www.w3.org/2001/XMLSchema#time",
        unsignedByte: "http://www.w3.org/2001/XMLSchema#unsignedByte",
        unsignedInt: "http://www.w3.org/2001/XMLSchema#unsignedInt",
        unsignedLong: "http://www.w3.org/2001/XMLSchema#unsignedLong",
        unsignedShort: "http://www.w3.org/2001/XMLSchema#unsignedShort",
    };



    var index = /*#__PURE__*/Object.freeze({
        DateSerializer: DateSerializer,
        dateSerializer: dateSerializer,
        DateTimeSerializer: DateTimeSerializer,
        dateTimeSerializer: dateTimeSerializer,
        TimeSerializer: TimeSerializer,
        timeSerializer: timeSerializer,
        IntegerSerializer: IntegerSerializer,
        integerSerializer: integerSerializer,
        LongSerializer: LongSerializer,
        longSerializer: longSerializer,
        UnsignedIntegerSerializer: UnsignedIntegerSerializer,
        unsignedIntegerSerializer: unsignedIntegerSerializer,
        UnsignedLongSerializer: UnsignedLongSerializer,
        unsignedLongSerializer: unsignedLongSerializer,
        FloatSerializer: FloatSerializer,
        floatSerializer: floatSerializer,
        BooleanSerializer: BooleanSerializer,
        booleanSerializer: booleanSerializer,
        StringSerializer: StringSerializer,
        stringSerializer: stringSerializer
    });

    var RDFLiteral = {
        from: function (value) {
            if (isNull(value))
                throw new IllegalArgumentError("Null cannot be converted into a Literal");
            if (!isDefined(value))
                throw new IllegalArgumentError("The value is undefined");
            var type;
            switch (true) {
                case isDate(value):
                    type = XSD.dateTime;
                    value = value.toISOString();
                    break;
                case isNumber(value):
                    if (isInteger(value)) {
                        type = XSD.integer;
                    }
                    else {
                        type = XSD.double;
                    }
                    break;
                case isString(value):
                    type = XSD.string;
                    break;
                case isBoolean(value):
                    type = XSD.boolean;
                    break;
                default:
                    type = XSD.object;
                    value = JSON.stringify(value);
                    break;
            }
            var literal = { "@value": value.toString() };
            if (type)
                literal["@type"] = type;
            return literal;
        },
        parse: function (valueOrLiteral, type) {
            var literalValue;
            if (isString(valueOrLiteral)) {
                literalValue = valueOrLiteral;
            }
            else {
                var literal = valueOrLiteral;
                if (!literal)
                    return null;
                if (!hasProperty(literal, "@value"))
                    return null;
                type = "@type" in literal ? literal["@type"] : null;
                literalValue = literal["@value"];
            }
            var value = literalValue;
            switch (type) {
                case XSD.date:
                case XSD.dateTime:
                    value = new Date(literalValue);
                    break;
                case XSD.time:
                    var parts = literalValue.match(/(\d+):(\d+):(\d+)\.(\d+)Z/);
                    if (!parts)
                        throw new IllegalArgumentError("Invalid value for type " + XSD.time + ".");
                    value = new Date();
                    value.setUTCHours(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4]));
                    break;
                case XSD.duration:
                    break;
                case XSD.gDay:
                case XSD.gMonth:
                case XSD.gMonthDay:
                case XSD.gYear:
                case XSD.gYearMonth:
                    break;
                case XSD.byte:
                case XSD.decimal:
                case XSD.int:
                case XSD.integer:
                case XSD.long:
                case XSD.negativeInteger:
                case XSD.nonNegativeInteger:
                case XSD.nonPositiveInteger:
                case XSD.positiveInteger:
                case XSD.short:
                case XSD.unsignedLong:
                case XSD.unsignedInt:
                case XSD.unsignedShort:
                case XSD.unsignedByte:
                case XSD.double:
                case XSD.float:
                    value = parseFloat(literalValue);
                    break;
                case XSD.boolean:
                    value = parseBoolean(literalValue);
                    break;
                case XSD.string:
                    value = literalValue;
                    break;
                case XSD.object:
                    value = JSON.parse(literalValue);
                    break;
                default:
                    break;
            }
            return value;
        },
        is: function (value) {
            return hasProperty(value, "@value")
                && isString(value["@value"]);
        },
        hasType: function (value, type) {
            if (!value["@type"] && type === XSD.string)
                return true;
            return value["@type"] === type;
        },
    };

    var RDFNode = {
        is: function (value) {
            return hasProperty(value, "@id")
                && isString(value["@id"]);
        },
        create: function (uri) {
            return {
                "@id": uri,
            };
        },
        getID: function (node) {
            return node["@id"];
        },
        getRelativeID: function (node) {
            var id = RDFNode.getID(node);
            return URI.hasFragment(id) ? URI.getFragment(id) : id;
        },
        areEqual: function (node1, node2) {
            return RDFNode.getID(node1) === RDFNode.getID(node2);
        },
        isFragment: function (node) {
            var id = RDFNode.getID(node);
            return URI.hasFragment(id) || URI.isBNodeID(id);
        },
        hasType: function (node, type) {
            return RDFNode.getTypes(node).indexOf(type) !== -1;
        },
        getTypes: function (node) {
            if (!("@type" in node))
                return [];
            return node["@type"];
        },
        getList: function (propertyValues) {
            if (!Array.isArray(propertyValues))
                return;
            return propertyValues
                .find(RDFList.is);
        },
        getPropertyLiterals: function (propertyValues, literalType) {
            if (!Array.isArray(propertyValues))
                return;
            return propertyValues
                .filter(RDFLiteral.is)
                .filter(function (literal) { return RDFLiteral.hasType(literal, literalType); })
                .map(RDFLiteral.parse);
        },
        getPropertyLanguageMap: function (propertyValues) {
            if (!Array.isArray(propertyValues))
                return;
            var propertyLanguageMap = {};
            for (var _i = 0, propertyValues_1 = propertyValues; _i < propertyValues_1.length; _i++) {
                var propertyValue = propertyValues_1[_i];
                if (!RDFLiteral.is(propertyValue))
                    continue;
                if (!RDFLiteral.hasType(propertyValue, XSD.string))
                    continue;
                var languageTag = propertyValue["@language"];
                if (!languageTag)
                    continue;
                propertyLanguageMap[languageTag] = RDFLiteral.parse(propertyValue);
            }
            return propertyLanguageMap;
        },
    };

    var RDFValue = {
        parse: function (pointerLibrary, value) {
            if (isString(value))
                return value;
            if (RDFLiteral.is(value))
                return RDFLiteral.parse(value);
            if (RDFNode.is(value))
                return _getPointer(pointerLibrary, value["@id"]);
            if (RDFList.is(value))
                return value["@list"]
                    .map(RDFValue.parse.bind(null, pointerLibrary));
            return null;
        },
    };

    function _guessXSDType(value) {
        if (isFunction(value))
            return null;
        if (isString(value))
            return XSD.string;
        if (isDate(value))
            return XSD.dateTime;
        if (isNumber(value))
            return XSD.float;
        if (isBoolean(value))
            return XSD.boolean;
        return null;
    }

    var JSONLDConverter = (function () {
        function JSONLDConverter(literalSerializers) {
            this._literalSerializers = literalSerializers ?
                MapUtils.extend(new Map(), literalSerializers) :
                JSONLDConverter.getDefaultSerializers();
        }
        Object.defineProperty(JSONLDConverter.prototype, "literalSerializers", {
            get: function () { return this._literalSerializers; },
            enumerable: true,
            configurable: true
        });
        JSONLDConverter.getDefaultSerializers = function () {
            var literalSerializers = new Map();
            literalSerializers.set(XSD.date, dateSerializer);
            literalSerializers.set(XSD.dateTime, dateTimeSerializer);
            literalSerializers.set(XSD.time, timeSerializer);
            literalSerializers.set(XSD.integer, integerSerializer);
            literalSerializers.set(XSD.int, integerSerializer);
            literalSerializers.set(XSD.unsignedInt, unsignedIntegerSerializer);
            literalSerializers.set(XSD.long, longSerializer);
            literalSerializers.set(XSD.unsignedLong, unsignedLongSerializer);
            literalSerializers.set(XSD.float, floatSerializer);
            literalSerializers.set(XSD.double, floatSerializer);
            literalSerializers.set(XSD.boolean, booleanSerializer);
            literalSerializers.set(XSD.string, stringSerializer);
            return literalSerializers;
        };
        JSONLDConverter.prototype.compact = function (expandedObjectOrObjects, targetObjectOrObjectsOrDigestedContext, digestedSchemaOrPointerLibrary, pointerLibrary, strict) {
            var targetObjectOrObjects = !pointerLibrary ? null : targetObjectOrObjectsOrDigestedContext;
            var digestedSchema = !pointerLibrary ? targetObjectOrObjectsOrDigestedContext : digestedSchemaOrPointerLibrary;
            pointerLibrary = !pointerLibrary ? digestedSchemaOrPointerLibrary : pointerLibrary;
            if (!Array.isArray(expandedObjectOrObjects))
                return this.__compactSingle(expandedObjectOrObjects, targetObjectOrObjects, digestedSchema, pointerLibrary, strict);
            var expandedObjects = expandedObjectOrObjects;
            var targetObjects = !!targetObjectOrObjects ? targetObjectOrObjects : [];
            for (var i = 0, length_1 = expandedObjects.length; i < length_1; i++) {
                var expandedObject = expandedObjects[i];
                var targetObject = targetObjects[i] = !!targetObjects[i] ? targetObjects[i] : {};
                this.__compactSingle(expandedObject, targetObject, digestedSchema, pointerLibrary, strict);
            }
            return targetObjects;
        };
        JSONLDConverter.prototype.expand = function (compactedObjectOrObjects, generalSchema, digestedSchema) {
            if (!Array.isArray(compactedObjectOrObjects))
                return this.__expandSingle(compactedObjectOrObjects, generalSchema, digestedSchema);
        };
        JSONLDConverter.prototype.update = function (target, node, digestedSchema, pointerLibrary, strict) {
            var compactedData = this.compact(node, {}, digestedSchema, pointerLibrary, strict);
            new Set(Object.getOwnPropertyNames(target).concat(Object.keys(compactedData))).forEach(function (key) {
                var _a;
                if (key.startsWith("$"))
                    return;
                if (isFunction(target[key]))
                    return;
                if (!compactedData.hasOwnProperty(key)) {
                    if (!strict || digestedSchema.properties.has(key))
                        delete target[key];
                    return;
                }
                if (!Array.isArray(target[key])) {
                    target[key] = compactedData[key];
                    return;
                }
                var values = Array.isArray(compactedData[key]) ? compactedData[key] : [compactedData[key]];
                target[key].length = 0;
                (_a = target[key]).push.apply(_a, values);
            });
        };
        JSONLDConverter.prototype.__expandSingle = function (compactedObject, generalSchema, digestedSchema) {
            var expandedObject = {};
            expandedObject["@id"] = !!compactedObject["$id"] ? compactedObject["$id"] : "";
            if (compactedObject["types"]) {
                var types = Array.isArray(compactedObject["types"]) ?
                    compactedObject["types"] : [compactedObject["types"]];
                if (types.length)
                    expandedObject["@type"] = types
                        .map(function (type) { return generalSchema.resolveURI(type, { vocab: true, base: true }); });
            }
            for (var _i = 0, _a = Object.keys(compactedObject); _i < _a.length; _i++) {
                var propertyName = _a[_i];
                if (propertyName === "$id")
                    continue;
                if (propertyName === "types")
                    continue;
                var expandedPropertyName = digestedSchema.resolveURI(propertyName, { vocab: true });
                if (URI.isRelative(expandedPropertyName))
                    continue;
                var expandedValue = this.__expandProperty(propertyName, compactedObject[propertyName], digestedSchema, generalSchema);
                if (expandedValue === null)
                    continue;
                expandedObject[expandedPropertyName] = expandedValue;
            }
            return expandedObject;
        };
        JSONLDConverter.prototype.__expandProperty = function (propertyName, propertyValue, digestedSchema, generalSchema) {
            var definition = digestedSchema.properties.get(propertyName);
            var propertyContainer = definition ? definition.containerType : void 0;
            if (propertyContainer === ContainerType.LANGUAGE)
                return this.__expandPropertyLanguageMap(propertyValue);
            propertyValue = Array.isArray(propertyValue) ? propertyValue : [propertyValue];
            if (propertyContainer === null)
                propertyValue = [propertyValue[0]];
            var propertyType = definition ? definition.literal : null;
            var expandedValues = propertyType === true ?
                this.__expandPropertyLiteral(propertyValue, definition, digestedSchema) :
                propertyType === false ?
                    this.__expandPropertyPointer(propertyValue, digestedSchema, generalSchema) :
                    this.__expandPropertyValue(propertyValue, digestedSchema, generalSchema);
            var filteredValues = expandedValues.filter(function (value) { return value !== null; });
            if (!filteredValues.length)
                return null;
            if (propertyContainer === ContainerType.LIST)
                return [
                    { "@list": filteredValues },
                ];
            return filteredValues;
        };
        JSONLDConverter.prototype.__expandPropertyValue = function (propertyValue, digestedSchema, generalSchema) {
            var _this = this;
            return propertyValue.map(function (value) { return _this.__expandValue(value, digestedSchema, generalSchema); });
        };
        JSONLDConverter.prototype.__expandPropertyPointer = function (propertyValue, digestedSchema, generalSchema) {
            var _this = this;
            return propertyValue.map(function (value) { return _this.__expandPointerValue(value, digestedSchema, generalSchema); });
        };
        JSONLDConverter.prototype.__expandPropertyLiteral = function (propertyValue, definition, digestedSchema) {
            var _this = this;
            var literalType = digestedSchema.resolveURI(definition.literalType, { vocab: true, base: true });
            var expandedValues = propertyValue.map(function (value) { return _this.__expandLiteralValue(value, literalType); });
            if (definition.language)
                expandedValues.forEach(function (value) { return value["@language"] = definition.language; });
            return expandedValues;
        };
        JSONLDConverter.prototype.__expandPropertyLanguageMap = function (propertyValue) {
            if (!isObject(propertyValue)) {
                return null;
            }
            var mapValues = [];
            for (var _i = 0, _a = Object.keys(propertyValue); _i < _a.length; _i++) {
                var languageTag = _a[_i];
                var serializedValue = this.literalSerializers.get(XSD.string).serialize(propertyValue[languageTag]);
                mapValues.push({ "@value": serializedValue, "@type": XSD.string, "@language": languageTag });
            }
            return mapValues;
        };
        JSONLDConverter.prototype.__expandPointerValue = function (propertyValue, digestedSchema, generalSchema) {
            var isStringID = isString(propertyValue);
            var id = Pointer.is(propertyValue) ?
                propertyValue.$id :
                isStringID ?
                    propertyValue :
                    null;
            if (!id)
                return null;
            var resolved = generalSchema.resolveURI(id, { vocab: isStringID });
            return { "@id": resolved };
        };
        JSONLDConverter.prototype.__expandValue = function (propertyValue, digestedSchema, generalSchema) {
            if (Array.isArray(propertyValue))
                return null;
            return Pointer.is(propertyValue) ?
                this.__expandPointerValue(propertyValue, generalSchema, digestedSchema) :
                this.__expandLiteralValue(propertyValue, _guessXSDType(propertyValue));
        };
        JSONLDConverter.prototype.__expandLiteralValue = function (literalValue, literalType) {
            if (literalType === null)
                return null;
            if (!this.literalSerializers.has(literalType))
                return null;
            var serializedValue = this.literalSerializers
                .get(literalType)
                .serialize(literalValue);
            return { "@value": serializedValue, "@type": literalType };
        };
        JSONLDConverter.prototype.__compactSingle = function (expandedObject, targetObject, digestedSchema, pointerLibrary, strict) {
            if (!expandedObject["@id"])
                throw new IllegalArgumentError("The expandedObject doesn't have an @id defined.");
            targetObject["$id"] = expandedObject["@id"];
            targetObject["types"] = !!expandedObject["@type"] ? expandedObject["@type"] : [];
            var propertyURINameMap = this.__getPropertyURINameMap(digestedSchema);
            for (var _i = 0, _a = Object.keys(expandedObject); _i < _a.length; _i++) {
                var propertyURI = _a[_i];
                if (propertyURI === "@id")
                    continue;
                if (propertyURI === "@type")
                    continue;
                var propertyValues = expandedObject[propertyURI];
                if (!_isExistingValue(propertyValues))
                    continue;
                if (!propertyURINameMap.has(propertyURI) && strict)
                    continue;
                var propertyName = propertyURINameMap.has(propertyURI) ?
                    propertyURINameMap.get(propertyURI) :
                    digestedSchema.vocab ?
                        URI.getRelativeURI(propertyURI, digestedSchema.vocab) :
                        propertyURI;
                var targetValue = this.__getPropertyValue(propertyName, propertyValues, digestedSchema, pointerLibrary);
                if (targetValue === null || targetValue === void 0)
                    continue;
                targetObject[propertyName] = targetValue;
            }
            return targetObject;
        };
        JSONLDConverter.prototype.__getPropertyContainerType = function (propertyValues) {
            if (propertyValues.length === 1) {
                if (RDFList.is(propertyValues[0]))
                    return ContainerType.LIST;
            }
            else {
                return ContainerType.SET;
            }
            return null;
        };
        JSONLDConverter.prototype.__getPropertyValue = function (propertyName, propertyValues, digestedSchema, pointerLibrary) {
            var definition = digestedSchema.properties.get(propertyName);
            var propertyContainer = definition ?
                definition.containerType :
                this.__getPropertyContainerType(propertyValues);
            if (propertyContainer === ContainerType.LANGUAGE) {
                return RDFNode.getPropertyLanguageMap(propertyValues);
            }
            if (propertyContainer === ContainerType.LIST) {
                var list = RDFNode.getList(propertyValues);
                if (!list)
                    return null;
                propertyValues = list["@list"];
            }
            var propertyType = definition ? definition.literal : null;
            if (propertyType === true && (definition && definition.language)) {
                propertyValues = propertyValues.filter(function (value) { return value["@language"] === definition.language; });
            }
            if (propertyContainer === null)
                propertyValues = [propertyValues[0]];
            var compactedValues = propertyType === true ?
                this.__compactPropertyLiteral(propertyValues, definition, digestedSchema) :
                propertyType === false ?
                    this.__getPropertyPointers(propertyValues, pointerLibrary) :
                    this.__getProperties(propertyValues, pointerLibrary);
            if (!compactedValues)
                return null;
            var filteredValues = compactedValues.filter(function (value) { return value !== null; });
            if (!filteredValues.length)
                return null;
            if (propertyContainer === null)
                return filteredValues[0];
            return filteredValues;
        };
        JSONLDConverter.prototype.__getPropertyURINameMap = function (digestedSchema) {
            var map = new Map();
            digestedSchema.properties.forEach(function (definition, propertyName) {
                var uri = digestedSchema.resolveURI(definition.uri, { vocab: true });
                map.set(uri, propertyName);
            });
            return map;
        };
        JSONLDConverter.prototype.__compactPropertyLiteral = function (propertyValues, definition, digestedSchema) {
            var literalType = definition.literalType === null ?
                XSD.string : digestedSchema.resolveURI(definition.literalType, { vocab: true, base: true });
            return RDFNode.getPropertyLiterals(propertyValues, literalType);
        };
        JSONLDConverter.prototype.__getProperties = function (propertyValues, pointerLibrary) {
            if (!Array.isArray(propertyValues))
                return;
            return propertyValues
                .map(RDFValue.parse.bind(null, pointerLibrary))
                .filter(function (value) { return !isNull(value); });
        };
        JSONLDConverter.prototype.__getPropertyPointers = function (propertyValues, pointerLibrary) {
            if (!Array.isArray(propertyValues))
                return;
            return propertyValues
                .filter(RDFNode.is)
                .map(RDFNode.getID)
                .map(_getPointer.bind(null, pointerLibrary))
                .filter(function (pointer) { return !isNull(pointer); });
        };
        return JSONLDConverter;
    }());

    var DigestedObjectSchemaProperty = (function () {
        function DigestedObjectSchemaProperty() {
            this.uri = null;
            this.literal = null;
            this.literalType = null;
            this.pointerType = null;
            this.containerType = null;
        }
        return DigestedObjectSchemaProperty;
    }());

    var ObjectSchemaUtils = (function () {
        function ObjectSchemaUtils() {
        }
        ObjectSchemaUtils._resolveProperty = function (schema, definition, inSame) {
            var uri = definition.uri;
            var type = definition.literalType;
            var resolvedURI = schema.resolveURI(uri, { vocab: true });
            var resolvedType = schema.resolveURI(type, { vocab: true, base: true });
            if (resolvedURI !== uri || resolvedType !== type) {
                if (!inSame) {
                    definition = Object
                        .assign(new DigestedObjectSchemaProperty(), definition);
                }
                definition.uri = resolvedURI;
                definition.literalType = resolvedType;
            }
            return definition;
        };
        return ObjectSchemaUtils;
    }());

    var DigestedObjectSchema = (function () {
        function DigestedObjectSchema() {
            this.base = "";
            this.vocab = undefined;
            this.language = null;
            this.prefixes = new Map();
            this.properties = new Map();
        }
        DigestedObjectSchema.prototype.resolveURI = function (uri, relativeTo) {
            if (relativeTo === void 0) { relativeTo = {}; }
            if (uri === null || URI.isAbsolute(uri) || URI.isBNodeID(uri))
                return uri;
            var _a = uri.split(":"), prefix = _a[0], _b = _a[1], localName = _b === void 0 ? "" : _b;
            var definedReference = this.prefixes.has(prefix) ?
                this.prefixes.get(prefix) : this.properties.has(prefix) ?
                this.properties.get(prefix).uri
                : null;
            if (definedReference !== null && definedReference !== prefix) {
                return this.resolveURI(definedReference + localName, { vocab: true });
            }
            if (localName)
                return uri;
            if (relativeTo.vocab && this.vocab)
                return this.vocab + uri;
            if (relativeTo.base)
                return URI.resolve(this.base, uri);
            return uri;
        };
        DigestedObjectSchema.prototype.getProperty = function (name) {
            if (!this.properties.has(name))
                return void 0;
            return ObjectSchemaUtils._resolveProperty(this, this.properties.get(name));
        };
        return DigestedObjectSchema;
    }());

    var RegisteredPointer = {
        PROTOTYPE: {
            get $registry() {
                throw new IllegalArgumentError("Property \"$registry\" is required.");
            },
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(RegisteredPointer.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (RegisteredPointer.isDecorated(object))
                return object;
            var resource = ModelDecorator
                .decorateMultiple(object, Pointer);
            return ModelDecorator
                .definePropertiesFrom(RegisteredPointer.PROTOTYPE, resource);
        },
        create: function (data) {
            var copy = Object.assign({}, data);
            return RegisteredPointer.createFrom(copy);
        },
        createFrom: function (object) {
            return RegisteredPointer.decorate(object);
        },
        is: function (value) {
            return Pointer.is(value)
                && RegisteredPointer.isDecorated(value);
        },
    };

    function __getContext(registry) {
        if (!registry)
            return;
        if ("context" in registry && registry.context)
            return registry.context;
        return __getContext("$id" in registry ? registry.$registry : registry.registry);
    }
    function __resolveURI(resource, uri) {
        if (URI.isAbsolute(uri))
            return uri;
        var context = __getContext(resource.$registry);
        if (!context)
            return uri;
        return context
            .getObjectSchema()
            .resolveURI(uri, { vocab: true });
    }
    var Resource = {
        PROTOTYPE: {
            get types() { return []; },
            get $slug() {
                if (URI.isBNodeID(this.$id))
                    return this.$id;
                return URI.getSlug(this.$id);
            },
            set $slug(slug) { },
            $addType: function (type) {
                type = __resolveURI(this, type);
                if (this.types.indexOf(type) !== -1)
                    return;
                this.types.push(type);
            },
            $hasType: function (type) {
                type = __resolveURI(this, type);
                return this.types.indexOf(type) !== -1;
            },
            $removeType: function (type) {
                type = __resolveURI(this, type);
                var index = this.types.indexOf(type);
                if (index !== -1)
                    this.types.splice(index, 1);
            },
            toJSON: function (contextOrKey) {
                var context = typeof contextOrKey === "object" ?
                    contextOrKey : __getContext(this.$registry);
                var generalSchema = context ?
                    context.registry.getGeneralSchema() : new DigestedObjectSchema();
                var resourceSchema = context && context.registry ?
                    context.registry.getSchemaFor(this) : generalSchema;
                var jsonldConverter = context ?
                    context.jsonldConverter : new JSONLDConverter();
                return jsonldConverter.expand(this, generalSchema, resourceSchema);
            },
        },
        isDecorated: function (object) {
            return isObject(object)
                && ModelDecorator
                    .hasPropertiesFrom(Resource.PROTOTYPE, object);
        },
        is: function (value) {
            return Pointer.is(value)
                && Resource.isDecorated(value);
        },
        create: function (data) {
            var clone = Object.assign({}, data);
            return Resource.createFrom(clone);
        },
        createFrom: function (object) {
            return Resource.decorate(object);
        },
        decorate: function (object) {
            if (Resource.isDecorated(object))
                return object;
            if (!object.hasOwnProperty("$registry"))
                object.$registry = void 0;
            var resource = ModelDecorator
                .decorateMultiple(object, RegisteredPointer);
            return ModelDecorator
                .definePropertiesFrom(Resource.PROTOTYPE, resource);
        },
    };

    var FreeResources = {
        PROTOTYPE: {
            _getLocalID: function (id) {
                if (isAbsolute(id) && !URI.hasProtocol(id))
                    return id;
                throw new IllegalArgumentError("\"" + id + "\" is out of scope.");
            },
            _addPointer: function (base) {
                if (!base.$id)
                    base.$id = URI.generateBNodeID();
                return Registry.PROTOTYPE._addPointer.call(this, base);
            },
            toJSON: function (contextOrKey) {
                return this
                    .getPointers(true)
                    .map(function (resource) { return resource.toJSON(contextOrKey); });
            },
        },
        is: function (value) {
            return Registry.isDecorated(value)
                && FreeResources.isDecorated(value);
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(FreeResources.PROTOTYPE, object);
        },
        create: function (data) {
            var copy = Object.assign({}, data);
            return FreeResources.createFrom(copy);
        },
        createFrom: function (object) {
            return FreeResources.decorate(object);
        },
        decorate: function (object) {
            if (FreeResources.isDecorated(object))
                return object;
            var base = Object.assign(object, {
                __modelDecorator: Resource,
            });
            var resource = ModelDecorator
                .decorateMultiple(base, Registry);
            return ModelDecorator
                .definePropertiesFrom(FreeResources.PROTOTYPE, resource);
        },
        parseFreeNodes: function (registry, freeNodes) {
            var freeResources = FreeResources
                .createFrom({ registry: registry });
            freeNodes
                .forEach(function (node) {
                var digestedSchema = registry.getSchemaFor(node);
                var target = freeResources.getPointer(node["@id"], true);
                registry.context.jsonldConverter.compact(node, target, digestedSchema, freeResources);
            });
            return freeResources;
        },
    };

    var JSONParser = (function () {
        function JSONParser() {
        }
        JSONParser.prototype.parse = function (body) {
            return new Promise(function (resolve) { return resolve(JSON.parse(body)); });
        };
        return JSONParser;
    }());

    var InvalidJSONLDSyntaxError = (function (_super) {
        __extends(InvalidJSONLDSyntaxError, _super);
        function InvalidJSONLDSyntaxError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(InvalidJSONLDSyntaxError.prototype, "name", {
            get: function () { return "InvalidJSONLDSyntaxError"; },
            enumerable: true,
            configurable: true
        });
        return InvalidJSONLDSyntaxError;
    }(AbstractError));

    var NotImplementedError = (function (_super) {
        __extends(NotImplementedError, _super);
        function NotImplementedError(message) {
            if (message === void 0) { message = ""; }
            return _super.call(this, message) || this;
        }
        Object.defineProperty(NotImplementedError.prototype, "name", {
            get: function () { return "NotImplementedError"; },
            enumerable: true,
            configurable: true
        });
        return NotImplementedError;
    }(AbstractError));

    var HTTPError = (function (_super) {
        __extends(HTTPError, _super);
        function HTTPError(message, response) {
            var _this = _super.call(this, message) || this;
            _this.response = response;
            return _this;
        }
        Object.defineProperty(HTTPError, "statusCode", {
            get: function () { return null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HTTPError.prototype, "name", {
            get: function () { return "HTTPError"; },
            enumerable: true,
            configurable: true
        });
        return HTTPError;
    }(AbstractError));

    var name = "BadRequestError";
    var statusCode = 400;
    var BadRequestError = (function (_super) {
        __extends(BadRequestError, _super);
        function BadRequestError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(BadRequestError, "statusCode", {
            get: function () { return statusCode; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BadRequestError.prototype, "name", {
            get: function () { return name; },
            enumerable: true,
            configurable: true
        });
        return BadRequestError;
    }(HTTPError));

    var name$1 = "ConflictError";
    var statusCode$1 = 409;
    var ConflictError = (function (_super) {
        __extends(ConflictError, _super);
        function ConflictError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(ConflictError, "statusCode", {
            get: function () { return statusCode$1; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConflictError.prototype, "name", {
            get: function () { return name$1; },
            enumerable: true,
            configurable: true
        });
        return ConflictError;
    }(HTTPError));

    var name$2 = "ForbiddenError";
    var statusCode$2 = 403;
    var ForbiddenError = (function (_super) {
        __extends(ForbiddenError, _super);
        function ForbiddenError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(ForbiddenError, "statusCode", {
            get: function () { return statusCode$2; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ForbiddenError.prototype, "name", {
            get: function () { return name$2; },
            enumerable: true,
            configurable: true
        });
        return ForbiddenError;
    }(HTTPError));

    var name$3 = "MethodNotAllowedError";
    var statusCode$3 = 405;
    var MethodNotAllowedError = (function (_super) {
        __extends(MethodNotAllowedError, _super);
        function MethodNotAllowedError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(MethodNotAllowedError, "statusCode", {
            get: function () { return statusCode$3; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MethodNotAllowedError.prototype, "name", {
            get: function () { return name$3; },
            enumerable: true,
            configurable: true
        });
        return MethodNotAllowedError;
    }(HTTPError));

    var name$4 = "NotAcceptableError";
    var statusCode$4 = 406;
    var NotAcceptableError = (function (_super) {
        __extends(NotAcceptableError, _super);
        function NotAcceptableError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(NotAcceptableError, "statusCode", {
            get: function () { return statusCode$4; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NotAcceptableError.prototype, "name", {
            get: function () { return name$4; },
            enumerable: true,
            configurable: true
        });
        return NotAcceptableError;
    }(HTTPError));

    var name$5 = "NotFoundError";
    var statusCode$5 = 404;
    var NotFoundError = (function (_super) {
        __extends(NotFoundError, _super);
        function NotFoundError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(NotFoundError, "statusCode", {
            get: function () { return statusCode$5; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NotFoundError.prototype, "name", {
            get: function () { return name$5; },
            enumerable: true,
            configurable: true
        });
        return NotFoundError;
    }(HTTPError));

    var name$6 = "PreconditionFailedError";
    var statusCode$6 = 412;
    var PreconditionFailedError = (function (_super) {
        __extends(PreconditionFailedError, _super);
        function PreconditionFailedError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(PreconditionFailedError, "statusCode", {
            get: function () { return statusCode$6; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PreconditionFailedError.prototype, "name", {
            get: function () { return name$6; },
            enumerable: true,
            configurable: true
        });
        return PreconditionFailedError;
    }(HTTPError));

    var name$7 = "PreconditionRequiredError";
    var statusCode$7 = 428;
    var PreconditionRequiredError = (function (_super) {
        __extends(PreconditionRequiredError, _super);
        function PreconditionRequiredError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(PreconditionRequiredError, "statusCode", {
            get: function () { return statusCode$7; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PreconditionRequiredError.prototype, "name", {
            get: function () { return name$7; },
            enumerable: true,
            configurable: true
        });
        return PreconditionRequiredError;
    }(HTTPError));

    var name$8 = "RequestEntityTooLargeError";
    var statusCode$8 = 413;
    var RequestEntityTooLargeError = (function (_super) {
        __extends(RequestEntityTooLargeError, _super);
        function RequestEntityTooLargeError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(RequestEntityTooLargeError, "statusCode", {
            get: function () { return statusCode$8; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RequestEntityTooLargeError.prototype, "name", {
            get: function () { return name$8; },
            enumerable: true,
            configurable: true
        });
        return RequestEntityTooLargeError;
    }(HTTPError));

    var name$9 = "RequestHeaderFieldsTooLargeError";
    var statusCode$9 = 431;
    var RequestHeaderFieldsTooLargeError = (function (_super) {
        __extends(RequestHeaderFieldsTooLargeError, _super);
        function RequestHeaderFieldsTooLargeError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(RequestHeaderFieldsTooLargeError, "statusCode", {
            get: function () { return statusCode$9; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RequestHeaderFieldsTooLargeError.prototype, "name", {
            get: function () { return name$9; },
            enumerable: true,
            configurable: true
        });
        return RequestHeaderFieldsTooLargeError;
    }(HTTPError));

    var name$a = "RequestURITooLongError";
    var statusCode$a = 414;
    var RequestURITooLongError = (function (_super) {
        __extends(RequestURITooLongError, _super);
        function RequestURITooLongError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(RequestURITooLongError, "statusCode", {
            get: function () { return statusCode$a; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RequestURITooLongError.prototype, "name", {
            get: function () { return name$a; },
            enumerable: true,
            configurable: true
        });
        return RequestURITooLongError;
    }(HTTPError));

    var name$b = "TooManyRequestsError";
    var statusCode$b = 429;
    var TooManyRequestsError = (function (_super) {
        __extends(TooManyRequestsError, _super);
        function TooManyRequestsError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(TooManyRequestsError, "statusCode", {
            get: function () { return statusCode$b; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TooManyRequestsError.prototype, "name", {
            get: function () { return name$b; },
            enumerable: true,
            configurable: true
        });
        return TooManyRequestsError;
    }(HTTPError));

    var name$c = "UnauthorizedError";
    var statusCode$c = 401;
    var UnauthorizedError = (function (_super) {
        __extends(UnauthorizedError, _super);
        function UnauthorizedError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(UnauthorizedError, "statusCode", {
            get: function () { return statusCode$c; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UnauthorizedError.prototype, "name", {
            get: function () { return name$c; },
            enumerable: true,
            configurable: true
        });
        return UnauthorizedError;
    }(HTTPError));

    var name$d = "UnsupportedMediaTypeError";
    var statusCode$d = 415;
    var UnsupportedMediaTypeError = (function (_super) {
        __extends(UnsupportedMediaTypeError, _super);
        function UnsupportedMediaTypeError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(UnsupportedMediaTypeError, "statusCode", {
            get: function () { return statusCode$d; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UnsupportedMediaTypeError.prototype, "name", {
            get: function () { return name$d; },
            enumerable: true,
            configurable: true
        });
        return UnsupportedMediaTypeError;
    }(HTTPError));



    var ClientErrors = /*#__PURE__*/Object.freeze({
        BadRequestError: BadRequestError,
        ConflictError: ConflictError,
        ForbiddenError: ForbiddenError,
        MethodNotAllowedError: MethodNotAllowedError,
        NotAcceptableError: NotAcceptableError,
        NotFoundError: NotFoundError,
        PreconditionFailedError: PreconditionFailedError,
        PreconditionRequiredError: PreconditionRequiredError,
        RequestEntityTooLargeError: RequestEntityTooLargeError,
        RequestHeaderFieldsTooLargeError: RequestHeaderFieldsTooLargeError,
        RequestURITooLongError: RequestURITooLongError,
        TooManyRequestsError: TooManyRequestsError,
        UnauthorizedError: UnauthorizedError,
        UnsupportedMediaTypeError: UnsupportedMediaTypeError
    });

    var name$e = "BadResponseError";
    var statusCode$e = 0;
    var BadResponseError = (function (_super) {
        __extends(BadResponseError, _super);
        function BadResponseError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(BadResponseError, "statusCode", {
            get: function () { return statusCode$e; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BadResponseError.prototype, "name", {
            get: function () { return name$e; },
            enumerable: true,
            configurable: true
        });
        return BadResponseError;
    }(HTTPError));

    var name$f = "BadGatewayError";
    var statusCode$f = 502;
    var BadGatewayError = (function (_super) {
        __extends(BadGatewayError, _super);
        function BadGatewayError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(BadGatewayError, "statusCode", {
            get: function () { return statusCode$f; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BadGatewayError.prototype, "name", {
            get: function () { return name$f; },
            enumerable: true,
            configurable: true
        });
        return BadGatewayError;
    }(HTTPError));

    var name$g = "GatewayTimeoutError";
    var statusCode$g = 504;
    var GatewayTimeoutError = (function (_super) {
        __extends(GatewayTimeoutError, _super);
        function GatewayTimeoutError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(GatewayTimeoutError, "statusCode", {
            get: function () { return statusCode$g; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GatewayTimeoutError.prototype, "name", {
            get: function () { return name$g; },
            enumerable: true,
            configurable: true
        });
        return GatewayTimeoutError;
    }(HTTPError));

    var name$h = "HTTPVersionNotSupportedError";
    var statusCode$h = 505;
    var HTTPVersionNotSupportedError = (function (_super) {
        __extends(HTTPVersionNotSupportedError, _super);
        function HTTPVersionNotSupportedError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(HTTPVersionNotSupportedError, "statusCode", {
            get: function () { return statusCode$h; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HTTPVersionNotSupportedError.prototype, "name", {
            get: function () { return name$h; },
            enumerable: true,
            configurable: true
        });
        return HTTPVersionNotSupportedError;
    }(HTTPError));

    var name$i = "InternalServerErrorError";
    var statusCode$i = 500;
    var InternalServerErrorError = (function (_super) {
        __extends(InternalServerErrorError, _super);
        function InternalServerErrorError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(InternalServerErrorError, "statusCode", {
            get: function () { return statusCode$i; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InternalServerErrorError.prototype, "name", {
            get: function () { return name$i; },
            enumerable: true,
            configurable: true
        });
        return InternalServerErrorError;
    }(HTTPError));

    var name$j = "NotImplementedError";
    var statusCode$j = 501;
    var NotImplementedError$1 = (function (_super) {
        __extends(NotImplementedError, _super);
        function NotImplementedError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(NotImplementedError, "statusCode", {
            get: function () { return statusCode$j; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NotImplementedError.prototype, "name", {
            get: function () { return name$j; },
            enumerable: true,
            configurable: true
        });
        return NotImplementedError;
    }(HTTPError));

    var name$k = "ServiceUnavailableError";
    var statusCode$k = 503;
    var ServiceUnavailableError = (function (_super) {
        __extends(ServiceUnavailableError, _super);
        function ServiceUnavailableError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(ServiceUnavailableError, "statusCode", {
            get: function () { return statusCode$k; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ServiceUnavailableError.prototype, "name", {
            get: function () { return name$k; },
            enumerable: true,
            configurable: true
        });
        return ServiceUnavailableError;
    }(HTTPError));



    var ServerErrors = /*#__PURE__*/Object.freeze({
        BadResponseError: BadResponseError,
        BadGatewayError: BadGatewayError,
        GatewayTimeoutError: GatewayTimeoutError,
        HTTPVersionNotSupportedError: HTTPVersionNotSupportedError,
        InternalServerErrorError: InternalServerErrorError,
        NotImplementedError: NotImplementedError$1,
        ServiceUnavailableError: ServiceUnavailableError
    });

    var name$l = "UnknownError";
    var UnknownError = (function (_super) {
        __extends(UnknownError, _super);
        function UnknownError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(UnknownError.prototype, "name", {
            get: function () { return name$l; },
            enumerable: true,
            configurable: true
        });
        return UnknownError;
    }(HTTPError));

    var statusCodeMap = new Map();
    var addErrors = function (o) { return Object
        .keys(o)
        .map(function (k) { return o[k]; })
        .forEach(function (e) { return statusCodeMap.set(e.statusCode, e); }); };
    addErrors(ClientErrors);
    addErrors(ServerErrors);

    var index$1 = /*#__PURE__*/Object.freeze({
        statusCodeMap: statusCodeMap,
        BadRequestError: BadRequestError,
        ConflictError: ConflictError,
        ForbiddenError: ForbiddenError,
        MethodNotAllowedError: MethodNotAllowedError,
        NotAcceptableError: NotAcceptableError,
        NotFoundError: NotFoundError,
        PreconditionFailedError: PreconditionFailedError,
        PreconditionRequiredError: PreconditionRequiredError,
        RequestEntityTooLargeError: RequestEntityTooLargeError,
        RequestHeaderFieldsTooLargeError: RequestHeaderFieldsTooLargeError,
        RequestURITooLongError: RequestURITooLongError,
        TooManyRequestsError: TooManyRequestsError,
        UnauthorizedError: UnauthorizedError,
        UnsupportedMediaTypeError: UnsupportedMediaTypeError,
        BadResponseError: BadResponseError,
        BadGatewayError: BadGatewayError,
        GatewayTimeoutError: GatewayTimeoutError,
        HTTPVersionNotSupportedError: HTTPVersionNotSupportedError,
        InternalServerErrorError: InternalServerErrorError,
        NotImplementedError: NotImplementedError$1,
        ServiceUnavailableError: ServiceUnavailableError,
        HTTPError: HTTPError,
        UnknownError: UnknownError
    });

    var Header = (function () {
        function Header(values) {
            this.values = Array.isArray(values) ?
                values : Header.__parseValues(values);
        }
        Header.parseHeaders = function (headersString) {
            var headers = new Map();
            headersString.split(/\r?\n/).forEach(function (strHeader) {
                var _a;
                if (!strHeader.trim())
                    return;
                var parts = strHeader.split(":");
                if (parts.length < 2)
                    throw new IllegalArgumentError("The header couldn't be parsed.");
                var name = parts[0].trim().toLowerCase();
                var values = Header.__parseValues(parts.slice(1).join(":"));
                if (headers.has(name)) {
                    (_a = headers.get(name).values).push.apply(_a, values);
                }
                else {
                    headers.set(name, new Header(values));
                }
            });
            return headers;
        };
        Header.__parseValues = function (strValues) {
            if (!strValues)
                return [];
            return strValues
                .split(",")
                .map(function (valueString) {
                return valueString.trim();
            });
        };
        Header.prototype.hasValue = function (value) {
            return this.values.indexOf(value) !== -1;
        };
        Header.prototype.addValue = function (value) {
            var _a;
            var newValues = Header.__parseValues(value);
            (_a = this.values).push.apply(_a, newValues);
        };
        Header.prototype.toString = function () {
            return this.values.join(", ");
        };
        return Header;
    }());

    var HTTPMethod;
    (function (HTTPMethod) {
        HTTPMethod[HTTPMethod["OPTIONS"] = 0] = "OPTIONS";
        HTTPMethod[HTTPMethod["HEAD"] = 1] = "HEAD";
        HTTPMethod[HTTPMethod["GET"] = 2] = "GET";
        HTTPMethod[HTTPMethod["POST"] = 3] = "POST";
        HTTPMethod[HTTPMethod["PUT"] = 4] = "PUT";
        HTTPMethod[HTTPMethod["PATCH"] = 5] = "PATCH";
        HTTPMethod[HTTPMethod["DELETE"] = 6] = "DELETE";
    })(HTTPMethod || (HTTPMethod = {}));

    var Response = (function () {
        function Response(request, data, response) {
            this.request = request;
            if (typeof XMLHttpRequest !== "undefined" && request instanceof XMLHttpRequest) {
                this.status = request.status;
                this.data = request.responseText;
                this.headers = Header.parseHeaders(request.getAllResponseHeaders());
            }
            else {
                this.data = data || "";
                this.status = response && response.statusCode || 0;
                this.headers = new Map();
                if (!response)
                    return;
                for (var name_1 in response.headers) {
                    var header = new Header(response.headers[name_1]);
                    this.headers.set(name_1.toLowerCase(), header);
                }
            }
        }
        Response.prototype.getHeader = function (name) {
            name = name.toLowerCase();
            return this.headers.get(name) || null;
        };
        Response.prototype.getETag = function () {
            var eTagHeader = this.getHeader("ETag");
            if (!eTagHeader || !eTagHeader.values.length)
                throw new BadResponseError("The response doesn't contain an ETag", this);
            return eTagHeader.values[0];
        };
        return Response;
    }());

    function __onResolve(resolve, reject, response) {
        if (response.status >= 200 && response.status <= 299) {
            resolve(response);
        }
        else {
            if (!statusCodeMap.has(response.status))
                return reject(new UnknownError(response.data, response));
            reject(new (statusCodeMap.get(response.status))(response.data, response));
        }
    }
    function __sendWithBrowser(method, url, body, options) {
        return new Promise(function (resolve, reject) {
            var request = options.request ? options.request : new XMLHttpRequest();
            request.open(method, url, true);
            if (options.headers)
                options.headers
                    .forEach(function (header, name) { return request.setRequestHeader(name, header.toString()); });
            request.withCredentials = !!options.sendCredentialsOnCORS;
            if (options.timeout)
                request.timeout = options.timeout;
            request.onload = request.onerror = function () {
                var response = new Response(request);
                __onResolve(resolve, reject, response);
            };
            if (body) {
                request.send(body);
            }
            else {
                request.send();
            }
        });
    }
    function __sendWithNode(method, url, body, options) {
        return new Promise(function (resolve, reject) {
            function returnResponse(request, res) {
                var rawData = [];
                res.on("data", function (chunk) {
                    if (typeof chunk === "string")
                        chunk = Buffer.from(chunk, "utf-8");
                    rawData.push(chunk);
                }).on("end", function () {
                    var data = Buffer.concat(rawData).toString("utf8");
                    var response = new Response(request, data, res);
                    __onResolve(resolve, reject, response);
                });
            }
            var numberOfRedirects = 0;
            function sendRequestWithRedirect(_url) {
                var parsedURL = undefined.parse(_url);
                var Adapter = parsedURL.protocol === "http:" ? undefined : undefined;
                var requestOptions = {
                    protocol: parsedURL.protocol,
                    hostname: parsedURL.hostname,
                    port: parsedURL.port,
                    path: parsedURL.path,
                    method: method,
                    headers: {},
                };
                if (options.headers)
                    options.headers
                        .forEach(function (header, name) { return requestOptions.headers[name] = header.toString(); });
                var request = Adapter.request(requestOptions);
                if (options.timeout)
                    request.setTimeout(options.timeout);
                request.on("response", function (res) {
                    if (res.statusCode >= 300 && res.statusCode <= 399 && "location" in res.headers) {
                        if (++numberOfRedirects < 10)
                            return sendRequestWithRedirect(undefined.resolve(_url, res.headers.location));
                    }
                    returnResponse(request, res);
                });
                request.on("error", function (error) {
                    var response = new Response(request, error.message);
                    __onResolve(resolve, reject, response);
                });
                if (body) {
                    if (method === "DELETE")
                        request.useChunkedEncodingByDefault = true;
                    request.write(body);
                }
                request.end();
            }
            sendRequestWithRedirect(url);
        });
    }
    function __sendRequest(method, url, body, options) {
        return typeof XMLHttpRequest !== "undefined" ?
            __sendWithBrowser(method, url, body, options) :
            __sendWithNode(method, url, body, options);
    }
    function __isBody(data) {
        return isString(data)
            || typeof Blob !== "undefined" && data instanceof Blob
            || typeof Buffer !== "undefined" && data instanceof Buffer;
    }
    var RequestService = (function () {
        function RequestService() {
        }
        RequestService.send = function (method, url, bodyOrOptions, optionsOrParser, parser) {
            var _this = this;
            var body = undefined;
            var options = hasProperty(optionsOrParser, "parse") ? bodyOrOptions : optionsOrParser;
            parser = hasProperty(optionsOrParser, "parse") ? optionsOrParser : parser;
            if (!bodyOrOptions || __isBody(bodyOrOptions)) {
                body = bodyOrOptions;
            }
            else {
                options = bodyOrOptions ? bodyOrOptions : options;
            }
            options = Object.assign({}, RequestService.defaultOptions, options);
            if (isNumber(method))
                method = HTTPMethod[method];
            var requestPromise = __sendRequest(method, url, body, options)
                .then(function (response) {
                if (method === "GET" && options.headers)
                    return _this.__handleGETResponse(url, options, response);
                else
                    return response;
            });
            if (!parser)
                return requestPromise;
            return requestPromise.then(function (response) {
                return parser.parse(response.data).then(function (parsedBody) {
                    return [parsedBody, response];
                });
            });
        };
        RequestService.options = function (url, options) {
            if (options === void 0) { options = RequestService.defaultOptions; }
            return RequestService.send(HTTPMethod.OPTIONS, url, options);
        };
        RequestService.head = function (url, options) {
            if (options === void 0) { options = RequestService.defaultOptions; }
            return RequestService.send(HTTPMethod.HEAD, url, options);
        };
        RequestService.get = function (url, options, parser) {
            if (options === void 0) { options = RequestService.defaultOptions; }
            return RequestService.send(HTTPMethod.GET, url, undefined, options, parser);
        };
        RequestService.post = function (url, bodyOrOptions, options, parser) {
            if (bodyOrOptions === void 0) { bodyOrOptions = RequestService.defaultOptions; }
            if (options === void 0) { options = RequestService.defaultOptions; }
            return RequestService.send(HTTPMethod.POST, url, bodyOrOptions, options, parser);
        };
        RequestService.put = function (url, bodyOrOptions, options, parser) {
            if (bodyOrOptions === void 0) { bodyOrOptions = RequestService.defaultOptions; }
            if (options === void 0) { options = RequestService.defaultOptions; }
            return RequestService.send(HTTPMethod.PUT, url, bodyOrOptions, options, parser);
        };
        RequestService.patch = function (url, bodyOrOptions, options, parser) {
            if (bodyOrOptions === void 0) { bodyOrOptions = RequestService.defaultOptions; }
            if (options === void 0) { options = RequestService.defaultOptions; }
            return RequestService.send(HTTPMethod.PATCH, url, bodyOrOptions, options, parser);
        };
        RequestService.delete = function (url, bodyOrOptions, optionsOrParser, parser) {
            if (bodyOrOptions === void 0) { bodyOrOptions = RequestService.defaultOptions; }
            if (optionsOrParser === void 0) { optionsOrParser = RequestService.defaultOptions; }
            return RequestService.send(HTTPMethod.DELETE, url, bodyOrOptions, optionsOrParser, parser);
        };
        RequestService.__handleGETResponse = function (url, requestOptions, response) {
            var _this = this;
            return Promise.resolve()
                .then(function () {
                if (_this.__contentTypeIsAccepted(requestOptions, response))
                    return response;
                _this.__setNoCacheHeaders(requestOptions);
                if (!_this.__isChromiumAgent())
                    _this.__setFalseETag(requestOptions);
                return __sendRequest("GET", url, undefined, requestOptions)
                    .then(function (noCachedResponse) {
                    if (!_this.__contentTypeIsAccepted(requestOptions, response)) {
                        throw new BadResponseError("The server responded with an unacceptable Content-Type", response);
                    }
                    return noCachedResponse;
                });
            });
        };
        RequestService.__contentTypeIsAccepted = function (requestOptions, response) {
            if (!requestOptions.headers)
                return true;
            var accepts = requestOptions.headers.has("accept") ?
                requestOptions.headers.get("accept").values :
                [];
            var contentType = response.headers.has("content-type") ?
                response.headers.get("content-type") :
                undefined;
            return !contentType || accepts.some(contentType.hasValue, contentType);
        };
        RequestService.__setNoCacheHeaders = function (requestOptions) {
            requestOptions.headers
                .set("pragma", new Header("no-cache"))
                .set("cache-control", new Header("no-cache, max-age=0"));
        };
        RequestService.__isChromiumAgent = function () {
            return typeof window !== "undefined" && !!window["chrome"];
        };
        RequestService.__setFalseETag = function (requestOptions) {
            requestOptions.headers.set("if-none-match", new Header());
        };
        RequestService.defaultOptions = {
            sendCredentialsOnCORS: true,
        };
        return RequestService;
    }());
    var RequestUtils = (function () {
        function RequestUtils() {
        }
        RequestUtils.getHeader = function (headerName, requestOptions, initialize) {
            if (!requestOptions.headers) {
                if (!initialize)
                    return undefined;
                requestOptions.headers = new Map();
            }
            headerName = headerName.toLowerCase();
            var header = requestOptions.headers.get(headerName);
            if (!header) {
                if (!initialize)
                    return undefined;
                header = new Header();
                requestOptions.headers.set(headerName, header);
            }
            return header;
        };
        RequestUtils.setAcceptHeader = function (accept, requestOptions) {
            RequestUtils.__addHeaderValue("accept", accept, requestOptions);
            return requestOptions;
        };
        RequestUtils.setContentTypeHeader = function (contentType, requestOptions) {
            RequestUtils.__addHeaderValue("content-type", contentType, requestOptions);
            return requestOptions;
        };
        RequestUtils.setIfMatchHeader = function (eTag, requestOptions) {
            if (!eTag)
                return requestOptions;
            RequestUtils.__addHeaderValue("if-match", eTag, requestOptions);
            return requestOptions;
        };
        RequestUtils.setIfNoneMatchHeader = function (eTag, requestOptions) {
            if (!eTag)
                return requestOptions;
            RequestUtils.__addHeaderValue("if-none-match", eTag, requestOptions);
            return requestOptions;
        };
        RequestUtils.setPreferredInteractionModel = function (interactionModelURI, requestOptions) {
            var headerValue = interactionModelURI + "; rel=interaction-model";
            RequestUtils.__addHeaderValue("prefer", headerValue, requestOptions);
            return requestOptions;
        };
        RequestUtils.setPreferredRetrieval = function (retrievalType, requestOptions) {
            var headerValue = "return=" + retrievalType;
            RequestUtils.__addHeaderValue("prefer", headerValue, requestOptions);
            return requestOptions;
        };
        RequestUtils.setRetrievalPreferences = function (preferences, requestOptions) {
            var prefer = RequestUtils.getHeader("prefer", requestOptions, true);
            var keys = ["include", "omit"];
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                var key = keys_1[_i];
                if (!(key in preferences))
                    continue;
                if (preferences[key].length <= 0)
                    continue;
                var strPreferences = preferences[key].join(" ");
                prefer.values.push(key + "=\"" + strPreferences + "\"");
            }
            return requestOptions;
        };
        RequestUtils.setSlug = function (slug, requestOptions) {
            RequestUtils.__addHeaderValue("slug", slug, requestOptions);
            return requestOptions;
        };
        RequestUtils.isOptions = function (value) {
            return hasPropertyDefined(value, "headers")
                || hasPropertyDefined(value, "sendCredentialsOnCORS")
                || hasPropertyDefined(value, "timeout")
                || hasPropertyDefined(value, "request");
        };
        RequestUtils.cloneOptions = function (options) {
            var clone = __assign({}, options, { headers: new Map() });
            if (options.headers)
                options.headers
                    .forEach(function (value, key) { return clone.headers.set(key, new Header(value.values.slice())); });
            return clone;
        };
        RequestUtils.__addHeaderValue = function (headerName, headerValue, requestOptions) {
            var header = RequestUtils.getHeader(headerName, requestOptions, true);
            header.addValue(headerValue);
        };
        return RequestUtils;
    }());

    var PointerType;
    (function (PointerType) {
        PointerType[PointerType["ID"] = 0] = "ID";
        PointerType[PointerType["VOCAB"] = 1] = "VOCAB";
    })(PointerType || (PointerType = {}));

    var ObjectSchemaDigester = (function () {
        function ObjectSchemaDigester() {
        }
        ObjectSchemaDigester.digestSchema = function (schemas) {
            if (!Array.isArray(schemas))
                return ObjectSchemaDigester._digestSchema(schemas);
            var digestedSchemas = schemas
                .map(function (schema) { return ObjectSchemaDigester._digestSchema(schema); });
            return ObjectSchemaDigester._combineSchemas(digestedSchemas);
        };
        ObjectSchemaDigester.digestProperty = function (name, definition, digestedSchema) {
            var digestedDefinition = new DigestedObjectSchemaProperty();
            if ("@id" in definition) {
                var uri = definition["@id"];
                if (URI.isPrefixed(name))
                    throw new IllegalArgumentError("A prefixed property cannot have assigned another URI.");
                if (!isString(uri))
                    throw new IllegalArgumentError("@id needs to point to a string");
                digestedDefinition.uri = uri;
            }
            else {
                digestedDefinition.uri = name;
            }
            if ("@type" in definition) {
                var type = definition["@type"];
                if (!isString(type))
                    throw new IllegalArgumentError("@type needs to point to a string");
                if (type === "@id" || type === "@vocab") {
                    digestedDefinition.literal = false;
                    digestedDefinition.pointerType = type === "@id" ? PointerType.ID : PointerType.VOCAB;
                }
                else {
                    if (URI.isRelative(type) && type in XSD)
                        type = XSD[type];
                    digestedDefinition.literal = true;
                    digestedDefinition.literalType = type;
                }
            }
            if ("@language" in definition) {
                var language = definition["@language"];
                if (language !== null && !isString(language))
                    throw new IllegalArgumentError("@language needs to point to a string or null.");
                digestedDefinition.literal = true;
                digestedDefinition.language = language;
            }
            if ("@container" in definition) {
                switch (definition["@container"]) {
                    case "@set":
                        digestedDefinition.containerType = ContainerType.SET;
                        break;
                    case "@list":
                        digestedDefinition.containerType = ContainerType.LIST;
                        break;
                    case "@language":
                        if (isString(digestedDefinition.language))
                            throw new IllegalArgumentError("@container cannot be set to @language when the property definition already contains an @language tag.");
                        digestedDefinition.containerType = ContainerType.LANGUAGE;
                        break;
                    default:
                        throw new IllegalArgumentError("@container needs to be equal to '@list', '@set', or '@language'");
                }
            }
            return digestedSchema ?
                ObjectSchemaUtils._resolveProperty(digestedSchema, digestedDefinition, true) :
                digestedDefinition;
        };
        ObjectSchemaDigester.combineDigestedObjectSchemas = function (digestedSchemas) {
            if (digestedSchemas.length === 0)
                throw new IllegalArgumentError("At least one DigestedObjectSchema needs to be specified.");
            digestedSchemas.unshift(new DigestedObjectSchema());
            return ObjectSchemaDigester._combineSchemas(digestedSchemas);
        };
        ObjectSchemaDigester._digestSchema = function (schema) {
            var digestedSchema = new DigestedObjectSchema();
            for (var _i = 0, _a = ["@base", "@vocab"]; _i < _a.length; _i++) {
                var propertyName = _a[_i];
                if (!(propertyName in schema))
                    continue;
                var value = schema[propertyName];
                if (value !== null && !isString(value))
                    throw new IllegalArgumentError("The value of '" + propertyName + "' must be a string or null.");
                if ((propertyName === "@vocab" && value === "") || (value && !URI.isAbsolute(value) && !URI.isBNodeID(value)))
                    throw new IllegalArgumentError("The value of '" + propertyName + "' must be an absolute URI" + (propertyName === "@base" ? " or an empty string" : "") + ".");
                digestedSchema[propertyName.substr(1)] = value;
            }
            digestedSchema.base = digestedSchema.base || "";
            if ("@language" in schema) {
                var value = schema["@language"];
                if (value !== null && !isString(value))
                    throw new InvalidJSONLDSyntaxError("The value of '@language' must be a string or null.");
                digestedSchema.language = value;
            }
            for (var propertyName in schema) {
                if (!schema.hasOwnProperty(propertyName))
                    continue;
                if (propertyName === "@reverse")
                    continue;
                if (propertyName === "@index")
                    continue;
                if (propertyName === "@base")
                    continue;
                if (propertyName === "@vocab")
                    continue;
                if (propertyName === "@language")
                    continue;
                var propertyValue = schema[propertyName];
                if (isString(propertyValue)) {
                    if (URI.isPrefixed(propertyName))
                        throw new IllegalArgumentError("A prefixed property cannot be equal to another URI.");
                    digestedSchema.prefixes.set(propertyName, propertyValue);
                }
                else if (!!propertyValue && isObject(propertyValue)) {
                    var definition = ObjectSchemaDigester.digestProperty(propertyName, propertyValue);
                    digestedSchema.properties.set(propertyName, definition);
                }
                else {
                    throw new IllegalArgumentError("ObjectSchema Properties can only have string values or object values.");
                }
            }
            return digestedSchema;
        };
        ObjectSchemaDigester._combineSchemas = function (digestedSchemas) {
            var targetSchema = digestedSchemas[0], restSchemas = digestedSchemas.slice(1);
            restSchemas.forEach(function (schema) {
                if (schema.vocab !== void 0)
                    targetSchema.vocab = schema.vocab;
                if (schema.base !== "")
                    targetSchema.base = schema.base;
                if (schema.language !== null)
                    targetSchema.language = schema.language;
                MapUtils.extend(targetSchema.prefixes, schema.prefixes);
                MapUtils.extend(targetSchema.properties, schema.properties);
            });
            return targetSchema;
        };
        return ObjectSchemaDigester;
    }());

    var MAX_CONTEXT_URLS = 10;
    var LINK_HEADER_REL = "http://www.w3.org/ns/json-ld#context";
    var JSONLDProcessor = (function () {
        function JSONLDProcessor() {
        }
        JSONLDProcessor.expand = function (input) {
            return JSONLDProcessor.__retrieveContexts(input, Object.create(null), "").then(function () {
                var expanded = JSONLDProcessor.__process(new DigestedObjectSchema(), input);
                if (isObject(expanded) && "@graph" in expanded && Object.keys(expanded).length === 1) {
                    expanded = expanded["@graph"];
                }
                else if (expanded === null) {
                    expanded = [];
                }
                if (!isArray(expanded))
                    expanded = [expanded];
                return expanded;
            });
        };
        JSONLDProcessor.__getTargetFromLinkHeader = function (header) {
            var rLinkHeader = /\s*<([^>]*?)>\s*(?:;\s*(.*))?/;
            for (var _i = 0, _a = header.values; _i < _a.length; _i++) {
                var value = _a[_i];
                var match = value.toString().match(rLinkHeader);
                if (!match)
                    continue;
                var target = match[1];
                var params = match[2];
                var rParams = /(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g;
                var result = {};
                while (true) {
                    match = rParams.exec(params);
                    if (!match)
                        break;
                    result[match[1]] = (match[2] === undefined) ? match[3] : match[2];
                }
                if (result["rel"] === LINK_HEADER_REL)
                    return target;
            }
        };
        JSONLDProcessor.__findContextURLs = function (input, contexts, base, replace) {
            if (replace === void 0) { replace = false; }
            var previousContexts = Object.keys(contexts).length;
            if (isArray(input)) {
                for (var _i = 0, _a = input; _i < _a.length; _i++) {
                    var element = _a[_i];
                    JSONLDProcessor.__findContextURLs(element, contexts, base);
                }
            }
            else if (isPlainObject(input)) {
                for (var key in input) {
                    if ("@context" !== key) {
                        JSONLDProcessor.__findContextURLs(input[key], contexts, base);
                        continue;
                    }
                    var urlOrArrayOrContext = input[key];
                    if (isArray(urlOrArrayOrContext)) {
                        var contextArray = urlOrArrayOrContext;
                        for (var index = 0, length_1 = contextArray.length; index < length_1; ++index) {
                            var urlOrContext = contextArray[index];
                            if (!isString(urlOrContext))
                                continue;
                            var url = urlOrContext;
                            url = URI.resolve(base, url);
                            if (replace) {
                                if (isArray(contexts[url])) {
                                    contextArray.splice.apply(contextArray, [index, 1].concat([].concat(contexts[url])));
                                    index += contexts[url].length - 1;
                                    length_1 = contextArray.length;
                                }
                                else {
                                    contextArray[index] = contexts[url];
                                }
                            }
                            else if (!(url in contexts)) {
                                contexts[url] = true;
                            }
                        }
                    }
                    else if (isString(urlOrArrayOrContext)) {
                        var url = urlOrArrayOrContext;
                        url = URI.resolve(base, url);
                        if (replace) {
                            input[key] = contexts[url];
                        }
                        else if (!(url in contexts)) {
                            contexts[url] = null;
                        }
                    }
                }
            }
            return previousContexts < Object.keys(contexts).length;
        };
        JSONLDProcessor.__retrieveContexts = function (input, contextsRequested, base) {
            if (Object.keys(contextsRequested).length > MAX_CONTEXT_URLS)
                return Promise.reject(new InvalidJSONLDSyntaxError("Maximum number of @context URLs exceeded."));
            var contextToResolved = Object.create(null);
            if (!JSONLDProcessor.__findContextURLs(input, contextToResolved, base))
                return Promise.resolve();
            function resolved(url, promise) {
                return promise.then(function (_a) {
                    var object = _a[0], response = _a[1];
                    var _contextsRequested = ObjectUtils.clone(contextsRequested);
                    _contextsRequested[url] = true;
                    var contextWrapper = { "@context": {} };
                    var header = response.getHeader("Content-Type");
                    if (!header || !header.toString().includes("application/ld+json")) {
                        var link = void 0;
                        header = response.getHeader("Link");
                        if (header)
                            link = JSONLDProcessor.__getTargetFromLinkHeader(header);
                        if (link)
                            contextWrapper["@context"] = link;
                    }
                    else {
                        contextWrapper["@context"] = "@context" in object ? object["@context"] : {};
                    }
                    contextToResolved[url] = contextWrapper["@context"];
                    return JSONLDProcessor.__retrieveContexts(contextWrapper, _contextsRequested, url);
                });
            }
            var promises = [];
            var _loop_1 = function (url) {
                if (url in contextsRequested)
                    return { value: Promise.reject(new InvalidJSONLDSyntaxError("Cyclical @context URLs detected.")) };
                var requestOptions = { sendCredentialsOnCORS: false };
                RequestUtils.setAcceptHeader("application/ld+json, application/json", requestOptions);
                var promise = RequestService
                    .get(url, requestOptions, new JSONParser())
                    .catch(function (response) {
                    return Promise.reject(new InvalidJSONLDSyntaxError("Unable to resolve context from \"" + url + "\". Status code: " + response.status));
                });
                promises.push(resolved(url, promise));
            };
            for (var url in contextToResolved) {
                var state_1 = _loop_1(url);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
            return Promise.all(promises).then(function () {
                JSONLDProcessor.__findContextURLs(input, contextToResolved, base, true);
            });
        };
        JSONLDProcessor.__isKeyword = function (value) {
            if (!isString(value))
                return false;
            switch (value) {
                case "@base":
                case "@context":
                case "@container":
                case "@default":
                case "@embed":
                case "@explicit":
                case "@graph":
                case "@id":
                case "@index":
                case "@language":
                case "@list":
                case "@omitDefault":
                case "@preserve":
                case "@requireAll":
                case "@reverse":
                case "@set":
                case "@type":
                case "@value":
                case "@vocab":
                    return true;
                default:
                    return false;
            }
        };
        JSONLDProcessor.__isValidType = function (value) {
            if (isString(value))
                return true;
            if (!isArray(value))
                return false;
            for (var _i = 0, _a = value; _i < _a.length; _i++) {
                var element = _a[_i];
                if (!isString(element))
                    return false;
            }
            return true;
        };
        JSONLDProcessor.__expandURI = function (schema, uri, relativeTo) {
            if (JSONLDProcessor.__isKeyword(uri))
                return uri;
            return schema.resolveURI(uri, relativeTo);
        };
        JSONLDProcessor.__expandLanguageMap = function (languageMap) {
            var expandedLanguage = [];
            var keys = Object.keys(languageMap).sort();
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                var key = keys_1[_i];
                var values = languageMap[key];
                if (!isArray(values))
                    values = [values];
                for (var _a = 0, values_1 = values; _a < values_1.length; _a++) {
                    var item = values_1[_a];
                    if (item === null)
                        continue;
                    if (!isString(item))
                        throw new InvalidJSONLDSyntaxError("Language map values must be strings.");
                    expandedLanguage.push({
                        "@value": item,
                        "@language": key.toLowerCase(),
                    });
                }
            }
            return expandedLanguage;
        };
        JSONLDProcessor.__getContainer = function (context, property) {
            if (!property || !context.properties.has(property))
                return null;
            return context.properties.get(property).containerType;
        };
        JSONLDProcessor.__expandValue = function (context, value, propertyName) {
            if (value === null || !isDefined(value))
                return null;
            if (propertyName === "@id") {
                return JSONLDProcessor.__expandURI(context, value, { base: true });
            }
            else if (propertyName === "@type") {
                return JSONLDProcessor.__expandURI(context, value, { vocab: true, base: true });
            }
            var definition = propertyName && context.properties.has(propertyName)
                ? context.properties.get(propertyName)
                : new DigestedObjectSchemaProperty();
            if (definition.literal === false || (propertyName === "@graph" && isString(value))) {
                var options = { base: true };
                if (definition.pointerType === PointerType.VOCAB)
                    options.vocab = true;
                return { "@id": JSONLDProcessor.__expandURI(context, value, options) };
            }
            if (JSONLDProcessor.__isKeyword(propertyName))
                return value;
            var expandedValue = {};
            if (definition.literalType) {
                expandedValue["@type"] = context.resolveURI(definition.literalType, { vocab: true, base: true });
            }
            else if (isString(value)) {
                var language = isDefined(definition.language) ? definition.language : context.language;
                if (language)
                    expandedValue["@language"] = language;
            }
            if (["boolean", "number", "string"].indexOf(typeof value) === -1)
                value = value.toString();
            expandedValue["@value"] = value;
            return expandedValue;
        };
        JSONLDProcessor.__process = function (context, element, activeProperty, insideList) {
            if (element === null || !isDefined(element))
                return null;
            if (!isArray(element) && !isObject(element)) {
                if (!insideList && (activeProperty === null || activeProperty === "@graph"))
                    return null;
                return JSONLDProcessor.__expandValue(context, element, activeProperty);
            }
            if (isArray(element)) {
                var container = JSONLDProcessor.__getContainer(context, activeProperty);
                insideList = insideList || container === ContainerType.LIST;
                var expanded = [];
                for (var _i = 0, _a = element; _i < _a.length; _i++) {
                    var item = _a[_i];
                    var expandedItem = JSONLDProcessor.__process(context, item, activeProperty);
                    if (expandedItem === null)
                        continue;
                    if (insideList && (isArray(expandedItem) || RDFList.is(expandedItem)))
                        throw new InvalidJSONLDSyntaxError("Lists of lists are not permitted.");
                    if (!isArray(expandedItem))
                        expandedItem = [expandedItem];
                    expanded.push.apply(expanded, expandedItem);
                }
                return expanded;
            }
            if ("@context" in element) {
                context = ObjectSchemaDigester
                    .combineDigestedObjectSchemas([
                    context,
                    ObjectSchemaDigester.digestSchema(element["@context"]),
                ]);
            }
            var expandedElement = {};
            var keys = Object.keys(element);
            for (var _b = 0, keys_2 = keys; _b < keys_2.length; _b++) {
                var key = keys_2[_b];
                if (key === "@context")
                    continue;
                var uri = JSONLDProcessor.__expandURI(context, key, { vocab: true });
                if (!uri || !(URI.isAbsolute(uri) || URI.isBNodeID(uri) || JSONLDProcessor.__isKeyword(uri)))
                    continue;
                var value = element[key];
                if (JSONLDProcessor.__isKeyword(uri)) {
                    if (uri === "@id" && !isString(value))
                        throw new InvalidJSONLDSyntaxError("\"@id\" value must a string.");
                    if (uri === "@type" && !JSONLDProcessor.__isValidType(value))
                        throw new InvalidJSONLDSyntaxError("\"@type\" value must a string, an array of strings.");
                    if (uri === "@graph" && !(isObject(value) || isArray(value)))
                        throw new InvalidJSONLDSyntaxError("\"@graph\" value must not be an object or an array.");
                    if (uri === "@value" && (isObject(value) || isArray(value)))
                        throw new InvalidJSONLDSyntaxError("\"@value\" value must not be an object or an array.");
                    if (uri === "@language") {
                        if (value === null)
                            continue;
                        if (!isString(value))
                            throw new InvalidJSONLDSyntaxError("\"@language\" value must be a string.");
                        value = value.toLowerCase();
                    }
                    if (uri === "@index" && !isString(value))
                        throw new InvalidJSONLDSyntaxError("\"@index\" value must be a string.");
                    if (uri === "@reverse" && !isObject(value))
                        throw new InvalidJSONLDSyntaxError("\"@reverse\" value must be an object.");
                    if (uri === "@index" || uri === "@reverse")
                        throw new NotImplementedError("The SDK does not support \"@index\" and \"@reverse\" tags.");
                }
                var expandedValue = void 0;
                var container = JSONLDProcessor.__getContainer(context, key);
                if (container === ContainerType.LANGUAGE && isObject(value)) {
                    expandedValue = JSONLDProcessor.__expandLanguageMap(value);
                }
                else {
                    var nextActiveProperty = key;
                    var isList = uri === "@list";
                    if (isList || uri === "@set") {
                        nextActiveProperty = activeProperty;
                        if (isList && activeProperty === "@graph")
                            nextActiveProperty = null;
                    }
                    expandedValue = JSONLDProcessor.__process(context, value, nextActiveProperty, isList);
                }
                if (expandedValue === null && uri !== "@value")
                    continue;
                if (uri !== "@list" && !RDFList.is(expandedValue) && container === ContainerType.LIST) {
                    if (!isArray(expandedValue))
                        expandedValue = [expandedValue];
                    expandedValue = { "@list": expandedValue };
                }
                var useArray = ["@type", "@id", "@value", "@language"].indexOf(uri) === -1;
                JSONLDProcessor.__addValue(expandedElement, uri, expandedValue, { propertyIsArray: useArray });
            }
            if ("@value" in expandedElement) {
                if (expandedElement["@value"] === null)
                    expandedElement = null;
            }
            else if ("@type" in expandedElement) {
                if (!isArray(expandedElement["@type"]))
                    expandedElement["@type"] = [expandedElement["@type"]];
            }
            else if ("@set" in expandedElement) {
                expandedElement = expandedElement["@set"];
            }
            return expandedElement;
        };
        JSONLDProcessor.__addValue = function (element, propertyName, value, options) {
            if (isArray(value)) {
                var values = value;
                if (values.length === 0 && options.propertyIsArray && !hasProperty(element, propertyName))
                    element[propertyName] = [];
                for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {
                    var item = values_2[_i];
                    JSONLDProcessor.__addValue(element, propertyName, item, options);
                }
            }
            else if (propertyName in element) {
                if (!JSONLDProcessor.__hasValue(element, propertyName, value)) {
                    var items = element[propertyName];
                    if (!isArray(items))
                        items = element[propertyName] = [items];
                    items.push(value);
                }
            }
            else {
                element[propertyName] = options.propertyIsArray ? [value] : value;
            }
        };
        JSONLDProcessor.__hasProperty = function (element, propertyName) {
            if (propertyName in element) {
                var item = element[propertyName];
                return !isArray(item) || item.length > 0;
            }
            return false;
        };
        JSONLDProcessor.__compareValues = function (value1, value2) {
            if (value1 === value2)
                return true;
            if (isObject(value1) && isObject(value2)) {
                if ("@value" in value1
                    && value1["@value"] === value2["@value"]
                    && value1["@type"] === value2["@type"]
                    && value1["@language"] === value2["@language"]
                    && value1["@index"] === value2["@index"])
                    return true;
                if ("@id" in value1)
                    return value1["@id"] === value2["@id"];
            }
            return false;
        };
        JSONLDProcessor.__hasValue = function (element, propertyName, value) {
            if (JSONLDProcessor.__hasProperty(element, propertyName)) {
                var item = element[propertyName];
                var isList = RDFList.is(item);
                if (isList || isArray(item)) {
                    var items = isList ? item["@list"] : item;
                    for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                        var entry = items_1[_i];
                        if (JSONLDProcessor.__compareValues(entry, value))
                            return true;
                    }
                }
                else if (!isArray(value)) {
                    return JSONLDProcessor.__compareValues(item, value);
                }
            }
            return false;
        };
        return JSONLDProcessor;
    }());

    var JSONLDParser = (function (_super) {
        __extends(JSONLDParser, _super);
        function JSONLDParser() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        JSONLDParser.prototype.parse = function (input) {
            return _super.prototype.parse.call(this, input).then(JSONLDProcessor.expand);
        };
        return JSONLDParser;
    }(JSONParser));

    var C = {
        namespace: "https://carbonldp.com/ns/v1/platform#",
        AccessPoint: "https://carbonldp.com/ns/v1/platform#AccessPoint",
        AddMemberAction: "https://carbonldp.com/ns/v1/platform#AddMemberAction",
        ChildCreatedEvent: "https://carbonldp.com/ns/v1/platform#ChildCreatedEvent",
        Document: "https://carbonldp.com/ns/v1/platform#Document",
        DocumentCreatedEventDetails: "https://carbonldp.com/ns/v1/platform#DocumentCreatedEventDetails",
        DocumentDeletedEvent: "https://carbonldp.com/ns/v1/platform#DocumentDeletedEvent",
        DocumentMetadata: "https://carbonldp.com/ns/v1/platform#DocumentMetadata",
        DocumentModifiedEvent: "https://carbonldp.com/ns/v1/platform#DocumentModifiedEvent",
        ErrorResponse: "https://carbonldp.com/ns/v1/platform#ErrorResponse",
        Error: "https://carbonldp.com/ns/v1/platform#Error",
        Instance: "https://carbonldp.com/ns/v1/platform#Instance",
        Map: "https://carbonldp.com/ns/v1/platform#Map",
        MemberAddedEvent: "https://carbonldp.com/ns/v1/platform#MemberAddedEvent",
        MemberAddedEventDetails: "https://carbonldp.com/ns/v1/platform#MemberAddedEventDetails",
        MemberRemovedEvent: "https://carbonldp.com/ns/v1/platform#MemberRemovedEvent",
        MemberRemovedEventDetails: "https://carbonldp.com/ns/v1/platform#MemberRemovedEventDetails",
        NonReadableMembershipResourceTriples: "https://carbonldp.com/ns/v1/platform#NonReadableMembershipResourceTriples",
        Platform: "https://carbonldp.com/ns/v1/platform#Platform",
        PlatformInstance: "https://carbonldp.com/ns/v1/platform#PlatformInstance",
        PreferContainer: "https://carbonldp.com/ns/v1/platform#PreferContainer",
        PreferContainmentResources: "https://carbonldp.com/ns/v1/platform#PreferContainmentResources",
        PreferContainmentTriples: "https://carbonldp.com/ns/v1/platform#PreferContainmentTriples",
        PreferDocumentChecksums: "https://carbonldp.com/ns/v1/platform#PreferDocumentChecksums",
        PreferMembershipResources: "https://carbonldp.com/ns/v1/platform#PreferMembershipResources",
        PreferMembershipTriples: "https://carbonldp.com/ns/v1/platform#PreferMembershipTriples",
        PreferResultsContexts: "https://carbonldp.com/ns/v1/platform#PreferResultsContexts",
        PreferSelectedMembershipTriples: "https://carbonldp.com/ns/v1/platform#PreferSelectedMembershipTriples",
        QueryMetadata: "https://carbonldp.com/ns/v1/platform#QueryMetadata",
        RemoveMemberAction: "https://carbonldp.com/ns/v1/platform#RemoveMemberAction",
        ResponseMetadata: "https://carbonldp.com/ns/v1/platform#ResponseMetadata",
        ValidationError: "https://carbonldp.com/ns/v1/platform#ValidationError",
        VolatileResource: "https://carbonldp.com/ns/v1/platform#VolatileResource",
        accessPoint: "https://carbonldp.com/ns/v1/platform#accessPoint",
        bNodesMap: "https://carbonldp.com/ns/v1/platform#bNodesMap",
        buildDate: "https://carbonldp.com/ns/v1/platform#buildDate",
        checksum: "https://carbonldp.com/ns/v1/platform#checksum",
        created: "https://carbonldp.com/ns/v1/platform#created",
        createdDocument: "https://carbonldp.com/ns/v1/platform#createdDocument",
        details: "https://carbonldp.com/ns/v1/platform#details",
        defaultInteractionModel: "https://carbonldp.com/ns/v1/platform#defaultInteractionModel",
        document: "https://carbonldp.com/ns/v1/platform#document",
        documentMetadata: "https://carbonldp.com/ns/v1/platform#documentMetadata",
        entry: "https://carbonldp.com/ns/v1/platform#entry",
        entryKey: "https://carbonldp.com/ns/v1/platform#entryKey",
        entryValue: "https://carbonldp.com/ns/v1/platform#entryValue",
        error: "https://carbonldp.com/ns/v1/platform#error",
        errorCode: "https://carbonldp.com/ns/v1/platform#errorCode",
        errorDetails: "https://carbonldp.com/ns/v1/platform#errorDetails",
        errorMessage: "https://carbonldp.com/ns/v1/platform#errorMessage",
        errorParameters: "https://carbonldp.com/ns/v1/platform#errorParameters",
        httpStatusCode: "https://carbonldp.com/ns/v1/platform#httpStatusCode",
        instance: "https://carbonldp.com/ns/v1/platform#instance",
        mediaType: "https://carbonldp.com/ns/v1/platform#mediaType",
        member: "https://carbonldp.com/ns/v1/platform#member",
        modified: "https://carbonldp.com/ns/v1/platform#modified",
        requestID: "https://carbonldp.com/ns/v1/platform#requestID",
        relatedDocument: "https://carbonldp.com/ns/v1/platform#relatedDocument",
        size: "https://carbonldp.com/ns/v1/platform#size",
        target: "https://carbonldp.com/ns/v1/platform#target",
        targetMember: "https://carbonldp.com/ns/v1/platform#targetMember",
        version: "https://carbonldp.com/ns/v1/platform#version",
    };

    var SCHEMA = {
        "errors": {
            "@id": C.error,
            "@type": "@id",
            "@container": "@set",
        },
        "requestID": {
            "@id": C.requestID,
            "@type": XSD.string,
        },
        "statusCode": {
            "@id": C.httpStatusCode,
            "@type": XSD.int,
        },
    };
    var ErrorResponse = {
        TYPE: C.ErrorResponse,
        SCHEMA: SCHEMA,
        is: function (value) {
            return Resource.is(value)
                && value.$hasType(ErrorResponse.TYPE);
        },
        getMessage: function (errorResponse) {
            return errorResponse.errors
                .map(function (error) { return error.errorMessage; })
                .join(", ");
        },
    };

    var RDFDocument = {
        is: function (value) {
            return hasProperty(value, "@graph")
                && isArray(value["@graph"]);
        },
        create: function (resources, uri) {
            return {
                "@id": uri ? uri : "",
                "@graph": resources,
            };
        },
        getDocuments: function (objects) {
            if (isArray(objects))
                return objects
                    .filter(RDFDocument.is);
            if (RDFDocument.is(objects))
                return [objects];
            return [];
        },
        getFreeNodes: function (objects) {
            if (!Array.isArray(objects))
                return [];
            return objects
                .filter(function (element) { return !RDFDocument.is(element); })
                .filter(RDFNode.is);
        },
        getResources: function (objects) {
            var resources = RDFDocument.getFreeNodes(objects);
            RDFDocument
                .getDocuments(objects)
                .map(function (document) { return document["@graph"]; })
                .forEach(function (nodes) { return resources.push.apply(resources, nodes); });
            return resources;
        },
        getDocumentResources: function (document) {
            return RDFDocument
                .getResources(document)
                .filter(function (node) { return !RDFNode.isFragment(node); });
        },
        getNamedFragmentResources: function (document, documentResource) {
            var uriToMatch = isObject(documentResource) ?
                RDFNode.getID(documentResource) :
                documentResource;
            return RDFDocument
                .getResources(document)
                .filter(function (node) {
                var id = RDFNode.getID(node);
                if (!URI.hasFragment(id))
                    return;
                if (!uriToMatch)
                    return true;
                return URI.getDocumentURI(id) === uriToMatch;
            });
        },
        getBNodeResources: function (document) {
            return RDFDocument
                .getResources(document)
                .filter(function (node) {
                var id = RDFNode.getID(node);
                return URI.isBNodeID(id);
            });
        },
        getNodes: function (rdfDocument) {
            var documentNodes = [];
            var fragmentNodes = [];
            for (var _i = 0, _a = rdfDocument["@graph"]; _i < _a.length; _i++) {
                var node = _a[_i];
                (RDFNode.isFragment(node) ? fragmentNodes : documentNodes).push(node);
            }
            return [documentNodes, fragmentNodes];
        },
    };

    function _parseURIParams(resource, uri, args) {
        var _uri = isString(uri) ?
            URI.resolve(resource.$id, uri) : resource.$id;
        var _args = !isString(uri) ?
            Array.from(args) :
            Array.prototype.slice.call(args, 1);
        return { _uri: _uri, _args: _args };
    }
    function _parseResourceParams(resource, $resource, args) {
        var _resource = Pointer.is($resource) ?
            $resource : resource;
        var _args = !Pointer.is($resource) ?
            Array.from(args) :
            Array.prototype.slice.call(args, 1);
        return { _resource: _resource, _args: _args };
    }
    function _getErrorResponseParserFn(registry) {
        return function (error) {
            if (!("response" in error))
                return Promise.reject(error);
            if (!error.response.data)
                return Promise.reject(error);
            return new JSONLDParser()
                .parse(error.response.data)
                .then(function (rdfNodes) {
                var freeNodes = RDFDocument.getFreeNodes(rdfNodes);
                var freeResources = FreeResources.parseFreeNodes(registry, freeNodes);
                var errorResponses = freeResources
                    .getPointers(true)
                    .filter(ErrorResponse.is);
                if (errorResponses.length === 0)
                    return Promise.reject(error);
                var errorResponse = Object.assign(error, errorResponses[0]);
                error.message = ErrorResponse.getMessage(errorResponse);
                return Promise.reject(error);
            }, function () {
                return Promise.reject(error);
            });
        };
    }

    function __internalRevert(target, source) {
        if (!isObject(target) || !isObject(source))
            return;
        new Set(Object.keys(target).concat(Object.keys(source))).forEach(function (key) {
            var sourceValue = Array.isArray(source[key]) ? source[key].slice() : source[key];
            if (sourceValue === null || sourceValue === void 0) {
                delete target[key];
                return;
            }
            if (isFunction(sourceValue))
                return;
            target[key] = sourceValue;
        });
    }
    var ResolvablePointer = {
        PROTOTYPE: {
            get $repository() {
                throw new IllegalArgumentError("Property \"$repository\" is required.");
            },
            $eTag: void 0,
            $_resolved: false,
            $isResolved: function () {
                return this.$_resolved;
            },
            $_snapshot: {},
            $_syncSnapshot: function () {
                var clone = ObjectUtils.clone(this, { arrays: true });
                if (this.types)
                    clone.types = this.types.slice();
                this.$_snapshot = clone;
            },
            $isDirty: function () {
                return !ObjectUtils
                    .areEqual(this, this.$_snapshot, { arrays: true });
            },
            $revert: function () {
                __internalRevert(this, this.$_snapshot);
                if (!this.types)
                    this.types = [];
            },
            $get: function (uri) {
                var _a, _b;
                var _c = _parseURIParams(this, uri, arguments), _uri = _c._uri, _args = _c._args;
                return "$id" in this.$repository ? (_a = this.$repository).$get.apply(_a, [_uri].concat(_args)) : (_b = this.$repository).get.apply(_b, [_uri].concat(_args));
            },
            $resolve: function (resource) {
                var _a, _b;
                var _c = _parseResourceParams(this, resource, arguments), _resource = _c._resource, _args = _c._args;
                return "$id" in this.$repository ? (_a = this.$repository).$resolve.apply(_a, [_resource].concat(_args)) : (_b = this.$repository).resolve.apply(_b, [_resource].concat(_args));
            },
            $exists: function (uri) {
                var _a, _b;
                var _c = _parseURIParams(this, uri, arguments), _uri = _c._uri, _args = _c._args;
                return "$id" in this.$repository ? (_a = this.$repository).$exists.apply(_a, [_uri].concat(_args)) : (_b = this.$repository).exists.apply(_b, [_uri].concat(_args));
            },
            $refresh: function (resource) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var _a, _b;
                var _c = _parseResourceParams(this, resource, arguments), _resource = _c._resource, _args = _c._args;
                return "$id" in this.$repository ? (_a = this.$repository).$refresh.apply(_a, [_resource].concat(_args)) : (_b = this.$repository).refresh.apply(_b, [_resource].concat(_args));
            },
            $save: function (resource) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var _a, _b;
                var _c = _parseResourceParams(this, resource, arguments), _resource = _c._resource, _args = _c._args;
                return "$id" in this.$repository ? (_a = this.$repository).$save.apply(_a, [_resource].concat(_args)) : (_b = this.$repository).save.apply(_b, [_resource].concat(_args));
            },
            $saveAndRefresh: function (resource) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var _a, _b;
                var _c = _parseResourceParams(this, resource, arguments), _resource = _c._resource, _args = _c._args;
                return "$id" in this.$repository ? (_a = this.$repository).$saveAndRefresh.apply(_a, [_resource].concat(_args)) : (_b = this.$repository).saveAndRefresh.apply(_b, [_resource].concat(_args));
            },
            $delete: function (uri) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var _a, _b;
                var _c = _parseURIParams(this, uri, arguments), _uri = _c._uri, _args = _c._args;
                return "$id" in this.$repository ? (_a = this.$repository).$delete.apply(_a, [_uri].concat(_args)) : (_b = this.$repository).delete.apply(_b, [_uri].concat(_args));
            },
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(ResolvablePointer.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (ResolvablePointer.isDecorated(object))
                return object;
            var resource = ModelDecorator
                .decorateMultiple(object, Pointer);
            return ModelDecorator
                .definePropertiesFrom(ResolvablePointer.PROTOTYPE, resource);
        },
        is: function (value) {
            return Pointer.is(value)
                && ResolvablePointer.isDecorated(value);
        },
    };

    var QueryablePointer = {
        PROTOTYPE: {
            $_queryableMetadata: void 0,
            $isQueried: function () {
                return !!this.$_queryableMetadata;
            },
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(QueryablePointer.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (QueryablePointer.isDecorated(object))
                return object;
            var target = ModelDecorator
                .decorateMultiple(object, ResolvablePointer);
            return ModelDecorator
                .definePropertiesFrom(QueryablePointer.PROTOTYPE, target);
        },
        is: function (value) {
            return ResolvablePointer.is(value)
                && QueryablePointer.isDecorated(value);
        },
    };

    var TransientFragment = {
        PROTOTYPE: {
            get $registry() {
                throw new IllegalArgumentError("Property \"$registry\" is required.");
            },
            get $slug() {
                return URI.generateBNodeID();
            },
            get $id() {
                if (URI.isBNodeID(this.$slug))
                    return this.$slug;
                return this.$document.$id + "#" + this.$slug;
            },
            set $id(value) {
                if (URI.isBNodeID(value))
                    this.$slug = value;
                else
                    this.$slug = URI.getFragment(value);
            },
            get $document() {
                return this.$registry;
            },
            set $document(document) {
                this.$registry = document;
            },
        },
        isDecorated: function (object) {
            return Resource.isDecorated(object);
        },
        decorate: function (object) {
            if (TransientFragment.isDecorated(object))
                return object;
            var target = ModelDecorator
                .decorateMultiple(object, Resource);
            if (!target.$registry)
                delete target.$registry;
            if (!target.$slug)
                delete target.$slug;
            return ModelDecorator
                .definePropertiesFrom(TransientFragment.PROTOTYPE, target);
        },
        is: function (value) {
            return Resource.is(value);
        },
        create: function (data) {
            var copy = Object.assign({}, data);
            return TransientFragment.createFrom(copy);
        },
        createFrom: function (object) {
            return TransientFragment.decorate(object);
        },
    };

    var Fragment = {
        PROTOTYPE: {
            get $repository() {
                return this.$registry;
            },
            set $repository(document) {
                this.$registry = document;
            },
            get $_resolved() {
                return this.$document.$_resolved;
            },
            set $_resolved(_value) { },
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(Fragment.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (Fragment.isDecorated(object))
                return object;
            var forced = Object.assign(object, {
                $document: object.$registry,
                $repository: object.$registry,
            });
            var target = ModelDecorator
                .decorateMultiple(forced, TransientFragment, QueryablePointer);
            return ModelDecorator
                .definePropertiesFrom(Fragment.PROTOTYPE, target);
        },
        create: TransientFragment.create,
        createFrom: TransientFragment.createFrom,
    };

    var LDP = {
        namespace: "http://www.w3.org/ns/ldp#",
        Ascending: "http://www.w3.org/ns/ldp#Ascending",
        BasicContainer: "http://www.w3.org/ns/ldp#BasicContainer",
        Container: "http://www.w3.org/ns/ldp#Container",
        Descending: "http://www.w3.org/ns/ldp#Descending",
        DirectContainer: "http://www.w3.org/ns/ldp#DirectContainer",
        IndirectContainer: "http://www.w3.org/ns/ldp#IndirectContainer",
        RDFSource: "http://www.w3.org/ns/ldp#RDFSource",
        Resource: "http://www.w3.org/ns/ldp#Resource",
        MemberSubject: "http://www.w3.org/ns/ldp#MemberSubject",
        NonRDFSource: "http://www.w3.org/ns/ldp#NonRDFSource",
        Page: "http://www.w3.org/ns/ldp#Page",
        PageSortCriterion: "http://www.w3.org/ns/ldp#PageSortCriterion",
        PreferContainment: "http://www.w3.org/ns/ldp#PreferContainment",
        PreferEmptyContainer: "http://www.w3.org/ns/ldp#PreferEmptyContainer",
        PreferMembership: "http://www.w3.org/ns/ldp#PreferMembership",
        PreferMinimalContainer: "http://www.w3.org/ns/ldp#PreferMinimalContainer",
        constrainedBy: "http://www.w3.org/ns/ldp#constrainedBy",
        contains: "http://www.w3.org/ns/ldp#contains",
        hasMemberRelation: "http://www.w3.org/ns/ldp#hasMemberRelation",
        insertedContentRelation: "http://www.w3.org/ns/ldp#insertedContentRelation",
        isMemberOfRelation: "http://www.w3.org/ns/ldp#isMemberOfRelation",
        member: "http://www.w3.org/ns/ldp#member",
        membershipResource: "http://www.w3.org/ns/ldp#membershipResource",
        pageSequence: "http://www.w3.org/ns/ldp#pageSequence",
        pageSortCollation: "http://www.w3.org/ns/ldp#pageSortCollation",
        pageSortCriteria: "http://www.w3.org/ns/ldp#pageSortCriteria",
        pageSortOrder: "http://www.w3.org/ns/ldp#pageSortOrder",
    };

    var Event;
    (function (Event) {
        Event["CHILD_CREATED"] = "child.created";
        Event["DOCUMENT_MODIFIED"] = "document.modified";
        Event["DOCUMENT_DELETED"] = "document.deleted";
        Event["MEMBER_ADDED"] = "member.added";
        Event["MEMBER_REMOVED"] = "member.removed";
    })(Event || (Event = {}));

    function __getLabelFrom(slug) {
        if (!isRelative(slug) || slug.startsWith("#"))
            return slug;
        return "#" + slug;
    }
    function __getObjectId(object) {
        if ("$id" in object)
            return object.$id;
        if ("$slug" in object)
            return URI.hasFragment(object.$slug) ?
                object.$slug : __getLabelFrom(object.$slug);
        return URI.generateBNodeID();
    }
    function __convertNested(resource, target, tracker) {
        if (tracker === void 0) { tracker = new Set(); }
        Object
            .keys(target)
            .map(function (key) { return target[key]; })
            .forEach(function (next) {
            if (Array.isArray(next))
                return __convertNested(resource, next, tracker);
            if (!isPlainObject(next))
                return;
            if (TransientDocument.is(next))
                return;
            if (next._registry && next._registry !== resource)
                return;
            var idOrSlug = __getObjectId(next);
            if (tracker.has(idOrSlug))
                return;
            if (!resource.$inScope(idOrSlug, true))
                return;
            var fragment = resource.$hasPointer(idOrSlug, true) ?
                resource.$getPointer(idOrSlug, true) :
                resource.$createFragment(next, idOrSlug);
            tracker.add(fragment.$id);
            __convertNested(resource, fragment, tracker);
        });
    }
    var TransientDocument = {
        PROTOTYPE: {
            $registry: void 0,
            $_normalize: function () {
                var usedFragments = new Set();
                __convertNested(this, this, usedFragments);
                this.$getPointers(true)
                    .map(Pointer.getID)
                    .filter(URI.isBNodeID)
                    .filter(function (id) { return !usedFragments.has(id); })
                    .forEach(this.$removePointer, this);
            },
            $_getLocalID: function (id) {
                if (URI.isBNodeID(id))
                    return id;
                if (URI.isFragmentOf(id, this.$id))
                    return URI.getFragment(id);
                throw new IllegalArgumentError("\"" + id + "\" is out of scope.");
            },
            $getPointer: function (id, local) {
                id = URI.resolve(this.$id, id);
                return Registry.PROTOTYPE.getPointer.call(this, id, local);
            },
            $hasFragment: function (id) {
                id = __getLabelFrom(id);
                if (!this.$inScope(id, true))
                    return false;
                var localID = this.$_getLocalID(id);
                return this.$__resourcesMap.has(localID);
            },
            $getFragment: function (id) {
                id = __getLabelFrom(id);
                var localID = this.$_getLocalID(id);
                var resource = this.$__resourcesMap.get(localID);
                if (!resource)
                    return null;
                return resource;
            },
            $getFragments: function () {
                return this.$getPointers(true);
            },
            $createFragment: function (isOrObject, id) {
                var object = isObject(isOrObject) ? isOrObject : {};
                if (isString(isOrObject))
                    id = isOrObject;
                var $id = id ? __getLabelFrom(id) : __getObjectId(object);
                var fragment = this.$_addPointer(Object
                    .assign(object, { $id: $id }));
                __convertNested(this, fragment);
                return fragment;
            },
            $removeFragment: function (fragmentOrSlug) {
                var id = __getLabelFrom(Pointer.getID(fragmentOrSlug));
                if (!this.$inScope(id, true))
                    return false;
                return this.$removePointer(id);
            },
            toJSON: function (contextOrKey) {
                var nodes = [
                    Resource.PROTOTYPE.toJSON.call(this, contextOrKey)
                ].concat(this
                    .$getFragments()
                    .map(function (resource) { return resource.toJSON(contextOrKey); }));
                return {
                    "@id": this.$id,
                    "@graph": nodes,
                };
            },
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(TransientDocument.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (TransientDocument.isDecorated(object))
                return object;
            var base = ModelDecorator.definePropertiesFrom({
                $__modelDecorator: TransientFragment,
            }, object);
            var resource = ModelDecorator
                .decorateMultiple(base, Resource, Registry);
            return ModelDecorator
                .definePropertiesFrom(TransientDocument.PROTOTYPE, resource);
        },
        is: function (value) {
            return Resource.is(value) &&
                Registry.isDecorated(value) &&
                TransientDocument.isDecorated(value);
        },
        createFrom: function (object) {
            if (TransientDocument.is(object))
                throw new IllegalArgumentError("The object provided is already a Document.");
            var document = TransientDocument.decorate(object);
            __convertNested(document, document);
            return document;
        },
        create: function (data) {
            var copy = Object.assign({}, data);
            return TransientDocument.createFrom(copy);
        },
    };

    function __parseParams(resource, uriPatternOROnEvent, onEventOrOnError, onError) {
        var uriPattern = isString(uriPatternOROnEvent) ?
            URI.resolve(resource.$id, uriPatternOROnEvent) : resource.$id;
        var onEvent = isFunction(uriPatternOROnEvent) ?
            uriPatternOROnEvent : onEventOrOnError;
        if (onEvent !== onEventOrOnError)
            onError = onEventOrOnError;
        return { uriPattern: uriPattern, onEvent: onEvent, onError: onError };
    }
    var EventEmitterDocumentTrait = {
        PROTOTYPE: {
            $on: function (event, uriPatternOROnEvent, onEventOrOnError, onError) {
                var _a = __parseParams(this, uriPatternOROnEvent, onEventOrOnError, onError), uriPattern = _a.uriPattern, onEvent = _a.onEvent, $onError = _a.onError;
                return this.$repository.on(event, uriPattern, onEvent, $onError);
            },
            $off: function (event, uriPatternOROnEvent, onEventOrOnError, onError) {
                var _a = __parseParams(this, uriPatternOROnEvent, onEventOrOnError, onError), uriPattern = _a.uriPattern, onEvent = _a.onEvent, $onError = _a.onError;
                return this.$repository.off(event, uriPattern, onEvent, $onError);
            },
            $one: function (event, uriPatternOROnEvent, onEventOrOnError, onError) {
                var _a = __parseParams(this, uriPatternOROnEvent, onEventOrOnError, onError), uriPattern = _a.uriPattern, onEvent = _a.onEvent, $onError = _a.onError;
                return this.$repository.one(event, uriPattern, onEvent, $onError);
            },
            $onChildCreated: function (uriPatternOROnEvent, onEventOrOnError, onError) {
                return this.$on(Event.CHILD_CREATED, uriPatternOROnEvent, onEventOrOnError, onError);
            },
            $onDocumentModified: function (uriPatternOROnEvent, onEventOrOnError, onError) {
                return this.$on(Event.DOCUMENT_MODIFIED, uriPatternOROnEvent, onEventOrOnError, onError);
            },
            $onDocumentDeleted: function (uriPatternOROnEvent, onEventOrOnError, onError) {
                return this.$on(Event.DOCUMENT_DELETED, uriPatternOROnEvent, onEventOrOnError, onError);
            },
            $onMemberAdded: function (uriPatternOROnEvent, onEventOrOnError, onError) {
                return this.$on(Event.MEMBER_ADDED, uriPatternOROnEvent, onEventOrOnError, onError);
            },
            $onMemberRemoved: function (uriPatternOROnEvent, onEventOrOnError, onError) {
                return this.$on(Event.MEMBER_REMOVED, uriPatternOROnEvent, onEventOrOnError, onError);
            },
        },
        isDecorated: function (object) {
            return isObject(object)
                && ModelDecorator
                    .hasPropertiesFrom(EventEmitterDocumentTrait.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (EventEmitterDocumentTrait.isDecorated(object))
                return object;
            var resource = ModelDecorator
                .decorateMultiple(object, TransientDocument, ResolvablePointer);
            return ModelDecorator
                .definePropertiesFrom(EventEmitterDocumentTrait.PROTOTYPE, resource);
        },
    };

    function __parseMemberParams(resource, args) {
        var params = Array.from(args);
        var uri = isString(params[0]) && isString(Pointer.getID(params[1])) ?
            URI.resolve(resource.$id, params.shift()) : resource.$id;
        return { uri: uri, params: params };
    }
    var LDPDocumentTrait = {
        PROTOTYPE: {
            $create: function (uriOrChildren, childrenOrSlugsOrRequestOptions, slugsOrRequestOptions, requestOptions) {
                var _a;
                var _b = _parseURIParams(this, uriOrChildren, arguments), _uri = _b._uri, _args = _b._args;
                return (_a = this.$repository).create.apply(_a, [_uri].concat(_args));
            },
            $createAndRetrieve: function (uriOrChildren, childrenOrSlugsOrRequestOptions, slugsOrRequestOptions, requestOptions) {
                if (requestOptions === void 0) { requestOptions = {}; }
                var _a;
                var _b = _parseURIParams(this, uriOrChildren, arguments), _uri = _b._uri, _args = _b._args;
                return (_a = this.$repository).createAndRetrieve.apply(_a, [_uri].concat(_args));
            },
            $addMember: function (uriOrMember, memberOrOptions, requestOptions) {
                var _a;
                var _b = __parseMemberParams(this, arguments), uri = _b.uri, params = _b.params;
                return (_a = this.$repository).addMember.apply(_a, [uri].concat(params));
            },
            $addMembers: function (uriOrMembers, membersOrOptions, requestOptions) {
                var _a;
                var _b = _parseURIParams(this, uriOrMembers, arguments), _uri = _b._uri, _args = _b._args;
                return (_a = this.$repository).addMembers.apply(_a, [_uri].concat(_args));
            },
            $removeMember: function (uriOrMember, memberOrOptions, requestOptions) {
                var _a;
                var _b = __parseMemberParams(this, arguments), uri = _b.uri, params = _b.params;
                return (_a = this.$repository).removeMember.apply(_a, [uri].concat(params));
            },
            $removeMembers: function (uriOrMembersOrOptions, membersOrOptions, requestOptions) {
                var _a;
                var _b = _parseURIParams(this, uriOrMembersOrOptions, arguments), _uri = _b._uri, _args = _b._args;
                return (_a = this.$repository).removeMembers.apply(_a, [_uri].concat(_args));
            },
        },
        isDecorated: function (object) {
            return isObject(object)
                && ModelDecorator
                    .hasPropertiesFrom(LDPDocumentTrait.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (LDPDocumentTrait.isDecorated(object))
                return object;
            var target = ModelDecorator
                .decorateMultiple(object, TransientDocument, ResolvablePointer);
            return ModelDecorator
                .definePropertiesFrom(LDPDocumentTrait.PROTOTYPE, target);
        },
    };

    var QueryableDocumentTrait = {
        PROTOTYPE: {
            $get: function (uris) {
                var _this = this;
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var _a, _b;
                if (!Array.isArray(uris))
                    return (_a = ResolvablePointer.PROTOTYPE.$get).call.apply(_a, [this, uris].concat(args));
                var resolvedURIs = uris.map(function (uri) { return URI.resolve(_this.$id, uri); });
                return (_b = this.$repository).get.apply(_b, [resolvedURIs].concat(args));
            },
            $getChildren: function (uriOrQueryBuilderFnOrOptions, queryBuilderFnOrOptions, queryBuilderFn) {
                var _a;
                var _b = _parseURIParams(this, uriOrQueryBuilderFnOrOptions, arguments), _uri = _b._uri, _args = _b._args;
                return (_a = this.$repository).getChildren.apply(_a, [_uri].concat(_args));
            },
            $getMembers: function (uriOrQueryBuilderFnOrOptions, queryBuilderFnOrOptions, queryBuilderFn) {
                var _a;
                var _b = _parseURIParams(this, uriOrQueryBuilderFnOrOptions, arguments), _uri = _b._uri, _args = _b._args;
                return (_a = this.$repository).getMembers.apply(_a, [_uri].concat(_args));
            },
            $listChildren: function (uriOrOptions, requestOptions) {
                var _a;
                var _b = _parseURIParams(this, uriOrOptions, arguments), _uri = _b._uri, _args = _b._args;
                return (_a = this.$repository).listChildren.apply(_a, [_uri].concat(_args));
            },
            $listMembers: function (uriOrOptions, requestOptions) {
                var _a;
                var _b = _parseURIParams(this, uriOrOptions, arguments), _uri = _b._uri, _args = _b._args;
                return (_a = this.$repository).listMembers.apply(_a, [_uri].concat(_args));
            },
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(QueryableDocumentTrait.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (QueryableDocumentTrait.isDecorated(object))
                return object;
            var forced = object;
            var target = ModelDecorator
                .decorateMultiple(forced, LDPDocumentTrait, QueryablePointer);
            return ModelDecorator
                .definePropertiesFrom(QueryableDocumentTrait.PROTOTYPE, target);
        },
    };

    function __parseParams$1(resource, uriOrQuery, queryOrOptions, options) {
        var uri = resource.$id;
        var query = uriOrQuery;
        if (isObject(queryOrOptions)) {
            options = queryOrOptions;
        }
        else if (queryOrOptions !== void 0) {
            query = queryOrOptions;
            uri = URI.resolve(resource.$id, uriOrQuery);
        }
        return { uri: uri, query: query, options: options };
    }
    var SPARQLDocumentTrait = {
        PROTOTYPE: {
            $executeASKQuery: function (uriOrQuery, queryOrOptions, requestOptions) {
                var _a = __parseParams$1(this, uriOrQuery, queryOrOptions, requestOptions), uri = _a.uri, query = _a.query, options = _a.options;
                return this.$repository.executeASKQuery(uri, query, options);
            },
            $executeSELECTQuery: function (uriOrQuery, queryOrOptions, requestOptions) {
                var _a = __parseParams$1(this, uriOrQuery, queryOrOptions, requestOptions), uri = _a.uri, query = _a.query, options = _a.options;
                return this.$repository.executeSELECTQuery(uri, query, options);
            },
            $executeUPDATE: function (uriOrQuery, updateOrOptions, requestOptions) {
                var _a = __parseParams$1(this, uriOrQuery, updateOrOptions, requestOptions), uri = _a.uri, query = _a.query, options = _a.options;
                return this.$repository.executeUPDATE(uri, query, options);
            },
            $sparql: function (uri) {
                var $uri = uri ? URI.resolve(this.$id, uri) : this.$id;
                return this.$repository.sparql($uri);
            },
        },
        isDecorated: function (object) {
            return isObject(object)
                && ModelDecorator
                    .hasPropertiesFrom(SPARQLDocumentTrait.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (SPARQLDocumentTrait.isDecorated(object))
                return object;
            var target = ModelDecorator
                .decorateMultiple(object, TransientDocument, ResolvablePointer);
            return ModelDecorator
                .definePropertiesFrom(SPARQLDocumentTrait.PROTOTYPE, target);
        },
    };

    var Document = {
        TYPE: C.Document,
        SCHEMA: {
            "contains": {
                "@id": LDP.contains,
                "@container": "@set",
                "@type": "@id",
            },
            "members": {
                "@id": LDP.member,
                "@container": "@set",
                "@type": "@id",
            },
            "membershipResource": {
                "@id": LDP.membershipResource,
                "@type": "@id",
            },
            "isMemberOfRelation": {
                "@id": LDP.isMemberOfRelation,
                "@type": "@id",
            },
            "hasMemberRelation": {
                "@id": LDP.hasMemberRelation,
                "@type": "@id",
            },
            "insertedContentRelation": {
                "@id": LDP.insertedContentRelation,
                "@type": "@id",
            },
            "created": {
                "@id": C.created,
                "@type": XSD.dateTime,
            },
            "modified": {
                "@id": C.modified,
                "@type": XSD.dateTime,
            },
            "defaultInteractionModel": {
                "@id": C.defaultInteractionModel,
                "@type": "@id",
            },
            "accessPoints": {
                "@id": C.accessPoint,
                "@type": "@id",
                "@container": "@set",
            },
        },
        PROTOTYPE: {
            get $__savedFragments() { return []; },
            $_syncSavedFragments: function () {
                this.$__savedFragments = Array
                    .from(this.$__resourcesMap.values());
                this.$__savedFragments
                    .forEach(function (fragment) { return fragment.$_syncSnapshot(); });
            },
            $_syncSnapshot: function () {
                ResolvablePointer.PROTOTYPE.$_syncSnapshot.call(this);
                this.$_syncSavedFragments();
            },
            $isDirty: function () {
                var _this = this;
                var isSelfDirty = ResolvablePointer.PROTOTYPE.$isDirty.call(this);
                if (isSelfDirty)
                    return true;
                var hasRemovedFragments = this
                    .$__savedFragments
                    .some(function (fragment) { return !_this.$hasFragment(fragment.$id); });
                if (hasRemovedFragments)
                    return true;
                var hasNewFragments = this
                    .$__savedFragments.length !== this.$__resourcesMap.size;
                if (hasNewFragments)
                    return true;
                return this
                    .$__savedFragments
                    .some(function (fragment) { return fragment.$isDirty(); });
            },
            $revert: function () {
                var _this = this;
                ResolvablePointer.PROTOTYPE.$revert.call(this);
                this.$__resourcesMap.clear();
                this
                    .$__savedFragments
                    .forEach(function (fragment) {
                    fragment.$revert();
                    _this.$__resourcesMap.set(fragment.$slug, fragment);
                });
            },
        },
        isDecorated: function (object) {
            return isObject(object)
                && ModelDecorator
                    .hasPropertiesFrom(Document.PROTOTYPE, object);
        },
        is: function (object) {
            return TransientDocument.is(object)
                && SPARQLDocumentTrait.isDecorated(object)
                && EventEmitterDocumentTrait.isDecorated(object)
                && QueryableDocumentTrait.isDecorated(object)
                && Document.isDecorated(object);
        },
        decorate: function (object) {
            if (Document.isDecorated(object))
                return object;
            var base = Object.assign(object, {
                $__modelDecorator: Fragment,
            });
            var target = ModelDecorator
                .decorateMultiple(base, SPARQLDocumentTrait, EventEmitterDocumentTrait, QueryableDocumentTrait);
            return ModelDecorator
                .definePropertiesFrom(Document.PROTOTYPE, target);
        },
        create: TransientDocument.create,
        createFrom: TransientDocument.createFrom,
    };

    var TransientDirectContainer = {
        TYPE: LDP.DirectContainer,
        is: function (value) {
            return TransientDocument.is(value)
                && value.$hasType(TransientDirectContainer.TYPE)
                && value.hasOwnProperty("hasMemberRelation");
        },
        create: function (data) {
            var copy = Object.assign({}, data);
            return TransientDirectContainer.createFrom(copy);
        },
        createFrom: function (object) {
            if (TransientDirectContainer.is(object))
                throw new IllegalArgumentError("The base object is already a DirectContainer.");
            if (!object.hasMemberRelation)
                throw new IllegalArgumentError("The property hasMemberRelation is required.");
            var container = TransientDocument.is(object) ?
                object : TransientDocument.createFrom(object);
            container.$addType(TransientDirectContainer.TYPE);
            return container;
        },
    };

    var TransientAccessPoint = {
        TYPE: C.AccessPoint,
        is: function (value) {
            return TransientDirectContainer.is(value);
        },
        create: function (data) {
            var copy = Object.assign({}, data);
            return TransientAccessPoint.createFrom(copy);
        },
        createFrom: function (object) {
            var accessPoint = TransientDirectContainer
                .createFrom(object);
            accessPoint
                .$addType(TransientAccessPoint.TYPE);
            return accessPoint;
        },
    };

    var AccessPoint = {
        TYPE: TransientAccessPoint.TYPE,
        is: function (value) {
            return TransientAccessPoint.is(value)
                && Document.is(value);
        },
        create: TransientAccessPoint.create,
        createFrom: TransientAccessPoint.createFrom,
    };

    var ModelSchema = {
        is: function (object) {
            return "TYPE" in object
                && "SCHEMA" in object;
        },
    };

    var AbstractContext = (function () {
        function AbstractContext(parentContext) {
            this._parentContext = parentContext;
            this._typeObjectSchemaMap = new Map();
            this.jsonldConverter = new JSONLDConverter(parentContext && parentContext.jsonldConverter.literalSerializers);
        }
        Object.defineProperty(AbstractContext.prototype, "baseURI", {
            get: function () { return this._baseURI; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbstractContext.prototype, "parentContext", {
            get: function () { return this._parentContext; },
            enumerable: true,
            configurable: true
        });
        AbstractContext.prototype.resolve = function (relativeURI) {
            return URI.resolve(this.baseURI, relativeURI);
        };
        AbstractContext.prototype.hasObjectSchema = function (type) {
            type = this.__resolveTypeURI(type);
            if (this._typeObjectSchemaMap.has(type))
                return true;
            return !!this.parentContext && this.parentContext.hasObjectSchema(type);
        };
        AbstractContext.prototype.getObjectSchema = function (type) {
            if (!!type) {
                type = this.__resolveTypeURI(type);
                if (this._typeObjectSchemaMap.has(type))
                    return this._typeObjectSchemaMap.get(type);
                if (this.parentContext && this.parentContext.hasObjectSchema(type))
                    return this.parentContext.getObjectSchema(type);
                throw new IllegalArgumentError("\"" + type + "\" hasn't an object schema.");
            }
            else {
                var generalSchema = !this._generalObjectSchema ?
                    this.parentContext ?
                        this.parentContext.getObjectSchema() :
                        new DigestedObjectSchema() :
                    ObjectSchemaDigester
                        .combineDigestedObjectSchemas([this._generalObjectSchema]);
                if (generalSchema.vocab === void 0 && this._settings && this._settings.vocabulary)
                    generalSchema.vocab = this.resolve(this._settings.vocabulary);
                if (!generalSchema.base)
                    generalSchema.base = this.baseURI;
                return generalSchema;
            }
        };
        AbstractContext.prototype.extendObjectSchema = function (objectSchemaOrTypeOrModelSchema, objectSchema) {
            if (isString(objectSchemaOrTypeOrModelSchema)) {
                if (!objectSchema)
                    throw new IllegalArgumentError("An object schema is required.");
                return this.__extendTypeSchema(objectSchema, objectSchemaOrTypeOrModelSchema);
            }
            if (ModelSchema.is(objectSchemaOrTypeOrModelSchema))
                return this.__extendTypeSchema(objectSchemaOrTypeOrModelSchema.SCHEMA, objectSchemaOrTypeOrModelSchema.TYPE);
            if (Array.isArray(objectSchemaOrTypeOrModelSchema)) {
                objectSchemaOrTypeOrModelSchema.forEach(this.extendObjectSchema, this);
                return this;
            }
            return this.__extendGeneralSchema(objectSchemaOrTypeOrModelSchema);
        };
        AbstractContext.prototype.clearObjectSchema = function (type) {
            if (type === void 0) {
                this._generalObjectSchema = this.parentContext ? undefined : new DigestedObjectSchema();
            }
            else {
                type = this.__resolveTypeURI(type);
                this._typeObjectSchemaMap.delete(type);
            }
        };
        AbstractContext.prototype._getTypeObjectSchemas = function (excepts) {
            if (excepts === void 0) { excepts = []; }
            var exceptsSet = new Set(excepts);
            var types = this
                .__getObjectSchemasTypes()
                .filter(function (type) { return !exceptsSet.has(type); });
            return types.map(this.getObjectSchema, this);
        };
        AbstractContext.prototype.__getObjectSchemasTypes = function () {
            var localTypes = [];
            this._typeObjectSchemaMap
                .forEach(function (_, key) { return localTypes.push(key); });
            if (!this._parentContext)
                return localTypes;
            var allTypes = this._parentContext.__getObjectSchemasTypes();
            for (var _i = 0, localTypes_1 = localTypes; _i < localTypes_1.length; _i++) {
                var type = localTypes_1[_i];
                if (allTypes.indexOf(type) !== -1)
                    continue;
                allTypes.push(type);
            }
            return allTypes;
        };
        AbstractContext.prototype.__extendGeneralSchema = function (objectSchema) {
            var digestedSchemaToExtend = this.__getInheritGeneralSchema();
            this._generalObjectSchema = ObjectSchemaDigester._combineSchemas([
                digestedSchemaToExtend,
                ObjectSchemaDigester.digestSchema(objectSchema),
            ]);
            return this;
        };
        AbstractContext.prototype.__extendTypeSchema = function (objectSchema, type) {
            type = this.__resolveTypeURI(type);
            var digestedSchemaToExtend = this.__getInheritTypeSchema(type);
            var extendedDigestedSchema = ObjectSchemaDigester
                .combineDigestedObjectSchemas([
                digestedSchemaToExtend,
                ObjectSchemaDigester.digestSchema(objectSchema),
            ]);
            this._typeObjectSchemaMap
                .set(type, extendedDigestedSchema);
            return this;
        };
        AbstractContext.prototype.__getInheritGeneralSchema = function () {
            if (this._generalObjectSchema)
                return this._generalObjectSchema;
            if (this.parentContext)
                return this.parentContext.getObjectSchema();
            return new DigestedObjectSchema();
        };
        AbstractContext.prototype.__getInheritTypeSchema = function (type) {
            if (this._typeObjectSchemaMap.has(type))
                return this._typeObjectSchemaMap.get(type);
            if (this.parentContext && this.parentContext.hasObjectSchema(type))
                return this.parentContext.getObjectSchema(type);
            return new DigestedObjectSchema();
        };
        AbstractContext.prototype.__resolveTypeURI = function (uri) {
            return this.getObjectSchema()
                .resolveURI(uri, { vocab: true });
        };
        return AbstractContext;
    }());

    function __getSchemaForNode($context, node) {
        var types = RDFNode.getTypes(node);
        return __getSchema($context, types, node["@id"]);
    }
    function __getSchemaForResource($context, resource) {
        var types = resource.types || [];
        return __getSchema($context, types, resource.$id);
    }
    function __getSchema($context, objectTypes, objectID) {
        if (!$context)
            return new DigestedObjectSchema();
        if (objectID !== void 0 && !URI.hasFragment(objectID) && !URI.isBNodeID(objectID) && objectTypes.indexOf(C.Document) === -1)
            objectTypes = objectTypes.concat(C.Document);
        var objectSchemas = objectTypes
            .filter(function (type) { return $context.hasObjectSchema(type); })
            .map(function (type) { return $context.getObjectSchema(type); });
        return ObjectSchemaDigester
            ._combineSchemas([
            $context.getObjectSchema()
        ].concat(objectSchemas));
    }
    var ObjectSchemaResolver = {
        PROTOTYPE: {
            context: undefined,
            getGeneralSchema: function () {
                if (!this.context)
                    return new DigestedObjectSchema();
                return this.context.getObjectSchema();
            },
            hasSchemaFor: function (object, path) {
                return !path;
            },
            getSchemaFor: function (object) {
                return "types" in object || "$id" in object ?
                    __getSchemaForResource(this.context, object) :
                    __getSchemaForNode(this.context, object);
            },
        },
        isDecorated: function (object) {
            return ModelDecorator.hasPropertiesFrom(ObjectSchemaResolver.PROTOTYPE, object);
        },
        decorate: function (object) {
            return ModelDecorator.definePropertiesFrom(ObjectSchemaResolver.PROTOTYPE, object);
        },
    };

    var GeneralRegistry = {
        PROTOTYPE: {
            get context() {
                throw new IllegalArgumentError("Property context is required.");
            },
            get registry() {
                if (!this.context || !this.context.parentContext)
                    return;
                return this.context.parentContext.registry;
            },
            set registry(value) { },
            get __modelDecorators() { return new Map(); },
            addDecorator: function (decorator) {
                if (!decorator.TYPE)
                    throw new IllegalArgumentError("No TYPE specified in the model decorator.");
                this.__modelDecorators.set(decorator.TYPE, decorator);
                return this;
            },
            decorate: function (object) {
                var _this = this;
                if (!object.types)
                    return;
                object.types
                    .filter(function (type) { return _this.__modelDecorators.has(type); })
                    .map(function (type) { return _this.__modelDecorators.get(type); })
                    .forEach(function (decorator) { return decorator.decorate(object); });
            },
            _addPointer: function (pointer) {
                if (this.context.repository)
                    Object.assign(pointer, { $repository: this.context.repository });
                var resource = Registry.PROTOTYPE._addPointer.call(this, pointer);
                resource.$id = this.context.getObjectSchema().resolveURI(resource.$id, { base: true });
                return resource;
            },
            _getLocalID: function (id) {
                var uri = this.context.getObjectSchema().resolveURI(id, { base: true });
                if (!URI.isAbsolute(uri) || !URI.isBaseOf(this.context.baseURI, uri))
                    throw new IllegalArgumentError("\"" + uri + "\" is out of scope.");
                return URI.getRelativeURI(uri, this.context.baseURI);
            },
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(GeneralRegistry.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (GeneralRegistry.isDecorated(object))
                return object;
            var target = ModelDecorator
                .decorateMultiple(object, Registry, ObjectSchemaResolver);
            if (!target.context)
                delete target.context;
            return ModelDecorator
                .definePropertiesFrom(GeneralRegistry.PROTOTYPE, target);
        },
        create: function (data) {
            return GeneralRegistry.createFrom(__assign({}, data));
        },
        createFrom: function (object) {
            var registry = GeneralRegistry.decorate(object);
            if (registry.registry)
                MapUtils.extend(registry.__modelDecorators, registry.registry.__modelDecorators);
            return registry;
        },
    };

    var DocumentsRegistry = {
        PROTOTYPE: {
            register: function (id) {
                return this.getPointer(id, true);
            },
            _getLocalID: function (id) {
                if (URI.hasFragment(id))
                    throw new IllegalArgumentError("\"" + id + "\" is out of scope.");
                return GeneralRegistry.PROTOTYPE._getLocalID.call(this, id);
            },
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(DocumentsRegistry.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (DocumentsRegistry.isDecorated(object))
                return object;
            var base = Object.assign(object, {
                __modelDecorator: Document,
            });
            var target = ModelDecorator
                .decorateMultiple(base, GeneralRegistry);
            return ModelDecorator
                .definePropertiesFrom(DocumentsRegistry.PROTOTYPE, target);
        },
        create: function (data) {
            return DocumentsRegistry.createFrom(__assign({}, data));
        },
        createFrom: function (object) {
            var registry = DocumentsRegistry.decorate(object);
            return GeneralRegistry.createFrom(registry);
        },
    };

    function __throwNotImplemented() {
        return Promise.reject(new NotImplementedError("Must be implemented for a specific repository implementation."));
    }
    var Repository = {
        PROTOTYPE: {
            get: __throwNotImplemented,
            resolve: __throwNotImplemented,
            exists: __throwNotImplemented,
            refresh: __throwNotImplemented,
            save: __throwNotImplemented,
            saveAndRefresh: __throwNotImplemented,
            delete: __throwNotImplemented,
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(Repository.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (Repository.isDecorated(object))
                return;
            return ModelDecorator
                .definePropertiesFrom(Repository.PROTOTYPE, object);
        },
    };

    var GeneralRepository = {
        PROTOTYPE: {
            get context() {
                throw new IllegalArgumentError("Property \"context\" is required.");
            },
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(GeneralRepository.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (GeneralRepository.isDecorated(object))
                return object;
            var target = ModelDecorator
                .decorateMultiple(object, Repository);
            return ModelDecorator
                .definePropertiesFrom(GeneralRepository.PROTOTYPE, target);
        },
        create: function (data) {
            return GeneralRepository.createFrom(__assign({}, data));
        },
        createFrom: function (object) {
            return GeneralRepository.decorate(object);
        },
    };

    function _validateEventType(event) {
        if (!/(access-point|child|\*)\.(created|\*)|(document|\*)\.(modified|deleted|\*)|(member|\*)\.(added|removed|\*)/.test(event))
            throw new IllegalArgumentError("Provided event type \"" + event + "\" is invalid.");
    }
    function _parseURIPattern(uriPattern, baseURI) {
        if (!URI.isBaseOf(baseURI, uriPattern))
            throw new IllegalArgumentError("\"" + uriPattern + "\" is out of scope.");
        if (uriPattern === "/")
            return "";
        uriPattern = URI.getRelativeURI(uriPattern, baseURI);
        uriPattern = uriPattern.substring(+uriPattern.startsWith("/"), uriPattern.length - +uriPattern.endsWith("/"));
        return uriPattern
            .split("/")
            .map(function (slug) {
            if (slug === "**")
                return "#";
            return encodeURIComponent(slug)
                .replace(/\./g, "^");
        }).join(".");
    }
    function _createDestination(event, uriPattern, baseURI) {
        _validateEventType(event);
        uriPattern = _parseURIPattern(uriPattern, baseURI);
        return "/topic/" + event + (uriPattern ? "." + uriPattern : uriPattern);
    }

    var EventEmitterDocumentsRepositoryTrait = {
        PROTOTYPE: {
            on: function (event, uriPattern, onEvent, onError) {
                try {
                    var destination = _createDestination(event, uriPattern, this.context.baseURI);
                    this.context.messaging.subscribe(destination, onEvent, onError);
                }
                catch (error) {
                    if (!onError)
                        throw error;
                    onError(error);
                }
            },
            off: function (event, uriPattern, onEvent, onError) {
                try {
                    var destination = _createDestination(event, uriPattern, this.context.baseURI);
                    this.context.messaging.unsubscribe(destination, onEvent);
                }
                catch (error) {
                    if (!onError)
                        throw error;
                    onError(error);
                }
            },
            one: function (event, uriPattern, onEvent, onError) {
                var _this = this;
                try {
                    var destination_1 = _createDestination(event, uriPattern, this.context.baseURI);
                    var onEventWrapper_1 = function (message) {
                        onEvent(message);
                        _this.context.messaging.unsubscribe(destination_1, onEventWrapper_1);
                    };
                    this.context.messaging.subscribe(destination_1, onEventWrapper_1, onError);
                }
                catch (error) {
                    if (!onError)
                        throw error;
                    onError(error);
                }
            },
            onChildCreated: function (uriPattern, onEvent, onError) {
                return this.on(Event.CHILD_CREATED, uriPattern, onEvent, onError);
            },
            onDocumentModified: function (uriPattern, onEvent, onError) {
                return this.on(Event.DOCUMENT_MODIFIED, uriPattern, onEvent, onError);
            },
            onDocumentDeleted: function (uriPattern, onEvent, onError) {
                return this.on(Event.DOCUMENT_DELETED, uriPattern, onEvent, onError);
            },
            onMemberAdded: function (uriPattern, onEvent, onError) {
                return this.on(Event.MEMBER_ADDED, uriPattern, onEvent, onError);
            },
            onMemberRemoved: function (uriPattern, onEvent, onError) {
                return this.on(Event.MEMBER_REMOVED, uriPattern, onEvent, onError);
            },
        },
        isDecorated: function (object) {
            return isObject(object)
                && ModelDecorator
                    .hasPropertiesFrom(EventEmitterDocumentsRepositoryTrait.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (EventEmitterDocumentsRepositoryTrait.isDecorated(object))
                return object;
            var resource = ModelDecorator
                .decorateMultiple(object, GeneralRepository);
            return ModelDecorator
                .definePropertiesFrom(EventEmitterDocumentsRepositoryTrait.PROTOTYPE, resource);
        },
    };

    var BaseToken = (function () {
        function BaseToken(iri) {
            this.token = "base";
            this.iri = iri;
        }
        BaseToken.prototype.toString = function () {
            return "BASE " + this.iri;
        };
        return BaseToken;
    }());

    var BindToken = (function () {
        function BindToken(expression, variable) {
            this.token = "bind";
            this.expression = expression;
            this.variable = variable;
        }
        BindToken.prototype.toString = function (spaces) {
            return "BIND(" + this.expression + " AS " + this.variable + ")";
        };
        return BindToken;
    }());

    var INDENTATION_SPACES = 4;
    function getSeparator(spaces) {
        if (spaces === void 0)
            return " ";
        return "\n";
    }
    function getIndentation(spaces, extra) {
        if (spaces === void 0)
            return "";
        if (extra)
            spaces += extra;
        return " ".repeat(spaces);
    }
    function addSpaces(spaces, extra) {
        if (spaces === void 0)
            return spaces;
        return spaces + extra;
    }
    function getTokenContainerString(_a) {
        var spaces = _a.spaces, tags = _a.tags, tokensSeparator = _a.tokensSeparator, tokens = _a.tokens;
        if (!tokens.length)
            return tags.open + tags.close;
        var generalSeparator = getSeparator(spaces);
        var tokensSpaces = addSpaces(spaces, INDENTATION_SPACES);
        var strArrayTokens = tokens.map(function (token, index, array) {
            var strToken = token.toString(tokensSpaces);
            if (!tokensSeparator || index === array.length - 1)
                return strToken;
            if (tokensSeparator === "." && token.token !== "subject")
                return strToken;
            return strToken + tokensSeparator;
        });
        if (strArrayTokens.length === 1 && !strArrayTokens[0].includes("\n"))
            return tags.open + " " + strArrayTokens + " " + tags.close;
        var tokensIndent = getIndentation(tokensSpaces);
        var strTokens = strArrayTokens
            .map(function (x) { return tokensIndent + x; })
            .join(generalSeparator);
        var indent = getIndentation(spaces);
        return tags.open +
            generalSeparator + strTokens + generalSeparator +
            indent + tags.close;
    }

    var BlankNodePropertyToken = (function () {
        function BlankNodePropertyToken() {
            this.token = "blankNodeProperty";
            this.properties = [];
        }
        BlankNodePropertyToken.prototype.addProperty = function (property) {
            this.properties.push(property);
            return this;
        };
        BlankNodePropertyToken.prototype.toString = function (spaces) {
            return getTokenContainerString({
                spaces: spaces,
                tags: { open: "[", close: "]" },
                tokensSeparator: ";",
                tokens: this.properties,
            });
        };
        return BlankNodePropertyToken;
    }());

    var LABEL_REGEX = /^_:[A-Za-z0-9_]([A-Za-z0-9_\-.]*[A-Za-z0-9_\-])?$/;
    var BlankNodeToken = (function () {
        function BlankNodeToken(label) {
            this.token = "blankNode";
            if (!label)
                return;
            if (!LABEL_REGEX.test(label))
                throw new Error("Invalid blank node label.");
            this.label = label;
        }
        BlankNodeToken.prototype.toString = function (spaces) {
            if (this.label)
                return this.label;
            return "[]";
        };
        return BlankNodeToken;
    }());

    var CollectionToken = (function () {
        function CollectionToken() {
            this.token = "collection";
            this.objects = [];
        }
        CollectionToken.prototype.addObject = function () {
            var object = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                object[_i] = arguments[_i];
            }
            var _a;
            (_a = this.objects).push.apply(_a, object);
            return this;
        };
        CollectionToken.prototype.toString = function (spaces) {
            return getTokenContainerString({
                spaces: spaces,
                tags: { open: "(", close: ")" },
                tokens: this.objects,
            });
        };
        return CollectionToken;
    }());

    var GroupPatternToken = (function () {
        function GroupPatternToken() {
            this.token = "groupPattern";
            this.patterns = [];
        }
        GroupPatternToken.prototype.addPattern = function () {
            var patterns = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                patterns[_i] = arguments[_i];
            }
            var _a;
            (_a = this.patterns).push.apply(_a, patterns);
            return this;
        };
        GroupPatternToken.prototype.toString = function (spaces) {
            return getTokenContainerString({
                spaces: spaces,
                tags: { open: "{", close: "}" },
                tokensSeparator: ".",
                tokens: this.patterns,
            });
        };
        return GroupPatternToken;
    }());

    var WhereToken = (function () {
        function WhereToken() {
            this.token = "where";
            this.groupPattern = new GroupPatternToken();
        }
        WhereToken.prototype.toString = function (spaces) {
            var identifier = spaces === void 0 ? "" : "WHERE ";
            return identifier + this.groupPattern.toString(spaces);
        };
        return WhereToken;
    }());

    var SharedQueryClauseToken = (function () {
        function SharedQueryClauseToken() {
            this.where = new WhereToken();
            this.modifiers = [];
        }
        SharedQueryClauseToken.prototype.addPattern = function () {
            var patterns = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                patterns[_i] = arguments[_i];
            }
            var _a;
            (_a = this.where.groupPattern.patterns).push.apply(_a, patterns);
            return this;
        };
        SharedQueryClauseToken.prototype.addModifier = function () {
            var modifier = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                modifier[_i] = arguments[_i];
            }
            var _a;
            (_a = this.modifiers).push.apply(_a, modifier);
            return this;
        };
        return SharedQueryClauseToken;
    }());

    var ConstructToken = (function (_super) {
        __extends(ConstructToken, _super);
        function ConstructToken() {
            var _this = _super.call(this) || this;
            _this.token = "construct";
            _this.triples = [];
            return _this;
        }
        ConstructToken.prototype.addTriple = function () {
            var triple = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                triple[_i] = arguments[_i];
            }
            var _a;
            (_a = this.triples).push.apply(_a, triple);
            return this;
        };
        ConstructToken.prototype.toString = function (spaces) {
            var triples = getTokenContainerString({
                spaces: spaces,
                tags: { open: "{", close: "}" },
                tokensSeparator: ".",
                tokens: this.triples,
            });
            var separator = getSeparator(spaces);
            var query = "CONSTRUCT " +
                triples + separator +
                this.where.toString(spaces);
            if (this.modifiers.length)
                query += separator + this.modifiers.join(separator);
            return query;
        };
        return ConstructToken;
    }(SharedQueryClauseToken));

    var FilterToken = (function () {
        function FilterToken(constraint) {
            this.token = "filter";
            this.constraint = constraint;
        }
        FilterToken.prototype.toString = function (spaces) {
            return "FILTER( " + this.constraint + " )";
        };
        return FilterToken;
    }());

    var FromToken = (function () {
        function FromToken(source, named) {
            if (named === void 0) { named = false; }
            this.token = "from";
            this.source = source;
            this.named = named;
        }
        FromToken.prototype.toString = function (spaces) {
            var str = "FROM ";
            if (this.named)
                str += "NAMED ";
            return str + this.source;
        };
        return FromToken;
    }());

    var GraphToken = (function () {
        function GraphToken(graph) {
            this.token = "graph";
            this.graph = graph;
            this.groupPattern = new GroupPatternToken();
        }
        GraphToken.prototype.addPattern = function () {
            var pattern = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                pattern[_i] = arguments[_i];
            }
            var _a;
            (_a = this.groupPattern.patterns).push.apply(_a, pattern);
            return this;
        };
        GraphToken.prototype.toString = function (spaces) {
            return "GRAPH " + this.graph + " " + this.groupPattern.toString(spaces);
        };
        return GraphToken;
    }());

    var GroupToken = (function () {
        function GroupToken(rawCondition) {
            this.token = "group";
            this.rawCondition = rawCondition;
        }
        GroupToken.prototype.toString = function (spaces) {
            return "GROUP BY " + this.rawCondition;
        };
        return GroupToken;
    }());

    var HavingToken = (function () {
        function HavingToken(rawCondition) {
            this.token = "having";
            this.rawCondition = rawCondition;
        }
        HavingToken.prototype.toString = function (spaces) {
            return "HAVING " + this.rawCondition;
        };
        return HavingToken;
    }());

    var IRIRefToken = (function () {
        function IRIRefToken(value) {
            this.token = "iri";
            this.value = value;
        }
        IRIRefToken.prototype.toString = function (spaces) {
            return "<" + this.value + ">";
        };
        return IRIRefToken;
    }());

    var LANGUAGE_REGEX = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/;
    var LanguageToken = (function () {
        function LanguageToken(tag) {
            this.token = "language";
            if (!LANGUAGE_REGEX.test(tag))
                throw new Error("\"" + tag + "\" is an invalid language tag.");
            this.tag = tag;
        }
        LanguageToken.prototype.toString = function (spaces) {
            return "@" + this.tag;
        };
        return LanguageToken;
    }());

    var LimitToken = (function () {
        function LimitToken(value) {
            this.token = "limit";
            this.value = value;
        }
        LimitToken.prototype.toString = function () {
            return "LIMIT " + this.value;
        };
        return LimitToken;
    }());

    var LiteralToken = (function () {
        function LiteralToken(value) {
            this.token = "literal";
            this.value = value;
        }
        LiteralToken.prototype.toString = function (spaces) {
            return JSON.stringify(this.value);
        };
        return LiteralToken;
    }());

    var MinusPatternToken = (function () {
        function MinusPatternToken() {
            this.token = "minusPattern";
            this.groupPattern = new GroupPatternToken();
        }
        MinusPatternToken.prototype.toString = function (spaces) {
            return "MINUS " + this.groupPattern.toString(spaces);
        };
        return MinusPatternToken;
    }());

    var OffsetToken = (function () {
        function OffsetToken(value) {
            this.token = "offset";
            this.value = value;
        }
        OffsetToken.prototype.toString = function (spaces) {
            return "OFFSET " + this.value;
        };
        return OffsetToken;
    }());

    var OptionalToken = (function () {
        function OptionalToken() {
            this.token = "optional";
            this.groupPattern = new GroupPatternToken();
        }
        OptionalToken.prototype.addPattern = function () {
            var pattern = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                pattern[_i] = arguments[_i];
            }
            var _a;
            (_a = this.groupPattern.patterns).push.apply(_a, pattern);
            return this;
        };
        OptionalToken.prototype.toString = function (spaces) {
            return "OPTIONAL " + this.groupPattern.toString(spaces);
        };
        return OptionalToken;
    }());

    var OrderToken = (function () {
        function OrderToken(condition, flow) {
            this.token = "order";
            this.condition = condition;
            if (flow)
                this.flow = flow;
        }
        OrderToken.prototype.toString = function (spaces) {
            return "ORDER BY " + (this.flow ?
                this.flow + "( " + this.condition + " )" :
                "" + this.condition);
        };
        return OrderToken;
    }());

    var PathAlternativeToken = (function () {
        function PathAlternativeToken() {
            this.token = "pathAlternative";
            this.paths = [];
        }
        PathAlternativeToken.prototype.addPath = function (path) {
            this.paths.push(path);
            return this;
        };
        PathAlternativeToken.prototype.toString = function () {
            return this.paths
                .join("|");
        };
        return PathAlternativeToken;
    }());

    var PathInverseToken = (function () {
        function PathInverseToken(path) {
            this.token = "pathInverse";
            this.path = path;
        }
        PathInverseToken.prototype.toString = function () {
            return "^" + this.path;
        };
        return PathInverseToken;
    }());

    var PathModToken = (function () {
        function PathModToken(path, mod) {
            this.token = "pathMod";
            this.path = path;
            this.mod = mod;
        }
        PathModToken.prototype.toString = function () {
            return "" + this.path + this.mod;
        };
        return PathModToken;
    }());

    var PathNegatedToken = (function () {
        function PathNegatedToken(path) {
            this.token = "pathNegated";
            this.path = path;
        }
        PathNegatedToken.prototype.toString = function () {
            return "!" + this.path;
        };
        return PathNegatedToken;
    }());

    var PathSequenceToken = (function () {
        function PathSequenceToken() {
            this.token = "pathSequence";
            this.paths = [];
        }
        PathSequenceToken.prototype.addPath = function (path) {
            this.paths.push(path);
            return this;
        };
        PathSequenceToken.prototype.toString = function () {
            return this.paths
                .join("/");
        };
        return PathSequenceToken;
    }());

    var NAMESPACE_REGEX = /^([A-Za-z](([A-Za-z_\-0-9]|\.)*[A-Za-z_\-0-9])?)?$/;
    var PrefixedNameToken = (function () {
        function PrefixedNameToken(prefixedOrNamespace, localName) {
            var _a;
            this.token = "prefixedName";
            var namespace = prefixedOrNamespace;
            if (localName === void 0) {
                if (!isPrefixed(prefixedOrNamespace))
                    throw new Error("Invalid prefixed name.");
                _a = prefixedOrNamespace.split(/:(.*)/), namespace = _a[0], localName = _a[1];
            }
            if (!NAMESPACE_REGEX.test(namespace))
                throw new Error("Invalid prefixed namespace.");
            this.namespace = namespace;
            var _b = localName.split(/^(.)(?:(.*)?(.))?$/), ln1 = _b[1], ln2 = _b[2], ln3 = _b[3];
            var preSanitation = "";
            if (ln1)
                preSanitation += ln1.replace(/([\-.])/g, "\\$1");
            if (ln2)
                preSanitation += ln2;
            if (ln3)
                preSanitation += ln3.replace(/([.])/g, "\\$1");
            this.localName = preSanitation.replace(/([~!$&'|()*+,;=/?#@%])/g, "\\$1");
        }
        PrefixedNameToken.prototype.toString = function (spaces) {
            return this.namespace + ":" + this.localName;
        };
        return PrefixedNameToken;
    }());

    var PrefixToken = (function () {
        function PrefixToken(namespace, iri) {
            this.token = "prefix";
            this.namespace = namespace;
            this.iri = iri;
        }
        PrefixToken.prototype.toString = function (spaces) {
            return "PREFIX " + this.namespace + ": " + this.iri;
        };
        return PrefixToken;
    }());

    var PropertyToken = (function () {
        function PropertyToken(verb) {
            this.token = "property";
            this.verb = verb;
            this.objects = [];
        }
        PropertyToken.prototype.addObject = function () {
            var object = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                object[_i] = arguments[_i];
            }
            var _a;
            (_a = this.objects).push.apply(_a, object);
            return this;
        };
        PropertyToken.prototype.toString = function (spaces) {
            var separator = getSeparator(spaces);
            var verb = "" + this.verb;
            var objectSpaces = addSpaces(spaces, verb.length + 1);
            var objectIndent = getIndentation(objectSpaces);
            var objects = this.objects
                .map(function (object) {
                if (object.token === "collection" || object.token === "blankNodeProperty")
                    return object.toString(spaces);
                return object.toString(objectSpaces);
            })
                .join("," + separator + objectIndent);
            return verb + " " + objects;
        };
        return PropertyToken;
    }());

    var QueryToken = (function () {
        function QueryToken(query, values) {
            this.token = "query";
            this.prologues = [];
            this.queryClause = query;
            this.values = values;
        }
        QueryToken.prototype.addPrologues = function () {
            var prologues = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                prologues[_i] = arguments[_i];
            }
            var _a;
            (_a = this.prologues).push.apply(_a, prologues);
            return this;
        };
        QueryToken.prototype.toString = function (spaces) {
            var separator = getSeparator(spaces);
            var query = this.prologues
                .map(function (prologue) {
                if (prologue.token === "base")
                    return prologue + "\n";
                return prologue + separator;
            })
                .join("");
            if (this.queryClause)
                query += this.queryClause.toString(spaces);
            if (this.values)
                query += separator + this.values.toString(spaces);
            return query;
        };
        return QueryToken;
    }());

    var RDFLiteralToken = (function (_super) {
        __extends(RDFLiteralToken, _super);
        function RDFLiteralToken(value, typeOrLanguage) {
            var _this = _super.call(this, value) || this;
            if (!typeOrLanguage)
                return _this;
            if (typeOrLanguage.token === "language") {
                _this.language = typeOrLanguage;
            }
            else {
                _this.type = typeOrLanguage;
            }
            return _this;
        }
        RDFLiteralToken.prototype.toString = function (spaces) {
            var value = _super.prototype.toString.call(this);
            if (this.language)
                return value + this.language;
            if (this.type)
                return value + "^^" + this.type;
            return value;
        };
        return RDFLiteralToken;
    }(LiteralToken));

    var SharedSelectToken = (function (_super) {
        __extends(SharedSelectToken, _super);
        function SharedSelectToken(modifier) {
            var _this = _super.call(this) || this;
            _this.modifier = modifier;
            _this.variables = [];
            return _this;
        }
        SharedSelectToken.prototype.addVariable = function () {
            var variables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                variables[_i] = arguments[_i];
            }
            var _a;
            (_a = this.variables).push.apply(_a, variables);
            return this;
        };
        SharedSelectToken.prototype.toString = function (spaces) {
            var query = "SELECT";
            if (this.modifier)
                query += " " + this.modifier;
            query += this.variables.length ?
                " " + this.variables.join(" ") :
                " *";
            return query;
        };
        return SharedSelectToken;
    }(SharedQueryClauseToken));

    var SelectToken = (function (_super) {
        __extends(SelectToken, _super);
        function SelectToken(modifier) {
            var _this = _super.call(this, modifier) || this;
            _this.token = "select";
            _this.datasets = [];
            return _this;
        }
        SelectToken.prototype.toString = function (spaces) {
            var query = _super.prototype.toString.call(this, spaces);
            var separator = getSeparator(spaces);
            if (this.datasets.length)
                query += separator + this.datasets.join(separator);
            query += separator + this.where.toString(spaces);
            if (this.modifiers.length)
                query += separator + this.modifiers.join(separator);
            return query;
        };
        return SelectToken;
    }(SharedSelectToken));

    var ServicePatternToken = (function () {
        function ServicePatternToken(resource, modifier) {
            this.token = "servicePattern";
            this.modifier = modifier;
            this.resource = resource;
            this.groupPattern = new GroupPatternToken();
        }
        ServicePatternToken.prototype.toString = function (spaces) {
            var query = "SERVICE ";
            if (this.modifier)
                query += "SILENT ";
            query += this.resource + " " + this.groupPattern.toString(spaces);
            return query;
        };
        return ServicePatternToken;
    }());

    var SubjectToken = (function () {
        function SubjectToken(subject) {
            this.token = "subject";
            this.subject = subject;
            this.properties = [];
        }
        SubjectToken.prototype.addProperty = function (property) {
            this.properties.push(property);
            return this;
        };
        SubjectToken.prototype.toString = function (spaces) {
            var query = this.subject.toString(spaces);
            var separator = !this.properties.length ? ""
                : (this.subject.token === "collection" || this.subject.token === "blankNodeProperty")
                    && query.includes("\n") ? "\n"
                    : " ";
            var subSpaces = separator === " " ?
                addSpaces(spaces, query.length + 1) :
                addSpaces(spaces, INDENTATION_SPACES);
            var subIndent = getIndentation(subSpaces);
            var properties = this.properties
                .map(function (property) { return property.toString(subSpaces); })
                .join(";" + getSeparator(spaces) + subIndent);
            if (separator === "\n")
                separator += subIndent;
            return query + separator + properties;
        };
        return SubjectToken;
    }());

    var SubSelectToken = (function (_super) {
        __extends(SubSelectToken, _super);
        function SubSelectToken(modifier, values) {
            var _this = _super.call(this, modifier) || this;
            _this.token = "subSelect";
            _this.values = values;
            return _this;
        }
        SubSelectToken.prototype.toString = function (spaces) {
            var subSpaces = addSpaces(spaces, INDENTATION_SPACES);
            var subIndent = getIndentation(subSpaces);
            var separator = getSeparator(spaces);
            var query = _super.prototype.toString.call(this, spaces) + separator +
                subIndent + this.where.toString(subSpaces);
            if (this.modifiers.length)
                query += separator + this.modifiers
                    .map(function (x) { return subIndent + x; })
                    .join(separator);
            if (this.values)
                query += separator + subIndent + this.values;
            var indent = getIndentation(spaces);
            return "{" + separator + subIndent +
                query + separator +
                indent + "}";
        };
        return SubSelectToken;
    }(SharedSelectToken));

    var UnionPatternToken = (function () {
        function UnionPatternToken() {
            this.token = "unionPattern";
            this.groupPatterns = [];
        }
        UnionPatternToken.prototype.toString = function (spaces) {
            return this
                .groupPatterns
                .map(function (x) { return x.toString(spaces); })
                .join(" UNION ");
        };
        return UnionPatternToken;
    }());

    var ValuesToken = (function () {
        function ValuesToken() {
            this.token = "values";
            this.variables = [];
            this.values = [];
        }
        ValuesToken.prototype.addVariables = function () {
            var variables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                variables[_i] = arguments[_i];
            }
            var _a;
            (_a = this.variables).push.apply(_a, variables);
            return this;
        };
        ValuesToken.prototype.addValues = function () {
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            this.values.push(values);
            return this;
        };
        ValuesToken.prototype.toString = function (spaces) {
            var variables = this._getVariablesStr();
            var values = this._getValuesStr(spaces);
            return "VALUES " + variables + " " + values;
        };
        ValuesToken.prototype._getVariablesStr = function () {
            if (!this.variables.length)
                return "()";
            var variables = this.variables.join(" ");
            if (this.variables.length === 1)
                return variables;
            return "( " + variables + " )";
        };
        ValuesToken.prototype._getValuesStr = function (spaces) {
            if (!this.values.length)
                return "{}";
            if (this.variables.length === 1) {
                var values = this.values
                    .filter(function (x) { return x.length; })
                    .map(function (x) { return x[0]; })
                    .join(" ");
                if (!values)
                    return "{}";
                return "{ " + values + " }";
            }
            var subIndent = getIndentation(spaces, INDENTATION_SPACES);
            var separator = getSeparator(spaces);
            var indent = getIndentation(spaces);
            return "{" + separator +
                this.values
                    .map(function (values) {
                    var valuesStr = values.length ?
                        "( " + values.join(" ") + " )" : "()";
                    return subIndent + valuesStr;
                })
                    .join(separator) + separator +
                indent + "}";
        };
        return ValuesToken;
    }());

    var NAME_REGEX = /^((?:[0-9A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF]))((?:[0-9A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF]))*$/;
    var VariableToken = (function () {
        function VariableToken(name) {
            this.token = "variable";
            if (!NAME_REGEX.test(name))
                throw new Error("Invalid variable name");
            this.name = name;
        }
        VariableToken.prototype.toString = function (spaces) {
            return "?" + this.name;
        };
        return VariableToken;
    }());

    var IllegalStateError = (function (_super) {
        __extends(IllegalStateError, _super);
        function IllegalStateError(message) {
            if (message === void 0) { message = ""; }
            return _super.call(this, message) || this;
        }
        Object.defineProperty(IllegalStateError.prototype, "name", {
            get: function () { return "IllegalStateError"; },
            enumerable: true,
            configurable: true
        });
        return IllegalStateError;
    }(AbstractError));

    var Container = (function () {
        function Container(data) {
            var _newTarget = this.constructor;
            this.iriResolver = data.iriResolver;
            this.targetToken = data.targetToken;
            if (_newTarget === Container)
                Object.freeze(this);
        }
        return Container;
    }());

    var Factory = {
        createFrom: function () {
            var factories = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                factories[_i] = arguments[_i];
            }
            return function (container, object) {
                return factories
                    .reduce(function (target, factoryFn) { return factoryFn(container, target); }, object);
            };
        }
    };

    var IRIResolver = (function () {
        function IRIResolver(base, vocab) {
            var _newTarget = this.constructor;
            this.prefixes = base
                ? new Map(base.prefixes.entries())
                : new Map();
            this.vocab = vocab
                ? vocab
                : base && base.vocab;
            if (_newTarget === IRIResolver)
                Object.freeze(this);
        }
        IRIResolver.prototype.resolve = function (relativeIRI, vocab) {
            if (isPrefixed(relativeIRI))
                return this.resolvePrefixed(relativeIRI);
            return this.resolveIRIRef(relativeIRI, vocab);
        };
        IRIResolver.prototype.resolveIRIRef = function (relativeIRI, vocab) {
            if (vocab === void 0) { vocab = false; }
            if (vocab && this.vocab && isRelative(relativeIRI))
                relativeIRI = this.vocab + relativeIRI;
            return new IRIRefToken(relativeIRI);
        };
        IRIResolver.prototype.resolvePrefixed = function (prefixedName) {
            var token = new PrefixedNameToken(prefixedName);
            var used = this.prefixes.get(token.namespace);
            if (used === void 0)
                throw new Error("The prefix \"" + token.namespace + "\" has not been declared.");
            if (!used)
                this.prefixes.set(token.namespace, true);
            return token;
        };
        return IRIResolver;
    }());

    var QueryUnitContainer = (function (_super) {
        __extends(QueryUnitContainer, _super);
        function QueryUnitContainer(data) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, data) || this;
            _this.selectFinishClauseFactory = data.selectFinishClauseFactory;
            _this.askFinishClauseFactory = data.askFinishClauseFactory;
            if (_newTarget === QueryUnitContainer)
                Object.freeze(_this);
            return _this;
        }
        return QueryUnitContainer;
    }(Container));

    var FinishClause = {
        createFrom: function (container, object) {
            var toPrettyString = function () {
                return container.targetToken.toString(0);
            };
            var debug = function (debugFn) {
                debugFn.call(void 0, object, container);
                return object;
            };
            return Object.assign(object, {
                toCompactString: function () { return container.targetToken.toString(); },
                toPrettyString: toPrettyString,
                toString: toPrettyString,
                debug: debug,
            });
        }
    };

    var Pattern = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                getPattern: function () { return container.targetToken; },
            });
        },
    };

    var FinishPattern = {
        createFrom: function (container, object) {
            return Factory.createFrom(Pattern.createFrom, FinishClause.createFrom)(container, object);
        },
    };

    function cloneElement(element, newValues) {
        if (newValues === void 0) { newValues = {}; }
        var base = Object.create(Object.getPrototypeOf(element));
        var clone = Object
            .assign(base, element, newValues);
        return Object.freeze(clone);
    }

    function cloneSolutionModifierContainer(container, token) {
        var targetToken = container.targetToken.token === "query" ?
            _cloneFromQuery(container.targetToken, token) :
            _cloneFromClause(container.targetToken, token);
        return cloneElement(container, { targetToken: targetToken });
    }
    function _cloneFromClause(clauseToken, token) {
        var modifiers = clauseToken.modifiers.concat(token);
        return cloneElement(clauseToken, { modifiers: modifiers });
    }
    function _cloneFromQuery(queryToken, token) {
        var queryClause = _cloneFromClause(queryToken.queryClause, token);
        return cloneElement(queryToken, { queryClause: queryClause });
    }

    function getLimitFn(genericFactory, container) {
        return function (limit) {
            var token = new LimitToken(limit);
            var newContainer = cloneSolutionModifierContainer(container, token);
            return genericFactory(newContainer, {});
        };
    }
    var LimitClause = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                limit: getLimitFn(genericFactory, container),
            });
        },
    };

    function getOffsetFn(genericFactory, container) {
        return function (offset) {
            var token = new OffsetToken(offset);
            var newContainer = cloneSolutionModifierContainer(container, token);
            return genericFactory(newContainer, {});
        };
    }
    var OffsetClause = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                offset: getOffsetFn(genericFactory, container),
            });
        },
    };

    var NotTriplePattern = {
        createFrom: Pattern.createFrom,
    };

    function getAndFn(container) {
        return function (patterns) {
            var _a;
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            var newGroupToken = new GroupPatternToken();
            (_a = newGroupToken.patterns).push.apply(_a, patterns.map(function (x) { return x.getPattern(); }));
            var groupPatterns = container.targetToken.groupPatterns.concat(newGroupToken);
            var unionToken = cloneElement(container.targetToken, { groupPatterns: groupPatterns });
            var newContainer = new Container({
                iriResolver: container.iriResolver,
                targetToken: unionToken,
            });
            return UnionPattern.createFrom(newContainer, {});
        };
    }
    var UnionPattern = {
        createFrom: function (container, object) {
            return NotTriplePattern.createFrom(container, Object.assign(object, {
                and: getAndFn(container),
            }));
        },
    };

    function getUnionFn(container) {
        return function (patterns) {
            var _a;
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            var newGroupToken = new GroupPatternToken();
            (_a = newGroupToken.patterns).push.apply(_a, patterns.map(function (x) { return x.getPattern(); }));
            var unionToken = new UnionPatternToken();
            unionToken.groupPatterns.push(container.targetToken, newGroupToken);
            var newContainer = new Container({
                iriResolver: container.iriResolver,
                targetToken: unionToken,
            });
            return UnionPattern.createFrom(newContainer, {});
        };
    }
    var GroupPattern = {
        createFrom: function (container, object) {
            return NotTriplePattern.createFrom(container, Object.assign(object, {
                union: getUnionFn(container),
            }));
        }
    };

    function getIRIToken(iri) {
        if (isPrefixed(iri))
            return new PrefixedNameToken(iri);
        return new IRIRefToken(iri);
    }

    var XSD$1 = {
        namespace: "http://www.w3.org/2001/XMLSchema#",
        boolean: "http://www.w3.org/2001/XMLSchema#boolean",
        byte: "http://www.w3.org/2001/XMLSchema#byte",
        date: "http://www.w3.org/2001/XMLSchema#date",
        dateTime: "http://www.w3.org/2001/XMLSchema#dateTime",
        decimal: "http://www.w3.org/2001/XMLSchema#decimal",
        double: "http://www.w3.org/2001/XMLSchema#double",
        duration: "http://www.w3.org/2001/XMLSchema#duration",
        float: "http://www.w3.org/2001/XMLSchema#float",
        gDay: "http://www.w3.org/2001/XMLSchema#gDay",
        gMonth: "http://www.w3.org/2001/XMLSchema#gMonth",
        gMonthDay: "http://www.w3.org/2001/XMLSchema#gMonthDay",
        gYear: "http://www.w3.org/2001/XMLSchema#gYear",
        gYearMonth: "http://www.w3.org/2001/XMLSchema#gYearMonth",
        int: "http://www.w3.org/2001/XMLSchema#int",
        integer: "http://www.w3.org/2001/XMLSchema#integer",
        long: "http://www.w3.org/2001/XMLSchema#long",
        negativeInteger: "http://www.w3.org/2001/XMLSchema#negativeInteger",
        nonNegativeInteger: "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
        nonPositiveInteger: "http://www.w3.org/2001/XMLSchema#nonPositiveInteger",
        object: "http://www.w3.org/2001/XMLSchema#object",
        positiveInteger: "http://www.w3.org/2001/XMLSchema#positiveInteger",
        short: "http://www.w3.org/2001/XMLSchema#short",
        string: "http://www.w3.org/2001/XMLSchema#string",
        time: "http://www.w3.org/2001/XMLSchema#time",
        unsignedByte: "http://www.w3.org/2001/XMLSchema#unsignedByte",
        unsignedInt: "http://www.w3.org/2001/XMLSchema#unsignedInt",
        unsignedLong: "http://www.w3.org/2001/XMLSchema#unsignedLong",
        unsignedShort: "http://www.w3.org/2001/XMLSchema#unsignedShort",
    };

    function convertValue(value) {
        if (value instanceof Date)
            return new RDFLiteralToken(value.toISOString(), getIRIToken(XSD$1.dateTime));
        if (typeof value === "object")
            return value.getSubject();
        if (typeof value === "string") {
            if (value === "UNDEF")
                return value;
            return new LiteralToken(value);
        }
        return new LiteralToken(value);
    }

    function getHasFn(container) {
        return function () {
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            var parsedValues = container.targetToken.values.slice();
            parsedValues.push(values.map(convertValue));
            var targetToken = cloneElement(container.targetToken, { values: parsedValues });
            var newContainer = cloneElement(container, { targetToken: targetToken });
            return MultipleValuesPatternMore.createFrom(newContainer, {});
        };
    }
    var MultipleValuesPattern = {
        createFrom: function (container, object) {
            return NotTriplePattern.createFrom(container, Object.assign(object, {
                has: getHasFn(container),
            }));
        },
    };
    var MultipleValuesPatternMore = {
        createFrom: function (container, object) {
            return NotTriplePattern.createFrom(container, Object.assign(object, {
                and: getHasFn(container),
            }));
        },
    };

    function getHasFn$1(container) {
        return function (value) {
            var values = container.targetToken.values.slice();
            if (!values.length)
                values.push([]);
            values[0] = values[0].concat(convertValue(value));
            var targetToken = cloneElement(container.targetToken, { values: values });
            var newContainer = cloneElement(container, { targetToken: targetToken });
            return SingleValuesPatternMore.createFrom(newContainer, {});
        };
    }
    var SingleValuesPattern = {
        createFrom: function (container, object) {
            return NotTriplePattern.createFrom(container, Object.assign(object, {
                has: getHasFn$1(container),
            }));
        },
    };
    var SingleValuesPatternMore = {
        createFrom: function (container, object) {
            return NotTriplePattern.createFrom(container, Object.assign(object, {
                and: getHasFn$1(container),
            }));
        },
    };

    function _getPatternContainer(container, targetToken) {
        return new Container({
            iriResolver: container.iriResolver,
            targetToken: targetToken,
        });
    }
    function _getPattern(container, token) {
        var patternContainer = _getPatternContainer(container, token);
        return NotTriplePattern.createFrom(patternContainer, {});
    }
    function getGraphFn(container) {
        return function (iriOrVariable, patterns) {
            var varOrIRI = typeof iriOrVariable === "string" ?
                container.iriResolver.resolve(iriOrVariable) :
                iriOrVariable.getSubject();
            var token = new GraphToken(varOrIRI);
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            token.addPattern.apply(token, patterns.map(function (x) { return x.getPattern(); }));
            return _getPattern(container, token);
        };
    }
    function getGroupFn(container) {
        return function (patterns) {
            var _a;
            var token = new GroupPatternToken();
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            (_a = token.patterns).push.apply(_a, patterns.map(function (x) { return x.getPattern(); }));
            var patternContainer = _getPatternContainer(container, token);
            return GroupPattern.createFrom(patternContainer, {});
        };
    }
    function getUnionFn$1(container) {
        return function (patterns) {
            var token = new UnionPatternToken();
            var patternContainer = _getPatternContainer(container, token);
            var unionPattern = UnionPattern
                .createFrom(patternContainer, {});
            return unionPattern.and(patterns);
        };
    }
    function getOptionalFn(container) {
        return function (patterns) {
            var token = new OptionalToken();
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            token.addPattern.apply(token, patterns.map(function (x) { return x.getPattern(); }));
            return _getPattern(container, token);
        };
    }
    function getMinusFn(container) {
        return function (patterns) {
            var _a;
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            var token = new MinusPatternToken();
            (_a = token.groupPattern.patterns).push.apply(_a, patterns.map(function (x) { return x.getPattern(); }));
            return _getPattern(container, token);
        };
    }
    function getServiceFn(container, modifier) {
        return function (resource, patterns) {
            var _a;
            var varOrIRI = typeof resource === "string" ?
                container.iriResolver.resolve(resource) :
                resource.getSubject();
            var token = new ServicePatternToken(varOrIRI, modifier);
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            (_a = token.groupPattern.patterns).push.apply(_a, patterns.map(function (x) { return x.getPattern(); }));
            return _getPattern(container, token);
        };
    }
    function getFilterFn(container) {
        return function (rawConstraint) {
            var token = new FilterToken(rawConstraint);
            return _getPattern(container, token);
        };
    }
    function getBindFn(container) {
        return function (rawExpression, variable) {
            var parsedVar = typeof variable === "string" ?
                new VariableToken(variable) :
                variable.getSubject();
            var token = new BindToken(rawExpression, parsedVar);
            return _getPattern(container, token);
        };
    }
    function getValuesFn(container) {
        return function () {
            var variables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                variables[_i] = arguments[_i];
            }
            var _a;
            var token = new ValuesToken();
            (_a = token.variables).push.apply(_a, variables.map(function (x) { return x.getSubject(); }));
            var patternContainer = _getPatternContainer(container, token);
            if (variables.length === 1)
                return SingleValuesPattern
                    .createFrom(patternContainer, {});
            return MultipleValuesPattern
                .createFrom(patternContainer, {});
        };
    }
    var NotTriplePatternsBuilder = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                undefined: "UNDEF",
                graph: getGraphFn(container),
                group: getGroupFn(container),
                union: getUnionFn$1(container),
                optional: getOptionalFn(container),
                minus: getMinusFn(container),
                service: getServiceFn(container),
                serviceSilent: getServiceFn(container, "SILENT"),
                filter: getFilterFn(container),
                bind: getBindFn(container),
                values: getValuesFn(container),
            });
        },
    };

    var FluentPathContainer = (function (_super) {
        __extends(FluentPathContainer, _super);
        function FluentPathContainer(data) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, data) || this;
            _this.fluentPathFactory = data.fluentPathFactory;
            _this.deniableFluentPathFactory = data.deniableFluentPathFactory;
            if (_newTarget === FluentPathContainer)
                Object.freeze(_this);
            return _this;
        }
        return FluentPathContainer;
    }(Container));

    function getPropertyToken(container, property) {
        if (property === "a")
            return property;
        if (typeof property === "string")
            return container.iriResolver.resolve(property, true);
        if ("token" in property)
            return property;
        if ("getSubject" in property)
            return property.getSubject();
        return property.getPath();
    }

    var SharedSubPathToken = (function () {
        function SharedSubPathToken(path) {
            this.token = "subPath";
            this.path = path;
        }
        SharedSubPathToken.prototype.toString = function () {
            if (!this.path)
                return "()";
            return "(" + this.path + ")";
        };
        return SharedSubPathToken;
    }());

    function _getTokenWrapper() {
        var symbols = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            symbols[_i] = arguments[_i];
        }
        return function (token) {
            if (token === "a")
                return token;
            if (symbols.indexOf(token.token) !== -1)
                return new SharedSubPathToken(token);
            return token;
        };
    }
    function _isBasePrimitive(token) {
        return token === "a"
            || token.token === "iri"
            || token.token === "prefixedName";
    }
    function _isPathInNegatedToken(token) {
        return _isBasePrimitive(token)
            || (token.token === "pathInverse"
                && _isBasePrimitive(token.path));
    }

    var _getInAlternativeToken = _getTokenWrapper("pathAlternative");
    function getAlternativeFn(container) {
        return function () {
            var paths = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paths[_i] = arguments[_i];
            }
            var _a;
            var tokensParams = paths
                .reduce(function (array, paths) { return array.concat(paths); }, [])
                .map(function (path) { return getPropertyToken(container, path); });
            if (container.targetToken && !(container.targetToken instanceof PathAlternativeToken))
                tokensParams.unshift(container.targetToken);
            var processedTokens = tokensParams
                .map(_getInAlternativeToken);
            if (container.targetToken instanceof PathAlternativeToken)
                processedTokens.unshift.apply(processedTokens, container.targetToken.paths);
            var targetToken = new PathAlternativeToken();
            (_a = targetToken.paths).push.apply(_a, processedTokens);
            var newContainer = new FluentPathContainer(__assign({}, container, { targetToken: targetToken }));
            if (processedTokens.every(_isPathInNegatedToken))
                return container.deniableFluentPathFactory(newContainer, {});
            return container.fluentPathFactory(newContainer, {});
        };
    }

    var _getInInverseToken = _getTokenWrapper("pathAlternative", "pathSequence", "pathInverse");
    function getInverseFn(container) {
        return function (path) {
            var token = container.targetToken
                ? container.targetToken
                : getPropertyToken(container, path);
            var inInverseToken = _getInInverseToken(token);
            var targetToken = new PathInverseToken(inInverseToken);
            var newContainer = new FluentPathContainer(__assign({}, container, { targetToken: targetToken }));
            if (_isBasePrimitive(token))
                return container.deniableFluentPathFactory(newContainer, {});
            return container.fluentPathFactory(newContainer, {});
        };
    }

    var _getInModToken = _getTokenWrapper("pathAlternative", "pathSequence", "pathInverse", "pathMod");
    function getModFn(container, mod) {
        return function (path) {
            var token = container.targetToken
                ? container.targetToken
                : getPropertyToken(container, path);
            var inModToken = _getInModToken(token);
            var targetToken = new PathModToken(inModToken, mod);
            var newContainer = new FluentPathContainer(__assign({}, container, { targetToken: targetToken }));
            return container.fluentPathFactory(newContainer, {});
        };
    }

    var _getInSequenceToken = _getTokenWrapper("pathAlternative", "pathSequence");
    function getSequenceFn(container) {
        return function () {
            var paths = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paths[_i] = arguments[_i];
            }
            var _a;
            var tokensParams = paths
                .reduce(function (array, paths) { return array.concat(paths); }, [])
                .map(function (path) { return getPropertyToken(container, path); });
            if (container.targetToken && !(container.targetToken instanceof PathSequenceToken))
                tokensParams.unshift(container.targetToken);
            var processedTokens = tokensParams
                .map(_getInSequenceToken);
            if (container.targetToken instanceof PathSequenceToken)
                processedTokens.unshift.apply(processedTokens, container.targetToken.paths);
            var targetToken = new PathSequenceToken();
            (_a = targetToken.paths).push.apply(_a, processedTokens);
            var newContainer = new FluentPathContainer(__assign({}, container, { targetToken: targetToken }));
            return container.fluentPathFactory(newContainer, {});
        };
    }

    function _canBeNegated(token) {
        return !token
            || _isPathInNegatedToken(token)
            || (token.token === "pathAlternative" && token.paths.every(_isPathInNegatedToken));
    }
    function getSubPathFn(container) {
        return function (path) {
            var token = container.targetToken
                ? container.targetToken
                : path === void 0 ? path
                    : getPropertyToken(container, path);
            var targetToken = new SharedSubPathToken(token);
            var newContainer = new FluentPathContainer(__assign({}, container, { targetToken: targetToken }));
            if (_canBeNegated(token))
                return container.deniableFluentPathFactory(newContainer, {});
            return container.fluentPathFactory(newContainer, {});
        };
    }

    var Path = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                getPath: function () { return container.targetToken; },
            });
        }
    };

    var FluentPath = {
        createFrom: function (container, object) {
            return Path.createFrom(container, Object.assign(object, {
                subPath: getSubPathFn(container),
                or: getAlternativeFn(container),
                then: getSequenceFn(container),
                inverse: getInverseFn(container),
                oneOrNone: getModFn(container, "?"),
                zeroOrMore: getModFn(container, "*"),
                onceOrMore: getModFn(container, "+"),
            }));
        },
    };

    var _getInNegatedToken = _getTokenWrapper("pathAlternative");
    function getNegatedFn(container) {
        return function (path) {
            var token = container.targetToken
                ? container.targetToken
                : getPropertyToken(container, path);
            var inNegatedToken = _getInNegatedToken(token);
            var targetToken = new PathNegatedToken(inNegatedToken);
            var newContainer = new FluentPathContainer(__assign({}, container, { targetToken: targetToken }));
            return container.fluentPathFactory(newContainer, {});
        };
    }

    var DeniableFluentPath = {
        createFrom: function (container, object) {
            return FluentPath.createFrom(container, Object.assign(object, {
                negated: getNegatedFn(container),
            }));
        },
    };

    var PathBuilder = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                subPath: getSubPathFn(container),
                alternatives: getAlternativeFn(container),
                sequences: getSequenceFn(container),
                inverse: getInverseFn(container),
                negated: getNegatedFn(container),
                oneOrNone: getModFn(container, "?"),
                zeroOrMore: getModFn(container, "*"),
                onceOrMore: getModFn(container, "+"),
            });
        }
    };

    function _getContainer(container, targetToken) {
        return new FluentPathContainer(__assign({}, container, { targetToken: targetToken, fluentPathFactory: FluentPath.createFrom, deniableFluentPathFactory: DeniableFluentPath.createFrom }));
    }
    function _parseProperty(container, property) {
        var targetToken = getPropertyToken(container, property);
        var newContainer = _getContainer(container, targetToken);
        return DeniableFluentPath.createFrom(newContainer, {});
    }
    function getPathFn(container) {
        return function (propertyOrBuilderFn) {
            if (typeof propertyOrBuilderFn !== "function")
                return _parseProperty(container, propertyOrBuilderFn);
            var newContainer = _getContainer(container);
            var pathBuilder = PathBuilder.createFrom(newContainer, {});
            return propertyOrBuilderFn(pathBuilder);
        };
    }
    var PathsBuilder = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                path: getPathFn(container),
            });
        }
    };

    function _cloneContainer(container, propertyToken) {
        var properties = container.targetToken.properties.concat(propertyToken);
        var targetToken = cloneElement(container.targetToken, { properties: properties });
        return cloneElement(container, { targetToken: targetToken });
    }
    function _updateContainer(container, propertyToken) {
        container.targetToken.properties.push(propertyToken);
        return container;
    }
    function getHasFn$2(genericFactory, container) {
        return function (property, objects) {
            var verbToken = getPropertyToken(container, property);
            var propertyToken = new PropertyToken(verbToken);
            objects = Array.isArray(objects) ? objects : [objects];
            propertyToken.addObject.apply(propertyToken, objects.map(convertValue));
            var newContainer = container.targetToken.token === "subject" ?
                _cloneContainer(container, propertyToken) :
                _updateContainer(container, propertyToken);
            var genericObject = genericFactory(newContainer, {});
            return PropertyBuilderMore.createFrom(genericFactory, newContainer, genericObject);
        };
    }
    var PropertyBuilder = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                has: getHasFn$2(genericFactory, container),
            });
        }
    };
    var PropertyBuilderMore = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                and: getHasFn$2(genericFactory, container),
            });
        }
    };

    var emptyGenericFactory = function (container, object) { return object; };
    var BlankNodeBuilder = {
        createFrom: function (container, object) {
            return PropertyBuilder.createFrom(emptyGenericFactory, container, object);
        }
    };

    var TriplePattern = {
        createFrom: Pattern.createFrom,
    };

    var TripleSubject = {
        createFrom: function (container, object) {
            var triplePatternFactory = TriplePattern.createFrom;
            return PropertyBuilder.createFrom(triplePatternFactory, container, Object.assign(object, {
                getSubject: function () { return container.targetToken.subject; },
            }));
        }
    };

    function getWithTypeFn(container) {
        return function (type) {
            if (type in XSD$1)
                type = XSD$1[type];
            var iriType = container.iriResolver.resolve(type, true);
            var subject = cloneElement(container.targetToken.subject, { type: iriType });
            var targetToken = cloneElement(container.targetToken, { subject: subject });
            var newContainer = cloneElement(container, { targetToken: targetToken });
            return TripleSubject.createFrom(newContainer, {});
        };
    }
    function getWithLanguageFn(container) {
        return function (language) {
            var langToken = new LanguageToken(language);
            var subject = cloneElement(container.targetToken.subject, { language: langToken });
            var targetToken = cloneElement(container.targetToken, { subject: subject });
            var newContainer = cloneElement(container, { targetToken: targetToken });
            return TripleSubject.createFrom(newContainer, {});
        };
    }
    var RDFLiteral$1 = {
        createFrom: function (container, object) {
            return TripleSubject.createFrom(container, Object.assign(object, {
                withType: getWithTypeFn(container),
                withLanguage: getWithLanguageFn(container),
            }));
        },
    };

    function _getPatternContainer$1(container, token) {
        return new Container({
            iriResolver: container.iriResolver,
            targetToken: new SubjectToken(token),
        });
    }
    function _getTripleSubject(container, token) {
        var patternContainer = _getPatternContainer$1(container, token);
        return TripleSubject.createFrom(patternContainer, {});
    }
    function _getNodeSubject(container, token) {
        var patternContainer = _getPatternContainer$1(container, token);
        return Factory.createFrom(TripleSubject.createFrom, Pattern.createFrom)(patternContainer, {});
    }
    function getResourceFn(container) {
        return function (iri) {
            var token = container.iriResolver.resolve(iri);
            return _getTripleSubject(container, token);
        };
    }
    function getVarFn(container) {
        return function (name) {
            var token = new VariableToken(name);
            return _getTripleSubject(container, token);
        };
    }
    function getLiteralFn(container) {
        return function (value) {
            if (typeof value !== "string") {
                var token_1 = new LiteralToken(value);
                return _getTripleSubject(container, token_1);
            }
            var token = new RDFLiteralToken(value);
            var patternContainer = _getPatternContainer$1(container, token);
            return RDFLiteral$1.createFrom(patternContainer, {});
        };
    }
    function getCollectionFn(container) {
        return function () {
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            var _a;
            var token = (_a = new CollectionToken()).addObject.apply(_a, values.map(convertValue));
            return _getNodeSubject(container, token);
        };
    }
    function _getBlankNode(container, label) {
        if (label && !label.startsWith("_:"))
            label = "_:" + label;
        var token = new BlankNodeToken(label);
        return _getTripleSubject(container, token);
    }
    function _getBlankNodeProperty(container, builderFn) {
        var token = new BlankNodePropertyToken();
        var builderContainer = new Container({
            iriResolver: container.iriResolver,
            targetToken: token,
        });
        var builder = BlankNodeBuilder.createFrom(builderContainer, {});
        builderFn(builder);
        if (token.properties.length < 1)
            throw new Error("At least one property must be specified by the self builder.");
        return _getNodeSubject(container, token);
    }
    function getBlankNodeFn(container) {
        return function (labelOrBuilderFn) {
            if (typeof labelOrBuilderFn === "function")
                return _getBlankNodeProperty(container, labelOrBuilderFn);
            return _getBlankNode(container, labelOrBuilderFn);
        };
    }
    var TriplePatternsBuilder = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                resource: getResourceFn(container),
                var: getVarFn(container),
                literal: getLiteralFn(container),
                collection: getCollectionFn(container),
                blankNode: getBlankNodeFn(container),
            });
        },
    };

    var PatternBuilder = {
        create: function (iriResolver) {
            var container = new Container({
                iriResolver: iriResolver,
                targetToken: void 0,
            });
            return PatternBuilder
                .createFrom(container, {});
        },
        createFrom: function (container, object) {
            return Factory.createFrom(TriplePatternsBuilder.createFrom, NotTriplePatternsBuilder.createFrom, SubSelectPattern.createFrom, PathsBuilder.createFrom)(container, object);
        },
    };

    function _normalizeVariables(variableOrVariables) {
        var variables = Array.isArray(variableOrVariables) ? variableOrVariables : [variableOrVariables];
        return variables.map(function (x) { return new VariableToken(x); });
    }
    function _normalizeRawValues(valuesOrBuilder, iriResolver, isSingle) {
        var rawValues = typeof valuesOrBuilder === "function" ?
            valuesOrBuilder(PatternBuilder.create(iriResolver)) :
            valuesOrBuilder;
        if (!Array.isArray(rawValues))
            return [[rawValues]];
        if (isSingle)
            rawValues.map(function (value) { return [value]; });
        if (rawValues.some(Array.isArray))
            return rawValues;
        return [rawValues];
    }
    function createValuesFn(genericFactory, container) {
        return function (variableOrVariables, valuesOrBuilder) {
            var token = new ValuesToken();
            var variables = _normalizeVariables(variableOrVariables);
            token.addVariables.apply(token, variables);
            var isSingle = !Array.isArray(variableOrVariables);
            var iriResolver = new IRIResolver(container.iriResolver);
            var values = _normalizeRawValues(valuesOrBuilder, iriResolver, isSingle);
            values.forEach(function (valuesRow) { return token.addValues.apply(token, valuesRow.map(convertValue)); });
            var targetToken = cloneElement(container.targetToken, { values: token });
            var newContainer = cloneElement(container, { iriResolver: iriResolver, targetToken: targetToken });
            return genericFactory(newContainer, {});
        };
    }
    var ValuesClause = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                values: createValuesFn(genericFactory, container),
            });
        },
    };

    function _getLimitFactory(valuesFactory) {
        var offsetValuesFactory = OffsetClause
            .createFrom.bind(null, valuesFactory);
        return function (container1, object1) { return LimitClause
            .createFrom(Factory.createFrom(offsetValuesFactory, valuesFactory), container1, object1); };
    }
    function _getOffsetFactory(valuesFactory) {
        var limitValuesFactory = LimitClause
            .createFrom.bind(null, valuesFactory);
        return function (container1, object1) { return OffsetClause
            .createFrom(Factory.createFrom(valuesFactory, limitValuesFactory), container1, object1); };
    }
    var LimitOffsetClause = {
        createFrom: function (genericFactory, container, object) {
            var valuesFactory = ValuesClause
                .createFrom.bind(null, genericFactory);
            var genericAndValuesFactory = Factory.createFrom(genericFactory, valuesFactory);
            return Factory.createFrom(_getLimitFactory(genericAndValuesFactory), _getOffsetFactory(genericAndValuesFactory), valuesFactory)(container, object);
        },
    };

    function getOrderByFn(genericFactory, container) {
        return function (rawCondition) {
            var token = new OrderToken(rawCondition);
            var newContainer = cloneSolutionModifierContainer(container, token);
            var limitOffsetClause = LimitOffsetClause.createFrom(genericFactory, newContainer, {});
            return genericFactory(newContainer, limitOffsetClause);
        };
    }
    var OrderClause = {
        createFrom: function (genericFactory, container, object) {
            return LimitOffsetClause.createFrom(genericFactory, container, Object.assign(object, {
                orderBy: getOrderByFn(genericFactory, container),
            }));
        }
    };

    function getHavingFn(genericFactory, container) {
        return function (rawCondition) {
            var token = new HavingToken(rawCondition);
            var newContainer = cloneSolutionModifierContainer(container, token);
            var orderClause = OrderClause.createFrom(genericFactory, newContainer, {});
            return genericFactory(newContainer, orderClause);
        };
    }
    var HavingClause = {
        createFrom: function (genericFactory, container, object) {
            return OrderClause.createFrom(genericFactory, container, Object.assign(object, {
                having: getHavingFn(genericFactory, container),
            }));
        },
    };

    function getGroupByFn(genericFactory, container) {
        return function (rawCondition) {
            var token = new GroupToken(rawCondition);
            var newContainer = cloneSolutionModifierContainer(container, token);
            var havingClause = HavingClause.createFrom(genericFactory, newContainer, {});
            return genericFactory(newContainer, havingClause);
        };
    }
    var GroupClause = {
        createFrom: function (genericFactory, container, object) {
            return HavingClause.createFrom(genericFactory, container, Object.assign(object, {
                groupBy: getGroupByFn(genericFactory, container),
            }));
        },
    };

    function getWhereFn(container) {
        return function (patterns) {
            var _a;
            var where = new WhereToken();
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            (_a = where.groupPattern.patterns).push.apply(_a, patterns.map(function (x) { return x.getPattern(); }));
            var targetToken = cloneElement(container.targetToken, { where: where });
            var newContainer = cloneElement(container, { targetToken: targetToken });
            var groupClause = GroupClause.createFrom(FinishPattern.createFrom, newContainer, {});
            return FinishPattern.createFrom(newContainer, groupClause);
        };
    }
    var WherePattern = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                where: getWhereFn(container),
            });
        },
    };

    function getSelectFn(container, modifier) {
        return function () {
            var variables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                variables[_i] = arguments[_i];
            }
            var targetToken = new SubSelectToken(modifier);
            if (variables.length)
                targetToken.addVariable.apply(targetToken, variables.map(function (x) { return new VariableToken(x); }));
            var newContainer = new Container({
                iriResolver: container.iriResolver,
                targetToken: targetToken
            });
            return WherePattern.createFrom(newContainer, {});
        };
    }
    var SubSelectPattern = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                select: getSelectFn(container),
                selectDistinct: getSelectFn(container, "DISTINCT"),
                selectReduced: getSelectFn(container, "REDUCED"),
                selectAll: function () { return getSelectFn(container)(); },
                selectAllDistinct: function () { return getSelectFn(container, "DISTINCT")(); },
                selectAllReduced: function () { return getSelectFn(container, "REDUCED")(); },
            });
        },
    };

    var QueryContainerPropertyType;
    (function (QueryContainerPropertyType) {
        QueryContainerPropertyType["CHILD"] = "child";
        QueryContainerPropertyType["MEMBER"] = "member";
    })(QueryContainerPropertyType || (QueryContainerPropertyType = {}));

    var IllegalActionError = (function (_super) {
        __extends(IllegalActionError, _super);
        function IllegalActionError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IllegalActionError.prototype, "name", {
            get: function () { return "IllegalActionError"; },
            enumerable: true,
            configurable: true
        });
        return IllegalActionError;
    }(AbstractError));

    var QueryPropertyType;
    (function (QueryPropertyType) {
        QueryPropertyType[QueryPropertyType["PARTIAL"] = 0] = "PARTIAL";
        QueryPropertyType[QueryPropertyType["EMPTY"] = 1] = "EMPTY";
        QueryPropertyType[QueryPropertyType["ALL"] = 2] = "ALL";
        QueryPropertyType[QueryPropertyType["FULL"] = 3] = "FULL";
    })(QueryPropertyType || (QueryPropertyType = {}));

    function _getRootPath(path) {
        var root = path
            .split(".")
            .slice(0, 1)[0];
        return root;
    }
    function _getPathProperty(element, path) {
        if (element === void 0 || !path)
            return element;
        var _a = path.split("."), propName = _a[0], restParts = _a.slice(1);
        var property = element[propName];
        var restPath = restParts.join(".");
        return _getPathProperty(property, restPath);
    }
    function _areDifferentType(a, b) {
        if (typeof a !== typeof b)
            return true;
        if (typeof a === "object")
            return a instanceof Date !== b instanceof Date;
        return false;
    }
    function _getBestType(type1, type2) {
        if (type2 <= type1)
            return type1;
        return type2;
    }
    function _getMatchingDefinition(generalSchema, targetSchema, propertyName, propertyURI) {
        if (!targetSchema.properties.has(propertyName))
            return;
        var definition = ObjectSchemaUtils
            ._resolveProperty(generalSchema, targetSchema.properties.get(propertyName));
        if (propertyURI === void 0 || propertyURI === definition.uri)
            return definition;
    }

    var QueryProperty = (function () {
        function QueryProperty(data) {
            this.queryContainer = data.queryContainer;
            this.parent = data.parent;
            this.name = data.name;
            this.fullName = data.parent
                ? data.parent.fullName + "." + data.name
                : data.name;
            this.definition = data.definition;
            this.pathBuilderFn = data.pathBuilderFn;
            this.propertyType = data.propertyType;
            this.optional = data.optional === void 0
                ? true
                : data.optional;
            this.subProperties = new Map();
            this.values = data.values ? data.values : [];
            this._types = [];
            this._filters = [];
        }
        Object.defineProperty(QueryProperty.prototype, "variable", {
            get: function () {
                return this.queryContainer
                    .getVariable(this.fullName);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueryProperty.prototype, "identifier", {
            get: function () {
                if (this.values.length === 1) {
                    return this.values[0];
                }
                return this.queryContainer
                    .getVariable(this.fullName);
            },
            enumerable: true,
            configurable: true
        });
        QueryProperty.prototype.hasProperties = function () {
            return this.subProperties.size !== 0
                || this._isComplete();
        };
        QueryProperty.prototype.getProperty = function (path, flags) {
            if (!path)
                return this;
            var rootPath = _getRootPath(path);
            var property = this.subProperties.get(rootPath);
            if (!property) {
                if (rootPath === path && flags && flags.create && this._isComplete()) {
                    var newProperty = this.addProperty(rootPath, flags);
                    if (this.propertyType === QueryPropertyType.FULL)
                        newProperty.setType(QueryPropertyType.ALL);
                    return newProperty;
                }
                return;
            }
            var restPath = path.substr(rootPath.length + 1);
            return property.getProperty(restPath);
        };
        QueryProperty.prototype.addProperty = function (propertyName, propertyDefinition) {
            var definition = this
                .__getDefinition(propertyName, propertyDefinition);
            return this._addSubProperty(propertyName, {
                definition: definition,
                pathBuilderFn: propertyDefinition.path,
                optional: !propertyDefinition.required,
            });
        };
        QueryProperty.prototype._addSubProperty = function (propertyName, data) {
            var property = new QueryProperty(__assign({}, data, { name: propertyName, queryContainer: this.queryContainer, parent: this }));
            this.subProperties.set(propertyName, property);
            return property;
        };
        QueryProperty.prototype.__getDefinition = function (propertyName, propertyDefinition) {
            var digestedDefinition = this.queryContainer
                .digestProperty(propertyName, propertyDefinition);
            if (propertyDefinition.inherit === false)
                return digestedDefinition;
            var propertyURI = "@id" in propertyDefinition ? digestedDefinition.uri : void 0;
            var inheritDefinition = this
                .__getInheritDefinition(propertyName, propertyURI);
            if (inheritDefinition) {
                for (var key in inheritDefinition) {
                    if (digestedDefinition[key] !== null && key !== "uri")
                        continue;
                    digestedDefinition[key] = inheritDefinition[key];
                }
            }
            return digestedDefinition;
        };
        QueryProperty.prototype.__getInheritDefinition = function (propertyName, propertyURI) {
            var searchSchema = this._getSearchSchema();
            var localDefinition = _getMatchingDefinition(searchSchema, searchSchema, propertyName, propertyURI);
            if (localDefinition)
                return localDefinition;
            var schemas = this.queryContainer.context
                ._getTypeObjectSchemas(this._types);
            for (var _i = 0, schemas_1 = schemas; _i < schemas_1.length; _i++) {
                var targetSchema = schemas_1[_i];
                var definition = _getMatchingDefinition(searchSchema, targetSchema, propertyName, propertyURI);
                if (definition)
                    return definition;
            }
        };
        QueryProperty.prototype._isComplete = function () {
            return this.propertyType === QueryPropertyType.ALL
                || this.propertyType === QueryPropertyType.FULL;
        };
        QueryProperty.prototype._isPartial = function () {
            return this.propertyType === QueryPropertyType.PARTIAL
                || this.propertyType === QueryPropertyType.ALL
                || !!this.subProperties.size;
        };
        QueryProperty.prototype._isEmpty = function () {
            return this.propertyType === undefined
                || this.propertyType === QueryPropertyType.EMPTY;
        };
        QueryProperty.prototype.setType = function (type) {
            this.propertyType = _getBestType(this.propertyType, type);
        };
        QueryProperty.prototype.addType = function (type) {
            var schema = this._getSearchSchema();
            var iri = schema.resolveURI(type, { vocab: true });
            this._types.push(iri);
            if (!this.queryContainer.context.hasObjectSchema(iri))
                return;
            var typedSchema = this.queryContainer.context.getObjectSchema(iri);
            ObjectSchemaDigester._combineSchemas([schema, typedSchema]);
        };
        QueryProperty.prototype.addValues = function (values) {
            var _a;
            (_a = this.values).push.apply(_a, values);
        };
        QueryProperty.prototype.addFilter = function (constraint) {
            this._filters.push(constraint);
        };
        QueryProperty.prototype.setObligatory = function (flags) {
            if (!this.optional)
                return;
            this.optional = false;
            if (flags && flags.inheritParents && this.parent)
                this.parent.setObligatory(flags);
        };
        QueryProperty.prototype._getVariable = function (name) {
            return this.queryContainer
                .getVariable(this.fullName + "." + name);
        };
        QueryProperty.prototype.__createIRIToken = function () {
            return this
                .queryContainer
                .compactIRI(this.definition.uri);
        };
        QueryProperty.prototype.__createPathToken = function () {
            if (!this.pathBuilderFn)
                return this.__createIRIToken();
            var pathBuilder = PathBuilder
                .createFrom(this.queryContainer, {});
            return this.pathBuilderFn
                .call(void 0, pathBuilder)
                .getPath();
        };
        QueryProperty.prototype._getContextVariable = function () {
            if (this.propertyType === QueryPropertyType.FULL)
                return this.__getSelfToken();
            return this._getVariable("_graph");
        };
        QueryProperty.prototype._getContextGraph = function () {
            return new GraphToken(this._getContextVariable());
        };
        QueryProperty.prototype.getSelfPattern = function () {
            var pattern = this.__createSelfPattern();
            if (!pattern)
                return;
            if (!this.optional)
                return pattern;
            return new OptionalToken()
                .addPattern(pattern);
        };
        QueryProperty.prototype.__createSelfPattern = function () {
            if (!this.parent)
                throw new IllegalActionError("Cannot create pattern without a parent.");
            return this
                .__addPropertyTo(new SubjectToken(this.parent.identifier));
        };
        QueryProperty.prototype.__addPropertyTo = function (subject) {
            return subject
                .addProperty(new PropertyToken(this.__createPathToken())
                .addObject(this.identifier));
        };
        QueryProperty.prototype.getSearchPatterns = function () {
            var _a;
            var patterns = this
                .__createSearchPatterns();
            if (!this.optional)
                return patterns;
            return [(_a = new OptionalToken()).addPattern.apply(_a, patterns),];
        };
        QueryProperty.prototype.__createSearchPatterns = function () {
            var patterns = [];
            var values = this.__createValuesPattern();
            if (values)
                patterns.push(values);
            var selfTriple = this.__createSelfPattern();
            if (selfTriple) {
                if (this.parent && !this.pathBuilderFn) {
                    patterns.push(this.parent._getContextGraph()
                        .addPattern(selfTriple));
                }
                else {
                    patterns.push(selfTriple);
                }
            }
            switch (this.propertyType) {
                case QueryPropertyType.EMPTY:
                    patterns.push(this.__createTypesSearchPatterns());
                    break;
                case QueryPropertyType.PARTIAL:
                    patterns.push.apply(patterns, this.__createPartialSearchPatterns());
                    break;
                case QueryPropertyType.ALL:
                    patterns.push(this.__createSearchAllPattern());
                    patterns.push.apply(patterns, this.__createSubPropertiesPatterns());
                    break;
                case QueryPropertyType.FULL:
                    patterns.push(this.__createSearchGraphPattern());
                    patterns.push.apply(patterns, this.__createSubPropertiesPatterns());
                    break;
                default:
                    var selfTypeFilter = this.__createSelfTypeFilter();
                    if (selfTypeFilter)
                        patterns.push(selfTypeFilter);
                    break;
            }
            if (this._filters.length) {
                var filters = this._filters
                    .map(function (constraint) { return new FilterToken(constraint); });
                patterns.push.apply(patterns, filters);
            }
            return patterns;
        };
        QueryProperty.prototype.__createValuesPattern = function () {
            if (this.values.length <= 1)
                return;
            var values = new ValuesToken()
                .addVariables(this.variable);
            this.values
                .forEach(function (value) { return values.addValues(value); });
            return values;
        };
        QueryProperty.prototype.__createSelfTypeFilter = function () {
            var identifier = this.identifier;
            if (this.definition.literal) {
                var literalToken = this.queryContainer
                    .compactIRI(this.definition.literalType);
                if (identifier.token === "variable")
                    return new FilterToken("datatype( " + identifier + " ) = " + literalToken);
            }
            if (this.definition.pointerType !== null && identifier.token === "variable")
                return new FilterToken("! isLiteral( " + identifier + " )");
        };
        QueryProperty.prototype.__createPartialSearchPatterns = function () {
            return [
                this.__createTypesSearchPatterns()
            ].concat(this.__createSubPropertiesPatterns());
        };
        QueryProperty.prototype.__createSubPropertiesPatterns = function () {
            var patterns = [];
            this.subProperties.forEach(function (subProperty) {
                patterns.push.apply(patterns, subProperty.getSearchPatterns());
            });
            return patterns;
        };
        QueryProperty.prototype.__createTypesSearchPatterns = function () {
            var types = this.__createTypesPattern();
            var pattern = this.propertyType === QueryPropertyType.EMPTY
                ? types
                : this._getContextGraph()
                    .addPattern(types);
            if (!this._types.length)
                return new OptionalToken()
                    .addPattern(pattern);
            this.__addTypesTo(types);
            return pattern;
        };
        QueryProperty.prototype.__addTypesTo = function (pattern) {
            var _a;
            var types = this
                .__createTypesTokens();
            var aProperty = pattern.properties
                .find(function (_) { return _.verb === "a"; });
            if (!aProperty) {
                aProperty = new PropertyToken("a");
                pattern.addProperty(aProperty);
            }
            (_a = aProperty.objects).unshift.apply(_a, types);
        };
        QueryProperty.prototype.__createTypesTokens = function () {
            var _this = this;
            return this._types
                .map(function (type) { return _this.queryContainer.compactIRI(type); });
        };
        QueryProperty.prototype.__createSearchAllPattern = function () {
            var pattern = this.__createAllPattern();
            if (this._types.length)
                this.__addTypesTo(pattern);
            return this
                ._getContextGraph()
                .addPattern(pattern);
        };
        QueryProperty.prototype.__createSearchGraphPattern = function () {
            var graph = new GraphToken(this.__getSelfToken());
            if (this._types.length) {
                var pattern = new SubjectToken(this.__getSelfToken());
                this.__addTypesTo(pattern);
                graph.addPattern(pattern);
            }
            return graph
                .addPattern(this.__createGraphSubPattern());
        };
        QueryProperty.prototype.__getValuedPatterns = function () {
            var _a;
            if (this.optional)
                return;
            var selfSubject = new SubjectToken(this.identifier);
            var patterns = [selfSubject];
            var valuesPattern = this.__createValuesPattern();
            if (valuesPattern)
                patterns.push(valuesPattern);
            if (this._types.length) {
                var typesTokens = this
                    .__createTypesTokens();
                selfSubject
                    .addProperty((_a = new PropertyToken("a")).addObject.apply(_a, typesTokens));
            }
            this.subProperties.forEach(function (subProperty) {
                var subPatterns = subProperty
                    .__getValuedPatterns();
                if (subPatterns) {
                    subProperty.__addPropertyTo(selfSubject);
                    patterns.push.apply(patterns, subPatterns);
                }
            });
            if (!selfSubject.properties.length)
                return patterns.slice(1);
            return patterns;
        };
        QueryProperty.prototype.getConstructPatterns = function () {
            var patterns = [];
            var selfPattern = this.__createSelfConstructPattern();
            if (selfPattern)
                patterns.push(selfPattern);
            this.subProperties.forEach(function (property) {
                var subPatterns = property
                    .getConstructPatterns();
                patterns.push.apply(patterns, subPatterns);
            });
            return patterns;
        };
        QueryProperty.prototype.__createSelfConstructPattern = function () {
            switch (this.propertyType) {
                case QueryPropertyType.EMPTY:
                    return this.__createTypesPattern();
                case QueryPropertyType.PARTIAL:
                    return this.__createPartialConstructPattern();
                case QueryPropertyType.ALL:
                case QueryPropertyType.FULL:
                    return this.__createCompleteConstructPattern()
                        .addProperty(new PropertyToken(this.queryContainer.compactIRI(C.document))
                        .addObject(this._getContextVariable()));
                default:
                    return;
            }
        };
        QueryProperty.prototype.__createCompleteConstructPattern = function () {
            switch (this.propertyType) {
                case QueryPropertyType.ALL:
                    return this.__createAllPattern();
                case QueryPropertyType.FULL:
                    return this.__createGraphSubPattern();
                default:
                    throw new IllegalActionError("Invalid property type");
            }
        };
        QueryProperty.prototype.__createPartialConstructPattern = function () {
            var subject = this.__createTypesPattern()
                .addProperty(new PropertyToken(this.queryContainer.compactIRI(C.document))
                .addObject(this._getContextVariable()));
            this.subProperties.forEach(function (subProperty) {
                subject.addProperty(new PropertyToken(subProperty.__createIRIToken())
                    .addObject(subProperty.identifier));
            });
            return subject;
        };
        QueryProperty.prototype.__createTypesPattern = function () {
            return new SubjectToken(this.identifier)
                .addProperty(new PropertyToken("a")
                .addObject(this._getVariable("types")));
        };
        QueryProperty.prototype.__createAllPattern = function () {
            return new SubjectToken(this.__getSelfToken())
                .addProperty(new PropertyToken(this._getVariable("_predicate"))
                .addObject(this._getVariable("_object")));
        };
        QueryProperty.prototype.__createGraphSubPattern = function () {
            return new SubjectToken(this._getVariable("_subject"))
                .addProperty(new PropertyToken(this._getVariable("_predicate"))
                .addObject(this._getVariable("_object")));
        };
        QueryProperty.prototype.__getSelfToken = function () {
            var identifier = this.identifier;
            if (identifier.token === "literal")
                throw new IllegalActionError("Property is not a resource.");
            return identifier;
        };
        QueryProperty.prototype.getSchemaFor = function (object) {
            switch (this.propertyType) {
                case void 0:
                    return new DigestedObjectSchema();
                case QueryPropertyType.EMPTY:
                case QueryPropertyType.PARTIAL:
                    return this.__createSchema();
                default:
                    return ObjectSchemaDigester._combineSchemas([
                        this.queryContainer.context.registry.getSchemaFor(object),
                        this.__createSchema(),
                    ]);
            }
        };
        QueryProperty.prototype.__createSchema = function () {
            var schema = new DigestedObjectSchema();
            this.subProperties.forEach(function (property) {
                schema.properties.set(property.name, property.definition);
            });
            return schema;
        };
        QueryProperty.prototype._getSearchSchema = function () {
            if (this._searchSchema)
                return this._searchSchema;
            return this._searchSchema = this.queryContainer.getGeneralSchema();
        };
        return QueryProperty;
    }());

    var QueryContainerProperty = (function (_super) {
        __extends(QueryContainerProperty, _super);
        function QueryContainerProperty(data) {
            var _this = _super.call(this, {
                queryContainer: data.queryContainer,
                name: data.containerPropertyType,
                definition: new DigestedObjectSchemaProperty(),
                optional: false,
                propertyType: QueryPropertyType.PARTIAL,
            }) || this;
            _this.containerIRI = data.containerIRI;
            _this.containerPropertyType = data.containerPropertyType;
            return _this;
        }
        QueryContainerProperty.prototype.__createSelfPattern = function () {
            var subSelect = new SubSelectToken("DISTINCT")
                .addVariable(this.variable);
            switch (this.containerPropertyType) {
                case QueryContainerPropertyType.CHILD:
                    subSelect.addPattern(this.__createChildSelfPattern());
                    break;
                case QueryContainerPropertyType.MEMBER:
                    subSelect.addPattern.apply(subSelect, this.__createMemberSelfPattern());
                    break;
                default:
                    throw new IllegalStateError("Invalid container type.");
            }
            var valuedPatterns = this.__getValuedPatterns();
            if (valuedPatterns)
                subSelect.addPattern.apply(subSelect, valuedPatterns);
            this.__addOrderTo(subSelect);
            this.__addLimitTo(subSelect);
            this.__addOffsetTo(subSelect);
            return subSelect;
        };
        QueryContainerProperty.prototype.__createChildSelfPattern = function () {
            return new SubjectToken(this.containerIRI)
                .addProperty(new PropertyToken(this.queryContainer.compactIRI(LDP.contains))
                .addObject(this.identifier));
        };
        QueryContainerProperty.prototype.__createMemberSelfPattern = function () {
            var membershipResource = this.queryContainer.getVariable("membershipResource");
            var hasMemberRelation = this.queryContainer.getVariable("hasMemberRelation");
            var memberRelations = new SubSelectToken()
                .addVariable(membershipResource, hasMemberRelation)
                .addPattern(new SubjectToken(this.containerIRI)
                .addProperty(new PropertyToken(this.queryContainer.compactIRI(LDP.membershipResource))
                .addObject(membershipResource))
                .addProperty(new PropertyToken(this.queryContainer.compactIRI(LDP.hasMemberRelation))
                .addObject(hasMemberRelation)));
            var memberSelection = new SubjectToken(membershipResource)
                .addProperty(new PropertyToken(hasMemberRelation)
                .addObject(this.identifier));
            return [memberRelations, memberSelection];
        };
        QueryContainerProperty.prototype.__addLimitTo = function (subSelect) {
            if (this._limit === void 0)
                return;
            subSelect.addModifier(new LimitToken(this._limit));
        };
        QueryContainerProperty.prototype.__addOffsetTo = function (subSelect) {
            if (this._offset === void 0)
                return;
            subSelect.addModifier(new OffsetToken(this._offset));
        };
        QueryContainerProperty.prototype.__addOrderTo = function (subSelect) {
            if (!this.order)
                return;
            var targetProperty = this.getProperty(this.order.path, { create: true });
            if (!targetProperty)
                throw new IllegalArgumentError("Property \"" + this.order.path + "\" hasn't been defined.");
            var identifier = targetProperty.identifier;
            var constraint = identifier.token === "variable"
                ? identifier
                : "( " + identifier + " )";
            subSelect.addModifier(new OrderToken(constraint, this.order.flow));
            var orderPatterns = this.__createSubPatternsFrom(targetProperty);
            orderPatterns
                .filter(function (pattern) {
                if (pattern.token !== "subject")
                    return true;
                var targetSubject = subSelect
                    .where.groupPattern.patterns
                    .find(function (selectPattern) {
                    if (selectPattern.token !== "subject")
                        return false;
                    return selectPattern.subject === pattern.subject;
                });
                if (!targetSubject)
                    return true;
                pattern.properties.forEach(function (property) {
                    var targetPredicate = targetSubject
                        .properties
                        .find(function (selectProperty) {
                        return property.toString() === selectProperty.toString();
                    });
                    if (!targetPredicate)
                        targetSubject.addProperty(property);
                    property.objects.forEach(function (object) {
                        var targetObject = targetPredicate
                            .objects
                            .find(function (selectObject) {
                            return selectObject.toString() === object.toString();
                        });
                        if (!targetObject)
                            targetPredicate.addObject(object);
                    });
                });
            })
                .forEach(function (pattern) {
                subSelect.addPattern(pattern);
            });
        };
        QueryContainerProperty.prototype.__createSubPatternsFrom = function (targetProperty) {
            var matchPatterns = [];
            while (targetProperty !== this) {
                var subTargetPattern = targetProperty.getSelfPattern();
                if (subTargetPattern.token !== "optional") {
                    matchPatterns.unshift(subTargetPattern);
                }
                else {
                    matchPatterns = [
                        subTargetPattern
                            .addPattern.apply(subTargetPattern, matchPatterns),
                    ];
                }
                if (!targetProperty.parent)
                    break;
                targetProperty = targetProperty.parent;
            }
            return matchPatterns;
        };
        QueryContainerProperty.prototype.__addTypesTo = function (pattern) { };
        QueryContainerProperty.prototype.setOrder = function (order) {
            this.order = order;
        };
        QueryContainerProperty.prototype.setLimit = function (limit) {
            this._limit = limit;
        };
        QueryContainerProperty.prototype.setOffset = function (offset) {
            this._offset = offset;
        };
        return QueryContainerProperty;
    }(QueryProperty));

    var QueryRootProperty = (function (_super) {
        __extends(QueryRootProperty, _super);
        function QueryRootProperty(data) {
            return _super.call(this, {
                queryContainer: data.queryContainer,
                name: "document",
                definition: new DigestedObjectSchemaProperty(),
                optional: false,
                propertyType: QueryPropertyType.PARTIAL,
                values: data.values,
            }) || this;
        }
        QueryRootProperty.prototype.__createSelfPattern = function () {
            return;
        };
        return QueryRootProperty;
    }(QueryProperty));

    var QueryVariable = (function (_super) {
        __extends(QueryVariable, _super);
        function QueryVariable(name, index) {
            var _this = _super.call(this, name
                .replace(/[.]/g, "__")
                .replace(/[^0-9A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/g, "_")) || this;
            _this.index = index;
            return _this;
        }
        QueryVariable.prototype.toString = function () {
            return "?_" + this.index;
        };
        return QueryVariable;
    }(VariableToken));

    var QueryContainer = (function (_super) {
        __extends(QueryContainer, _super);
        function QueryContainer(context, propertyData) {
            var _this = this;
            var schema = context.getObjectSchema();
            _this = _super.call(this, {
                iriResolver: __createIRIResolver(schema),
                targetToken: void 0,
                fluentPathFactory: FluentPath.createFrom,
                deniableFluentPathFactory: DeniableFluentPath.createFrom,
            }) || this;
            _this.context = context;
            _this._generalSchema = schema;
            _this._prefixesTuples = Array.from(schema.prefixes);
            _this._variablesCounter = 0;
            _this._variablesMap = new Map();
            if ("uris" in propertyData) {
                var values = propertyData.uris.map(_this.compactIRI, _this);
                _this._queryProperty = new QueryRootProperty({
                    queryContainer: _this,
                    values: values,
                });
            }
            else {
                var iri = _this.compactIRI(propertyData.uri);
                _this._queryProperty = new QueryContainerProperty({
                    queryContainer: _this,
                    containerIRI: iri,
                    containerPropertyType: propertyData.containerPropertyType,
                });
            }
            return _this;
        }
        QueryContainer.prototype.getVariable = function (name) {
            if (this._variablesMap.has(name))
                return this._variablesMap.get(name);
            var variable = new QueryVariable(name, this._variablesCounter++);
            this._variablesMap.set(name, variable);
            return variable;
        };
        QueryContainer.prototype.compactIRI = function (iri) {
            var compactedIRI = this.__getCompactedIRI(iri);
            return this.iriResolver.resolve(compactedIRI);
        };
        QueryContainer.prototype.__getCompactedIRI = function (iri) {
            if (isPrefixed(iri))
                return iri;
            var prefix = this._prefixesTuples
                .find(function (_a) {
                var x = _a[1];
                return iri.startsWith(x);
            });
            if (!prefix)
                return iri;
            var namespace = prefix[0], prefixIRI = prefix[1];
            return namespace + ":" + iri.substr(prefixIRI.length);
        };
        QueryContainer.prototype.getPrologues = function () {
            return this._prefixesTuples
                .filter(this.__isUsedPrefix, this)
                .map(__createPrefixToken);
        };
        QueryContainer.prototype.__isUsedPrefix = function (_a) {
            var namespace = _a[0];
            return !!this.iriResolver.prefixes.get(namespace);
        };
        QueryContainer.prototype.digestProperty = function (name, definition) {
            return ObjectSchemaDigester
                .digestProperty(name, definition, this._generalSchema);
        };
        QueryContainer.prototype.getGeneralSchema = function () {
            return ObjectSchemaDigester
                .combineDigestedObjectSchemas([this._generalSchema]);
        };
        QueryContainer.prototype.serializeLiteral = function (type, value) {
            if (!this.context.jsonldConverter.literalSerializers.has(type))
                throw new IllegalArgumentError("Type \"" + type + "\" hasn't a defined serializer.");
            return this.context.jsonldConverter
                .literalSerializers
                .get(type)
                .serialize(value);
        };
        return QueryContainer;
    }(FluentPathContainer));
    function __createIRIResolver(schema) {
        var iriResolver = new IRIResolver(void 0, schema.vocab);
        Array.from(schema.prefixes.keys())
            .forEach(function (key) { return iriResolver.prefixes.set(key, false); });
        return iriResolver;
    }
    function __createPrefixToken(_a) {
        var namespace = _a[0], iri = _a[1];
        return new PrefixToken(namespace, new IRIRefToken(iri));
    }

    var QueryObject = (function () {
        function QueryObject(queryContainer, id) {
            this._queryContainer = queryContainer;
            this._resource = isBNodeLabel(id)
                ? new BlankNodeToken(id)
                : this._queryContainer.compactIRI(id);
        }
        QueryObject.prototype.getToken = function () {
            return this._resource;
        };
        QueryObject.prototype.toString = function () {
            return "" + this._resource;
        };
        return QueryObject;
    }());

    var QueryValue = (function () {
        function QueryValue(queryContainer, value) {
            this._value = value;
            this._queryContainer = queryContainer;
            if (isDate(value)) {
                this.withType(XSD.dateTime);
            }
            else {
                this._literal = new LiteralToken(value);
            }
        }
        QueryValue.prototype.withType = function (type) {
            if (XSD.hasOwnProperty(type))
                type = XSD[type];
            var value = this._queryContainer.serializeLiteral(type, this._value);
            var typeToken = this._queryContainer.compactIRI(type);
            this._literal = new RDFLiteralToken(value, typeToken);
            return this;
        };
        QueryValue.prototype.withLanguage = function (language) {
            var value = this._queryContainer.serializeLiteral(XSD.string, this._value);
            var languageToken = new LanguageToken(language);
            this._literal = new RDFLiteralToken(value, languageToken);
            return this;
        };
        QueryValue.prototype.getToken = function () {
            return this._literal;
        };
        QueryValue.prototype.toString = function () {
            return "" + this._literal;
        };
        return QueryValue;
    }());

    var QueryDocumentBuilder = (function () {
        function QueryDocumentBuilder(queryContainer, queryProperty) {
            this.inherit = QueryDocumentBuilder.INHERIT;
            this.all = QueryDocumentBuilder.ALL;
            this._queryContainer = queryContainer;
            this._queryProperty = queryProperty;
        }
        QueryDocumentBuilder.prototype.property = function (name) {
            var parent = this._queryProperty;
            while (parent) {
                var property = parent.getProperty(name, { create: true });
                if (property)
                    return property.identifier;
                parent = parent.parent;
            }
            throw new IllegalArgumentError("The property \"" + name + "\" was not declared.");
        };
        QueryDocumentBuilder.prototype.value = function (value) {
            return new QueryValue(this._queryContainer, value);
        };
        QueryDocumentBuilder.prototype.object = function (object) {
            var id = Pointer.getID(object);
            return new QueryObject(this._queryContainer, id);
        };
        QueryDocumentBuilder.prototype.withType = function (type) {
            if (this._queryProperty.hasProperties())
                throw new IllegalStateError("Types must be specified before the properties.");
            this._queryProperty.addType(type);
            return this;
        };
        QueryDocumentBuilder.prototype.properties = function (propertiesSchema) {
            if (propertiesSchema === QueryDocumentBuilder.ALL) {
                this._queryProperty.setType(QueryPropertyType.ALL);
                return this;
            }
            if (propertiesSchema === QueryDocumentBuilder.FULL) {
                this._queryProperty.setType(QueryPropertyType.FULL);
                return this;
            }
            this._queryProperty.setType(QueryPropertyType.PARTIAL);
            for (var propertyName in propertiesSchema) {
                var queryPropertySchema = propertiesSchema[propertyName];
                var querySchemaProperty = isObject(queryPropertySchema)
                    ? queryPropertySchema : { "@id": queryPropertySchema };
                var property = this._queryProperty
                    .addProperty(propertyName, querySchemaProperty);
                var subQuery = querySchemaProperty.query;
                if (!subQuery)
                    continue;
                var builder = new SubQueryDocumentsBuilder(this._queryContainer, property);
                if (builder !== subQuery.call(void 0, builder))
                    throw new IllegalArgumentError("The provided query builder was not returned");
            }
            return this;
        };
        QueryDocumentBuilder.ALL = Object.freeze({});
        QueryDocumentBuilder.FULL = Object.freeze({});
        QueryDocumentBuilder.INHERIT = Object.freeze({});
        return QueryDocumentBuilder;
    }());
    var SubQueryDocumentsBuilder = (function (_super) {
        __extends(SubQueryDocumentsBuilder, _super);
        function SubQueryDocumentsBuilder() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SubQueryDocumentsBuilder.prototype.filter = function (constraint) {
            this._queryProperty
                .addFilter(constraint);
            return this;
        };
        SubQueryDocumentsBuilder.prototype.values = function () {
            var _this = this;
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            var tokens = values
                .map(function (value) {
                var token = value.getToken();
                if (token.token === "blankNode")
                    throw new IllegalArgumentError("Cannot assign blank nodes (\"" + token.label + "\").");
                if (_this._queryProperty.definition.literal) {
                    if (token.token !== "literal")
                        throw new IllegalArgumentError("\"" + token + "\" is not a literal value.");
                }
                if (_this._queryProperty.definition.pointerType !== null) {
                    if (token.token === "literal")
                        throw new IllegalArgumentError("\"" + token + "\" is not a resource value.");
                }
                return token;
            });
            this._queryProperty.addValues(tokens);
            this._queryProperty.setObligatory({ inheritParents: true });
            return this;
        };
        return SubQueryDocumentsBuilder;
    }(QueryDocumentBuilder));

    var QueryDocumentsBuilder = (function (_super) {
        __extends(QueryDocumentsBuilder, _super);
        function QueryDocumentsBuilder(queryContainer, queryProperty) {
            return _super.call(this, queryContainer, queryProperty) || this;
        }
        QueryDocumentsBuilder.prototype.orderBy = function (property, flow) {
            this._queryProperty.setOrder({
                path: property,
                flow: parseFlowString(flow),
            });
            return this;
        };
        QueryDocumentsBuilder.prototype.limit = function (limit) {
            this._queryProperty.setLimit(limit);
            return this;
        };
        QueryDocumentsBuilder.prototype.offset = function (offset) {
            this._queryProperty.setOffset(offset);
            return this;
        };
        return QueryDocumentsBuilder;
    }(SubQueryDocumentsBuilder));
    function parseFlowString(flow) {
        if (flow === void 0)
            return;
        var upperCase = flow
            .toUpperCase();
        switch (upperCase) {
            case "ASC":
            case "DESC":
                return upperCase;
            case "ASCENDING":
            case "DESCENDING":
                return upperCase
                    .slice(0, -6);
            default:
                throw new IllegalArgumentError("Invalid flow order.");
        }
    }

    var VolatileResource = {
        TYPE: C.VolatileResource,
        is: function (value) {
            return Resource.is(value)
                && value.$hasType(VolatileResource.TYPE);
        },
        create: function (data) {
            var copy = Object.assign({}, data);
            return VolatileResource.createFrom(copy);
        },
        createFrom: function (object) {
            var resource = Resource.createFrom(object);
            resource.$addType(VolatileResource.TYPE);
            return resource;
        },
    };

    var SCHEMA$1 = {
        "targets": {
            "@id": C.target,
            "@type": "@id",
            "@container": "@set",
        },
    };
    var QueryMetadata = {
        TYPE: C.QueryMetadata,
        SCHEMA: SCHEMA$1,
        is: function (value) {
            return VolatileResource.is(value)
                && value.$hasType(QueryMetadata.TYPE);
        },
    };

    var QueryableProperty = (function () {
        function QueryableProperty(data) {
            this.definition = data.definition;
            this.pathBuilderFn = data.pathBuilderFn;
            this.propertyType = data.propertyType;
            this.optional = data.optional;
            this.subProperties = new Map();
            this.values = data.values
                ? data.values
                : [];
        }
        QueryableProperty.prototype.setType = function (type) {
            this.propertyType = _getBestType(this.propertyType, type);
        };
        QueryableProperty.prototype.setProperty = function (propertyName, property) {
            this.subProperties.set(propertyName, property);
        };
        QueryableProperty.prototype.getProperty = function (propertyName, data) {
            if (!this.subProperties.has(propertyName)) {
                if (!data)
                    throw new Error("Property \"" + propertyName + "\" doesn't exists.");
                var property = new QueryableProperty(data);
                this.subProperties.set(propertyName, property);
                return property;
            }
            else {
                var property = this.subProperties.get(propertyName);
                if (data)
                    property
                        .mergeData(propertyName, data);
                return property;
            }
        };
        QueryableProperty.prototype.mergeData = function (propertyName, data) {
            if (this === data)
                return;
            this.setType(data.propertyType);
            this.__mergeDefinition(propertyName, data.definition);
        };
        QueryableProperty.prototype.__mergeDefinition = function (propertyName, newDefinition) {
            for (var key in newDefinition) {
                var oldValue = this.definition[key];
                var newValue = newDefinition[key];
                if (oldValue === null)
                    this.definition[key] = newValue;
                if (newValue !== oldValue) {
                    throw new IllegalArgumentError("Property \"" + propertyName + "\" has different \"" + key + "\": \"" + oldValue + "\", \"" + newValue + "\".");
                }
            }
        };
        QueryableProperty.prototype.getSchema = function () {
            var schema = new DigestedObjectSchema();
            this.subProperties.forEach(function (property, propertyName) {
                schema.properties.set(propertyName, property.definition);
            });
            return schema;
        };
        return QueryableProperty;
    }());

    var QueryableRootProperty = (function (_super) {
        __extends(QueryableRootProperty, _super);
        function QueryableRootProperty(_a) {
            var uri = _a.uri, propertyType = _a.propertyType;
            return _super.call(this, {
                definition: new DigestedObjectSchemaProperty(),
                propertyType: propertyType,
                optional: false,
                values: [new IRIRefToken(uri)],
            }) || this;
        }
        QueryableRootProperty.prototype.__mergeDefinition = function (propertyName, newDefinition) {
            return;
        };
        return QueryableRootProperty;
    }(QueryableProperty));

    var QueryResultCompacter = (function () {
        function QueryResultCompacter(registry, queryContainer) {
            this.registry = registry;
            this.queryContainer = queryContainer;
        }
        Object.defineProperty(QueryResultCompacter.prototype, "jsonldConverter", {
            get: function () {
                return this.queryContainer.context.jsonldConverter;
            },
            enumerable: true,
            configurable: true
        });
        QueryResultCompacter.prototype.compactDocuments = function (rdfDocuments, targetDocuments) {
            var _this = this;
            if (!targetDocuments)
                targetDocuments = rdfDocuments.map(function (x) { return x["@id"]; });
            var compactionMap = new Map();
            rdfDocuments.forEach(function (rdfDocument) {
                var document = _this.registry.getPointer(rdfDocument["@id"], true);
                if (!document.$_queryableMetadata) {
                    document.$_queryableMetadata = new QueryableRootProperty({
                        uri: document.$id,
                        propertyType: QueryPropertyType.PARTIAL,
                    });
                }
                var previousFragments = new Set();
                document
                    .$getPointers(true)
                    .forEach(function (pointer) { return previousFragments.add(pointer.$id); });
                rdfDocument["@graph"].forEach(function (rdfNode) {
                    var nodeID = rdfNode["@id"];
                    var resource = nodeID !== rdfDocument["@id"]
                        ? document.$getPointer(nodeID, true)
                        : document;
                    compactionMap.set(nodeID, {
                        node: rdfNode,
                        document: document,
                        resource: resource,
                    });
                    previousFragments.delete(nodeID);
                });
                previousFragments
                    .forEach(function (pointer) { return document.$removePointer(pointer); });
            });
            targetDocuments.forEach(function (documentID) {
                var compactionNode = compactionMap.get(documentID);
                if (!compactionNode)
                    throw new IllegalArgumentError("Invalid data provided.");
                var queryProperty = _this.queryContainer._queryProperty;
                var metadataProperty = compactionNode.resource.$_queryableMetadata;
                _this.__processNode(compactionMap, compactionNode, queryProperty, metadataProperty);
            });
            compactionMap.forEach(function (_a) {
                var node = _a.node, resource = _a.resource, document = _a.document, isCompacted = _a.isCompacted;
                var _b;
                if (!isCompacted) {
                    var targetNode = __assign({}, node, (_b = {}, _b[C.document] = undefined, _b[C.checksum] = undefined, _b));
                    var targetSchema = _this.queryContainer.context.registry.getSchemaFor(targetNode);
                    _this.jsonldConverter.update(resource, targetNode, targetSchema, document);
                    resource.$_queryableMetadata = void 0;
                }
                _this.registry.decorate(resource);
            });
            rdfDocuments
                .map(RDFNode.getID)
                .map(function (id) { return compactionMap.get(id); })
                .filter(_isExistingValue)
                .forEach(function (_a) {
                var resource = _a.resource, node = _a.node;
                resource.$_syncSnapshot();
                var rawValues = node[C.checksum];
                if (!rawValues || typeof rawValues === "string")
                    return;
                var eTag = RDFNode.getPropertyLiterals(rawValues, XSD.string)[0];
                if (!eTag)
                    return;
                resource.$eTag = "\"" + eTag + "\"";
                resource.$_resolved = true;
            });
            return targetDocuments.map(function (id) {
                return compactionMap
                    .get(id)
                    .resource;
            });
        };
        QueryResultCompacter.prototype.__processNode = function (compactionMap, compactionNode, queryProperty, metadataProperty) {
            var _this = this;
            var _a;
            var node = compactionNode.node, document = compactionNode.document, resource = compactionNode.resource;
            compactionNode.isCompacted = true;
            var targetSchema = queryProperty.getSchemaFor(node);
            var pointerLibrary = __createPointerLibrary(compactionMap, document);
            var targetNode = __assign({}, node, (_a = {}, _a[C.document] = undefined, _a[C.checksum] = undefined, _a));
            this.jsonldConverter
                .update(resource, targetNode, targetSchema, pointerLibrary, !queryProperty._isComplete());
            if (!queryProperty._isPartial()) {
                resource.$_queryableMetadata = void 0;
                return;
            }
            queryProperty.subProperties.forEach(function (subQueryProperty, propertyName) {
                if (resource.hasOwnProperty(propertyName) && subQueryProperty.pathBuilderFn) {
                    Object.defineProperty(resource, propertyName, {
                        enumerable: false,
                        configurable: true,
                        writable: true,
                    });
                }
                var subMetadataProperty = metadataProperty
                    .getProperty(propertyName, subQueryProperty);
                if (!resource.hasOwnProperty(propertyName))
                    return;
                if (subQueryProperty.propertyType === void 0)
                    return;
                var values = Array.isArray(resource[propertyName])
                    ? resource[propertyName]
                    : [resource[propertyName]];
                values.forEach(function (value) {
                    if (!Pointer.is(value))
                        return;
                    var subCompactionNode = compactionMap.get(value.$id);
                    if (!subCompactionNode)
                        throw new IllegalArgumentError("Invalid data provided.");
                    if (subCompactionNode.resource.$_queryableMetadata) {
                        subCompactionNode.resource.$_queryableMetadata
                            .mergeData(propertyName, subMetadataProperty);
                        if (subCompactionNode.document === document && !subCompactionNode.isCompacted) {
                            metadataProperty
                                .setProperty(propertyName, subCompactionNode.resource.$_queryableMetadata);
                        }
                        else {
                            subMetadataProperty.propertyType = void 0;
                        }
                    }
                    else {
                        if (subCompactionNode.document === document) {
                            subCompactionNode.resource.$_queryableMetadata = subMetadataProperty;
                        }
                        else {
                            subCompactionNode.resource.$_queryableMetadata = new QueryableProperty({
                                propertyType: subMetadataProperty.propertyType,
                                optional: subMetadataProperty.optional,
                                definition: Object.assign(new DigestedObjectSchemaProperty(), subMetadataProperty.definition, {
                                    uri: null,
                                }),
                            });
                            subMetadataProperty.propertyType = void 0;
                        }
                    }
                    _this.__processNode(compactionMap, subCompactionNode, subQueryProperty, subCompactionNode.resource.$_queryableMetadata);
                });
            });
        };
        return QueryResultCompacter;
    }());
    function __createPointerLibrary(compactionMap, document) {
        return {
            hasPointer: function (id) {
                if (compactionMap.has(id))
                    return true;
                return document.$hasPointer(id);
            },
            getPointer: function (id) {
                if (compactionMap.has(id))
                    return compactionMap
                        .get(id)
                        .resource;
                return document
                    .$getPointer(id);
            },
        };
    }

    var StringParser = (function () {
        function StringParser() {
        }
        StringParser.prototype.parse = function (body) {
            return new Promise(function (resolve) { return resolve(body); });
        };
        return StringParser;
    }());

    var SPARQLRawResultsParser = (function (_super) {
        __extends(SPARQLRawResultsParser, _super);
        function SPARQLRawResultsParser() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SPARQLRawResultsParser.prototype.parse = function (input) {
            return _super.prototype.parse.call(this, input).then(function (object) { return object; });
        };
        return SPARQLRawResultsParser;
    }(JSONParser));

    var SPARQLService = (function () {
        function SPARQLService() {
        }
        SPARQLService.executeRawASKQuery = function (url, askQuery, options) {
            if (options === void 0) { options = {}; }
            options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
            RequestUtils.setAcceptHeader("application/sparql-results+json", options);
            RequestUtils.setContentTypeHeader("application/sparql-query", options);
            return RequestService.post(url, askQuery, options, SPARQLService.RESULTS_PARSER);
        };
        SPARQLService.executeASKQuery = function (url, askQuery, options) {
            if (options === void 0) { options = {}; }
            return SPARQLService
                .executeRawASKQuery(url, askQuery, options)
                .then(function (_a) {
                var rawResults = _a[0], response = _a[1];
                return [rawResults.boolean, response];
            });
        };
        SPARQLService.executeRawSELECTQuery = function (url, selectQuery, options) {
            if (options === void 0) { options = {}; }
            options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
            RequestUtils.setAcceptHeader("application/sparql-results+json", options);
            RequestUtils.setContentTypeHeader("application/sparql-query", options);
            return RequestService.post(url, selectQuery, options, SPARQLService.RESULTS_PARSER);
        };
        SPARQLService.executeSELECTQuery = function (url, selectQuery, pointerLibrary, options) {
            if (options === void 0) { options = {}; }
            return SPARQLService
                .executeRawSELECTQuery(url, selectQuery, options)
                .then(function (_a) {
                var rawResults = _a[0], response = _a[1];
                var rawBindings = rawResults.results.bindings;
                var bindings = [];
                for (var _i = 0, rawBindings_1 = rawBindings; _i < rawBindings_1.length; _i++) {
                    var bindingColumn = rawBindings_1[_i];
                    var binding = {};
                    for (var bindingRow in bindingColumn) {
                        var bindingCell = bindingColumn[bindingRow];
                        binding[bindingRow] = SPARQLService.__parseRawBindingProperty(bindingCell, pointerLibrary);
                    }
                    bindings.push(binding);
                }
                var results = {
                    vars: rawResults.head.vars,
                    bindings: bindings,
                };
                return [results, response];
            });
        };
        SPARQLService.executeRawCONSTRUCTQuery = function (url, constructQuery, options) {
            if (options === void 0) { options = {}; }
            options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
            RequestUtils.setAcceptHeader("application/ld+json", options);
            RequestUtils.setContentTypeHeader("application/sparql-query", options);
            return RequestService.post(url, constructQuery, options, SPARQLService.STRING_PARSER);
        };
        SPARQLService.executeRawDESCRIBEQuery = function (url, describeQuery, options) {
            if (options === void 0) { options = {}; }
            options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
            RequestUtils.setAcceptHeader("application/ld+json", options);
            RequestUtils.setContentTypeHeader("application/sparql-query", options);
            return RequestService.post(url, describeQuery, options, SPARQLService.STRING_PARSER);
        };
        SPARQLService.executeUPDATE = function (url, updateQuery, options) {
            if (options === void 0) { options = {}; }
            options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
            RequestUtils.setAcceptHeader("application/ld+json", options);
            RequestUtils.setContentTypeHeader("application/sparql-update", options);
            return RequestService.post(url, updateQuery, options);
        };
        SPARQLService.__parseRawBindingProperty = function (rawBindingProperty, pointerLibrary) {
            switch (rawBindingProperty.type) {
                case "uri":
                    return _getPointer(pointerLibrary, rawBindingProperty.value);
                case "bnode":
                    throw new NotImplementedError("BNodes cannot be queried directly");
                case "literal":
                    if ("datatype" in rawBindingProperty) {
                        return RDFLiteral.parse(rawBindingProperty.value, rawBindingProperty.datatype);
                    }
                    else {
                        return RDFLiteral.parse(rawBindingProperty.value);
                    }
                default:
                    throw new IllegalArgumentError("The bindingProperty has an unsupported type");
            }
        };
        SPARQLService.DEFAULT_OPTIONS = {};
        SPARQLService.RESULTS_PARSER = new SPARQLRawResultsParser();
        SPARQLService.STRING_PARSER = new StringParser();
        return SPARQLService;
    }());

    var SCHEMA$2 = {
        "targetMembers": {
            "@id": C.targetMember,
            "@type": "@id",
            "@container": "@set",
        },
    };
    var AddMemberAction = {
        TYPE: C.AddMemberAction,
        SCHEMA: SCHEMA$2,
        is: function (value) {
            return Resource.is(value)
                && value.$hasType(AddMemberAction.TYPE);
        },
        create: function (data) {
            var copy = Object.assign({}, data);
            return AddMemberAction.createFrom(copy);
        },
        createFrom: function (object) {
            var resource = Resource.createFrom(object);
            resource.$addType(AddMemberAction.TYPE);
            return resource;
        },
    };

    var SCHEMA$3 = {
        "targetMembers": {
            "@id": C.targetMember,
            "@type": "@id",
            "@container": "@set",
        },
    };
    var RemoveMemberAction = {
        TYPE: C.RemoveMemberAction,
        SCHEMA: SCHEMA$3,
        is: function (value) {
            return Resource.is(value)
                && value.$hasType(RemoveMemberAction.TYPE);
        },
        create: function (data) {
            var copy = Object.assign({}, data);
            return RemoveMemberAction.createFrom(copy);
        },
        createFrom: function (object) {
            var resource = Resource.createFrom(object);
            resource.$addType(RemoveMemberAction.TYPE);
            return resource;
        },
    };

    var SCHEMA$4 = {
        "documentsMetadata": {
            "@id": C.documentMetadata,
            "@type": "@id",
            "@container": "@set",
        },
    };
    var ResponseMetadata = {
        TYPE: C.ResponseMetadata,
        SCHEMA: SCHEMA$4,
        is: function (object) {
            return VolatileResource.is(object)
                && object.$hasType(ResponseMetadata.TYPE);
        },
    };

    var LDPatchToken = (function () {
        function LDPatchToken() {
            this.token = "ldpatch";
            this.prologues = [];
            this.statements = [];
        }
        LDPatchToken.prototype.toString = function () {
            var tokens = this.prologues.concat(this.statements);
            return tokens.join(" ");
        };
        return LDPatchToken;
    }());
    var PrefixToken$1 = (function () {
        function PrefixToken(namespace, iri) {
            this.token = "prefix";
            this.namespace = namespace;
            this.iri = iri;
        }
        PrefixToken.prototype.toString = function () {
            return "@prefix " + this.namespace + ": " + this.iri + ".";
        };
        return PrefixToken;
    }());
    var AddToken = (function () {
        function AddToken() {
            this.token = "add";
            this.triples = [];
        }
        AddToken.prototype.toString = function () {
            return "Add { " + this.triples.join(". ") + ". }.";
        };
        return AddToken;
    }());
    var DeleteToken = (function () {
        function DeleteToken() {
            this.token = "delete";
            this.triples = [];
        }
        DeleteToken.prototype.toString = function () {
            return "Delete { " + this.triples.join(". ") + ". }.";
        };
        return DeleteToken;
    }());
    var UpdateListToken = (function () {
        function UpdateListToken(subject, predicate, slice, collection) {
            this.token = "updateList";
            this.subject = subject;
            this.predicate = predicate;
            this.slice = slice;
            this.collection = collection;
        }
        UpdateListToken.prototype.toString = function () {
            return "UpdateList " + this.subject + " " + this.predicate + " " + this.slice + " " + this.collection + ".";
        };
        return UpdateListToken;
    }());
    var SliceToken = (function () {
        function SliceToken(minIndex, maxIndex) {
            this.token = "slice";
            if (isNumber(minIndex))
                this.minIndex = minIndex;
            if (isNumber(maxIndex))
                this.maxIndex = maxIndex;
        }
        SliceToken.prototype.toString = function () {
            var buffer = "..";
            if (this.minIndex !== void 0)
                buffer = this.minIndex + buffer;
            if (this.maxIndex !== void 0)
                buffer = buffer + this.maxIndex;
            return buffer;
        };
        return SliceToken;
    }());

    var typesDefinition = new DigestedObjectSchemaProperty();
    typesDefinition.literal = false;
    typesDefinition.pointerType = PointerType.ID;
    typesDefinition.containerType = ContainerType.SET;
    var DeltaCreator = (function () {
        function DeltaCreator(context) {
            this.prefixesMap = new Map();
            this.context = context;
            this.addToken = new AddToken();
            this.deleteToken = new DeleteToken();
            this.updateLists = [];
        }
        DeltaCreator.prototype.getPatch = function () {
            var _a;
            var patch = new LDPatchToken();
            this.prefixesMap.forEach(function (prefix) { return patch.prologues.push(prefix); });
            (_a = patch.statements).push.apply(_a, this.updateLists);
            if (this.addToken.triples.length)
                patch.statements.push(this.addToken);
            if (this.deleteToken.triples.length)
                patch.statements.push(this.deleteToken);
            return "" + patch;
        };
        DeltaCreator.prototype.addResource = function (id, previousResource, currentResource) {
            var _this = this;
            var _a;
            var schema = this.__getSchema(id, previousResource, currentResource);
            var resource = isBNodeLabel(id) ?
                new BlankNodeToken(id) : this.__compactIRI(schema, id);
            var updateLists = [];
            var addTriples = new SubjectToken(resource);
            var deleteTriples = new SubjectToken(resource);
            new Set([
                "types"
            ].concat(Object.keys(previousResource), Object.keys(currentResource))).forEach(function (propertyName) {
                if (propertyName === "$id")
                    return;
                var predicateURI = propertyName === "types" ?
                    "a" : _this._getPropertyIRI(schema, propertyName);
                var definition = predicateURI === "a" ?
                    typesDefinition : schema.getProperty(propertyName);
                var oldValue = previousResource[propertyName];
                var newValue = currentResource[propertyName];
                if (definition && definition.containerType === ContainerType.LIST && _isExistingValue(oldValue)) {
                    var listUpdates = [];
                    if (!_isExistingValue(newValue)) {
                        deleteTriples.addProperty(new PropertyToken(predicateURI).addObject(new CollectionToken()));
                        listUpdates.push({ slice: [0, void 0], objects: [] });
                    }
                    else {
                        definition.containerType = ContainerType.SET;
                        listUpdates.push.apply(listUpdates, __getListDelta(_this.__getObjects(oldValue, schema, definition), _this.__getObjects(newValue, schema, definition)));
                    }
                    if (!listUpdates.length)
                        return;
                    _this.__addPrefixFrom(predicateURI, schema);
                    listUpdates.forEach(function (updateDelta) {
                        var collection = new CollectionToken();
                        updateDelta.objects.forEach(function (object) {
                            collection.addObject(object);
                            _this.__addPrefixFrom(object, schema);
                        });
                        updateLists.push(new UpdateListToken(resource, predicateURI, updateDelta.objects.length ?
                            new SliceToken(updateDelta.slice[0], updateDelta.slice[0]) : new (SliceToken.bind.apply(SliceToken, [void 0].concat(updateDelta.slice)))(), collection));
                    });
                }
                else {
                    var oldObjects = _this.__getObjects(oldValue, schema, definition);
                    var newObjects = _this.__getObjects(newValue, schema, definition);
                    var setDelta = __getArrayDelta(oldObjects, newObjects);
                    var addValues = function (objects, triple) {
                        if (!objects.length)
                            return;
                        var property = new PropertyToken(predicateURI);
                        objects.forEach(function (object) {
                            property.addObject(object);
                            _this.__addPrefixFrom(object, schema);
                        });
                        triple.addProperty(property);
                    };
                    addValues(setDelta.toAdd, addTriples);
                    addValues(setDelta.toDelete, deleteTriples);
                }
            });
            (_a = this.updateLists).push.apply(_a, updateLists);
            updateLists.forEach(function (x) { return _this.__addPrefixFrom(x.predicate, schema); });
            if (addTriples.properties.length)
                this.addToken.triples.push(addTriples);
            addTriples.properties.forEach(function (x) { return _this.__addPrefixFrom(x.verb, schema); });
            if (deleteTriples.properties.length)
                this.deleteToken.triples.push(deleteTriples);
            deleteTriples.properties.forEach(function (x) { return _this.__addPrefixFrom(x.verb, schema); });
            this.__addPrefixFrom(resource, schema);
        };
        DeltaCreator.prototype.__getSchema = function ($id, previousResource, currentResource) {
            var typesSet = new Set();
            if ("types" in previousResource)
                previousResource
                    .types.forEach(typesSet.add, typesSet);
            if ("types" in currentResource)
                currentResource
                    .types.forEach(typesSet.add, typesSet);
            var mergedResource = { $id: $id, types: Array.from(typesSet) };
            var baseSchema = this.context.registry
                .getSchemaFor(mergedResource);
            var queryableProperty = previousResource.$_queryableMetadata || previousResource.$_queryableMetadata;
            if (!queryableProperty)
                return baseSchema;
            return ObjectSchemaDigester._combineSchemas([
                baseSchema,
                queryableProperty.getSchema(),
            ]);
        };
        DeltaCreator.prototype._getPropertyIRI = function (schema, propertyName) {
            var propertyDefinition = schema.properties.get(propertyName);
            var uri = propertyDefinition && propertyDefinition.uri ?
                propertyDefinition.uri :
                propertyName;
            return this.__compactIRI(schema, uri);
        };
        DeltaCreator.prototype.__getObjects = function (value, schema, definition) {
            var _a;
            var values = (Array.isArray(value) ?
                !definition || definition.containerType !== null ? value : value.slice(0, 1) :
                [value]).filter(_isExistingValue);
            if (definition && definition.containerType === ContainerType.LIST) {
                if (!_isExistingValue(value))
                    return [];
                var collection = new CollectionToken();
                (_a = collection.objects).push.apply(_a, this.__expandValues(values, schema, definition));
                return [collection];
            }
            if (definition && definition.containerType === ContainerType.LANGUAGE) {
                return this.__expandLanguageMap(values, schema);
            }
            return this.__expandValues(values, schema, definition);
        };
        DeltaCreator.prototype.__expandValues = function (values, schema, definition) {
            var _this = this;
            var areDefinedLiteral = definition && definition.literal !== null ? definition.literal : null;
            return values
                .map(function (value) {
                var isLiteral = areDefinedLiteral !== null ? areDefinedLiteral : !Pointer.is(value);
                if (isLiteral)
                    return _this.__expandLiteral(value, schema, definition);
                return _this.__expandPointer(value, schema);
            })
                .filter(_isExistingValue);
        };
        DeltaCreator.prototype.__expandLanguageMap = function (values, schema) {
            var _this = this;
            if (!values.length)
                return [];
            var languageMap = values[0];
            return Object
                .keys(languageMap)
                .map(function (key) {
                var value = languageMap[key];
                var tempDefinition = new DigestedObjectSchemaProperty();
                tempDefinition.language = key;
                tempDefinition.literalType = XSD.string;
                return _this.__expandLiteral(value, schema, tempDefinition);
            })
                .filter(_isExistingValue);
        };
        DeltaCreator.prototype.__expandPointer = function (value, schema) {
            var id = Pointer.is(value) ? value.$id : value;
            if (!isString(id))
                return null;
            return isBNodeLabel(id) ?
                new BlankNodeToken(id) :
                this.__compactIRI(schema, id);
        };
        DeltaCreator.prototype.__expandLiteral = function (value, schema, definition) {
            var type = definition && definition.literalType ?
                definition.literalType :
                _guessXSDType(value);
            if (type === null || !this.context.jsonldConverter.literalSerializers.has(type))
                return null;
            value = this.context.jsonldConverter.literalSerializers.get(type).serialize(value);
            if (type !== XSD.string)
                return new RDFLiteralToken(value, this.__compactIRI(schema, type));
            if (definition && typeof definition.language === "string")
                return new RDFLiteralToken(value, new LanguageToken(definition.language));
            return new LiteralToken(value);
        };
        DeltaCreator.prototype.__compactIRI = function (schema, iri) {
            iri = schema.resolveURI(iri, { vocab: true });
            var matchPrefix = Array.from(schema.prefixes.entries())
                .find(function (_a) {
                var prefixURI = _a[1];
                return iri.startsWith(prefixURI);
            });
            if (!matchPrefix)
                return new IRIRefToken(iri);
            return new PrefixedNameToken(matchPrefix[0], iri.substr(matchPrefix[1].length));
        };
        DeltaCreator.prototype.__addPrefixFrom = function (object, schema) {
            var _this = this;
            if (object === "a")
                return;
            if ("objects" in object)
                return object.objects.forEach(function (collectionObject) {
                    _this.__addPrefixFrom(collectionObject, schema);
                });
            if ("type" in object)
                return this.__addPrefixFrom(object.type, schema);
            if (object.token !== "prefixedName")
                return;
            var namespace = object.namespace;
            if (this.prefixesMap.has(namespace))
                return;
            var iri = schema.prefixes.get(namespace);
            this.prefixesMap.set(namespace, new PrefixToken$1(namespace, new IRIRefToken(iri)));
        };
        return DeltaCreator;
    }());
    function __getArrayDelta(oldValues, newValues) {
        var objectMapper = function (object) { return ["" + object, object]; };
        var toAdd = new Map(newValues.map(objectMapper));
        var toDelete = new Map(oldValues.map(objectMapper));
        toAdd.forEach(function (value, identifier) {
            if (!toDelete.has(identifier))
                return;
            toDelete.delete(identifier);
            toAdd.delete(identifier);
        });
        return {
            toAdd: Array.from(toAdd.values()),
            toDelete: Array.from(toDelete.values()),
        };
    }
    function __getListDelta(oldValues, newValues) {
        var nodeMapper = function (object, index) { return ({
            identifier: "" + object,
            object: object,
            index: index,
        }); };
        var oldPositions = oldValues.map(nodeMapper);
        var newPositions = newValues.map(nodeMapper);
        var addsSet = new Set(newPositions);
        var deletes = [];
        var offset = 0;
        var remnants = newPositions;
        oldPositions.forEach(function (oldNode) {
            var currentIndex = remnants.findIndex(function (newNode) { return newNode.identifier === oldNode.identifier; });
            if (currentIndex === -1) {
                oldNode.index -= offset++;
                deletes.push(oldNode);
            }
            else {
                addsSet.delete(remnants[currentIndex]);
                remnants = remnants.slice(currentIndex + 1);
            }
        });
        var updates = [];
        var last;
        deletes.forEach(function (node) {
            if (last && last.slice[0] === node.index) {
                last.slice = [last.slice[0], last.slice[1] + 1];
                return;
            }
            updates.push(last = {
                slice: [node.index, node.index + 1],
                objects: [],
            });
        });
        last = void 0;
        addsSet.forEach(function (node) {
            if (last && last.slice[1] === node.index) {
                last.slice = [last.slice[0], node.index + 1];
                last.objects.push(node.object);
                return;
            }
            updates.push(last = {
                slice: [node.index, node.index + 1],
                objects: [node.object],
            });
        });
        return updates;
    }

    var HTTPRepositoryTrait = {
        PROTOTYPE: {
            get: function (uri, requestOptions) {
                var _this = this;
                if (!this.context.registry.inScope(uri, true))
                    return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
                var url = this.context.getObjectSchema().resolveURI(uri, { base: true });
                if (this.context.registry.hasPointer(url, true)) {
                    var resource = this.context.registry.getPointer(url, true);
                    if (resource.$isResolved() && !(requestOptions && requestOptions.ensureLatest))
                        return Promise.resolve(resource);
                }
                return RequestService
                    .get(url, requestOptions)
                    .then(function (response) {
                    return _this._parseResponseData(response, url);
                });
            },
            resolve: function (resource, requestOptions) {
                return this.get(resource.$id, requestOptions);
            },
            exists: function (uri, requestOptions) {
                if (!this.context.registry.inScope(uri, true))
                    return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
                var url = this.context.getObjectSchema().resolveURI(uri, { base: true });
                return RequestService
                    .head(url, requestOptions)
                    .then(function () { return true; })
                    .catch(function (error) {
                    if ("response" in error && error.response.status === 404)
                        return false;
                    return Promise.reject(error);
                });
            },
            refresh: function (resource, requestOptions) {
                var _this = this;
                if (!ResolvablePointer.is(resource))
                    return Promise.reject(new IllegalArgumentError("The resource isn't a resolvable pointer."));
                if (!this.context.registry.inScope(resource.$id, true))
                    return Promise.reject(new IllegalArgumentError("\"" + resource.$id + "\" is out of scope."));
                var url = this.context.getObjectSchema().resolveURI(resource.$id, { base: true });
                return RequestService
                    .get(url, requestOptions)
                    .then(function (response) {
                    return _this._parseResponseData(response, url);
                })
                    .catch(function (error) {
                    if ("response" in error && error.response.status === 304)
                        return resource;
                    return Promise.reject(error);
                });
            },
            save: function (resource, requestOptions) {
                if (!ResolvablePointer.is(resource))
                    return Promise.reject(new IllegalArgumentError("The resource isn't a resolvable pointer."));
                if (!this.context.registry.inScope(resource.$id, true))
                    return Promise.reject(new IllegalArgumentError("\"" + resource.$id + "\" is out of scope."));
                var url = this.context.getObjectSchema().resolveURI(resource.$id, { base: true });
                if (!resource.$isDirty())
                    return Promise.resolve(resource);
                var body = JSON.stringify(resource);
                return RequestService
                    .put(url, body, requestOptions)
                    .then(function () { return resource; });
            },
            saveAndRefresh: function (resource, requestOptions) {
                var _this = this;
                return this
                    .save(resource, requestOptions)
                    .then(function () { return _this.refresh(resource, requestOptions); });
            },
            delete: function (uri, requestOptions) {
                var _this = this;
                if (!this.context.registry.inScope(uri, true))
                    return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
                var url = this.context.getObjectSchema().resolveURI(uri, { base: true });
                return RequestService
                    .delete(url, requestOptions)
                    .then(function () {
                    _this.context.registry.removePointer(url);
                });
            },
            _parseResponseData: function (response, id) {
                return __awaiter(this, void 0, void 0, function () {
                    var resolvable;
                    return __generator(this, function (_a) {
                        resolvable = this.context.registry
                            .getPointer(id, true);
                        resolvable.$eTag = response.getETag();
                        resolvable.$_resolved = true;
                        return [2, resolvable];
                    });
                });
            },
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(HTTPRepositoryTrait.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (HTTPRepositoryTrait.isDecorated(object))
                return object;
            var resource = ModelDecorator
                .decorateMultiple(object, GeneralRepository);
            return ModelDecorator
                .definePropertiesFrom(HTTPRepositoryTrait.PROTOTYPE, resource);
        },
    };

    var __JSONLD_PARSER = new JSONLDParser();
    function __setDefaultRequestOptions(requestOptions, interactionModel) {
        if (interactionModel)
            RequestUtils.setPreferredInteractionModel(interactionModel, requestOptions);
        RequestUtils.setAcceptHeader("application/ld+json", requestOptions);
    }
    function __getTargetID(id, response) {
        var locationHeader = response.getHeader("Content-Location");
        if (!locationHeader)
            return id;
        if (locationHeader.values.length !== 1)
            throw new BadResponseError("The response must contain one Content-Location header.", response);
        var locationString = "" + locationHeader;
        if (!locationString)
            throw new BadResponseError("The response doesn't contain a valid 'Content-Location' header.", response);
        return locationString;
    }
    function __getErrorResponseParserFnFrom(repository) {
        return _getErrorResponseParserFn(repository.context.registry);
    }
    function __changeNodesID(resource, map) {
        map
            .entries
            .forEach(function (_a) {
            var entryKey = _a.entryKey, entryValue = _a.entryValue;
            var node = resource
                .$getPointer(entryKey.$id, true);
            resource.$removePointer(entryKey.$id);
            node.$id = entryValue.$id;
            resource.$_addPointer(node);
        });
    }
    function __applyResponseMetadata(repository, freeNodes) {
        if (!freeNodes.length)
            return;
        var freeResources = FreeResources.parseFreeNodes(repository.context.registry, freeNodes);
        var responseMetadata = freeResources
            .getPointers(true)
            .find(ResponseMetadata.is);
        if (!responseMetadata)
            return;
        responseMetadata
            .documentsMetadata
            .forEach(function (metadata) { return __changeNodesID(metadata.relatedDocument, metadata.bNodesMap); });
    }
    function __applyResponseRepresentation(repository, resource, response) {
        if (response.status === 204 || !response.data)
            return resource;
        return __JSONLD_PARSER
            .parse(response.data)
            .then(function (expandedResult) {
            var freeNodes = RDFDocument.getFreeNodes(expandedResult);
            __applyResponseMetadata(repository, freeNodes);
            var preferenceHeader = response.getHeader("Preference-Applied");
            if (preferenceHeader === null || !preferenceHeader.hasValue("return=representation"))
                return resource;
            return repository._parseResponseData(response, resource.$id);
        });
    }
    function __isInvalidChild(child) {
        return ResolvablePointer.is(child);
    }
    function __isPersistingChild(object) {
        return object["__CarbonLDP_persisting__"];
    }
    function __createChild(repository, parentURI, requestOptions, child, slug) {
        if (ResolvablePointer.is(child))
            throw new IllegalArgumentError("Cannot persist an already resolvable pointer.");
        var transient = TransientDocument.is(child) ?
            child : TransientDocument.decorate(child);
        transient.$_normalize();
        transient.$registry = repository.context.registry;
        var body = JSON.stringify(transient);
        if (!!slug)
            RequestUtils.setSlug(slug, requestOptions);
        Object.defineProperty(transient, "__CarbonLDP_persisting__", { configurable: true, value: true });
        return RequestService
            .post(parentURI, body, requestOptions)
            .then(function (response) {
            delete transient["__CarbonLDP_persisting__"];
            var locationHeader = response.getHeader("Location");
            if (locationHeader === null || locationHeader.values.length < 1)
                throw new BadResponseError("The response is missing a Location header.", response);
            if (locationHeader.values.length !== 1)
                throw new BadResponseError("The response contains more than one Location header.", response);
            transient.$id = locationHeader.values[0].toString();
            var document = repository.context.registry._addPointer(transient);
            document
                .$getFragments()
                .forEach(document.$__modelDecorator.decorate);
            return __applyResponseRepresentation(repository, document, response);
        })
            .catch(function (error) {
            delete transient["__CarbonLDP_persisting__"];
            return __getErrorResponseParserFnFrom(repository)(error);
        });
    }
    function __createChildren(retrievalType, repository, uri, children, slugsOrOptions, requestOptions) {
        if (!repository.context.registry.inScope(uri, true))
            return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
        var url = repository.context.getObjectSchema().resolveURI(uri, { base: true });
        requestOptions = RequestUtils.isOptions(slugsOrOptions) ?
            slugsOrOptions :
            requestOptions ? requestOptions : {};
        var slugs = isString(slugsOrOptions) || Array.isArray(slugsOrOptions) ?
            slugsOrOptions : null;
        __setDefaultRequestOptions(requestOptions, LDP.Container);
        RequestUtils.setPreferredRetrieval(retrievalType, requestOptions);
        RequestUtils.setContentTypeHeader("application/ld+json", requestOptions);
        if (!Array.isArray(children)) {
            if (__isInvalidChild(children))
                return Promise.reject(new IllegalArgumentError("The object is already a resolvable pointer."));
            if (__isPersistingChild(children))
                return Promise.reject(new IllegalArgumentError("The object is already being persisted."));
            return __createChild(repository, url, requestOptions, children, slugs ? slugs.toString() : undefined);
        }
        var invalidChild = children
            .findIndex(function (child) { return __isInvalidChild(child); });
        if (invalidChild !== -1)
            return Promise.reject(new IllegalArgumentError("The object in \"" + invalidChild + "\" is already a resolvable pointer."));
        var persistingChild = children
            .findIndex(function (child) { return __isPersistingChild(child); });
        if (persistingChild !== -1)
            return Promise.reject(new IllegalArgumentError("The object in \"" + persistingChild + "\" is already being persisted."));
        var promises = children.map(function (child, index) {
            var cloneOptions = RequestUtils.cloneOptions(requestOptions);
            var slug = slugs && index < slugs.length ? slugs[index] : void 0;
            return __createChild(repository, url, cloneOptions, child, slug);
        });
        return Promise.all(promises);
    }
    function __sendPatch(repository, document, requestOptions) {
        if (!ResolvablePointer.is(document))
            return Promise.reject(new IllegalArgumentError("The document isn't a resolvable pointer."));
        if (!repository.context.registry.inScope(document.$id))
            return Promise.reject(new IllegalArgumentError("\"" + document.$id + "\" is out of scope."));
        var url = repository.context.getObjectSchema().resolveURI(document.$id, { base: true });
        if (!document.$isDirty())
            return Promise.resolve(document);
        document.$_normalize();
        __setDefaultRequestOptions(requestOptions);
        RequestUtils.setContentTypeHeader("text/ldpatch", requestOptions);
        RequestUtils.setIfMatchHeader(document.$eTag, requestOptions);
        var deltaCreator = new DeltaCreator(repository.context);
        deltaCreator.addResource(document.$id, document.$_snapshot, document);
        document
            .$getPointers(true)
            .forEach(function (pointer) {
            deltaCreator.addResource(pointer.$id, pointer.$_snapshot, pointer);
        });
        document.$__savedFragments
            .filter(function (pointer) { return !document.$hasPointer(pointer.$id); })
            .forEach(function (pointer) {
            deltaCreator.addResource(pointer.$id, pointer.$_snapshot, {});
        });
        var body = deltaCreator.getPatch();
        return RequestService
            .patch(url, body, requestOptions)
            .then(function (response) {
            return __applyResponseRepresentation(repository, document, response);
        })
            .catch(__getErrorResponseParserFnFrom(repository));
    }
    function __parseMembers(registry, pointers) {
        return pointers
            .map(function (pointer) {
            if (isString(pointer))
                return registry.getPointer(pointer);
            if (Pointer.is(pointer))
                return pointer;
        })
            .filter(function (pointer) { return !!pointer; });
    }
    function __sendAddAction(repository, uri, members, requestOptions) {
        if (requestOptions === void 0) { requestOptions = {}; }
        if (!repository.context.registry.inScope(uri, true))
            return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
        var url = repository.context.getObjectSchema().resolveURI(uri, { base: true });
        __setDefaultRequestOptions(requestOptions, LDP.Container);
        RequestUtils.setContentTypeHeader("application/ld+json", requestOptions);
        var freeResources = FreeResources.createFrom({ registry: repository.context.registry });
        var targetMembers = __parseMembers(repository.context.registry, members);
        freeResources._addPointer(AddMemberAction.createFrom({ targetMembers: targetMembers }));
        var body = JSON.stringify(freeResources);
        return RequestService
            .put(url, body, requestOptions)
            .then(function () { })
            .catch(__getErrorResponseParserFnFrom(repository));
    }
    function __sendRemoveAction(repository, uri, members, requestOptions) {
        if (requestOptions === void 0) { requestOptions = {}; }
        if (!repository.context.registry.inScope(uri, true))
            return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
        var url = repository.context.getObjectSchema().resolveURI(uri, { base: true });
        __setDefaultRequestOptions(requestOptions, LDP.Container);
        RequestUtils.setContentTypeHeader("application/ld+json", requestOptions);
        RequestUtils.setRetrievalPreferences({
            include: [C.PreferSelectedMembershipTriples],
            omit: [C.PreferMembershipTriples],
        }, requestOptions);
        var freeResources = FreeResources.createFrom({ registry: repository.context.registry });
        var targetMembers = __parseMembers(repository.context.registry, members);
        freeResources._addPointer(RemoveMemberAction.createFrom({ targetMembers: targetMembers }));
        var body = JSON.stringify(freeResources);
        return RequestService
            .delete(url, body, requestOptions)
            .then(function () { })
            .catch(__getErrorResponseParserFnFrom(repository));
    }
    function __sendRemoveAll(repository, uri, requestOptions) {
        if (requestOptions === void 0) { requestOptions = {}; }
        if (!repository.context.registry.inScope(uri, true))
            return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
        var url = repository.context.getObjectSchema().resolveURI(uri, { base: true });
        __setDefaultRequestOptions(requestOptions, LDP.Container);
        RequestUtils.setRetrievalPreferences({
            include: [
                C.PreferMembershipTriples,
            ],
            omit: [
                C.PreferMembershipResources,
                C.PreferContainmentTriples,
                C.PreferContainmentResources,
                C.PreferContainer,
            ],
        }, requestOptions);
        return RequestService
            .delete(url, requestOptions)
            .then(function () { })
            .catch(__getErrorResponseParserFnFrom(repository));
    }
    var LDPDocumentsRepositoryTrait = {
        PROTOTYPE: {
            get: function (uri, requestOptions) {
                if (requestOptions === void 0) { requestOptions = {}; }
                __setDefaultRequestOptions(requestOptions, LDP.RDFSource);
                return HTTPRepositoryTrait.PROTOTYPE
                    .get.call(this, uri, requestOptions)
                    .catch(__getErrorResponseParserFnFrom(this));
            },
            exists: function (uri, requestOptions) {
                if (requestOptions === void 0) { requestOptions = {}; }
                __setDefaultRequestOptions(requestOptions, LDP.RDFSource);
                return HTTPRepositoryTrait.PROTOTYPE
                    .exists.call(this, uri, requestOptions)
                    .catch(__getErrorResponseParserFnFrom(this));
            },
            create: function (uri, children, slugsOrOptions, requestOptions) {
                return __createChildren("minimal", this, uri, children, slugsOrOptions, requestOptions);
            },
            createAndRetrieve: function (uri, children, slugsOrOptions, requestOptions) {
                return __createChildren("representation", this, uri, children, slugsOrOptions, requestOptions);
            },
            refresh: function (document, requestOptions) {
                if (requestOptions === void 0) { requestOptions = {}; }
                __setDefaultRequestOptions(requestOptions, LDP.RDFSource);
                RequestUtils.setIfNoneMatchHeader(document.$eTag, requestOptions);
                return HTTPRepositoryTrait.PROTOTYPE
                    .refresh.call(this, document, requestOptions)
                    .catch(__getErrorResponseParserFnFrom(this));
            },
            save: function (document, requestOptions) {
                if (requestOptions === void 0) { requestOptions = {}; }
                RequestUtils.setPreferredRetrieval("minimal", requestOptions);
                return __sendPatch(this, document, requestOptions);
            },
            saveAndRefresh: function (document, requestOptions) {
                if (requestOptions === void 0) { requestOptions = {}; }
                RequestUtils.setPreferredRetrieval("representation", requestOptions);
                return __sendPatch(this, document, requestOptions);
            },
            delete: function (uri, requestOptions) {
                if (requestOptions === void 0) { requestOptions = {}; }
                __setDefaultRequestOptions(requestOptions, LDP.RDFSource);
                return HTTPRepositoryTrait.PROTOTYPE
                    .delete.call(this, uri, requestOptions)
                    .catch(__getErrorResponseParserFnFrom(this));
            },
            addMember: function (uri, member, requestOptions) {
                return __sendAddAction(this, uri, [member], requestOptions);
            },
            addMembers: function (uri, members, requestOptions) {
                return __sendAddAction(this, uri, members, requestOptions);
            },
            removeMember: function (uri, member, requestOptions) {
                return __sendRemoveAction(this, uri, [member], requestOptions);
            },
            removeMembers: function (uri, membersOrOptions, requestOptions) {
                if (Array.isArray(membersOrOptions))
                    return __sendRemoveAction(this, uri, membersOrOptions, requestOptions);
                return __sendRemoveAll(this, uri, membersOrOptions || requestOptions);
            },
            _parseResponseData: function (response, id) {
                var _this = this;
                return __JSONLD_PARSER
                    .parse(response.data)
                    .then(function (rdfNodes) {
                    var rdfDocuments = RDFDocument
                        .getDocuments(rdfNodes);
                    id = __getTargetID(id, response);
                    var rdfDocument = rdfDocuments.find(function (doc) { return doc["@id"] === id; });
                    if (!rdfDocument)
                        throw new BadResponseError("No document \"" + id + "\" was returned.", response);
                    var document = _this.context.registry.register(id);
                    var previousFragments = new Set();
                    document
                        .$getPointers(true)
                        .forEach(function (pointer) { return previousFragments.add(pointer.$id); });
                    var elements = rdfDocument["@graph"].map(function (node) {
                        var target = document.$getPointer(node["@id"]);
                        var schema = _this.context.registry.getSchemaFor(node);
                        _this.context.jsonldConverter.update(target, node, schema, document);
                        if ("$document" in target)
                            previousFragments.delete(target.$id);
                        return target;
                    });
                    previousFragments
                        .forEach(function (pointer) { return document.$removePointer(pointer); });
                    elements.forEach(function (element) {
                        element.$_syncSnapshot();
                        _this.context.registry.decorate(element);
                    });
                    document.$eTag = response.getETag();
                    document.$_resolved = true;
                    return document;
                });
            },
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(LDPDocumentsRepositoryTrait.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (LDPDocumentsRepositoryTrait.isDecorated(object))
                return object;
            var target = ModelDecorator
                .decorateMultiple(object, HTTPRepositoryTrait);
            return ModelDecorator
                .definePropertiesFrom(LDPDocumentsRepositoryTrait.PROTOTYPE, target);
        },
    };

    function __executeQueryBuilder(queryContainer, queryData) {
        var queryBuilder = "containerPropertyType" in queryContainer._queryProperty
            ? new QueryDocumentsBuilder(queryContainer, queryContainer._queryProperty)
            : new QueryDocumentBuilder(queryContainer, queryContainer._queryProperty);
        if (queryData.rootType !== void 0)
            queryContainer._queryProperty
                .setType(queryData.rootType);
        if (queryData.queryBuilderFn && queryData.queryBuilderFn.call(void 0, queryBuilder) !== queryBuilder)
            throw new IllegalArgumentError("The provided query builder was not returned");
    }
    function __sortQueryDocuments(queryContainer, documents) {
        if (!("order" in queryContainer._queryProperty) || !queryContainer._queryProperty.order)
            return documents;
        var _a = queryContainer._queryProperty.order, path = _a.path, flow = _a.flow;
        var inverter = flow === "DESC" ? -1 : 1;
        return documents.sort(function (a, b) {
            a = _getPathProperty(a, path);
            b = _getPathProperty(b, path);
            var aValue = Pointer.is(a) ? a.$id : a;
            var bValue = Pointer.is(b) ? b.$id : b;
            if (aValue === bValue)
                return 0;
            if (aValue === void 0)
                return -1 * inverter;
            if (bValue === void 0)
                return inverter;
            if (!_areDifferentType(a, b)) {
                if (Pointer.is(a)) {
                    var aIsBNode = URI.isBNodeID(aValue);
                    var bIsBNode = URI.isBNodeID(bValue);
                    if (aIsBNode && !bIsBNode)
                        return -1 * inverter;
                    if (bIsBNode && !aIsBNode)
                        return inverter;
                }
            }
            else {
                if (Pointer.is(a))
                    return -1 * inverter;
                if (Pointer.is(b))
                    return inverter;
                if (isNumber(a))
                    return -1 * inverter;
                if (isNumber(b))
                    return inverter;
                if (isDate(a))
                    return -1 * inverter;
                if (isDate(b))
                    return inverter;
                if (isBoolean(a))
                    return -1 * inverter;
                if (isBoolean(b))
                    return inverter;
                if (isString(a))
                    return -1 * inverter;
                if (isString(b))
                    return inverter;
            }
            if (aValue < bValue)
                return -1 * inverter;
            if (aValue > bValue)
                return inverter;
            return 0;
        });
    }
    function __requestQueryDocuments(repository, url, requestOptions, queryContainer) {
        var _a, _b, _c;
        var construct = (_a = (_b = new ConstructToken()
            .addTriple(new SubjectToken(new IRIRefToken("cldp-sdk://metadata-" + UUIDUtils.generate()))
            .addProperty(new PropertyToken("a")
            .addObject(queryContainer.compactIRI(C.VolatileResource))
            .addObject(queryContainer.compactIRI(C.QueryMetadata)))
            .addProperty(new PropertyToken(queryContainer.compactIRI(C.target))
            .addObject(queryContainer._queryProperty.identifier)))).addTriple.apply(_b, queryContainer._queryProperty.getConstructPatterns())).addPattern.apply(_a, queryContainer._queryProperty.getSearchPatterns());
        var query = (_c = new QueryToken(construct)).addPrologues.apply(_c, queryContainer.getPrologues());
        RequestUtils.setRetrievalPreferences({ include: [C.PreferResultsContexts] }, requestOptions);
        return SPARQLService
            .executeRawCONSTRUCTQuery(url, query.toString(), requestOptions)
            .then(function (_a) {
            var strConstruct = _a[0];
            return strConstruct;
        })
            .then(function (jsonldString) {
            return new JSONLDParser().parse(jsonldString);
        })
            .then(function (rdfNodes) {
            var freeNodes = RDFDocument.getFreeNodes(rdfNodes);
            var freeResources = FreeResources
                .parseFreeNodes(repository.context.registry, freeNodes);
            var targetDocuments = freeResources
                .getPointers(true)
                .filter(QueryMetadata.is)
                .map(function (x) { return x.targets; })
                .reduce(function (targets, x) { return targets.concat(x); }, [])
                .map(function (x) { return x.$id; });
            var rdfDocuments = rdfNodes
                .filter(RDFDocument.is);
            return new QueryResultCompacter(repository.context.registry, queryContainer)
                .compactDocuments(rdfDocuments, targetDocuments);
        })
            .then(function (documents) { return __sortQueryDocuments(queryContainer, documents); })
            .catch(_getErrorResponseParserFn(repository.context.registry));
    }
    function __requestRelations(repository, uri, requestOptions, queryData) {
        if (!repository.context.registry.inScope(uri, true))
            return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
        var url = repository.context
            .getObjectSchema()
            .resolveURI(uri, { base: true });
        var queryContainer = new QueryContainer(repository.context, {
            containerPropertyType: queryData.containerPropertyType,
            uri: url,
        });
        __executeQueryBuilder(queryContainer, queryData);
        return __requestQueryDocuments(repository, url, requestOptions, queryContainer);
    }
    function __requestDocuments(repository, uris, requestOptions, queryData) {
        for (var _i = 0, uris_1 = uris; _i < uris_1.length; _i++) {
            var uri = uris_1[_i];
            if (!repository.context.registry.inScope(uri, true))
                return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
        }
        var urls = uris.map(function (uri) { return repository.context
            .getObjectSchema()
            .resolveURI(uri, { base: true }); });
        var queryContainer = new QueryContainer(repository.context, {
            uris: urls,
        });
        __executeQueryBuilder(queryContainer, queryData);
        var url = urls.length === 1 ? urls[0] : repository.context.baseURI;
        RequestUtils.setRetrievalPreferences({ include: [C.PreferDocumentChecksums] }, requestOptions);
        return __requestQueryDocuments(repository, url, requestOptions, queryContainer);
    }
    function __getQueryable(repository, uri, requestOptions, queryBuilderFn) {
        return __requestDocuments(repository, [uri], requestOptions, { queryBuilderFn: queryBuilderFn })
            .then(function (documents) { return documents[0]; });
    }
    function __addRefreshProperties(parentProperty, queryableProperty) {
        queryableProperty.subProperties.forEach(function (subProperty, propertyName) {
            var queryProperty = parentProperty._addSubProperty(propertyName, subProperty);
            __addRefreshProperties(queryProperty, subProperty);
        });
    }
    function __refreshQueryable(repository, document, requestOptions) {
        if (requestOptions === void 0) { requestOptions = {}; }
        if (!repository.context.registry.inScope(document.$id, true))
            return Promise.reject(new IllegalArgumentError("\"" + document.$id + "\" is out of scope."));
        var url = repository.context
            .getObjectSchema()
            .resolveURI(document.$id, { base: true });
        var queryContainer = new QueryContainer(repository.context, { uris: [url] });
        __addRefreshProperties(queryContainer._queryProperty, document.$_queryableMetadata);
        RequestUtils.setRetrievalPreferences({ include: [C.PreferDocumentChecksums] }, requestOptions);
        return __requestQueryDocuments(repository, url, requestOptions, queryContainer)
            .then(function (documents) { return documents[0]; });
    }
    var QueryableDocumentsRepositoryTrait = {
        PROTOTYPE: {
            get: function (uriOrURIs, requestOptionsOrQueryBuilderFn, queryBuilderFn) {
                var requestOptions = typeof requestOptionsOrQueryBuilderFn === "object" ?
                    requestOptionsOrQueryBuilderFn : {};
                queryBuilderFn = isFunction(requestOptionsOrQueryBuilderFn) ?
                    requestOptionsOrQueryBuilderFn : queryBuilderFn;
                if (typeof uriOrURIs !== "string") {
                    return __requestDocuments(this, uriOrURIs, requestOptions, {
                        rootType: queryBuilderFn ? void 0 : QueryPropertyType.FULL,
                        queryBuilderFn: queryBuilderFn,
                    });
                }
                var uri = uriOrURIs;
                var target = this.context.registry.hasPointer(uri) ?
                    this.context.registry.getPointer(uri, true) :
                    void 0;
                if (queryBuilderFn) {
                    var types_1 = target ? target.types : [];
                    return __getQueryable(this, uri, requestOptions, function (_) {
                        types_1.forEach(function (type) { return _.withType(type); });
                        return queryBuilderFn.call(void 0, _);
                    });
                }
                if (target && target.$isQueried())
                    requestOptions.ensureLatest = true;
                return LDPDocumentsRepositoryTrait.PROTOTYPE
                    .get.call(this, uri, requestOptions)
                    .then(function (document) {
                    if (!document.$_queryableMetadata)
                        return document;
                    var resources = document.$getFragments();
                    resources.push(document);
                    resources.forEach(function (resource) {
                        resource.$_queryableMetadata = void 0;
                    });
                    return document;
                });
            },
            resolve: function (document, requestOptionsOrQueryBuilderFn, queryBuilderFn) {
                return this.get(document.$id, requestOptionsOrQueryBuilderFn, queryBuilderFn);
            },
            refresh: function (document, requestOptions) {
                if (!document.$isQueried())
                    return LDPDocumentsRepositoryTrait.PROTOTYPE
                        .refresh.call(this, document, requestOptions);
                return __refreshQueryable(this, document, requestOptions);
            },
            saveAndRefresh: function (document, requestOptions) {
                var _this = this;
                if (!document.$_queryableMetadata)
                    return LDPDocumentsRepositoryTrait.PROTOTYPE
                        .saveAndRefresh.call(this, document, requestOptions);
                if (document.$eTag === null)
                    return Promise.reject(new IllegalStateError("The document \"" + document.$id + "\" is locally outdated and cannot be saved."));
                var cloneOptions = RequestUtils.cloneOptions(requestOptions || {});
                return this.save(document, cloneOptions)
                    .then(function (doc) {
                    return __refreshQueryable(_this, doc, requestOptions);
                });
            },
            getChildren: function (uri, requestOptionsOrQueryBuilderFn, queryBuilderFn) {
                var requestOptions = typeof requestOptionsOrQueryBuilderFn === "object" ?
                    requestOptionsOrQueryBuilderFn : {};
                queryBuilderFn = isFunction(requestOptionsOrQueryBuilderFn) ?
                    requestOptionsOrQueryBuilderFn : queryBuilderFn;
                RequestUtils.setRetrievalPreferences({ include: [C.PreferDocumentChecksums] }, requestOptions);
                return __requestRelations(this, uri, requestOptions, {
                    rootType: queryBuilderFn ? void 0 : QueryPropertyType.FULL,
                    containerPropertyType: QueryContainerPropertyType.CHILD,
                    queryBuilderFn: queryBuilderFn,
                });
            },
            getMembers: function (uri, requestOptionsOrQueryBuilderFn, queryBuilderFn) {
                var requestOptions = typeof requestOptionsOrQueryBuilderFn === "object" ?
                    requestOptionsOrQueryBuilderFn : {};
                queryBuilderFn = isFunction(requestOptionsOrQueryBuilderFn) ?
                    requestOptionsOrQueryBuilderFn : queryBuilderFn;
                RequestUtils.setRetrievalPreferences({ include: [C.PreferDocumentChecksums] }, requestOptions);
                return __requestRelations(this, uri, requestOptions, {
                    rootType: queryBuilderFn ? void 0 : QueryPropertyType.FULL,
                    containerPropertyType: QueryContainerPropertyType.MEMBER,
                    queryBuilderFn: queryBuilderFn,
                });
            },
            listChildren: function (uri, requestOptions) {
                if (requestOptions === void 0) { requestOptions = {}; }
                return __requestRelations(this, uri, requestOptions, {
                    containerPropertyType: QueryContainerPropertyType.CHILD,
                    rootType: QueryPropertyType.EMPTY,
                });
            },
            listMembers: function (uri, requestOptions) {
                if (requestOptions === void 0) { requestOptions = {}; }
                return __requestRelations(this, uri, requestOptions, {
                    rootType: QueryPropertyType.EMPTY,
                    containerPropertyType: QueryContainerPropertyType.MEMBER,
                });
            },
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(QueryableDocumentsRepositoryTrait.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (QueryableDocumentsRepositoryTrait.isDecorated(object))
                return object;
            var target = ModelDecorator
                .decorateMultiple(object, LDPDocumentsRepositoryTrait);
            return ModelDecorator
                .definePropertiesFrom(QueryableDocumentsRepositoryTrait.PROTOTYPE, target);
        },
    };

    var AskToken = (function (_super) {
        __extends(AskToken, _super);
        function AskToken() {
            var _this = _super.call(this) || this;
            _this.token = "ask";
            _this.datasets = [];
            return _this;
        }
        AskToken.prototype.toString = function (spaces) {
            var query = "ASK";
            var separator = getSeparator(spaces);
            if (this.datasets.length)
                query += separator + this.datasets.join(separator);
            query += separator + this.where.toString(spaces);
            if (this.modifiers.length)
                query += separator + this.modifiers.join(separator);
            return query;
        };
        return AskToken;
    }(SharedQueryClauseToken));

    function _getPatterns(iriResolver, patternFunction) {
        var patternOrPatterns = patternFunction(PatternBuilder.create(iriResolver));
        var patterns = Array.isArray(patternOrPatterns) ? patternOrPatterns : [patternOrPatterns];
        return patterns.map(function (x) { return x.getPattern(); });
    }
    function getWhereFn$1(genericFactory, container) {
        return function (patternFunction) {
            var _a;
            var iriResolver = new IRIResolver(container.iriResolver);
            var patterns = _getPatterns(iriResolver, patternFunction);
            var query = (_a = cloneElement(container.targetToken.queryClause, { where: new WhereToken() })).addPattern.apply(_a, patterns);
            var queryToken = cloneElement(container.targetToken, { queryClause: query });
            var newContainer = cloneElement(container, { iriResolver: iriResolver, targetToken: queryToken });
            var groupClause = GroupClause.createFrom(genericFactory, newContainer, {});
            return genericFactory(newContainer, groupClause);
        };
    }
    var WhereClause = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                where: getWhereFn$1(genericFactory, container),
            });
        },
    };

    function getFromFn(genericFactory, container, named) {
        return function (iri) {
            var iriResolver = new IRIResolver(container.iriResolver);
            var datasets = container.targetToken.queryClause.datasets
                .concat(new FromToken(iriResolver.resolve(iri), named));
            var queryClause = cloneElement(container.targetToken.queryClause, { datasets: datasets });
            var queryToken = cloneElement(container.targetToken, { queryClause: queryClause });
            var newContainer = cloneElement(container, {
                iriResolver: iriResolver,
                targetToken: queryToken,
            });
            return FromClause.createFrom(genericFactory, newContainer, {});
        };
    }
    var FromClause = {
        createFrom: function (genericFactory, container, object) {
            return WhereClause.createFrom(genericFactory, container, Object.assign(object, {
                from: getFromFn(genericFactory, container),
                fromNamed: getFromFn(genericFactory, container, true),
            }));
        },
    };

    function getSelectFn$1(genericFactory, container) {
        return function () {
            var queryClause = new AskToken();
            var queryToken = cloneElement(container.targetToken, { queryClause: queryClause });
            var newContainer = new Container({
                iriResolver: container.iriResolver,
                targetToken: queryToken,
            });
            return FromClause.createFrom(genericFactory, newContainer, {});
        };
    }
    var AskClause = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                ask: getSelectFn$1(genericFactory, container),
            });
        },
    };

    function getSelectFn$2(genericFactory, container, modifier) {
        return function () {
            var variables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                variables[_i] = arguments[_i];
            }
            var queryClause = new SelectToken(modifier);
            if (variables.length)
                queryClause.addVariable.apply(queryClause, variables.map(function (x) { return new VariableToken(x); }));
            var queryToken = cloneElement(container.targetToken, { queryClause: queryClause });
            var newContainer = new Container({
                iriResolver: container.iriResolver,
                targetToken: queryToken,
            });
            return FromClause.createFrom(genericFactory, newContainer, {});
        };
    }
    var SelectClause = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                select: getSelectFn$2(genericFactory, container),
                selectDistinct: getSelectFn$2(genericFactory, container, "DISTINCT"),
                selectReduced: getSelectFn$2(genericFactory, container, "REDUCED"),
                selectAll: function () { return getSelectFn$2(genericFactory, container)(); },
                selectAllDistinct: function () { return getSelectFn$2(genericFactory, container, "DISTINCT")(); },
                selectAllReduced: function () { return getSelectFn$2(genericFactory, container, "REDUCED")(); },
            });
        },
    };

    function base(iri) {
        var token = new BaseToken(new IRIRefToken(iri));
        var prologues = this.targetToken
            .prologues.concat(token);
        var queryToken = cloneElement(this.targetToken, { prologues: prologues });
        var container = cloneElement(this, { targetToken: queryToken });
        return QueryClause.createFrom(container, {});
    }
    function vocab(iri) {
        var iriResolver = new IRIResolver(this.iriResolver, iri);
        var container = cloneElement(this, { iriResolver: iriResolver });
        return QueryClause.createFrom(container, {});
    }
    function prefix(name, iri) {
        var iriResolver = new IRIResolver(this.iriResolver);
        var prologues = this.targetToken.prologues.slice();
        if (iriResolver.prefixes.has(name)) {
            var index = prologues
                .findIndex(function (token) { return token.token === "prefix" && token.namespace === name; });
            if (index !== -1)
                prologues.splice(index, 1);
        }
        prologues.push(new PrefixToken(name, new IRIRefToken(iri)));
        iriResolver.prefixes.set(name, false);
        var queryToken = cloneElement(this.targetToken, { prologues: prologues });
        var container = cloneElement(this, {
            iriResolver: iriResolver,
            targetToken: queryToken,
        });
        return QueryClause.createFrom(container, {});
    }
    var QueryClause = {
        createFrom: function (container, object) {
            var selectFactory = SelectClause
                .createFrom.bind(null, container.selectFinishClauseFactory);
            var askFactory = AskClause
                .createFrom.bind(null, container.askFinishClauseFactory);
            return Factory.createFrom(selectFactory, askFactory)(container, Object.assign(object, {
                base: base.bind(container),
                vocab: vocab.bind(container),
                prefix: prefix.bind(container),
            }));
        },
    };

    var SPARQLER = (function () {
        function SPARQLER(finishSelectFactory, finishAskFactory) {
            if (finishSelectFactory === void 0) { finishSelectFactory = FinishClause.createFrom; }
            if (finishAskFactory === void 0) { finishAskFactory = FinishClause.createFrom; }
            var container = new QueryUnitContainer({
                iriResolver: new IRIResolver(),
                targetToken: new QueryToken(void 0),
                selectFinishClauseFactory: finishSelectFactory,
                askFinishClauseFactory: finishAskFactory,
            });
            return QueryClause.createFrom(container, this);
        }
        return SPARQLER;
    }());

    function getFinishSelectFactory(resource, entryPoint) {
        return function (container, object) {
            var finishClause = FinishClause.createFrom(container, object);
            return Object.assign(finishClause, {
                execute: function () { return resource.executeSELECTQuery(entryPoint, finishClause.toCompactString()); },
            });
        };
    }
    function getFinishAskFactory(resource, entryPoint) {
        return function (container, object) {
            var finishClause = FinishClause.createFrom(container, object);
            return Object.assign(finishClause, {
                execute: function () { return resource.executeASKQuery(entryPoint, finishClause.toCompactString()); },
            });
        };
    }
    var SPARQLBuilder = (function (_super) {
        __extends(SPARQLBuilder, _super);
        function SPARQLBuilder(repository, entryPoint) {
            var _this = this;
            var finishSelectFactory = getFinishSelectFactory(repository, entryPoint);
            var finishAskFactory = getFinishAskFactory(repository, entryPoint);
            _this = _super.call(this, finishSelectFactory, finishAskFactory) || this;
            return _this;
        }
        return SPARQLBuilder;
    }(SPARQLER));

    var SPARQLDocumentsRepositoryTrait = {
        PROTOTYPE: {
            executeASKQuery: function (uri, askQuery, requestOptions) {
                if (!this.context.registry.inScope(uri, true))
                    return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
                var url = this.context.getObjectSchema().resolveURI(uri, { base: true });
                requestOptions = requestOptions ? requestOptions : {};
                RequestUtils.setAcceptHeader("application/ld+json; q=0.9", requestOptions);
                return SPARQLService
                    .executeASKQuery(url, askQuery, requestOptions)
                    .then(function (_a) {
                    var rawResults = _a[0];
                    return rawResults;
                })
                    .catch(_getErrorResponseParserFn(this.context.registry));
            },
            executeSELECTQuery: function (uri, selectQuery, requestOptions) {
                if (!this.context.registry.inScope(uri, true))
                    return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
                var url = this.context.getObjectSchema().resolveURI(uri, { base: true });
                requestOptions = requestOptions ? requestOptions : {};
                RequestUtils.setAcceptHeader("application/ld+json; q=0.9", requestOptions);
                return SPARQLService
                    .executeSELECTQuery(url, selectQuery, this.context.registry, requestOptions)
                    .then(function (_a) {
                    var selectResults = _a[0];
                    return selectResults;
                })
                    .catch(_getErrorResponseParserFn(this.context.registry));
            },
            executeUPDATE: function (uri, update, requestOptions) {
                if (!this.context.registry.inScope(uri, true))
                    return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
                var url = this.context.getObjectSchema().resolveURI(uri, { base: true });
                return SPARQLService
                    .executeUPDATE(url, update, requestOptions)
                    .then(function () { })
                    .catch(_getErrorResponseParserFn(this.context.registry));
            },
            sparql: function (uri) {
                if (!this.context.registry.inScope(uri, true))
                    throw new IllegalArgumentError("\"" + uri + "\" is out of scope.");
                var url = this.context.getObjectSchema().resolveURI(uri, { base: true });
                var schema = this.context.registry.getGeneralSchema();
                var builder = new SPARQLBuilder(this, url)
                    .base(schema.base)
                    .vocab(schema.vocab);
                schema.prefixes.forEach(function (name, prefix) {
                    builder = builder.prefix(prefix, name);
                });
                return builder;
            },
        },
        isDecorated: function (object) {
            return ModelDecorator
                .hasPropertiesFrom(SPARQLDocumentsRepositoryTrait.PROTOTYPE, object);
        },
        decorate: function (object) {
            if (SPARQLDocumentsRepositoryTrait.isDecorated(object))
                return object;
            var target = ModelDecorator
                .decorateMultiple(object, GeneralRepository);
            return ModelDecorator
                .definePropertiesFrom(SPARQLDocumentsRepositoryTrait.PROTOTYPE, target);
        },
    };

    var DocumentsRepository = {
        create: function (data) {
            return DocumentsRepository.createFrom(__assign({}, data));
        },
        createFrom: function (object) {
            return ModelDecorator
                .decorateMultiple(object, QueryableDocumentsRepositoryTrait, SPARQLDocumentsRepositoryTrait, EventEmitterDocumentsRepositoryTrait);
        },
        is: function (value) {
            return isObject(value)
                && QueryableDocumentsRepositoryTrait.isDecorated(value)
                && SPARQLDocumentsRepositoryTrait.isDecorated(value)
                && EventEmitterDocumentsRepositoryTrait.isDecorated(value);
        },
    };

    var global$1 = (typeof global !== "undefined" ? global :
                typeof self !== "undefined" ? self :
                typeof window !== "undefined" ? window : {});

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var browserCrypto = createCommonjsModule(function (module) {

    if (global$1.crypto && global$1.crypto.getRandomValues) {
      module.exports.randomBytes = function(length) {
        var bytes = new Uint8Array(length);
        global$1.crypto.getRandomValues(bytes);
        return bytes;
      };
    } else {
      module.exports.randomBytes = function(length) {
        var bytes = new Array(length);
        for (var i = 0; i < length; i++) {
          bytes[i] = Math.floor(Math.random() * 256);
        }
        return bytes;
      };
    }
    });
    var browserCrypto_1 = browserCrypto.randomBytes;

    /* global crypto:true */


    // This string has length 32, a power of 2, so the modulus doesn't introduce a
    // bias.
    var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
    var random = {
      string: function(length) {
        var max = _randomStringChars.length;
        var bytes = browserCrypto.randomBytes(length);
        var ret = [];
        for (var i = 0; i < length; i++) {
          ret.push(_randomStringChars.substr(bytes[i] % max, 1));
        }
        return ret.join('');
      }

    , number: function(max) {
        return Math.floor(Math.random() * max);
      }

    , numberString: function(max) {
        var t = ('' + (max - 1)).length;
        var p = new Array(t + 1).join('0');
        return (p + this.number(max)).slice(-t);
      }
    };

    var event = createCommonjsModule(function (module) {



    var onUnload = {}
      , afterUnload = false
        // detect google chrome packaged apps because they don't allow the 'unload' event
      , isChromePackagedApp = global$1.chrome && global$1.chrome.app && global$1.chrome.app.runtime
      ;

    module.exports = {
      attachEvent: function(event, listener) {
        if (typeof global$1.addEventListener !== 'undefined') {
          global$1.addEventListener(event, listener, false);
        } else if (global$1.document && global$1.attachEvent) {
          // IE quirks.
          // According to: http://stevesouders.com/misc/test-postmessage.php
          // the message gets delivered only to 'document', not 'window'.
          global$1.document.attachEvent('on' + event, listener);
          // I get 'window' for ie8.
          global$1.attachEvent('on' + event, listener);
        }
      }

    , detachEvent: function(event, listener) {
        if (typeof global$1.addEventListener !== 'undefined') {
          global$1.removeEventListener(event, listener, false);
        } else if (global$1.document && global$1.detachEvent) {
          global$1.document.detachEvent('on' + event, listener);
          global$1.detachEvent('on' + event, listener);
        }
      }

    , unloadAdd: function(listener) {
        if (isChromePackagedApp) {
          return null;
        }

        var ref = random.string(8);
        onUnload[ref] = listener;
        if (afterUnload) {
          setTimeout(this.triggerUnloadCallbacks, 0);
        }
        return ref;
      }

    , unloadDel: function(ref) {
        if (ref in onUnload) {
          delete onUnload[ref];
        }
      }

    , triggerUnloadCallbacks: function() {
        for (var ref in onUnload) {
          onUnload[ref]();
          delete onUnload[ref];
        }
      }
    };

    var unloadTriggered = function() {
      if (afterUnload) {
        return;
      }
      afterUnload = true;
      module.exports.triggerUnloadCallbacks();
    };

    // 'unload' alone is not reliable in opera within an iframe, but we
    // can't use `beforeunload` as IE fires it on javascript: links.
    if (!isChromePackagedApp) {
      module.exports.attachEvent('unload', unloadTriggered);
    }
    });
    var event_1 = event.attachEvent;
    var event_2 = event.detachEvent;
    var event_3 = event.unloadAdd;
    var event_4 = event.unloadDel;
    var event_5 = event.triggerUnloadCallbacks;

    /**
     * Check if we're required to add a port number.
     *
     * @see https://url.spec.whatwg.org/#default-port
     * @param {Number|String} port Port number we need to check
     * @param {String} protocol Protocol we need to check against.
     * @returns {Boolean} Is it a default port for the given protocol
     * @api private
     */
    var requiresPort = function required(port, protocol) {
      protocol = protocol.split(':')[0];
      port = +port;

      if (!port) return false;

      switch (protocol) {
        case 'http':
        case 'ws':
        return port !== 80;

        case 'https':
        case 'wss':
        return port !== 443;

        case 'ftp':
        return port !== 21;

        case 'gopher':
        return port !== 70;

        case 'file':
        return false;
      }

      return port !== 0;
    };

    var has = Object.prototype.hasOwnProperty
      , undef;

    /**
     * Decode a URI encoded string.
     *
     * @param {String} input The URI encoded string.
     * @returns {String} The decoded string.
     * @api private
     */
    function decode(input) {
      return decodeURIComponent(input.replace(/\+/g, ' '));
    }

    /**
     * Simple query string parser.
     *
     * @param {String} query The query string that needs to be parsed.
     * @returns {Object}
     * @api public
     */
    function querystring(query) {
      var parser = /([^=?&]+)=?([^&]*)/g
        , result = {}
        , part;

      while (part = parser.exec(query)) {
        var key = decode(part[1])
          , value = decode(part[2]);

        //
        // Prevent overriding of existing properties. This ensures that build-in
        // methods like `toString` or __proto__ are not overriden by malicious
        // querystrings.
        //
        if (key in result) continue;
        result[key] = value;
      }

      return result;
    }

    /**
     * Transform a query string to an object.
     *
     * @param {Object} obj Object that should be transformed.
     * @param {String} prefix Optional prefix.
     * @returns {String}
     * @api public
     */
    function querystringify(obj, prefix) {
      prefix = prefix || '';

      var pairs = []
        , value
        , key;

      //
      // Optionally prefix with a '?' if needed
      //
      if ('string' !== typeof prefix) prefix = '?';

      for (key in obj) {
        if (has.call(obj, key)) {
          value = obj[key];

          //
          // Edge cases where we actually want to encode the value to an empty
          // string instead of the stringified value.
          //
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = '';
          }

          pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(value));
        }
      }

      return pairs.length ? prefix + pairs.join('&') : '';
    }

    //
    // Expose the module.
    //
    var stringify = querystringify;
    var parse = querystring;

    var querystringify_1 = {
    	stringify: stringify,
    	parse: parse
    };

    var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
      , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

    /**
     * These are the parse rules for the URL parser, it informs the parser
     * about:
     *
     * 0. The char it Needs to parse, if it's a string it should be done using
     *    indexOf, RegExp using exec and NaN means set as current value.
     * 1. The property we should set when parsing this value.
     * 2. Indication if it's backwards or forward parsing, when set as number it's
     *    the value of extra chars that should be split off.
     * 3. Inherit from location if non existing in the parser.
     * 4. `toLowerCase` the resulting value.
     */
    var rules = [
      ['#', 'hash'],                        // Extract from the back.
      ['?', 'query'],                       // Extract from the back.
      function sanitize(address) {          // Sanitize what is left of the address
        return address.replace('\\', '/');
      },
      ['/', 'pathname'],                    // Extract from the back.
      ['@', 'auth', 1],                     // Extract from the front.
      [NaN, 'host', undefined, 1, 1],       // Set left over value.
      [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
      [NaN, 'hostname', undefined, 1, 1]    // Set left over.
    ];

    /**
     * These properties should not be copied or inherited from. This is only needed
     * for all non blob URL's as a blob URL does not include a hash, only the
     * origin.
     *
     * @type {Object}
     * @private
     */
    var ignore = { hash: 1, query: 1 };

    /**
     * The location object differs when your code is loaded through a normal page,
     * Worker or through a worker using a blob. And with the blobble begins the
     * trouble as the location object will contain the URL of the blob, not the
     * location of the page where our code is loaded in. The actual origin is
     * encoded in the `pathname` so we can thankfully generate a good "default"
     * location from it so we can generate proper relative URL's again.
     *
     * @param {Object|String} loc Optional default location object.
     * @returns {Object} lolcation object.
     * @public
     */
    function lolcation(loc) {
      var globalVar;

      if (typeof window !== 'undefined') globalVar = window;
      else if (typeof global$1 !== 'undefined') globalVar = global$1;
      else if (typeof self !== 'undefined') globalVar = self;
      else globalVar = {};

      var location = globalVar.location || {};
      loc = loc || location;

      var finaldestination = {}
        , type = typeof loc
        , key;

      if ('blob:' === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ('string' === type) {
        finaldestination = new Url(loc, {});
        for (key in ignore) delete finaldestination[key];
      } else if ('object' === type) {
        for (key in loc) {
          if (key in ignore) continue;
          finaldestination[key] = loc[key];
        }

        if (finaldestination.slashes === undefined) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }

      return finaldestination;
    }

    /**
     * @typedef ProtocolExtract
     * @type Object
     * @property {String} protocol Protocol matched in the URL, in lowercase.
     * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
     * @property {String} rest Rest of the URL that is not part of the protocol.
     */

    /**
     * Extract protocol information from a URL with/without double slash ("//").
     *
     * @param {String} address URL we want to extract from.
     * @return {ProtocolExtract} Extracted information.
     * @private
     */
    function extractProtocol(address) {
      var match = protocolre.exec(address);

      return {
        protocol: match[1] ? match[1].toLowerCase() : '',
        slashes: !!match[2],
        rest: match[3]
      };
    }

    /**
     * Resolve a relative URL pathname against a base URL pathname.
     *
     * @param {String} relative Pathname of the relative URL.
     * @param {String} base Pathname of the base URL.
     * @return {String} Resolved pathname.
     * @private
     */
    function resolve(relative, base) {
      var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
        , i = path.length
        , last = path[i - 1]
        , unshift = false
        , up = 0;

      while (i--) {
        if (path[i] === '.') {
          path.splice(i, 1);
        } else if (path[i] === '..') {
          path.splice(i, 1);
          up++;
        } else if (up) {
          if (i === 0) unshift = true;
          path.splice(i, 1);
          up--;
        }
      }

      if (unshift) path.unshift('');
      if (last === '.' || last === '..') path.push('');

      return path.join('/');
    }

    /**
     * The actual URL instance. Instead of returning an object we've opted-in to
     * create an actual constructor as it's much more memory efficient and
     * faster and it pleases my OCD.
     *
     * It is worth noting that we should not use `URL` as class name to prevent
     * clashes with the global URL instance that got introduced in browsers.
     *
     * @constructor
     * @param {String} address URL we want to parse.
     * @param {Object|String} [location] Location defaults for relative paths.
     * @param {Boolean|Function} [parser] Parser for the query string.
     * @private
     */
    function Url(address, location, parser) {
      if (!(this instanceof Url)) {
        return new Url(address, location, parser);
      }

      var relative, extracted, parse, instruction, index, key
        , instructions = rules.slice()
        , type = typeof location
        , url = this
        , i = 0;

      //
      // The following if statements allows this module two have compatibility with
      // 2 different API:
      //
      // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
      //    where the boolean indicates that the query string should also be parsed.
      //
      // 2. The `URL` interface of the browser which accepts a URL, object as
      //    arguments. The supplied object will be used as default values / fall-back
      //    for relative paths.
      //
      if ('object' !== type && 'string' !== type) {
        parser = location;
        location = null;
      }

      if (parser && 'function' !== typeof parser) parser = querystringify_1.parse;

      location = lolcation(location);

      //
      // Extract protocol information before running the instructions.
      //
      extracted = extractProtocol(address || '');
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || '';
      address = extracted.rest;

      //
      // When the authority component is absent the URL starts with a path
      // component.
      //
      if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

      for (; i < instructions.length; i++) {
        instruction = instructions[i];

        if (typeof instruction === 'function') {
          address = instruction(address);
          continue;
        }

        parse = instruction[0];
        key = instruction[1];

        if (parse !== parse) {
          url[key] = address;
        } else if ('string' === typeof parse) {
          if (~(index = address.indexOf(parse))) {
            if ('number' === typeof instruction[2]) {
              url[key] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if ((index = parse.exec(address))) {
          url[key] = index[1];
          address = address.slice(0, index.index);
        }

        url[key] = url[key] || (
          relative && instruction[3] ? location[key] || '' : ''
        );

        //
        // Hostname, host and protocol should be lowercased so they can be used to
        // create a proper `origin`.
        //
        if (instruction[4]) url[key] = url[key].toLowerCase();
      }

      //
      // Also parse the supplied query string in to an object. If we're supplied
      // with a custom parser as function use that instead of the default build-in
      // parser.
      //
      if (parser) url.query = parser(url.query);

      //
      // If the URL is relative, resolve the pathname against the base URL.
      //
      if (
          relative
        && location.slashes
        && url.pathname.charAt(0) !== '/'
        && (url.pathname !== '' || location.pathname !== '')
      ) {
        url.pathname = resolve(url.pathname, location.pathname);
      }

      //
      // We should not add port numbers if they are already the default port number
      // for a given protocol. As the host also contains the port number we're going
      // override it with the hostname which contains no port number.
      //
      if (!requiresPort(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = '';
      }

      //
      // Parse down the `auth` for the username and password.
      //
      url.username = url.password = '';
      if (url.auth) {
        instruction = url.auth.split(':');
        url.username = instruction[0] || '';
        url.password = instruction[1] || '';
      }

      url.origin = url.protocol && url.host && url.protocol !== 'file:'
        ? url.protocol +'//'+ url.host
        : 'null';

      //
      // The href is just the compiled result.
      //
      url.href = url.toString();
    }

    /**
     * This is convenience method for changing properties in the URL instance to
     * insure that they all propagate correctly.
     *
     * @param {String} part          Property we need to adjust.
     * @param {Mixed} value          The newly assigned value.
     * @param {Boolean|Function} fn  When setting the query, it will be the function
     *                               used to parse the query.
     *                               When setting the protocol, double slash will be
     *                               removed from the final url if it is true.
     * @returns {URL} URL instance for chaining.
     * @public
     */
    function set(part, value, fn) {
      var url = this;

      switch (part) {
        case 'query':
          if ('string' === typeof value && value.length) {
            value = (fn || querystringify_1.parse)(value);
          }

          url[part] = value;
          break;

        case 'port':
          url[part] = value;

          if (!requiresPort(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = '';
          } else if (value) {
            url.host = url.hostname +':'+ value;
          }

          break;

        case 'hostname':
          url[part] = value;

          if (url.port) value += ':'+ url.port;
          url.host = value;
          break;

        case 'host':
          url[part] = value;

          if (/:\d+$/.test(value)) {
            value = value.split(':');
            url.port = value.pop();
            url.hostname = value.join(':');
          } else {
            url.hostname = value;
            url.port = '';
          }

          break;

        case 'protocol':
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;

        case 'pathname':
        case 'hash':
          if (value) {
            var char = part === 'pathname' ? '/' : '#';
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;

        default:
          url[part] = value;
      }

      for (var i = 0; i < rules.length; i++) {
        var ins = rules[i];

        if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
      }

      url.origin = url.protocol && url.host && url.protocol !== 'file:'
        ? url.protocol +'//'+ url.host
        : 'null';

      url.href = url.toString();

      return url;
    }

    /**
     * Transform the properties back in to a valid and full URL string.
     *
     * @param {Function} stringify Optional query stringify function.
     * @returns {String} Compiled version of the URL.
     * @public
     */
    function toString(stringify) {
      if (!stringify || 'function' !== typeof stringify) stringify = querystringify_1.stringify;

      var query
        , url = this
        , protocol = url.protocol;

      if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

      var result = protocol + (url.slashes ? '//' : '');

      if (url.username) {
        result += url.username;
        if (url.password) result += ':'+ url.password;
        result += '@';
      }

      result += url.host + url.pathname;

      query = 'object' === typeof url.query ? stringify(url.query) : url.query;
      if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

      if (url.hash) result += url.hash;

      return result;
    }

    Url.prototype = { set: set, toString: toString };

    //
    // Expose the URL parser and some additional properties that might be useful for
    // others or testing.
    //
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.qs = querystringify_1;

    var urlParse = Url;

    /**
     * Helpers.
     */

    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} [options]
     * @throws {Error} throw an error if val is not a non-empty string or a number
     * @return {String|Number}
     * @api public
     */

    var ms = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse$1(val);
      } else if (type === 'number' && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        'val is not a non-empty string or a valid number. val=' +
          JSON.stringify(val)
      );
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse$1(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'weeks':
        case 'week':
        case 'w':
          return n * w;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
      }
      return ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    }

    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     */
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = ms;
      Object.keys(env).forEach(function (key) {
        createDebug[key] = env[key];
      });
      /**
      * Active `debug` instances.
      */

      createDebug.instances = [];
      /**
      * The currently active debug mode names, and names to skip.
      */

      createDebug.names = [];
      createDebug.skips = [];
      /**
      * Map of special "%n" handling functions, for the debug "format" argument.
      *
      * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
      */

      createDebug.formatters = {};
      /**
      * Selects a color for a debug namespace
      * @param {String} namespace The namespace string for the for the debug instance to be colored
      * @return {Number|String} An ANSI color code for the given namespace
      * @api private
      */

      function selectColor(namespace) {
        var hash = 0;

        for (var i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0; // Convert to 32bit integer
        }

        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }

      createDebug.selectColor = selectColor;
      /**
      * Create a debugger with the given `namespace`.
      *
      * @param {String} namespace
      * @return {Function}
      * @api public
      */

      function createDebug(namespace) {
        var prevTime;

        function debug() {
          // Disabled?
          if (!debug.enabled) {
            return;
          }

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var self = debug; // Set `diff` timestamp

          var curr = Number(new Date());
          var ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);

          if (typeof args[0] !== 'string') {
            // Anything else let's inspect with %O
            args.unshift('%O');
          } // Apply any `formatters` transformations


          var index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
            // If we encounter an escaped % then don't increase the array index
            if (match === '%%') {
              return match;
            }

            index++;
            var formatter = createDebug.formatters[format];

            if (typeof formatter === 'function') {
              var val = args[index];
              match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

              args.splice(index, 1);
              index--;
            }

            return match;
          }); // Apply env-specific formatting (colors, etc.)

          createDebug.formatArgs.call(self, args);
          var logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }

        debug.namespace = namespace;
        debug.enabled = createDebug.enabled(namespace);
        debug.useColors = createDebug.useColors();
        debug.color = selectColor(namespace);
        debug.destroy = destroy;
        debug.extend = extend; // Debug.formatArgs = formatArgs;
        // debug.rawLog = rawLog;
        // env-specific initialization logic for debug instances

        if (typeof createDebug.init === 'function') {
          createDebug.init(debug);
        }

        createDebug.instances.push(debug);
        return debug;
      }

      function destroy() {
        var index = createDebug.instances.indexOf(this);

        if (index !== -1) {
          createDebug.instances.splice(index, 1);
          return true;
        }

        return false;
      }

      function extend(namespace, delimiter) {
        return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
      }
      /**
      * Enables a debug mode by namespaces. This can include modes
      * separated by a colon and wildcards.
      *
      * @param {String} namespaces
      * @api public
      */


      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        var i;
        var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
        var len = split.length;

        for (i = 0; i < len; i++) {
          if (!split[i]) {
            // ignore empty strings
            continue;
          }

          namespaces = split[i].replace(/\*/g, '.*?');

          if (namespaces[0] === '-') {
            createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
          } else {
            createDebug.names.push(new RegExp('^' + namespaces + '$'));
          }
        }

        for (i = 0; i < createDebug.instances.length; i++) {
          var instance = createDebug.instances[i];
          instance.enabled = createDebug.enabled(instance.namespace);
        }
      }
      /**
      * Disable debug output.
      *
      * @api public
      */


      function disable() {
        createDebug.enable('');
      }
      /**
      * Returns true if the given mode name is enabled, false otherwise.
      *
      * @param {String} name
      * @return {Boolean}
      * @api public
      */


      function enabled(name) {
        if (name[name.length - 1] === '*') {
          return true;
        }

        var i;
        var len;

        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }

        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }

        return false;
      }
      /**
      * Coerce `val`.
      *
      * @param {Mixed} val
      * @return {Mixed}
      * @api private
      */


      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }

        return val;
      }

      createDebug.enable(createDebug.load());
      return createDebug;
    }

    var common = setup;

    var browser = createCommonjsModule(function (module, exports) {

    function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    /* eslint-env browser */

    /**
     * This is the web browser implementation of `debug()`.
     */
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    /**
     * Colors.
     */

    exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */
    // eslint-disable-next-line complexity

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
      } // Internet Explorer and Edge do not support colors.


      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      } // Is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */


    function formatArgs(args) {
      args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

      if (!this.useColors) {
        return;
      }

      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into

      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if (match === '%%') {
          return;
        }

        index++;

        if (match === '%c') {
          // We only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */


    function log() {
      var _console;

      // This hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
    }
    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */


    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {// Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }
    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */


    function load() {
      var r;

      try {
        r = exports.storage.getItem('debug');
      } catch (error) {} // Swallow
      // XXX (@Qix-) should we be logging these?
      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }

      return r;
    }
    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */


    function localstorage() {
      try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
      } catch (error) {// Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }

    module.exports = common(exports);
    var formatters = module.exports.formatters;
    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
    });
    var browser_1 = browser.log;
    var browser_2 = browser.formatArgs;
    var browser_3 = browser.save;
    var browser_4 = browser.load;
    var browser_5 = browser.useColors;
    var browser_6 = browser.storage;
    var browser_7 = browser.colors;

    var debug = function() {};

    var url = {
      getOrigin: function(url) {
        if (!url) {
          return null;
        }

        var p = new urlParse(url);
        if (p.protocol === 'file:') {
          return null;
        }

        var port = p.port;
        if (!port) {
          port = (p.protocol === 'https:') ? '443' : '80';
        }

        return p.protocol + '//' + p.hostname + ':' + port;
      }

    , isOriginEqual: function(a, b) {
        var res = this.getOrigin(a) === this.getOrigin(b);
        debug('same', a, b, res);
        return res;
      }

    , isSchemeEqual: function(a, b) {
        return (a.split(':')[0] === b.split(':')[0]);
      }

    , addPath: function (url, path) {
        var qs = url.split('?');
        return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
      }

    , addQuery: function (url, q) {
        return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
      }
    };

    var inherits_browser = createCommonjsModule(function (module) {
    if (typeof Object.create === 'function') {
      // implementation from standard node.js 'util' module
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      // old school shim for old browsers
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    });

    /* Simplified implementation of DOM2 EventTarget.
     *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
     */

    function EventTarget() {
      this._listeners = {};
    }

    EventTarget.prototype.addEventListener = function(eventType, listener) {
      if (!(eventType in this._listeners)) {
        this._listeners[eventType] = [];
      }
      var arr = this._listeners[eventType];
      // #4
      if (arr.indexOf(listener) === -1) {
        // Make a copy so as not to interfere with a current dispatchEvent.
        arr = arr.concat([listener]);
      }
      this._listeners[eventType] = arr;
    };

    EventTarget.prototype.removeEventListener = function(eventType, listener) {
      var arr = this._listeners[eventType];
      if (!arr) {
        return;
      }
      var idx = arr.indexOf(listener);
      if (idx !== -1) {
        if (arr.length > 1) {
          // Make a copy so as not to interfere with a current dispatchEvent.
          this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
        } else {
          delete this._listeners[eventType];
        }
        return;
      }
    };

    EventTarget.prototype.dispatchEvent = function() {
      var event = arguments[0];
      var t = event.type;
      // equivalent of Array.prototype.slice.call(arguments, 0);
      var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
      // TODO: This doesn't match the real behavior; per spec, onfoo get
      // their place in line from the /first/ time they're set from
      // non-null. Although WebKit bumps it to the end every time it's
      // set.
      if (this['on' + t]) {
        this['on' + t].apply(this, args);
      }
      if (t in this._listeners) {
        // Grab a reference to the listeners list. removeEventListener may alter the list.
        var listeners = this._listeners[t];
        for (var i = 0; i < listeners.length; i++) {
          listeners[i].apply(this, args);
        }
      }
    };

    var eventtarget = EventTarget;

    function EventEmitter() {
      eventtarget.call(this);
    }

    inherits_browser(EventEmitter, eventtarget);

    EventEmitter.prototype.removeAllListeners = function(type) {
      if (type) {
        delete this._listeners[type];
      } else {
        this._listeners = {};
      }
    };

    EventEmitter.prototype.once = function(type, listener) {
      var self = this
        , fired = false;

      function g() {
        self.removeListener(type, g);

        if (!fired) {
          fired = true;
          listener.apply(this, arguments);
        }
      }

      this.on(type, g);
    };

    EventEmitter.prototype.emit = function() {
      var type = arguments[0];
      var listeners = this._listeners[type];
      if (!listeners) {
        return;
      }
      // equivalent of Array.prototype.slice.call(arguments, 1);
      var l = arguments.length;
      var args = new Array(l - 1);
      for (var ai = 1; ai < l; ai++) {
        args[ai - 1] = arguments[ai];
      }
      for (var i = 0; i < listeners.length; i++) {
        listeners[i].apply(this, args);
      }
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener = eventtarget.prototype.addEventListener;
    EventEmitter.prototype.removeListener = eventtarget.prototype.removeEventListener;

    var EventEmitter_1 = EventEmitter;

    var emitter = {
    	EventEmitter: EventEmitter_1
    };

    var websocket = createCommonjsModule(function (module) {

    var Driver = global$1.WebSocket || global$1.MozWebSocket;
    if (Driver) {
    	module.exports = function WebSocketBrowserDriver(url) {
    		return new Driver(url);
    	};
    } else {
    	module.exports = undefined;
    }
    });

    var EventEmitter$1 = emitter.EventEmitter
      ;

    var debug$1 = function() {};

    function WebSocketTransport(transUrl, ignore, options) {
      if (!WebSocketTransport.enabled()) {
        throw new Error('Transport created when disabled');
      }

      EventEmitter$1.call(this);
      debug$1('constructor', transUrl);

      var self = this;
      var url$1 = url.addPath(transUrl, '/websocket');
      if (url$1.slice(0, 5) === 'https') {
        url$1 = 'wss' + url$1.slice(5);
      } else {
        url$1 = 'ws' + url$1.slice(4);
      }
      this.url = url$1;

      this.ws = new websocket(this.url, [], options);
      this.ws.onmessage = function(e) {
        debug$1('message event', e.data);
        self.emit('message', e.data);
      };
      // Firefox has an interesting bug. If a websocket connection is
      // created after onunload, it stays alive even when user
      // navigates away from the page. In such situation let's lie -
      // let's not open the ws connection at all. See:
      // https://github.com/sockjs/sockjs-client/issues/28
      // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
      this.unloadRef = event.unloadAdd(function() {
        debug$1('unload');
        self.ws.close();
      });
      this.ws.onclose = function(e) {
        debug$1('close event', e.code, e.reason);
        self.emit('close', e.code, e.reason);
        self._cleanup();
      };
      this.ws.onerror = function(e) {
        debug$1('error event', e);
        self.emit('close', 1006, 'WebSocket connection broken');
        self._cleanup();
      };
    }

    inherits_browser(WebSocketTransport, EventEmitter$1);

    WebSocketTransport.prototype.send = function(data) {
      var msg = '[' + data + ']';
      debug$1('send', msg);
      this.ws.send(msg);
    };

    WebSocketTransport.prototype.close = function() {
      debug$1('close');
      var ws = this.ws;
      this._cleanup();
      if (ws) {
        ws.close();
      }
    };

    WebSocketTransport.prototype._cleanup = function() {
      debug$1('_cleanup');
      var ws = this.ws;
      if (ws) {
        ws.onmessage = ws.onclose = ws.onerror = null;
      }
      event.unloadDel(this.unloadRef);
      this.unloadRef = this.ws = null;
      this.removeAllListeners();
    };

    WebSocketTransport.enabled = function() {
      debug$1('enabled');
      return !!websocket;
    };
    WebSocketTransport.transportName = 'websocket';

    // In theory, ws should require 1 round trip. But in chrome, this is
    // not very stable over SSL. Most likely a ws connection requires a
    // separate SSL connection, in which case 2 round trips are an
    // absolute minumum.
    WebSocketTransport.roundTrips = 2;

    var websocket$1 = WebSocketTransport;

    var EventEmitter$2 = emitter.EventEmitter
      ;

    var debug$2 = function() {};

    function BufferedSender(url, sender) {
      debug$2(url);
      EventEmitter$2.call(this);
      this.sendBuffer = [];
      this.sender = sender;
      this.url = url;
    }

    inherits_browser(BufferedSender, EventEmitter$2);

    BufferedSender.prototype.send = function(message) {
      debug$2('send', message);
      this.sendBuffer.push(message);
      if (!this.sendStop) {
        this.sendSchedule();
      }
    };

    // For polling transports in a situation when in the message callback,
    // new message is being send. If the sending connection was started
    // before receiving one, it is possible to saturate the network and
    // timeout due to the lack of receiving socket. To avoid that we delay
    // sending messages by some small time, in order to let receiving
    // connection be started beforehand. This is only a halfmeasure and
    // does not fix the big problem, but it does make the tests go more
    // stable on slow networks.
    BufferedSender.prototype.sendScheduleWait = function() {
      debug$2('sendScheduleWait');
      var self = this;
      var tref;
      this.sendStop = function() {
        debug$2('sendStop');
        self.sendStop = null;
        clearTimeout(tref);
      };
      tref = setTimeout(function() {
        debug$2('timeout');
        self.sendStop = null;
        self.sendSchedule();
      }, 25);
    };

    BufferedSender.prototype.sendSchedule = function() {
      debug$2('sendSchedule', this.sendBuffer.length);
      var self = this;
      if (this.sendBuffer.length > 0) {
        var payload = '[' + this.sendBuffer.join(',') + ']';
        this.sendStop = this.sender(this.url, payload, function(err) {
          self.sendStop = null;
          if (err) {
            debug$2('error', err);
            self.emit('close', err.code || 1006, 'Sending error: ' + err);
            self.close();
          } else {
            self.sendScheduleWait();
          }
        });
        this.sendBuffer = [];
      }
    };

    BufferedSender.prototype._cleanup = function() {
      debug$2('_cleanup');
      this.removeAllListeners();
    };

    BufferedSender.prototype.close = function() {
      debug$2('close');
      this._cleanup();
      if (this.sendStop) {
        this.sendStop();
        this.sendStop = null;
      }
    };

    var bufferedSender = BufferedSender;

    var EventEmitter$3 = emitter.EventEmitter
      ;

    var debug$3 = function() {};

    function Polling(Receiver, receiveUrl, AjaxObject) {
      debug$3(receiveUrl);
      EventEmitter$3.call(this);
      this.Receiver = Receiver;
      this.receiveUrl = receiveUrl;
      this.AjaxObject = AjaxObject;
      this._scheduleReceiver();
    }

    inherits_browser(Polling, EventEmitter$3);

    Polling.prototype._scheduleReceiver = function() {
      debug$3('_scheduleReceiver');
      var self = this;
      var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

      poll.on('message', function(msg) {
        debug$3('message', msg);
        self.emit('message', msg);
      });

      poll.once('close', function(code, reason) {
        debug$3('close', code, reason, self.pollIsClosing);
        self.poll = poll = null;

        if (!self.pollIsClosing) {
          if (reason === 'network') {
            self._scheduleReceiver();
          } else {
            self.emit('close', code || 1006, reason);
            self.removeAllListeners();
          }
        }
      });
    };

    Polling.prototype.abort = function() {
      debug$3('abort');
      this.removeAllListeners();
      this.pollIsClosing = true;
      if (this.poll) {
        this.poll.abort();
      }
    };

    var polling = Polling;

    var debug$4 = function() {};

    function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
      var pollUrl = url.addPath(transUrl, urlSuffix);
      debug$4(pollUrl);
      var self = this;
      bufferedSender.call(this, transUrl, senderFunc);

      this.poll = new polling(Receiver, pollUrl, AjaxObject);
      this.poll.on('message', function(msg) {
        debug$4('poll message', msg);
        self.emit('message', msg);
      });
      this.poll.once('close', function(code, reason) {
        debug$4('poll close', code, reason);
        self.poll = null;
        self.emit('close', code, reason);
        self.close();
      });
    }

    inherits_browser(SenderReceiver, bufferedSender);

    SenderReceiver.prototype.close = function() {
      bufferedSender.prototype.close.call(this);
      debug$4('close');
      this.removeAllListeners();
      if (this.poll) {
        this.poll.abort();
        this.poll = null;
      }
    };

    var senderReceiver = SenderReceiver;

    var debug$5 = function() {};

    function createAjaxSender(AjaxObject) {
      return function(url$1, payload, callback) {
        debug$5('create ajax sender', url$1, payload);
        var opt = {};
        if (typeof payload === 'string') {
          opt.headers = {'Content-type': 'text/plain'};
        }
        var ajaxUrl = url.addPath(url$1, '/xhr_send');
        var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
        xo.once('finish', function(status) {
          debug$5('finish', status);
          xo = null;

          if (status !== 200 && status !== 204) {
            return callback(new Error('http status ' + status));
          }
          callback();
        });
        return function() {
          debug$5('abort');
          xo.close();
          xo = null;

          var err = new Error('Aborted');
          err.code = 1000;
          callback(err);
        };
      };
    }

    function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
      senderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
    }

    inherits_browser(AjaxBasedTransport, senderReceiver);

    var ajaxBased = AjaxBasedTransport;

    var EventEmitter$4 = emitter.EventEmitter
      ;

    var debug$6 = function() {};

    function XhrReceiver(url, AjaxObject) {
      debug$6(url);
      EventEmitter$4.call(this);
      var self = this;

      this.bufferPosition = 0;

      this.xo = new AjaxObject('POST', url, null);
      this.xo.on('chunk', this._chunkHandler.bind(this));
      this.xo.once('finish', function(status, text) {
        debug$6('finish', status, text);
        self._chunkHandler(status, text);
        self.xo = null;
        var reason = status === 200 ? 'network' : 'permanent';
        debug$6('close', reason);
        self.emit('close', null, reason);
        self._cleanup();
      });
    }

    inherits_browser(XhrReceiver, EventEmitter$4);

    XhrReceiver.prototype._chunkHandler = function(status, text) {
      debug$6('_chunkHandler', status);
      if (status !== 200 || !text) {
        return;
      }

      for (var idx = -1; ; this.bufferPosition += idx + 1) {
        var buf = text.slice(this.bufferPosition);
        idx = buf.indexOf('\n');
        if (idx === -1) {
          break;
        }
        var msg = buf.slice(0, idx);
        if (msg) {
          debug$6('message', msg);
          this.emit('message', msg);
        }
      }
    };

    XhrReceiver.prototype._cleanup = function() {
      debug$6('_cleanup');
      this.removeAllListeners();
    };

    XhrReceiver.prototype.abort = function() {
      debug$6('abort');
      if (this.xo) {
        this.xo.close();
        debug$6('close');
        this.emit('close', null, 'user');
        this.xo = null;
      }
      this._cleanup();
    };

    var xhr = XhrReceiver;

    var EventEmitter$5 = emitter.EventEmitter
      , XHR = global$1.XMLHttpRequest
      ;

    var debug$7 = function() {};

    function AbstractXHRObject(method, url, payload, opts) {
      debug$7(method, url);
      var self = this;
      EventEmitter$5.call(this);

      setTimeout(function () {
        self._start(method, url, payload, opts);
      }, 0);
    }

    inherits_browser(AbstractXHRObject, EventEmitter$5);

    AbstractXHRObject.prototype._start = function(method, url$1, payload, opts) {
      var self = this;

      try {
        this.xhr = new XHR();
      } catch (x) {
        // intentionally empty
      }

      if (!this.xhr) {
        debug$7('no xhr');
        this.emit('finish', 0, 'no xhr support');
        this._cleanup();
        return;
      }

      // several browsers cache POSTs
      url$1 = url.addQuery(url$1, 't=' + (+new Date()));

      // Explorer tends to keep connection open, even after the
      // tab gets closed: http://bugs.jquery.com/ticket/5280
      this.unloadRef = event.unloadAdd(function() {
        debug$7('unload cleanup');
        self._cleanup(true);
      });
      try {
        this.xhr.open(method, url$1, true);
        if (this.timeout && 'timeout' in this.xhr) {
          this.xhr.timeout = this.timeout;
          this.xhr.ontimeout = function() {
            debug$7('xhr timeout');
            self.emit('finish', 0, '');
            self._cleanup(false);
          };
        }
      } catch (e) {
        debug$7('exception', e);
        // IE raises an exception on wrong port.
        this.emit('finish', 0, '');
        this._cleanup(false);
        return;
      }

      if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
        debug$7('withCredentials');
        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
        // "This never affects same-site requests."

        this.xhr.withCredentials = true;
      }
      if (opts && opts.headers) {
        for (var key in opts.headers) {
          this.xhr.setRequestHeader(key, opts.headers[key]);
        }
      }

      this.xhr.onreadystatechange = function() {
        if (self.xhr) {
          var x = self.xhr;
          var text, status;
          debug$7('readyState', x.readyState);
          switch (x.readyState) {
          case 3:
            // IE doesn't like peeking into responseText or status
            // on Microsoft.XMLHTTP and readystate=3
            try {
              status = x.status;
              text = x.responseText;
            } catch (e) {
              // intentionally empty
            }
            debug$7('status', status);
            // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
            if (status === 1223) {
              status = 204;
            }

            // IE does return readystate == 3 for 404 answers.
            if (status === 200 && text && text.length > 0) {
              debug$7('chunk');
              self.emit('chunk', status, text);
            }
            break;
          case 4:
            status = x.status;
            debug$7('status', status);
            // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
            if (status === 1223) {
              status = 204;
            }
            // IE returns this for a bad port
            // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
            if (status === 12005 || status === 12029) {
              status = 0;
            }

            debug$7('finish', status, x.responseText);
            self.emit('finish', status, x.responseText);
            self._cleanup(false);
            break;
          }
        }
      };

      try {
        self.xhr.send(payload);
      } catch (e) {
        self.emit('finish', 0, '');
        self._cleanup(false);
      }
    };

    AbstractXHRObject.prototype._cleanup = function(abort) {
      debug$7('cleanup');
      if (!this.xhr) {
        return;
      }
      this.removeAllListeners();
      event.unloadDel(this.unloadRef);

      // IE needs this field to be a function
      this.xhr.onreadystatechange = function() {};
      if (this.xhr.ontimeout) {
        this.xhr.ontimeout = null;
      }

      if (abort) {
        try {
          this.xhr.abort();
        } catch (x) {
          // intentionally empty
        }
      }
      this.unloadRef = this.xhr = null;
    };

    AbstractXHRObject.prototype.close = function() {
      debug$7('close');
      this._cleanup(true);
    };

    AbstractXHRObject.enabled = !!XHR;
    // override XMLHttpRequest for IE6/7
    // obfuscate to avoid firewalls
    var axo = ['Active'].concat('Object').join('X');
    if (!AbstractXHRObject.enabled && (axo in global$1)) {
      debug$7('overriding xmlhttprequest');
      XHR = function() {
        try {
          return new global$1[axo]('Microsoft.XMLHTTP');
        } catch (e) {
          return null;
        }
      };
      AbstractXHRObject.enabled = !!new XHR();
    }

    var cors = false;
    try {
      cors = 'withCredentials' in new XHR();
    } catch (ignored) {
      // intentionally empty
    }

    AbstractXHRObject.supportsCORS = cors;

    var abstractXhr = AbstractXHRObject;

    function XHRCorsObject(method, url, payload, opts) {
      abstractXhr.call(this, method, url, payload, opts);
    }

    inherits_browser(XHRCorsObject, abstractXhr);

    XHRCorsObject.enabled = abstractXhr.enabled && abstractXhr.supportsCORS;

    var xhrCors = XHRCorsObject;

    function XHRLocalObject(method, url, payload /*, opts */) {
      abstractXhr.call(this, method, url, payload, {
        noCredentials: true
      });
    }

    inherits_browser(XHRLocalObject, abstractXhr);

    XHRLocalObject.enabled = abstractXhr.enabled;

    var xhrLocal = XHRLocalObject;

    var browser$1 = {
      isOpera: function() {
        return global$1.navigator &&
          /opera/i.test(global$1.navigator.userAgent);
      }

    , isKonqueror: function() {
        return global$1.navigator &&
          /konqueror/i.test(global$1.navigator.userAgent);
      }

      // #187 wrap document.domain in try/catch because of WP8 from file:///
    , hasDomain: function () {
        // non-browser client always has a domain
        if (!global$1.document) {
          return true;
        }

        try {
          return !!global$1.document.domain;
        } catch (e) {
          return false;
        }
      }
    };

    function XhrStreamingTransport(transUrl) {
      if (!xhrLocal.enabled && !xhrCors.enabled) {
        throw new Error('Transport created when disabled');
      }
      ajaxBased.call(this, transUrl, '/xhr_streaming', xhr, xhrCors);
    }

    inherits_browser(XhrStreamingTransport, ajaxBased);

    XhrStreamingTransport.enabled = function(info) {
      if (info.nullOrigin) {
        return false;
      }
      // Opera doesn't support xhr-streaming #60
      // But it might be able to #92
      if (browser$1.isOpera()) {
        return false;
      }

      return xhrCors.enabled;
    };

    XhrStreamingTransport.transportName = 'xhr-streaming';
    XhrStreamingTransport.roundTrips = 2; // preflight, ajax

    // Safari gets confused when a streaming ajax request is started
    // before onload. This causes the load indicator to spin indefinetely.
    // Only require body when used in a browser
    XhrStreamingTransport.needBody = !!global$1.document;

    var xhrStreaming = XhrStreamingTransport;

    var EventEmitter$6 = emitter.EventEmitter
      ;

    var debug$8 = function() {};

    // References:
    //   http://ajaxian.com/archives/100-line-ajax-wrapper
    //   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

    function XDRObject(method, url, payload) {
      debug$8(method, url);
      var self = this;
      EventEmitter$6.call(this);

      setTimeout(function() {
        self._start(method, url, payload);
      }, 0);
    }

    inherits_browser(XDRObject, EventEmitter$6);

    XDRObject.prototype._start = function(method, url$1, payload) {
      debug$8('_start');
      var self = this;
      var xdr = new global$1.XDomainRequest();
      // IE caches even POSTs
      url$1 = url.addQuery(url$1, 't=' + (+new Date()));

      xdr.onerror = function() {
        debug$8('onerror');
        self._error();
      };
      xdr.ontimeout = function() {
        debug$8('ontimeout');
        self._error();
      };
      xdr.onprogress = function() {
        debug$8('progress', xdr.responseText);
        self.emit('chunk', 200, xdr.responseText);
      };
      xdr.onload = function() {
        debug$8('load');
        self.emit('finish', 200, xdr.responseText);
        self._cleanup(false);
      };
      this.xdr = xdr;
      this.unloadRef = event.unloadAdd(function() {
        self._cleanup(true);
      });
      try {
        // Fails with AccessDenied if port number is bogus
        this.xdr.open(method, url$1);
        if (this.timeout) {
          this.xdr.timeout = this.timeout;
        }
        this.xdr.send(payload);
      } catch (x) {
        this._error();
      }
    };

    XDRObject.prototype._error = function() {
      this.emit('finish', 0, '');
      this._cleanup(false);
    };

    XDRObject.prototype._cleanup = function(abort) {
      debug$8('cleanup', abort);
      if (!this.xdr) {
        return;
      }
      this.removeAllListeners();
      event.unloadDel(this.unloadRef);

      this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
      if (abort) {
        try {
          this.xdr.abort();
        } catch (x) {
          // intentionally empty
        }
      }
      this.unloadRef = this.xdr = null;
    };

    XDRObject.prototype.close = function() {
      debug$8('close');
      this._cleanup(true);
    };

    // IE 8/9 if the request target uses the same scheme - #79
    XDRObject.enabled = !!(global$1.XDomainRequest && browser$1.hasDomain());

    var xdr = XDRObject;

    // According to:
    //   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
    //   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

    function XdrStreamingTransport(transUrl) {
      if (!xdr.enabled) {
        throw new Error('Transport created when disabled');
      }
      ajaxBased.call(this, transUrl, '/xhr_streaming', xhr, xdr);
    }

    inherits_browser(XdrStreamingTransport, ajaxBased);

    XdrStreamingTransport.enabled = function(info) {
      if (info.cookie_needed || info.nullOrigin) {
        return false;
      }
      return xdr.enabled && info.sameScheme;
    };

    XdrStreamingTransport.transportName = 'xdr-streaming';
    XdrStreamingTransport.roundTrips = 2; // preflight, ajax

    var xdrStreaming = XdrStreamingTransport;

    var eventsource = global$1.EventSource;

    var EventEmitter$7 = emitter.EventEmitter
      ;

    var debug$9 = function() {};

    function EventSourceReceiver(url) {
      debug$9(url);
      EventEmitter$7.call(this);

      var self = this;
      var es = this.es = new eventsource(url);
      es.onmessage = function(e) {
        debug$9('message', e.data);
        self.emit('message', decodeURI(e.data));
      };
      es.onerror = function(e) {
        debug$9('error', es.readyState, e);
        // ES on reconnection has readyState = 0 or 1.
        // on network error it's CLOSED = 2
        var reason = (es.readyState !== 2 ? 'network' : 'permanent');
        self._cleanup();
        self._close(reason);
      };
    }

    inherits_browser(EventSourceReceiver, EventEmitter$7);

    EventSourceReceiver.prototype.abort = function() {
      debug$9('abort');
      this._cleanup();
      this._close('user');
    };

    EventSourceReceiver.prototype._cleanup = function() {
      debug$9('cleanup');
      var es = this.es;
      if (es) {
        es.onmessage = es.onerror = null;
        es.close();
        this.es = null;
      }
    };

    EventSourceReceiver.prototype._close = function(reason) {
      debug$9('close', reason);
      var self = this;
      // Safari and chrome < 15 crash if we close window before
      // waiting for ES cleanup. See:
      // https://code.google.com/p/chromium/issues/detail?id=89155
      setTimeout(function() {
        self.emit('close', null, reason);
        self.removeAllListeners();
      }, 200);
    };

    var eventsource$1 = EventSourceReceiver;

    function EventSourceTransport(transUrl) {
      if (!EventSourceTransport.enabled()) {
        throw new Error('Transport created when disabled');
      }

      ajaxBased.call(this, transUrl, '/eventsource', eventsource$1, xhrCors);
    }

    inherits_browser(EventSourceTransport, ajaxBased);

    EventSourceTransport.enabled = function() {
      return !!eventsource;
    };

    EventSourceTransport.transportName = 'eventsource';
    EventSourceTransport.roundTrips = 2;

    var eventsource$2 = EventSourceTransport;

    var json3 = createCommonjsModule(function (module, exports) {
    (function () {
      // Detect the `define` function exposed by asynchronous module loaders. The
      // strict `define` check is necessary for compatibility with `r.js`.
      var isLoader = typeof undefined === "function" && undefined.amd;

      // A set of types used to distinguish objects from primitives.
      var objectTypes = {
        "function": true,
        "object": true
      };

      // Detect the `exports` object exposed by CommonJS implementations.
      var freeExports = exports && !exports.nodeType && exports;

      // Use the `global` object exposed by Node (including Browserify via
      // `insert-module-globals`), Narwhal, and Ringo as the default context,
      // and the `window` object in browsers. Rhino exports a `global` function
      // instead.
      var root = objectTypes[typeof window] && window || this,
          freeGlobal = freeExports && objectTypes['object'] && module && !module.nodeType && typeof global$1 == "object" && global$1;

      if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
        root = freeGlobal;
      }

      // Public: Initializes JSON 3 using the given `context` object, attaching the
      // `stringify` and `parse` functions to the specified `exports` object.
      function runInContext(context, exports) {
        context || (context = root["Object"]());
        exports || (exports = root["Object"]());

        // Native constructor aliases.
        var Number = context["Number"] || root["Number"],
            String = context["String"] || root["String"],
            Object = context["Object"] || root["Object"],
            Date = context["Date"] || root["Date"],
            SyntaxError = context["SyntaxError"] || root["SyntaxError"],
            TypeError = context["TypeError"] || root["TypeError"],
            Math = context["Math"] || root["Math"],
            nativeJSON = context["JSON"] || root["JSON"];

        // Delegate to the native `stringify` and `parse` implementations.
        if (typeof nativeJSON == "object" && nativeJSON) {
          exports.stringify = nativeJSON.stringify;
          exports.parse = nativeJSON.parse;
        }

        // Convenience aliases.
        var objectProto = Object.prototype,
            getClass = objectProto.toString,
            isProperty, forEach, undef;

        // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
        var isExtended = new Date(-3509827334573292);
        try {
          // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
          // results for certain dates in Opera >= 10.53.
          isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
            // Safari < 2.0.2 stores the internal millisecond time value correctly,
            // but clips the values returned by the date methods to the range of
            // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
            isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
        } catch (exception) {}

        // Internal: Determines whether the native `JSON.stringify` and `parse`
        // implementations are spec-compliant. Based on work by Ken Snyder.
        function has(name) {
          if (has[name] !== undef) {
            // Return cached feature test result.
            return has[name];
          }
          var isSupported;
          if (name == "bug-string-char-index") {
            // IE <= 7 doesn't support accessing string characters using square
            // bracket notation. IE 8 only supports this for primitives.
            isSupported = "a"[0] != "a";
          } else if (name == "json") {
            // Indicates whether both `JSON.stringify` and `JSON.parse` are
            // supported.
            isSupported = has("json-stringify") && has("json-parse");
          } else {
            var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
            // Test `JSON.stringify`.
            if (name == "json-stringify") {
              var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
              if (stringifySupported) {
                // A test function object with a custom `toJSON` method.
                (value = function () {
                  return 1;
                }).toJSON = value;
                try {
                  stringifySupported =
                    // Firefox 3.1b1 and b2 serialize string, number, and boolean
                    // primitives as object literals.
                    stringify(0) === "0" &&
                    // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                    // literals.
                    stringify(new Number()) === "0" &&
                    stringify(new String()) == '""' &&
                    // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                    // does not define a canonical JSON representation (this applies to
                    // objects with `toJSON` properties as well, *unless* they are nested
                    // within an object or array).
                    stringify(getClass) === undef &&
                    // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                    // FF 3.1b3 pass this test.
                    stringify(undef) === undef &&
                    // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                    // respectively, if the value is omitted entirely.
                    stringify() === undef &&
                    // FF 3.1b1, 2 throw an error if the given value is not a number,
                    // string, array, object, Boolean, or `null` literal. This applies to
                    // objects with custom `toJSON` methods as well, unless they are nested
                    // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                    // methods entirely.
                    stringify(value) === "1" &&
                    stringify([value]) == "[1]" &&
                    // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                    // `"[null]"`.
                    stringify([undef]) == "[null]" &&
                    // YUI 3.0.0b1 fails to serialize `null` literals.
                    stringify(null) == "null" &&
                    // FF 3.1b1, 2 halts serialization if an array contains a function:
                    // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                    // elides non-JSON values from objects and arrays, unless they
                    // define custom `toJSON` methods.
                    stringify([undef, getClass, null]) == "[null,null,null]" &&
                    // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                    // where character escape codes are expected (e.g., `\b` => `\u0008`).
                    stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                    // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                    stringify(null, value) === "1" &&
                    stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                    // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                    // serialize extended years.
                    stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                    // The milliseconds are optional in ES 5, but required in 5.1.
                    stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                    // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                    // four-digit years instead of six-digit years. Credits: @Yaffle.
                    stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                    // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                    // values less than 1000. Credits: @Yaffle.
                    stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
                } catch (exception) {
                  stringifySupported = false;
                }
              }
              isSupported = stringifySupported;
            }
            // Test `JSON.parse`.
            if (name == "json-parse") {
              var parse = exports.parse;
              if (typeof parse == "function") {
                try {
                  // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
                  // Conforming implementations should also coerce the initial argument to
                  // a string prior to parsing.
                  if (parse("0") === 0 && !parse(false)) {
                    // Simple parsing test.
                    value = parse(serialized);
                    var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                    if (parseSupported) {
                      try {
                        // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                        parseSupported = !parse('"\t"');
                      } catch (exception) {}
                      if (parseSupported) {
                        try {
                          // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                          // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                          // certain octal literals.
                          parseSupported = parse("01") !== 1;
                        } catch (exception) {}
                      }
                      if (parseSupported) {
                        try {
                          // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                          // points. These environments, along with FF 3.1b1 and 2,
                          // also allow trailing commas in JSON objects and arrays.
                          parseSupported = parse("1.") !== 1;
                        } catch (exception) {}
                      }
                    }
                  }
                } catch (exception) {
                  parseSupported = false;
                }
              }
              isSupported = parseSupported;
            }
          }
          return has[name] = !!isSupported;
        }

        if (!has("json")) {
          // Common `[[Class]]` name aliases.
          var functionClass = "[object Function]",
              dateClass = "[object Date]",
              numberClass = "[object Number]",
              stringClass = "[object String]",
              arrayClass = "[object Array]",
              booleanClass = "[object Boolean]";

          // Detect incomplete support for accessing string characters by index.
          var charIndexBuggy = has("bug-string-char-index");

          // Define additional utility methods if the `Date` methods are buggy.
          if (!isExtended) {
            var floor = Math.floor;
            // A mapping between the months of the year and the number of days between
            // January 1st and the first of the respective month.
            var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
            // Internal: Calculates the number of days between the Unix epoch and the
            // first day of the given month.
            var getDay = function (year, month) {
              return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
            };
          }

          // Internal: Determines if a property is a direct property of the given
          // object. Delegates to the native `Object#hasOwnProperty` method.
          if (!(isProperty = objectProto.hasOwnProperty)) {
            isProperty = function (property) {
              var members = {}, constructor;
              if ((members.__proto__ = null, members.__proto__ = {
                // The *proto* property cannot be set multiple times in recent
                // versions of Firefox and SeaMonkey.
                "toString": 1
              }, members).toString != getClass) {
                // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
                // supports the mutable *proto* property.
                isProperty = function (property) {
                  // Capture and break the object's prototype chain (see section 8.6.2
                  // of the ES 5.1 spec). The parenthesized expression prevents an
                  // unsafe transformation by the Closure Compiler.
                  var original = this.__proto__, result = property in (this.__proto__ = null, this);
                  // Restore the original prototype chain.
                  this.__proto__ = original;
                  return result;
                };
              } else {
                // Capture a reference to the top-level `Object` constructor.
                constructor = members.constructor;
                // Use the `constructor` property to simulate `Object#hasOwnProperty` in
                // other environments.
                isProperty = function (property) {
                  var parent = (this.constructor || constructor).prototype;
                  return property in this && !(property in parent && this[property] === parent[property]);
                };
              }
              members = null;
              return isProperty.call(this, property);
            };
          }

          // Internal: Normalizes the `for...in` iteration algorithm across
          // environments. Each enumerated key is yielded to a `callback` function.
          forEach = function (object, callback) {
            var size = 0, Properties, members, property;

            // Tests for bugs in the current environment's `for...in` algorithm. The
            // `valueOf` property inherits the non-enumerable flag from
            // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
            (Properties = function () {
              this.valueOf = 0;
            }).prototype.valueOf = 0;

            // Iterate over a new instance of the `Properties` class.
            members = new Properties();
            for (property in members) {
              // Ignore all properties inherited from `Object.prototype`.
              if (isProperty.call(members, property)) {
                size++;
              }
            }
            Properties = members = null;

            // Normalize the iteration algorithm.
            if (!size) {
              // A list of non-enumerable properties inherited from `Object.prototype`.
              members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
              // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
              // properties.
              forEach = function (object, callback) {
                var isFunction = getClass.call(object) == functionClass, property, length;
                var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
                for (property in object) {
                  // Gecko <= 1.0 enumerates the `prototype` property of functions under
                  // certain conditions; IE does not.
                  if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                    callback(property);
                  }
                }
                // Manually invoke the callback for each non-enumerable property.
                for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
              };
            } else if (size == 2) {
              // Safari <= 2.0.4 enumerates shadowed properties twice.
              forEach = function (object, callback) {
                // Create a set of iterated properties.
                var members = {}, isFunction = getClass.call(object) == functionClass, property;
                for (property in object) {
                  // Store each property name to prevent double enumeration. The
                  // `prototype` property of functions is not enumerated due to cross-
                  // environment inconsistencies.
                  if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                    callback(property);
                  }
                }
              };
            } else {
              // No bugs detected; use the standard `for...in` algorithm.
              forEach = function (object, callback) {
                var isFunction = getClass.call(object) == functionClass, property, isConstructor;
                for (property in object) {
                  if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                    callback(property);
                  }
                }
                // Manually invoke the callback for the `constructor` property due to
                // cross-environment inconsistencies.
                if (isConstructor || isProperty.call(object, (property = "constructor"))) {
                  callback(property);
                }
              };
            }
            return forEach(object, callback);
          };

          // Public: Serializes a JavaScript `value` as a JSON string. The optional
          // `filter` argument may specify either a function that alters how object and
          // array members are serialized, or an array of strings and numbers that
          // indicates which properties should be serialized. The optional `width`
          // argument may be either a string or number that specifies the indentation
          // level of the output.
          if (!has("json-stringify")) {
            // Internal: A map of control characters and their escaped equivalents.
            var Escapes = {
              92: "\\\\",
              34: '\\"',
              8: "\\b",
              12: "\\f",
              10: "\\n",
              13: "\\r",
              9: "\\t"
            };

            // Internal: Converts `value` into a zero-padded string such that its
            // length is at least equal to `width`. The `width` must be <= 6.
            var leadingZeroes = "000000";
            var toPaddedString = function (width, value) {
              // The `|| 0` expression is necessary to work around a bug in
              // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
              return (leadingZeroes + (value || 0)).slice(-width);
            };

            // Internal: Double-quotes a string `value`, replacing all ASCII control
            // characters (characters with code unit values between 0 and 31) with
            // their escaped equivalents. This is an implementation of the
            // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
            var unicodePrefix = "\\u00";
            var quote = function (value) {
              var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
              var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
              for (; index < length; index++) {
                var charCode = value.charCodeAt(index);
                // If the character is a control character, append its Unicode or
                // shorthand escape sequence; otherwise, append the character as-is.
                switch (charCode) {
                  case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                    result += Escapes[charCode];
                    break;
                  default:
                    if (charCode < 32) {
                      result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                      break;
                    }
                    result += useCharIndex ? symbols[index] : value.charAt(index);
                }
              }
              return result + '"';
            };

            // Internal: Recursively serializes an object. Implements the
            // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
            var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
              var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
              try {
                // Necessary for host object support.
                value = object[property];
              } catch (exception) {}
              if (typeof value == "object" && value) {
                className = getClass.call(value);
                if (className == dateClass && !isProperty.call(value, "toJSON")) {
                  if (value > -1 / 0 && value < 1 / 0) {
                    // Dates are serialized according to the `Date#toJSON` method
                    // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                    // for the ISO 8601 date time string format.
                    if (getDay) {
                      // Manually compute the year, month, date, hours, minutes,
                      // seconds, and milliseconds if the `getUTC*` methods are
                      // buggy. Adapted from @Yaffle's `date-shim` project.
                      date = floor(value / 864e5);
                      for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                      for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                      date = 1 + date - getDay(year, month);
                      // The `time` value specifies the time within the day (see ES
                      // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                      // to compute `A modulo B`, as the `%` operator does not
                      // correspond to the `modulo` operation for negative numbers.
                      time = (value % 864e5 + 864e5) % 864e5;
                      // The hours, minutes, seconds, and milliseconds are obtained by
                      // decomposing the time within the day. See section 15.9.1.10.
                      hours = floor(time / 36e5) % 24;
                      minutes = floor(time / 6e4) % 60;
                      seconds = floor(time / 1e3) % 60;
                      milliseconds = time % 1e3;
                    } else {
                      year = value.getUTCFullYear();
                      month = value.getUTCMonth();
                      date = value.getUTCDate();
                      hours = value.getUTCHours();
                      minutes = value.getUTCMinutes();
                      seconds = value.getUTCSeconds();
                      milliseconds = value.getUTCMilliseconds();
                    }
                    // Serialize extended years correctly.
                    value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                      "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                      // Months, dates, hours, minutes, and seconds should have two
                      // digits; milliseconds should have three.
                      "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                      // Milliseconds are optional in ES 5.0, but required in 5.1.
                      "." + toPaddedString(3, milliseconds) + "Z";
                  } else {
                    value = null;
                  }
                } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
                  // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
                  // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
                  // ignores all `toJSON` methods on these objects unless they are
                  // defined directly on an instance.
                  value = value.toJSON(property);
                }
              }
              if (callback) {
                // If a replacement function was provided, call it to obtain the value
                // for serialization.
                value = callback.call(object, property, value);
              }
              if (value === null) {
                return "null";
              }
              className = getClass.call(value);
              if (className == booleanClass) {
                // Booleans are represented literally.
                return "" + value;
              } else if (className == numberClass) {
                // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
                // `"null"`.
                return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
              } else if (className == stringClass) {
                // Strings are double-quoted and escaped.
                return quote("" + value);
              }
              // Recursively serialize objects and arrays.
              if (typeof value == "object") {
                // Check for cyclic structures. This is a linear search; performance
                // is inversely proportional to the number of unique nested objects.
                for (length = stack.length; length--;) {
                  if (stack[length] === value) {
                    // Cyclic structures cannot be serialized by `JSON.stringify`.
                    throw TypeError();
                  }
                }
                // Add the object to the stack of traversed objects.
                stack.push(value);
                results = [];
                // Save the current indentation level and indent one additional level.
                prefix = indentation;
                indentation += whitespace;
                if (className == arrayClass) {
                  // Recursively serialize array elements.
                  for (index = 0, length = value.length; index < length; index++) {
                    element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                    results.push(element === undef ? "null" : element);
                  }
                  result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
                } else {
                  // Recursively serialize object members. Members are selected from
                  // either a user-specified list of property names, or the object
                  // itself.
                  forEach(properties || value, function (property) {
                    var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                    if (element !== undef) {
                      // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                      // is not the empty string, let `member` {quote(property) + ":"}
                      // be the concatenation of `member` and the `space` character."
                      // The "`space` character" refers to the literal space
                      // character, not the `space` {width} argument provided to
                      // `JSON.stringify`.
                      results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                    }
                  });
                  result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
                }
                // Remove the object from the traversed object stack.
                stack.pop();
                return result;
              }
            };

            // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
            exports.stringify = function (source, filter, width) {
              var whitespace, callback, properties, className;
              if (objectTypes[typeof filter] && filter) {
                if ((className = getClass.call(filter)) == functionClass) {
                  callback = filter;
                } else if (className == arrayClass) {
                  // Convert the property names array into a makeshift set.
                  properties = {};
                  for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
                }
              }
              if (width) {
                if ((className = getClass.call(width)) == numberClass) {
                  // Convert the `width` to an integer and create a string containing
                  // `width` number of space characters.
                  if ((width -= width % 1) > 0) {
                    for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
                  }
                } else if (className == stringClass) {
                  whitespace = width.length <= 10 ? width : width.slice(0, 10);
                }
              }
              // Opera <= 7.54u2 discards the values associated with empty string keys
              // (`""`) only if they are used directly within an object member list
              // (e.g., `!("" in { "": 1})`).
              return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
            };
          }

          // Public: Parses a JSON source string.
          if (!has("json-parse")) {
            var fromCharCode = String.fromCharCode;

            // Internal: A map of escaped control characters and their unescaped
            // equivalents.
            var Unescapes = {
              92: "\\",
              34: '"',
              47: "/",
              98: "\b",
              116: "\t",
              110: "\n",
              102: "\f",
              114: "\r"
            };

            // Internal: Stores the parser state.
            var Index, Source;

            // Internal: Resets the parser state and throws a `SyntaxError`.
            var abort = function () {
              Index = Source = null;
              throw SyntaxError();
            };

            // Internal: Returns the next token, or `"$"` if the parser has reached
            // the end of the source string. A token may be a string, number, `null`
            // literal, or Boolean literal.
            var lex = function () {
              var source = Source, length = source.length, value, begin, position, isSigned, charCode;
              while (Index < length) {
                charCode = source.charCodeAt(Index);
                switch (charCode) {
                  case 9: case 10: case 13: case 32:
                    // Skip whitespace tokens, including tabs, carriage returns, line
                    // feeds, and space characters.
                    Index++;
                    break;
                  case 123: case 125: case 91: case 93: case 58: case 44:
                    // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                    // the current position.
                    value = charIndexBuggy ? source.charAt(Index) : source[Index];
                    Index++;
                    return value;
                  case 34:
                    // `"` delimits a JSON string; advance to the next character and
                    // begin parsing the string. String tokens are prefixed with the
                    // sentinel `@` character to distinguish them from punctuators and
                    // end-of-string tokens.
                    for (value = "@", Index++; Index < length;) {
                      charCode = source.charCodeAt(Index);
                      if (charCode < 32) {
                        // Unescaped ASCII control characters (those with a code unit
                        // less than the space character) are not permitted.
                        abort();
                      } else if (charCode == 92) {
                        // A reverse solidus (`\`) marks the beginning of an escaped
                        // control character (including `"`, `\`, and `/`) or Unicode
                        // escape sequence.
                        charCode = source.charCodeAt(++Index);
                        switch (charCode) {
                          case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                            // Revive escaped control characters.
                            value += Unescapes[charCode];
                            Index++;
                            break;
                          case 117:
                            // `\u` marks the beginning of a Unicode escape sequence.
                            // Advance to the first character and validate the
                            // four-digit code point.
                            begin = ++Index;
                            for (position = Index + 4; Index < position; Index++) {
                              charCode = source.charCodeAt(Index);
                              // A valid sequence comprises four hexdigits (case-
                              // insensitive) that form a single hexadecimal value.
                              if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                                // Invalid Unicode escape sequence.
                                abort();
                              }
                            }
                            // Revive the escaped character.
                            value += fromCharCode("0x" + source.slice(begin, Index));
                            break;
                          default:
                            // Invalid escape sequence.
                            abort();
                        }
                      } else {
                        if (charCode == 34) {
                          // An unescaped double-quote character marks the end of the
                          // string.
                          break;
                        }
                        charCode = source.charCodeAt(Index);
                        begin = Index;
                        // Optimize for the common case where a string is valid.
                        while (charCode >= 32 && charCode != 92 && charCode != 34) {
                          charCode = source.charCodeAt(++Index);
                        }
                        // Append the string as-is.
                        value += source.slice(begin, Index);
                      }
                    }
                    if (source.charCodeAt(Index) == 34) {
                      // Advance to the next character and return the revived string.
                      Index++;
                      return value;
                    }
                    // Unterminated string.
                    abort();
                  default:
                    // Parse numbers and literals.
                    begin = Index;
                    // Advance past the negative sign, if one is specified.
                    if (charCode == 45) {
                      isSigned = true;
                      charCode = source.charCodeAt(++Index);
                    }
                    // Parse an integer or floating-point value.
                    if (charCode >= 48 && charCode <= 57) {
                      // Leading zeroes are interpreted as octal literals.
                      if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                        // Illegal octal literal.
                        abort();
                      }
                      isSigned = false;
                      // Parse the integer component.
                      for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                      // Floats cannot contain a leading decimal point; however, this
                      // case is already accounted for by the parser.
                      if (source.charCodeAt(Index) == 46) {
                        position = ++Index;
                        // Parse the decimal component.
                        for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                        if (position == Index) {
                          // Illegal trailing decimal.
                          abort();
                        }
                        Index = position;
                      }
                      // Parse exponents. The `e` denoting the exponent is
                      // case-insensitive.
                      charCode = source.charCodeAt(Index);
                      if (charCode == 101 || charCode == 69) {
                        charCode = source.charCodeAt(++Index);
                        // Skip past the sign following the exponent, if one is
                        // specified.
                        if (charCode == 43 || charCode == 45) {
                          Index++;
                        }
                        // Parse the exponential component.
                        for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                        if (position == Index) {
                          // Illegal empty exponent.
                          abort();
                        }
                        Index = position;
                      }
                      // Coerce the parsed value to a JavaScript number.
                      return +source.slice(begin, Index);
                    }
                    // A negative sign may only precede numbers.
                    if (isSigned) {
                      abort();
                    }
                    // `true`, `false`, and `null` literals.
                    if (source.slice(Index, Index + 4) == "true") {
                      Index += 4;
                      return true;
                    } else if (source.slice(Index, Index + 5) == "false") {
                      Index += 5;
                      return false;
                    } else if (source.slice(Index, Index + 4) == "null") {
                      Index += 4;
                      return null;
                    }
                    // Unrecognized token.
                    abort();
                }
              }
              // Return the sentinel `$` character if the parser has reached the end
              // of the source string.
              return "$";
            };

            // Internal: Parses a JSON `value` token.
            var get = function (value) {
              var results, hasMembers;
              if (value == "$") {
                // Unexpected end of input.
                abort();
              }
              if (typeof value == "string") {
                if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
                  // Remove the sentinel `@` character.
                  return value.slice(1);
                }
                // Parse object and array literals.
                if (value == "[") {
                  // Parses a JSON array, returning a new JavaScript array.
                  results = [];
                  for (;; hasMembers || (hasMembers = true)) {
                    value = lex();
                    // A closing square bracket marks the end of the array literal.
                    if (value == "]") {
                      break;
                    }
                    // If the array literal contains elements, the current token
                    // should be a comma separating the previous element from the
                    // next.
                    if (hasMembers) {
                      if (value == ",") {
                        value = lex();
                        if (value == "]") {
                          // Unexpected trailing `,` in array literal.
                          abort();
                        }
                      } else {
                        // A `,` must separate each array element.
                        abort();
                      }
                    }
                    // Elisions and leading commas are not permitted.
                    if (value == ",") {
                      abort();
                    }
                    results.push(get(value));
                  }
                  return results;
                } else if (value == "{") {
                  // Parses a JSON object, returning a new JavaScript object.
                  results = {};
                  for (;; hasMembers || (hasMembers = true)) {
                    value = lex();
                    // A closing curly brace marks the end of the object literal.
                    if (value == "}") {
                      break;
                    }
                    // If the object literal contains members, the current token
                    // should be a comma separator.
                    if (hasMembers) {
                      if (value == ",") {
                        value = lex();
                        if (value == "}") {
                          // Unexpected trailing `,` in object literal.
                          abort();
                        }
                      } else {
                        // A `,` must separate each object member.
                        abort();
                      }
                    }
                    // Leading commas are not permitted, object property names must be
                    // double-quoted strings, and a `:` must separate each property
                    // name and value.
                    if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                      abort();
                    }
                    results[value.slice(1)] = get(lex());
                  }
                  return results;
                }
                // Unexpected token encountered.
                abort();
              }
              return value;
            };

            // Internal: Updates a traversed object member.
            var update = function (source, property, callback) {
              var element = walk(source, property, callback);
              if (element === undef) {
                delete source[property];
              } else {
                source[property] = element;
              }
            };

            // Internal: Recursively traverses a parsed JSON object, invoking the
            // `callback` function for each value. This is an implementation of the
            // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
            var walk = function (source, property, callback) {
              var value = source[property], length;
              if (typeof value == "object" && value) {
                // `forEach` can't be used to traverse an array in Opera <= 8.54
                // because its `Object#hasOwnProperty` implementation returns `false`
                // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
                if (getClass.call(value) == arrayClass) {
                  for (length = value.length; length--;) {
                    update(value, length, callback);
                  }
                } else {
                  forEach(value, function (property) {
                    update(value, property, callback);
                  });
                }
              }
              return callback.call(source, property, value);
            };

            // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
            exports.parse = function (source, callback) {
              var result, value;
              Index = 0;
              Source = "" + source;
              result = get(lex());
              // If a JSON string contains multiple tokens, it is invalid.
              if (lex() != "$") {
                abort();
              }
              // Reset the parser state.
              Index = Source = null;
              return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
            };
          }
        }

        exports["runInContext"] = runInContext;
        return exports;
      }

      if (freeExports && !isLoader) {
        // Export for CommonJS environments.
        runInContext(root, freeExports);
      } else {
        // Export for web browsers and JavaScript engines.
        var nativeJSON = root.JSON,
            previousJSON = root["JSON3"],
            isRestored = false;

        var JSON3 = runInContext(root, (root["JSON3"] = {
          // Public: Restores the original value of the global `JSON` object and
          // returns a reference to the `JSON3` object.
          "noConflict": function () {
            if (!isRestored) {
              isRestored = true;
              root.JSON = nativeJSON;
              root["JSON3"] = previousJSON;
              nativeJSON = previousJSON = null;
            }
            return JSON3;
          }
        }));

        root.JSON = {
          "parse": JSON3.parse,
          "stringify": JSON3.stringify
        };
      }
    }).call(this);
    });

    var version = '1.3.0';

    var iframe = createCommonjsModule(function (module) {



    var debug = function() {};

    module.exports = {
      WPrefix: '_jp'
    , currentWindowId: null

    , polluteGlobalNamespace: function() {
        if (!(module.exports.WPrefix in global$1)) {
          global$1[module.exports.WPrefix] = {};
        }
      }

    , postMessage: function(type, data) {
        if (global$1.parent !== global$1) {
          global$1.parent.postMessage(json3.stringify({
            windowId: module.exports.currentWindowId
          , type: type
          , data: data || ''
          }), '*');
        } else {
          debug('Cannot postMessage, no parent window.', type, data);
        }
      }

    , createIframe: function(iframeUrl, errorCallback) {
        var iframe = global$1.document.createElement('iframe');
        var tref, unloadRef;
        var unattach = function() {
          debug('unattach');
          clearTimeout(tref);
          // Explorer had problems with that.
          try {
            iframe.onload = null;
          } catch (x) {
            // intentionally empty
          }
          iframe.onerror = null;
        };
        var cleanup = function() {
          debug('cleanup');
          if (iframe) {
            unattach();
            // This timeout makes chrome fire onbeforeunload event
            // within iframe. Without the timeout it goes straight to
            // onunload.
            setTimeout(function() {
              if (iframe) {
                iframe.parentNode.removeChild(iframe);
              }
              iframe = null;
            }, 0);
            event.unloadDel(unloadRef);
          }
        };
        var onerror = function(err) {
          debug('onerror', err);
          if (iframe) {
            cleanup();
            errorCallback(err);
          }
        };
        var post = function(msg, origin) {
          debug('post', msg, origin);
          setTimeout(function() {
            try {
              // When the iframe is not loaded, IE raises an exception
              // on 'contentWindow'.
              if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage(msg, origin);
              }
            } catch (x) {
              // intentionally empty
            }
          }, 0);
        };

        iframe.src = iframeUrl;
        iframe.style.display = 'none';
        iframe.style.position = 'absolute';
        iframe.onerror = function() {
          onerror('onerror');
        };
        iframe.onload = function() {
          debug('onload');
          // `onload` is triggered before scripts on the iframe are
          // executed. Give it few seconds to actually load stuff.
          clearTimeout(tref);
          tref = setTimeout(function() {
            onerror('onload timeout');
          }, 2000);
        };
        global$1.document.body.appendChild(iframe);
        tref = setTimeout(function() {
          onerror('timeout');
        }, 15000);
        unloadRef = event.unloadAdd(cleanup);
        return {
          post: post
        , cleanup: cleanup
        , loaded: unattach
        };
      }

    /* eslint no-undef: "off", new-cap: "off" */
    , createHtmlfile: function(iframeUrl, errorCallback) {
        var axo = ['Active'].concat('Object').join('X');
        var doc = new global$1[axo]('htmlfile');
        var tref, unloadRef;
        var iframe;
        var unattach = function() {
          clearTimeout(tref);
          iframe.onerror = null;
        };
        var cleanup = function() {
          if (doc) {
            unattach();
            event.unloadDel(unloadRef);
            iframe.parentNode.removeChild(iframe);
            iframe = doc = null;
            CollectGarbage();
          }
        };
        var onerror = function(r) {
          debug('onerror', r);
          if (doc) {
            cleanup();
            errorCallback(r);
          }
        };
        var post = function(msg, origin) {
          try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            setTimeout(function() {
              if (iframe && iframe.contentWindow) {
                  iframe.contentWindow.postMessage(msg, origin);
              }
            }, 0);
          } catch (x) {
            // intentionally empty
          }
        };

        doc.open();
        doc.write('<html><s' + 'cript>' +
                  'document.domain="' + global$1.document.domain + '";' +
                  '</s' + 'cript></html>');
        doc.close();
        doc.parentWindow[module.exports.WPrefix] = global$1[module.exports.WPrefix];
        var c = doc.createElement('div');
        doc.body.appendChild(c);
        iframe = doc.createElement('iframe');
        c.appendChild(iframe);
        iframe.src = iframeUrl;
        iframe.onerror = function() {
          onerror('onerror');
        };
        tref = setTimeout(function() {
          onerror('timeout');
        }, 15000);
        unloadRef = event.unloadAdd(cleanup);
        return {
          post: post
        , cleanup: cleanup
        , loaded: unattach
        };
      }
    };

    module.exports.iframeEnabled = false;
    if (global$1.document) {
      // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
      // huge delay, or not at all.
      module.exports.iframeEnabled = (typeof global$1.postMessage === 'function' ||
        typeof global$1.postMessage === 'object') && (!browser$1.isKonqueror());
    }
    });
    var iframe_1 = iframe.WPrefix;
    var iframe_2 = iframe.currentWindowId;
    var iframe_3 = iframe.polluteGlobalNamespace;
    var iframe_4 = iframe.postMessage;
    var iframe_5 = iframe.createIframe;
    var iframe_6 = iframe.createHtmlfile;
    var iframe_7 = iframe.iframeEnabled;

    // Few cool transports do work only for same-origin. In order to make
    // them work cross-domain we shall use iframe, served from the
    // remote domain. New browsers have capabilities to communicate with
    // cross domain iframe using postMessage(). In IE it was implemented
    // from IE 8+, but of course, IE got some details wrong:
    //    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
    //    http://stevesouders.com/misc/test-postmessage.php

    var EventEmitter$8 = emitter.EventEmitter
      ;

    var debug$a = function() {};

    function IframeTransport(transport, transUrl, baseUrl) {
      if (!IframeTransport.enabled()) {
        throw new Error('Transport created when disabled');
      }
      EventEmitter$8.call(this);

      var self = this;
      this.origin = url.getOrigin(baseUrl);
      this.baseUrl = baseUrl;
      this.transUrl = transUrl;
      this.transport = transport;
      this.windowId = random.string(8);

      var iframeUrl = url.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
      debug$a(transport, transUrl, iframeUrl);

      this.iframeObj = iframe.createIframe(iframeUrl, function(r) {
        debug$a('err callback');
        self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
        self.close();
      });

      this.onmessageCallback = this._message.bind(this);
      event.attachEvent('message', this.onmessageCallback);
    }

    inherits_browser(IframeTransport, EventEmitter$8);

    IframeTransport.prototype.close = function() {
      debug$a('close');
      this.removeAllListeners();
      if (this.iframeObj) {
        event.detachEvent('message', this.onmessageCallback);
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          this.postMessage('c');
        } catch (x) {
          // intentionally empty
        }
        this.iframeObj.cleanup();
        this.iframeObj = null;
        this.onmessageCallback = this.iframeObj = null;
      }
    };

    IframeTransport.prototype._message = function(e) {
      debug$a('message', e.data);
      if (!url.isOriginEqual(e.origin, this.origin)) {
        debug$a('not same origin', e.origin, this.origin);
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = json3.parse(e.data);
      } catch (ignored) {
        debug$a('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== this.windowId) {
        debug$a('mismatched window id', iframeMessage.windowId, this.windowId);
        return;
      }

      switch (iframeMessage.type) {
      case 's':
        this.iframeObj.loaded();
        // window global dependency
        this.postMessage('s', json3.stringify([
          version
        , this.transport
        , this.transUrl
        , this.baseUrl
        ]));
        break;
      case 't':
        this.emit('message', iframeMessage.data);
        break;
      case 'c':
        var cdata;
        try {
          cdata = json3.parse(iframeMessage.data);
        } catch (ignored) {
          debug$a('bad json', iframeMessage.data);
          return;
        }
        this.emit('close', cdata[0], cdata[1]);
        this.close();
        break;
      }
    };

    IframeTransport.prototype.postMessage = function(type, data) {
      debug$a('postMessage', type, data);
      this.iframeObj.post(json3.stringify({
        windowId: this.windowId
      , type: type
      , data: data || ''
      }), this.origin);
    };

    IframeTransport.prototype.send = function(message) {
      debug$a('send', message);
      this.postMessage('m', message);
    };

    IframeTransport.enabled = function() {
      return iframe.iframeEnabled;
    };

    IframeTransport.transportName = 'iframe';
    IframeTransport.roundTrips = 2;

    var iframe$1 = IframeTransport;

    var object = {
      isObject: function(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;
      }

    , extend: function(obj) {
        if (!this.isObject(obj)) {
          return obj;
        }
        var source, prop;
        for (var i = 1, length = arguments.length; i < length; i++) {
          source = arguments[i];
          for (prop in source) {
            if (Object.prototype.hasOwnProperty.call(source, prop)) {
              obj[prop] = source[prop];
            }
          }
        }
        return obj;
      }
    };

    var iframeWrap = function(transport) {

      function IframeWrapTransport(transUrl, baseUrl) {
        iframe$1.call(this, transport.transportName, transUrl, baseUrl);
      }

      inherits_browser(IframeWrapTransport, iframe$1);

      IframeWrapTransport.enabled = function(url, info) {
        if (!global$1.document) {
          return false;
        }

        var iframeInfo = object.extend({}, info);
        iframeInfo.sameOrigin = true;
        return transport.enabled(iframeInfo) && iframe$1.enabled();
      };

      IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
      IframeWrapTransport.needBody = true;
      IframeWrapTransport.roundTrips = iframe$1.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

      IframeWrapTransport.facadeTransport = transport;

      return IframeWrapTransport;
    };

    var EventEmitter$9 = emitter.EventEmitter
      ;

    var debug$b = function() {};

    function HtmlfileReceiver(url$1) {
      debug$b(url$1);
      EventEmitter$9.call(this);
      var self = this;
      iframe.polluteGlobalNamespace();

      this.id = 'a' + random.string(6);
      url$1 = url.addQuery(url$1, 'c=' + decodeURIComponent(iframe.WPrefix + '.' + this.id));

      debug$b('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
      var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
          iframe.createHtmlfile : iframe.createIframe;

      global$1[iframe.WPrefix][this.id] = {
        start: function() {
          debug$b('start');
          self.iframeObj.loaded();
        }
      , message: function(data) {
          debug$b('message', data);
          self.emit('message', data);
        }
      , stop: function() {
          debug$b('stop');
          self._cleanup();
          self._close('network');
        }
      };
      this.iframeObj = constructFunc(url$1, function() {
        debug$b('callback');
        self._cleanup();
        self._close('permanent');
      });
    }

    inherits_browser(HtmlfileReceiver, EventEmitter$9);

    HtmlfileReceiver.prototype.abort = function() {
      debug$b('abort');
      this._cleanup();
      this._close('user');
    };

    HtmlfileReceiver.prototype._cleanup = function() {
      debug$b('_cleanup');
      if (this.iframeObj) {
        this.iframeObj.cleanup();
        this.iframeObj = null;
      }
      delete global$1[iframe.WPrefix][this.id];
    };

    HtmlfileReceiver.prototype._close = function(reason) {
      debug$b('_close', reason);
      this.emit('close', null, reason);
      this.removeAllListeners();
    };

    HtmlfileReceiver.htmlfileEnabled = false;

    // obfuscate to avoid firewalls
    var axo$1 = ['Active'].concat('Object').join('X');
    if (axo$1 in global$1) {
      try {
        HtmlfileReceiver.htmlfileEnabled = !!new global$1[axo$1]('htmlfile');
      } catch (x) {
        // intentionally empty
      }
    }

    HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframe.iframeEnabled;

    var htmlfile = HtmlfileReceiver;

    function HtmlFileTransport(transUrl) {
      if (!htmlfile.enabled) {
        throw new Error('Transport created when disabled');
      }
      ajaxBased.call(this, transUrl, '/htmlfile', htmlfile, xhrLocal);
    }

    inherits_browser(HtmlFileTransport, ajaxBased);

    HtmlFileTransport.enabled = function(info) {
      return htmlfile.enabled && info.sameOrigin;
    };

    HtmlFileTransport.transportName = 'htmlfile';
    HtmlFileTransport.roundTrips = 2;

    var htmlfile$1 = HtmlFileTransport;

    function XhrPollingTransport(transUrl) {
      if (!xhrLocal.enabled && !xhrCors.enabled) {
        throw new Error('Transport created when disabled');
      }
      ajaxBased.call(this, transUrl, '/xhr', xhr, xhrCors);
    }

    inherits_browser(XhrPollingTransport, ajaxBased);

    XhrPollingTransport.enabled = function(info) {
      if (info.nullOrigin) {
        return false;
      }

      if (xhrLocal.enabled && info.sameOrigin) {
        return true;
      }
      return xhrCors.enabled;
    };

    XhrPollingTransport.transportName = 'xhr-polling';
    XhrPollingTransport.roundTrips = 2; // preflight, ajax

    var xhrPolling = XhrPollingTransport;

    function XdrPollingTransport(transUrl) {
      if (!xdr.enabled) {
        throw new Error('Transport created when disabled');
      }
      ajaxBased.call(this, transUrl, '/xhr', xhr, xdr);
    }

    inherits_browser(XdrPollingTransport, ajaxBased);

    XdrPollingTransport.enabled = xdrStreaming.enabled;
    XdrPollingTransport.transportName = 'xdr-polling';
    XdrPollingTransport.roundTrips = 2; // preflight, ajax

    var xdrPolling = XdrPollingTransport;

    var EventEmitter$a = emitter.EventEmitter
      ;

    var debug$c = function() {};

    function JsonpReceiver(url$1) {
      debug$c(url$1);
      var self = this;
      EventEmitter$a.call(this);

      iframe.polluteGlobalNamespace();

      this.id = 'a' + random.string(6);
      var urlWithId = url.addQuery(url$1, 'c=' + encodeURIComponent(iframe.WPrefix + '.' + this.id));

      global$1[iframe.WPrefix][this.id] = this._callback.bind(this);
      this._createScript(urlWithId);

      // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
      this.timeoutId = setTimeout(function() {
        debug$c('timeout');
        self._abort(new Error('JSONP script loaded abnormally (timeout)'));
      }, JsonpReceiver.timeout);
    }

    inherits_browser(JsonpReceiver, EventEmitter$a);

    JsonpReceiver.prototype.abort = function() {
      debug$c('abort');
      if (global$1[iframe.WPrefix][this.id]) {
        var err = new Error('JSONP user aborted read');
        err.code = 1000;
        this._abort(err);
      }
    };

    JsonpReceiver.timeout = 35000;
    JsonpReceiver.scriptErrorTimeout = 1000;

    JsonpReceiver.prototype._callback = function(data) {
      debug$c('_callback', data);
      this._cleanup();

      if (this.aborting) {
        return;
      }

      if (data) {
        debug$c('message', data);
        this.emit('message', data);
      }
      this.emit('close', null, 'network');
      this.removeAllListeners();
    };

    JsonpReceiver.prototype._abort = function(err) {
      debug$c('_abort', err);
      this._cleanup();
      this.aborting = true;
      this.emit('close', err.code, err.message);
      this.removeAllListeners();
    };

    JsonpReceiver.prototype._cleanup = function() {
      debug$c('_cleanup');
      clearTimeout(this.timeoutId);
      if (this.script2) {
        this.script2.parentNode.removeChild(this.script2);
        this.script2 = null;
      }
      if (this.script) {
        var script = this.script;
        // Unfortunately, you can't really abort script loading of
        // the script.
        script.parentNode.removeChild(script);
        script.onreadystatechange = script.onerror =
            script.onload = script.onclick = null;
        this.script = null;
      }
      delete global$1[iframe.WPrefix][this.id];
    };

    JsonpReceiver.prototype._scriptError = function() {
      debug$c('_scriptError');
      var self = this;
      if (this.errorTimer) {
        return;
      }

      this.errorTimer = setTimeout(function() {
        if (!self.loadedOkay) {
          self._abort(new Error('JSONP script loaded abnormally (onerror)'));
        }
      }, JsonpReceiver.scriptErrorTimeout);
    };

    JsonpReceiver.prototype._createScript = function(url) {
      debug$c('_createScript', url);
      var self = this;
      var script = this.script = global$1.document.createElement('script');
      var script2;  // Opera synchronous load trick.

      script.id = 'a' + random.string(8);
      script.src = url;
      script.type = 'text/javascript';
      script.charset = 'UTF-8';
      script.onerror = this._scriptError.bind(this);
      script.onload = function() {
        debug$c('onload');
        self._abort(new Error('JSONP script loaded abnormally (onload)'));
      };

      // IE9 fires 'error' event after onreadystatechange or before, in random order.
      // Use loadedOkay to determine if actually errored
      script.onreadystatechange = function() {
        debug$c('onreadystatechange', script.readyState);
        if (/loaded|closed/.test(script.readyState)) {
          if (script && script.htmlFor && script.onclick) {
            self.loadedOkay = true;
            try {
              // In IE, actually execute the script.
              script.onclick();
            } catch (x) {
              // intentionally empty
            }
          }
          if (script) {
            self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
          }
        }
      };
      // IE: event/htmlFor/onclick trick.
      // One can't rely on proper order for onreadystatechange. In order to
      // make sure, set a 'htmlFor' and 'event' properties, so that
      // script code will be installed as 'onclick' handler for the
      // script object. Later, onreadystatechange, manually execute this
      // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
      // set. For reference see:
      //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
      // Also, read on that about script ordering:
      //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
      if (typeof script.async === 'undefined' && global$1.document.attachEvent) {
        // According to mozilla docs, in recent browsers script.async defaults
        // to 'true', so we may use it to detect a good browser:
        // https://developer.mozilla.org/en/HTML/Element/script
        if (!browser$1.isOpera()) {
          // Naively assume we're in IE
          try {
            script.htmlFor = script.id;
            script.event = 'onclick';
          } catch (x) {
            // intentionally empty
          }
          script.async = true;
        } else {
          // Opera, second sync script hack
          script2 = this.script2 = global$1.document.createElement('script');
          script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
          script.async = script2.async = false;
        }
      }
      if (typeof script.async !== 'undefined') {
        script.async = true;
      }

      var head = global$1.document.getElementsByTagName('head')[0];
      head.insertBefore(script, head.firstChild);
      if (script2) {
        head.insertBefore(script2, head.firstChild);
      }
    };

    var jsonp = JsonpReceiver;

    var debug$d = function() {};

    var form, area;

    function createIframe(id) {
      debug$d('createIframe', id);
      try {
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
        return global$1.document.createElement('<iframe name="' + id + '">');
      } catch (x) {
        var iframe = global$1.document.createElement('iframe');
        iframe.name = id;
        return iframe;
      }
    }

    function createForm() {
      debug$d('createForm');
      form = global$1.document.createElement('form');
      form.style.display = 'none';
      form.style.position = 'absolute';
      form.method = 'POST';
      form.enctype = 'application/x-www-form-urlencoded';
      form.acceptCharset = 'UTF-8';

      area = global$1.document.createElement('textarea');
      area.name = 'd';
      form.appendChild(area);

      global$1.document.body.appendChild(form);
    }

    var jsonp$1 = function(url$1, payload, callback) {
      debug$d(url$1, payload);
      if (!form) {
        createForm();
      }
      var id = 'a' + random.string(8);
      form.target = id;
      form.action = url.addQuery(url.addPath(url$1, '/jsonp_send'), 'i=' + id);

      var iframe = createIframe(id);
      iframe.id = id;
      iframe.style.display = 'none';
      form.appendChild(iframe);

      try {
        area.value = payload;
      } catch (e) {
        // seriously broken browsers get here
      }
      form.submit();

      var completed = function(err) {
        debug$d('completed', id, err);
        if (!iframe.onerror) {
          return;
        }
        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
        // Opera mini doesn't like if we GC iframe
        // immediately, thus this timeout.
        setTimeout(function() {
          debug$d('cleaning up', id);
          iframe.parentNode.removeChild(iframe);
          iframe = null;
        }, 500);
        area.value = '';
        // It is not possible to detect if the iframe succeeded or
        // failed to submit our form.
        callback(err);
      };
      iframe.onerror = function() {
        debug$d('onerror', id);
        completed();
      };
      iframe.onload = function() {
        debug$d('onload', id);
        completed();
      };
      iframe.onreadystatechange = function(e) {
        debug$d('onreadystatechange', id, iframe.readyState, e);
        if (iframe.readyState === 'complete') {
          completed();
        }
      };
      return function() {
        debug$d('aborted', id);
        completed(new Error('Aborted'));
      };
    };

    // The simplest and most robust transport, using the well-know cross
    // domain hack - JSONP. This transport is quite inefficient - one
    // message could use up to one http request. But at least it works almost
    // everywhere.
    // Known limitations:
    //   o you will get a spinning cursor
    //   o for Konqueror a dumb timer is needed to detect errors



    function JsonPTransport(transUrl) {
      if (!JsonPTransport.enabled()) {
        throw new Error('Transport created when disabled');
      }
      senderReceiver.call(this, transUrl, '/jsonp', jsonp$1, jsonp);
    }

    inherits_browser(JsonPTransport, senderReceiver);

    JsonPTransport.enabled = function() {
      return !!global$1.document;
    };

    JsonPTransport.transportName = 'jsonp-polling';
    JsonPTransport.roundTrips = 1;
    JsonPTransport.needBody = true;

    var jsonpPolling = JsonPTransport;

    var transportList = [
      // streaming transports
      websocket$1
    , xhrStreaming
    , xdrStreaming
    , eventsource$2
    , iframeWrap(eventsource$2)

      // polling transports
    , htmlfile$1
    , iframeWrap(htmlfile$1)
    , xhrPolling
    , xdrPolling
    , iframeWrap(xhrPolling)
    , jsonpPolling
    ];

    /* eslint-disable */

    // pulled specific shims from https://github.com/es-shims/es5-shim

    var ArrayPrototype = Array.prototype;
    var ObjectPrototype = Object.prototype;
    var FunctionPrototype = Function.prototype;
    var StringPrototype = String.prototype;
    var array_slice = ArrayPrototype.slice;

    var _toString = ObjectPrototype.toString;
    var isFunction$1 = function (val) {
        return ObjectPrototype.toString.call(val) === '[object Function]';
    };
    var isArray$1 = function isArray(obj) {
        return _toString.call(obj) === '[object Array]';
    };
    var isString$1 = function isString(obj) {
        return _toString.call(obj) === '[object String]';
    };

    var supportsDescriptors = Object.defineProperty && (function () {
        try {
            Object.defineProperty({}, 'x', {});
            return true;
        } catch (e) { /* this is ES3 */
            return false;
        }
    }());

    // Define configurable, writable and non-enumerable props
    // if they don't exist.
    var defineProperty;
    if (supportsDescriptors) {
        defineProperty = function (object, name, method, forceAssign) {
            if (!forceAssign && (name in object)) { return; }
            Object.defineProperty(object, name, {
                configurable: true,
                enumerable: false,
                writable: true,
                value: method
            });
        };
    } else {
        defineProperty = function (object, name, method, forceAssign) {
            if (!forceAssign && (name in object)) { return; }
            object[name] = method;
        };
    }
    var defineProperties = function (object, map, forceAssign) {
        for (var name in map) {
            if (ObjectPrototype.hasOwnProperty.call(map, name)) {
              defineProperty(object, name, map[name], forceAssign);
            }
        }
    };

    var toObject = function (o) {
        if (o == null) { // this matches both null and undefined
            throw new TypeError("can't convert " + o + ' to object');
        }
        return Object(o);
    };

    //
    // Util
    // ======
    //

    // ES5 9.4
    // http://es5.github.com/#x9.4
    // http://jsperf.com/to-integer

    function toInteger(num) {
        var n = +num;
        if (n !== n) { // isNaN
            n = 0;
        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
            n = (n > 0 || -1) * Math.floor(Math.abs(n));
        }
        return n;
    }

    function ToUint32(x) {
        return x >>> 0;
    }

    //
    // Function
    // ========
    //

    // ES-5 15.3.4.5
    // http://es5.github.com/#x15.3.4.5

    function Empty() {}

    defineProperties(FunctionPrototype, {
        bind: function bind(that) { // .length is 1
            // 1. Let Target be the this value.
            var target = this;
            // 2. If IsCallable(Target) is false, throw a TypeError exception.
            if (!isFunction$1(target)) {
                throw new TypeError('Function.prototype.bind called on incompatible ' + target);
            }
            // 3. Let A be a new (possibly empty) internal list of all of the
            //   argument values provided after thisArg (arg1, arg2 etc), in order.
            // XXX slicedArgs will stand in for "A" if used
            var args = array_slice.call(arguments, 1); // for normal call
            // 4. Let F be a new native ECMAScript object.
            // 11. Set the [[Prototype]] internal property of F to the standard
            //   built-in Function prototype object as specified in 15.3.3.1.
            // 12. Set the [[Call]] internal property of F as described in
            //   15.3.4.5.1.
            // 13. Set the [[Construct]] internal property of F as described in
            //   15.3.4.5.2.
            // 14. Set the [[HasInstance]] internal property of F as described in
            //   15.3.4.5.3.
            var binder = function () {

                if (this instanceof bound) {
                    // 15.3.4.5.2 [[Construct]]
                    // When the [[Construct]] internal method of a function object,
                    // F that was created using the bind function is called with a
                    // list of arguments ExtraArgs, the following steps are taken:
                    // 1. Let target be the value of F's [[TargetFunction]]
                    //   internal property.
                    // 2. If target has no [[Construct]] internal method, a
                    //   TypeError exception is thrown.
                    // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Construct]] internal
                    //   method of target providing args as the arguments.

                    var result = target.apply(
                        this,
                        args.concat(array_slice.call(arguments))
                    );
                    if (Object(result) === result) {
                        return result;
                    }
                    return this;

                } else {
                    // 15.3.4.5.1 [[Call]]
                    // When the [[Call]] internal method of a function object, F,
                    // which was created using the bind function is called with a
                    // this value and a list of arguments ExtraArgs, the following
                    // steps are taken:
                    // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 2. Let boundThis be the value of F's [[BoundThis]] internal
                    //   property.
                    // 3. Let target be the value of F's [[TargetFunction]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Call]] internal method
                    //   of target providing boundThis as the this value and
                    //   providing args as the arguments.

                    // equiv: target.call(this, ...boundArgs, ...args)
                    return target.apply(
                        that,
                        args.concat(array_slice.call(arguments))
                    );

                }

            };

            // 15. If the [[Class]] internal property of Target is "Function", then
            //     a. Let L be the length property of Target minus the length of A.
            //     b. Set the length own property of F to either 0 or L, whichever is
            //       larger.
            // 16. Else set the length own property of F to 0.

            var boundLength = Math.max(0, target.length - args.length);

            // 17. Set the attributes of the length own property of F to the values
            //   specified in 15.3.5.1.
            var boundArgs = [];
            for (var i = 0; i < boundLength; i++) {
                boundArgs.push('$' + i);
            }

            // XXX Build a dynamic function with desired amount of arguments is the only
            // way to set the length property of a function.
            // In environments where Content Security Policies enabled (Chrome extensions,
            // for ex.) all use of eval or Function costructor throws an exception.
            // However in all of these environments Function.prototype.bind exists
            // and so this code will never be executed.
            var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

            if (target.prototype) {
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                // Clean up dangling references.
                Empty.prototype = null;
            }

            // TODO
            // 18. Set the [[Extensible]] internal property of F to true.

            // TODO
            // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
            // 20. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
            //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
            //   false.
            // 21. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
            //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
            //   and false.

            // TODO
            // NOTE Function objects created using Function.prototype.bind do not
            // have a prototype property or the [[Code]], [[FormalParameters]], and
            // [[Scope]] internal properties.
            // XXX can't delete prototype in pure-js.

            // 22. Return F.
            return bound;
        }
    });

    //
    // Array
    // =====
    //

    // ES5 15.4.3.2
    // http://es5.github.com/#x15.4.3.2
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
    defineProperties(Array, { isArray: isArray$1 });


    var boxedString = Object('a');
    var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

    var properlyBoxesContext = function properlyBoxed(method) {
        // Check node 0.6.21 bug where third parameter is not boxed
        var properlyBoxesNonStrict = true;
        var properlyBoxesStrict = true;
        if (method) {
            method.call('foo', function (_, __, context) {
                if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
            });

            method.call([1], function () {
                properlyBoxesStrict = typeof this === 'string';
            }, 'x');
        }
        return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
    };

    defineProperties(ArrayPrototype, {
        forEach: function forEach(fun /*, thisp*/) {
            var object = toObject(this),
                self = splitString && isString$1(this) ? this.split('') : object,
                thisp = arguments[1],
                i = -1,
                length = self.length >>> 0;

            // If no callback function or if callback is not a callable function
            if (!isFunction$1(fun)) {
                throw new TypeError(); // TODO message
            }

            while (++i < length) {
                if (i in self) {
                    // Invoke the callback function with call, passing arguments:
                    // context, property value, property key, thisArg object
                    // context
                    fun.call(thisp, self[i], i, object);
                }
            }
        }
    }, !properlyBoxesContext(ArrayPrototype.forEach));

    // ES5 15.4.4.14
    // http://es5.github.com/#x15.4.4.14
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
    var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
    defineProperties(ArrayPrototype, {
        indexOf: function indexOf(sought /*, fromIndex */ ) {
            var self = splitString && isString$1(this) ? this.split('') : toObject(this),
                length = self.length >>> 0;

            if (!length) {
                return -1;
            }

            var i = 0;
            if (arguments.length > 1) {
                i = toInteger(arguments[1]);
            }

            // handle negative indices
            i = i >= 0 ? i : Math.max(0, length + i);
            for (; i < length; i++) {
                if (i in self && self[i] === sought) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2IndexOfBug);

    //
    // String
    // ======
    //

    // ES5 15.5.4.14
    // http://es5.github.com/#x15.5.4.14

    // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
    // Many browsers do not split properly with regular expressions or they
    // do not perform the split correctly under obscure conditions.
    // See http://blog.stevenlevithan.com/archives/cross-browser-split
    // I've tested in many browsers and this seems to cover the deviant ones:
    //    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
    //    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
    //    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
    //       [undefined, "t", undefined, "e", ...]
    //    ''.split(/.?/) should be [], not [""]
    //    '.'.split(/()()/) should be ["."], not ["", "", "."]

    var string_split = StringPrototype.split;
    if (
        'ab'.split(/(?:ab)*/).length !== 2 ||
        '.'.split(/(.?)(.?)/).length !== 4 ||
        'tesst'.split(/(s)*/)[1] === 't' ||
        'test'.split(/(?:)/, -1).length !== 4 ||
        ''.split(/.?/).length ||
        '.'.split(/()()/).length > 1
    ) {
        (function () {
            var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

            StringPrototype.split = function (separator, limit) {
                var string = this;
                if (separator === void 0 && limit === 0) {
                    return [];
                }

                // If `separator` is not a regex, use native split
                if (_toString.call(separator) !== '[object RegExp]') {
                    return string_split.call(this, separator, limit);
                }

                var output = [],
                    flags = (separator.ignoreCase ? 'i' : '') +
                            (separator.multiline  ? 'm' : '') +
                            (separator.extended   ? 'x' : '') + // Proposed for ES6
                            (separator.sticky     ? 'y' : ''), // Firefox 3+
                    lastLastIndex = 0,
                    // Make `global` and avoid `lastIndex` issues by working with a copy
                    separator2, match, lastIndex, lastLength;
                separator = new RegExp(separator.source, flags + 'g');
                string += ''; // Type-convert
                if (!compliantExecNpcg) {
                    // Doesn't need flags gy, but they don't hurt
                    separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
                }
                /* Values for `limit`, per the spec:
                 * If undefined: 4294967295 // Math.pow(2, 32) - 1
                 * If 0, Infinity, or NaN: 0
                 * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
                 * If negative number: 4294967296 - Math.floor(Math.abs(limit))
                 * If other: Type-convert, then use the above rules
                 */
                limit = limit === void 0 ?
                    -1 >>> 0 : // Math.pow(2, 32) - 1
                    ToUint32(limit);
                while (match = separator.exec(string)) {
                    // `separator.lastIndex` is not reliable cross-browser
                    lastIndex = match.index + match[0].length;
                    if (lastIndex > lastLastIndex) {
                        output.push(string.slice(lastLastIndex, match.index));
                        // Fix browsers whose `exec` methods don't consistently return `undefined` for
                        // nonparticipating capturing groups
                        if (!compliantExecNpcg && match.length > 1) {
                            match[0].replace(separator2, function () {
                                for (var i = 1; i < arguments.length - 2; i++) {
                                    if (arguments[i] === void 0) {
                                        match[i] = void 0;
                                    }
                                }
                            });
                        }
                        if (match.length > 1 && match.index < string.length) {
                            ArrayPrototype.push.apply(output, match.slice(1));
                        }
                        lastLength = match[0].length;
                        lastLastIndex = lastIndex;
                        if (output.length >= limit) {
                            break;
                        }
                    }
                    if (separator.lastIndex === match.index) {
                        separator.lastIndex++; // Avoid an infinite loop
                    }
                }
                if (lastLastIndex === string.length) {
                    if (lastLength || !separator.test('')) {
                        output.push('');
                    }
                } else {
                    output.push(string.slice(lastLastIndex));
                }
                return output.length > limit ? output.slice(0, limit) : output;
            };
        }());

    // [bugfix, chrome]
    // If separator is undefined, then the result array contains just one String,
    // which is the this value (converted to a String). If limit is not undefined,
    // then the output array is truncated so that it contains no more than limit
    // elements.
    // "0".split(undefined, 0) -> []
    } else if ('0'.split(void 0, 0).length) {
        StringPrototype.split = function split(separator, limit) {
            if (separator === void 0 && limit === 0) { return []; }
            return string_split.call(this, separator, limit);
        };
    }

    // ECMA-262, 3rd B.2.3
    // Not an ECMAScript standard, although ECMAScript 3rd Edition has a
    // non-normative section suggesting uniform semantics and it should be
    // normalized across all browsers
    // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
    var string_substr = StringPrototype.substr;
    var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
    defineProperties(StringPrototype, {
        substr: function substr(start, length) {
            return string_substr.call(
                this,
                start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
                length
            );
        }
    }, hasNegativeSubstrBug);

    // Some extra characters that Chrome gets wrong, and substitutes with
    // something else on the wire.
    // eslint-disable-next-line no-control-regex
    var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
      , extraLookup;

    // This may be quite slow, so let's delay until user actually uses bad
    // characters.
    var unrollLookup = function(escapable) {
      var i;
      var unrolled = {};
      var c = [];
      for (i = 0; i < 65536; i++) {
        c.push( String.fromCharCode(i) );
      }
      escapable.lastIndex = 0;
      c.join('').replace(escapable, function(a) {
        unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        return '';
      });
      escapable.lastIndex = 0;
      return unrolled;
    };

    // Quote string, also taking care of unicode characters that browsers
    // often break. Especially, take care of unicode surrogates:
    // http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
    var _escape = {
      quote: function(string) {
        var quoted = json3.stringify(string);

        // In most cases this should be very fast and good enough.
        extraEscapable.lastIndex = 0;
        if (!extraEscapable.test(quoted)) {
          return quoted;
        }

        if (!extraLookup) {
          extraLookup = unrollLookup(extraEscapable);
        }

        return quoted.replace(extraEscapable, function(a) {
          return extraLookup[a];
        });
      }
    };

    var debug$e = function() {};

    var transport = function(availableTransports) {
      return {
        filterToEnabled: function(transportsWhitelist, info) {
          var transports = {
            main: []
          , facade: []
          };
          if (!transportsWhitelist) {
            transportsWhitelist = [];
          } else if (typeof transportsWhitelist === 'string') {
            transportsWhitelist = [transportsWhitelist];
          }

          availableTransports.forEach(function(trans) {
            if (!trans) {
              return;
            }

            if (trans.transportName === 'websocket' && info.websocket === false) {
              debug$e('disabled from server', 'websocket');
              return;
            }

            if (transportsWhitelist.length &&
                transportsWhitelist.indexOf(trans.transportName) === -1) {
              debug$e('not in whitelist', trans.transportName);
              return;
            }

            if (trans.enabled(info)) {
              debug$e('enabled', trans.transportName);
              transports.main.push(trans);
              if (trans.facadeTransport) {
                transports.facade.push(trans.facadeTransport);
              }
            } else {
              debug$e('disabled', trans.transportName);
            }
          });
          return transports;
        }
      };
    };

    var logObject = {};
    ['log', 'debug', 'warn'].forEach(function (level) {
      var levelExists;

      try {
        levelExists = global$1.console && global$1.console[level] && global$1.console[level].apply;
      } catch(e) {
        // do nothing
      }

      logObject[level] = levelExists ? function () {
        return global$1.console[level].apply(global$1.console, arguments);
      } : (level === 'log' ? function () {} : logObject.log);
    });

    var log = logObject;

    function Event$1(eventType) {
      this.type = eventType;
    }

    Event$1.prototype.initEvent = function(eventType, canBubble, cancelable) {
      this.type = eventType;
      this.bubbles = canBubble;
      this.cancelable = cancelable;
      this.timeStamp = +new Date();
      return this;
    };

    Event$1.prototype.stopPropagation = function() {};
    Event$1.prototype.preventDefault = function() {};

    Event$1.CAPTURING_PHASE = 1;
    Event$1.AT_TARGET = 2;
    Event$1.BUBBLING_PHASE = 3;

    var event$1 = Event$1;

    var location_1 = global$1.location || {
      origin: 'http://localhost:80'
    , protocol: 'http:'
    , host: 'localhost'
    , port: 80
    , href: 'http://localhost/'
    , hash: ''
    };

    function CloseEvent() {
      event$1.call(this);
      this.initEvent('close', false, false);
      this.wasClean = false;
      this.code = 0;
      this.reason = '';
    }

    inherits_browser(CloseEvent, event$1);

    var close = CloseEvent;

    function TransportMessageEvent(data) {
      event$1.call(this);
      this.initEvent('message', false, false);
      this.data = data;
    }

    inherits_browser(TransportMessageEvent, event$1);

    var transMessage = TransportMessageEvent;

    var EventEmitter$b = emitter.EventEmitter
      ;

    function XHRFake(/* method, url, payload, opts */) {
      var self = this;
      EventEmitter$b.call(this);

      this.to = setTimeout(function() {
        self.emit('finish', 200, '{}');
      }, XHRFake.timeout);
    }

    inherits_browser(XHRFake, EventEmitter$b);

    XHRFake.prototype.close = function() {
      clearTimeout(this.to);
    };

    XHRFake.timeout = 2000;

    var xhrFake = XHRFake;

    var EventEmitter$c = emitter.EventEmitter
      ;

    var debug$f = function() {};

    function InfoAjax(url, AjaxObject) {
      EventEmitter$c.call(this);

      var self = this;
      var t0 = +new Date();
      this.xo = new AjaxObject('GET', url);

      this.xo.once('finish', function(status, text) {
        var info, rtt;
        if (status === 200) {
          rtt = (+new Date()) - t0;
          if (text) {
            try {
              info = json3.parse(text);
            } catch (e) {
              debug$f('bad json', text);
            }
          }

          if (!object.isObject(info)) {
            info = {};
          }
        }
        self.emit('finish', info, rtt);
        self.removeAllListeners();
      });
    }

    inherits_browser(InfoAjax, EventEmitter$c);

    InfoAjax.prototype.close = function() {
      this.removeAllListeners();
      this.xo.close();
    };

    var infoAjax = InfoAjax;

    var EventEmitter$d = emitter.EventEmitter
      ;

    function InfoReceiverIframe(transUrl) {
      var self = this;
      EventEmitter$d.call(this);

      this.ir = new infoAjax(transUrl, xhrLocal);
      this.ir.once('finish', function(info, rtt) {
        self.ir = null;
        self.emit('message', json3.stringify([info, rtt]));
      });
    }

    inherits_browser(InfoReceiverIframe, EventEmitter$d);

    InfoReceiverIframe.transportName = 'iframe-info-receiver';

    InfoReceiverIframe.prototype.close = function() {
      if (this.ir) {
        this.ir.close();
        this.ir = null;
      }
      this.removeAllListeners();
    };

    var infoIframeReceiver = InfoReceiverIframe;

    var EventEmitter$e = emitter.EventEmitter
      ;

    var debug$g = function() {};

    function InfoIframe(baseUrl, url) {
      var self = this;
      EventEmitter$e.call(this);

      var go = function() {
        var ifr = self.ifr = new iframe$1(infoIframeReceiver.transportName, url, baseUrl);

        ifr.once('message', function(msg) {
          if (msg) {
            var d;
            try {
              d = json3.parse(msg);
            } catch (e) {
              debug$g('bad json', msg);
              self.emit('finish');
              self.close();
              return;
            }

            var info = d[0], rtt = d[1];
            self.emit('finish', info, rtt);
          }
          self.close();
        });

        ifr.once('close', function() {
          self.emit('finish');
          self.close();
        });
      };

      // TODO this seems the same as the 'needBody' from transports
      if (!global$1.document.body) {
        event.attachEvent('load', go);
      } else {
        go();
      }
    }

    inherits_browser(InfoIframe, EventEmitter$e);

    InfoIframe.enabled = function() {
      return iframe$1.enabled();
    };

    InfoIframe.prototype.close = function() {
      if (this.ifr) {
        this.ifr.close();
      }
      this.removeAllListeners();
      this.ifr = null;
    };

    var infoIframe = InfoIframe;

    var EventEmitter$f = emitter.EventEmitter
      ;

    var debug$h = function() {};

    function InfoReceiver(baseUrl, urlInfo) {
      debug$h(baseUrl);
      var self = this;
      EventEmitter$f.call(this);

      setTimeout(function() {
        self.doXhr(baseUrl, urlInfo);
      }, 0);
    }

    inherits_browser(InfoReceiver, EventEmitter$f);

    // TODO this is currently ignoring the list of available transports and the whitelist

    InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
      // determine method of CORS support (if needed)
      if (urlInfo.sameOrigin) {
        return new infoAjax(url, xhrLocal);
      }
      if (xhrCors.enabled) {
        return new infoAjax(url, xhrCors);
      }
      if (xdr.enabled && urlInfo.sameScheme) {
        return new infoAjax(url, xdr);
      }
      if (infoIframe.enabled()) {
        return new infoIframe(baseUrl, url);
      }
      return new infoAjax(url, xhrFake);
    };

    InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
      var self = this
        , url$1 = url.addPath(baseUrl, '/info')
        ;
      debug$h('doXhr', url$1);

      this.xo = InfoReceiver._getReceiver(baseUrl, url$1, urlInfo);

      this.timeoutRef = setTimeout(function() {
        debug$h('timeout');
        self._cleanup(false);
        self.emit('finish');
      }, InfoReceiver.timeout);

      this.xo.once('finish', function(info, rtt) {
        debug$h('finish', info, rtt);
        self._cleanup(true);
        self.emit('finish', info, rtt);
      });
    };

    InfoReceiver.prototype._cleanup = function(wasClean) {
      debug$h('_cleanup');
      clearTimeout(this.timeoutRef);
      this.timeoutRef = null;
      if (!wasClean && this.xo) {
        this.xo.close();
      }
      this.xo = null;
    };

    InfoReceiver.prototype.close = function() {
      debug$h('close');
      this.removeAllListeners();
      this._cleanup(false);
    };

    InfoReceiver.timeout = 8000;

    var infoReceiver = InfoReceiver;

    function FacadeJS(transport) {
      this._transport = transport;
      transport.on('message', this._transportMessage.bind(this));
      transport.on('close', this._transportClose.bind(this));
    }

    FacadeJS.prototype._transportClose = function(code, reason) {
      iframe.postMessage('c', json3.stringify([code, reason]));
    };
    FacadeJS.prototype._transportMessage = function(frame) {
      iframe.postMessage('t', frame);
    };
    FacadeJS.prototype._send = function(data) {
      this._transport.send(data);
    };
    FacadeJS.prototype._close = function() {
      this._transport.close();
      this._transport.removeAllListeners();
    };

    var facade = FacadeJS;

    var debug$i = function() {};

    var iframeBootstrap = function(SockJS, availableTransports) {
      var transportMap = {};
      availableTransports.forEach(function(at) {
        if (at.facadeTransport) {
          transportMap[at.facadeTransport.transportName] = at.facadeTransport;
        }
      });

      // hard-coded for the info iframe
      // TODO see if we can make this more dynamic
      transportMap[infoIframeReceiver.transportName] = infoIframeReceiver;
      var parentOrigin;

      /* eslint-disable camelcase */
      SockJS.bootstrap_iframe = function() {
        /* eslint-enable camelcase */
        var facade$1;
        iframe.currentWindowId = location_1.hash.slice(1);
        var onMessage = function(e) {
          if (e.source !== parent) {
            return;
          }
          if (typeof parentOrigin === 'undefined') {
            parentOrigin = e.origin;
          }
          if (e.origin !== parentOrigin) {
            return;
          }

          var iframeMessage;
          try {
            iframeMessage = json3.parse(e.data);
          } catch (ignored) {
            debug$i('bad json', e.data);
            return;
          }

          if (iframeMessage.windowId !== iframe.currentWindowId) {
            return;
          }
          switch (iframeMessage.type) {
          case 's':
            var p;
            try {
              p = json3.parse(iframeMessage.data);
            } catch (ignored) {
              debug$i('bad json', iframeMessage.data);
              break;
            }
            var version = p[0];
            var transport = p[1];
            var transUrl = p[2];
            var baseUrl = p[3];
            debug$i(version, transport, transUrl, baseUrl);
            // change this to semver logic
            if (version !== SockJS.version) {
              throw new Error('Incompatible SockJS! Main site uses:' +
                        ' "' + version + '", the iframe:' +
                        ' "' + SockJS.version + '".');
            }

            if (!url.isOriginEqual(transUrl, location_1.href) ||
                !url.isOriginEqual(baseUrl, location_1.href)) {
              throw new Error('Can\'t connect to different domain from within an ' +
                        'iframe. (' + location_1.href + ', ' + transUrl + ', ' + baseUrl + ')');
            }
            facade$1 = new facade(new transportMap[transport](transUrl, baseUrl));
            break;
          case 'm':
            facade$1._send(iframeMessage.data);
            break;
          case 'c':
            if (facade$1) {
              facade$1._close();
            }
            facade$1 = null;
            break;
          }
        };

        event.attachEvent('message', onMessage);

        // Start
        iframe.postMessage('s');
      };
    };

    var debug$j = function() {};

    var transports;

    // follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
    function SockJS(url$1, protocols, options) {
      if (!(this instanceof SockJS)) {
        return new SockJS(url$1, protocols, options);
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
      }
      eventtarget.call(this);

      this.readyState = SockJS.CONNECTING;
      this.extensions = '';
      this.protocol = '';

      // non-standard extension
      options = options || {};
      if (options.protocols_whitelist) {
        log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
      }
      this._transportsWhitelist = options.transports;
      this._transportOptions = options.transportOptions || {};

      var sessionId = options.sessionId || 8;
      if (typeof sessionId === 'function') {
        this._generateSessionId = sessionId;
      } else if (typeof sessionId === 'number') {
        this._generateSessionId = function() {
          return random.string(sessionId);
        };
      } else {
        throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
      }

      this._server = options.server || random.numberString(1000);

      // Step 1 of WS spec - parse and validate the url. Issue #8
      var parsedUrl = new urlParse(url$1);
      if (!parsedUrl.host || !parsedUrl.protocol) {
        throw new SyntaxError("The URL '" + url$1 + "' is invalid");
      } else if (parsedUrl.hash) {
        throw new SyntaxError('The URL must not contain a fragment');
      } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
        throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
      }

      var secure = parsedUrl.protocol === 'https:';
      // Step 2 - don't allow secure origin with an insecure protocol
      if (location_1.protocol === 'https:' && !secure) {
        throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
      }

      // Step 3 - check port access - no need here
      // Step 4 - parse protocols argument
      if (!protocols) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        protocols = [protocols];
      }

      // Step 5 - check protocols argument
      var sortedProtocols = protocols.sort();
      sortedProtocols.forEach(function(proto, i) {
        if (!proto) {
          throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
        }
        if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
          throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
        }
      });

      // Step 6 - convert origin
      var o = url.getOrigin(location_1.href);
      this._origin = o ? o.toLowerCase() : null;

      // remove the trailing slash
      parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

      // store the sanitized url
      this.url = parsedUrl.href;
      debug$j('using url', this.url);

      // Step 7 - start connection in background
      // obtain server info
      // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
      this._urlInfo = {
        nullOrigin: !browser$1.hasDomain()
      , sameOrigin: url.isOriginEqual(this.url, location_1.href)
      , sameScheme: url.isSchemeEqual(this.url, location_1.href)
      };

      this._ir = new infoReceiver(this.url, this._urlInfo);
      this._ir.once('finish', this._receiveInfo.bind(this));
    }

    inherits_browser(SockJS, eventtarget);

    function userSetCode(code) {
      return code === 1000 || (code >= 3000 && code <= 4999);
    }

    SockJS.prototype.close = function(code, reason) {
      // Step 1
      if (code && !userSetCode(code)) {
        throw new Error('InvalidAccessError: Invalid code');
      }
      // Step 2.4 states the max is 123 bytes, but we are just checking length
      if (reason && reason.length > 123) {
        throw new SyntaxError('reason argument has an invalid length');
      }

      // Step 3.1
      if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
        return;
      }

      // TODO look at docs to determine how to set this
      var wasClean = true;
      this._close(code || 1000, reason || 'Normal closure', wasClean);
    };

    SockJS.prototype.send = function(data) {
      // #13 - convert anything non-string to string
      // TODO this currently turns objects into [object Object]
      if (typeof data !== 'string') {
        data = '' + data;
      }
      if (this.readyState === SockJS.CONNECTING) {
        throw new Error('InvalidStateError: The connection has not been established yet');
      }
      if (this.readyState !== SockJS.OPEN) {
        return;
      }
      this._transport.send(_escape.quote(data));
    };

    SockJS.version = version;

    SockJS.CONNECTING = 0;
    SockJS.OPEN = 1;
    SockJS.CLOSING = 2;
    SockJS.CLOSED = 3;

    SockJS.prototype._receiveInfo = function(info, rtt) {
      debug$j('_receiveInfo', rtt);
      this._ir = null;
      if (!info) {
        this._close(1002, 'Cannot connect to server');
        return;
      }

      // establish a round-trip timeout (RTO) based on the
      // round-trip time (RTT)
      this._rto = this.countRTO(rtt);
      // allow server to override url used for the actual transport
      this._transUrl = info.base_url ? info.base_url : this.url;
      info = object.extend(info, this._urlInfo);
      debug$j('info', info);
      // determine list of desired and supported transports
      var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
      this._transports = enabledTransports.main;
      debug$j(this._transports.length + ' enabled transports');

      this._connect();
    };

    SockJS.prototype._connect = function() {
      for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
        debug$j('attempt', Transport.transportName);
        if (Transport.needBody) {
          if (!global$1.document.body ||
              (typeof global$1.document.readyState !== 'undefined' &&
                global$1.document.readyState !== 'complete' &&
                global$1.document.readyState !== 'interactive')) {
            debug$j('waiting for body');
            this._transports.unshift(Transport);
            event.attachEvent('load', this._connect.bind(this));
            return;
          }
        }

        // calculate timeout based on RTO and round trips. Default to 5s
        var timeoutMs = (this._rto * Transport.roundTrips) || 5000;
        this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
        debug$j('using timeout', timeoutMs);

        var transportUrl = url.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
        var options = this._transportOptions[Transport.transportName];
        debug$j('transport url', transportUrl);
        var transportObj = new Transport(transportUrl, this._transUrl, options);
        transportObj.on('message', this._transportMessage.bind(this));
        transportObj.once('close', this._transportClose.bind(this));
        transportObj.transportName = Transport.transportName;
        this._transport = transportObj;

        return;
      }
      this._close(2000, 'All transports failed', false);
    };

    SockJS.prototype._transportTimeout = function() {
      debug$j('_transportTimeout');
      if (this.readyState === SockJS.CONNECTING) {
        if (this._transport) {
          this._transport.close();
        }

        this._transportClose(2007, 'Transport timed out');
      }
    };

    SockJS.prototype._transportMessage = function(msg) {
      debug$j('_transportMessage', msg);
      var self = this
        , type = msg.slice(0, 1)
        , content = msg.slice(1)
        , payload
        ;

      // first check for messages that don't need a payload
      switch (type) {
        case 'o':
          this._open();
          return;
        case 'h':
          this.dispatchEvent(new event$1('heartbeat'));
          debug$j('heartbeat', this.transport);
          return;
      }

      if (content) {
        try {
          payload = json3.parse(content);
        } catch (e) {
          debug$j('bad json', content);
        }
      }

      if (typeof payload === 'undefined') {
        debug$j('empty payload', content);
        return;
      }

      switch (type) {
        case 'a':
          if (Array.isArray(payload)) {
            payload.forEach(function(p) {
              debug$j('message', self.transport, p);
              self.dispatchEvent(new transMessage(p));
            });
          }
          break;
        case 'm':
          debug$j('message', this.transport, payload);
          this.dispatchEvent(new transMessage(payload));
          break;
        case 'c':
          if (Array.isArray(payload) && payload.length === 2) {
            this._close(payload[0], payload[1], true);
          }
          break;
      }
    };

    SockJS.prototype._transportClose = function(code, reason) {
      debug$j('_transportClose', this.transport, code, reason);
      if (this._transport) {
        this._transport.removeAllListeners();
        this._transport = null;
        this.transport = null;
      }

      if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
        this._connect();
        return;
      }

      this._close(code, reason);
    };

    SockJS.prototype._open = function() {
      debug$j('_open', this._transport.transportName, this.readyState);
      if (this.readyState === SockJS.CONNECTING) {
        if (this._transportTimeoutId) {
          clearTimeout(this._transportTimeoutId);
          this._transportTimeoutId = null;
        }
        this.readyState = SockJS.OPEN;
        this.transport = this._transport.transportName;
        this.dispatchEvent(new event$1('open'));
        debug$j('connected', this.transport);
      } else {
        // The server might have been restarted, and lost track of our
        // connection.
        this._close(1006, 'Server lost session');
      }
    };

    SockJS.prototype._close = function(code, reason, wasClean) {
      debug$j('_close', this.transport, code, reason, wasClean, this.readyState);
      var forceFail = false;

      if (this._ir) {
        forceFail = true;
        this._ir.close();
        this._ir = null;
      }
      if (this._transport) {
        this._transport.close();
        this._transport = null;
        this.transport = null;
      }

      if (this.readyState === SockJS.CLOSED) {
        throw new Error('InvalidStateError: SockJS has already been closed');
      }

      this.readyState = SockJS.CLOSING;
      setTimeout(function() {
        this.readyState = SockJS.CLOSED;

        if (forceFail) {
          this.dispatchEvent(new event$1('error'));
        }

        var e = new close('close');
        e.wasClean = wasClean || false;
        e.code = code || 1000;
        e.reason = reason;

        this.dispatchEvent(e);
        this.onmessage = this.onclose = this.onerror = null;
        debug$j('disconnected');
      }.bind(this), 0);
    };

    // See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
    // and RFC 2988.
    SockJS.prototype.countRTO = function(rtt) {
      // In a local environment, when using IE8/9 and the `jsonp-polling`
      // transport the time needed to establish a connection (the time that pass
      // from the opening of the transport to the call of `_dispatchOpen`) is
      // around 200msec (the lower bound used in the article above) and this
      // causes spurious timeouts. For this reason we calculate a value slightly
      // larger than that used in the article.
      if (rtt > 100) {
        return 4 * rtt; // rto > 400msec
      }
      return 300 + rtt; // 300msec < rto <= 400msec
    };

    var main = function(availableTransports) {
      transports = transport(availableTransports);
      iframeBootstrap(SockJS, availableTransports);
      return SockJS;
    };

    var entry = main(transportList);

    // TODO can't get rid of this until all servers do
    if ('_sockjs_onload' in global$1) {
      setTimeout(global$1._sockjs_onload, 1);
    }

    var webstomp = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
      module.exports = factory();
    }(this, (function () {
      var classCallCheck = function (instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      };

      var createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();

      var slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        }

        return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      var toConsumableArray = function (arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

          return arr2;
        } else {
          return Array.from(arr);
        }
      };

      var VERSIONS = {
          V1_0: '1.0',
          V1_1: '1.1',
          V1_2: '1.2',
          // Versions of STOMP specifications supported
          supportedVersions: function supportedVersions() {
              return '1.2,1.1,1.0';
          },
          supportedProtocols: function supportedProtocols() {
              return ['v10.stomp', 'v11.stomp', 'v12.stomp'];
          }
      };

      var PROTOCOLS_VERSIONS = {
          'v10.stomp': VERSIONS.V1_0,
          'v11.stomp': VERSIONS.V1_1,
          'v12.stomp': VERSIONS.V1_2
      };

      function getSupportedVersion(protocol, debug) {
          var knownVersion = PROTOCOLS_VERSIONS[protocol];
          if (!knownVersion && debug) {
              debug('DEPRECATED: ' + protocol + ' is not a recognized STOMP version. In next major client version, this will close the connection.');
          }
          // 2nd temporary fallback if the protocol
          // does not match a supported STOMP version
          // This fallback will be removed in next major version
          return knownVersion || VERSIONS.V1_2;
      }

      // Define constants for bytes used throughout the code.
      var BYTES = {
          // LINEFEED byte (octet 10)
          LF: '\x0A',
          // NULL byte (octet 0)
          NULL: '\x00'
      };

      // utility function to trim any whitespace before and after a string
      var trim = function trim(str) {
          return str.replace(/^\s+|\s+$/g, '');
      };

      // from https://coolaj86.com/articles/unicode-string-to-a-utf-8-typed-array-buffer-in-javascript/
      function unicodeStringToTypedArray(s) {
          var escstr = encodeURIComponent(s);
          var binstr = escstr.replace(/%([0-9A-F]{2})/g, function (match, p1) {
              return String.fromCharCode('0x' + p1);
          });
          var arr = Array.prototype.map.call(binstr, function (c) {
              return c.charCodeAt(0);
          });
          return new Uint8Array(arr);
      }

      // from https://coolaj86.com/articles/unicode-string-to-a-utf-8-typed-array-buffer-in-javascript/
      function typedArrayToUnicodeString(ua) {
          var binstr = String.fromCharCode.apply(String, toConsumableArray(ua));
          var escstr = binstr.replace(/(.)/g, function (m, p) {
              var code = p.charCodeAt(0).toString(16).toUpperCase();
              if (code.length < 2) {
                  code = '0' + code;
              }
              return '%' + code;
          });
          return decodeURIComponent(escstr);
      }

      // Compute the size of a UTF-8 string by counting its number of bytes
      // (and not the number of characters composing the string)
      function sizeOfUTF8(s) {
          if (!s) return 0;
          return encodeURIComponent(s).match(/%..|./g).length;
      }

      function createId() {
          var ts = new Date().getTime();
          var rand = Math.floor(Math.random() * 1000);
          return ts + '-' + rand;
      }

      // [STOMP Frame](http://stomp.github.com/stomp-specification-1.1.html#STOMP_Frames) Class

      var Frame = function () {

          // Frame constructor
          function Frame(command) {
              var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var body = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
              classCallCheck(this, Frame);

              this.command = command;
              this.headers = headers;
              this.body = body;
          }

          // Provides a textual representation of the frame
          // suitable to be sent to the server


          createClass(Frame, [{
              key: 'toString',
              value: function toString() {
                  var _this = this;

                  var lines = [this.command],
                      skipContentLength = this.headers['content-length'] === false;
                  if (skipContentLength) delete this.headers['content-length'];

                  Object.keys(this.headers).forEach(function (name) {
                      var value = _this.headers[name];
                      lines.push(name + ':' + value);
                  });

                  if (this.body && !skipContentLength) {
                      lines.push('content-length:' + sizeOfUTF8(this.body));
                  }

                  lines.push(BYTES.LF + this.body);

                  return lines.join(BYTES.LF);
              }

              // Unmarshall a single STOMP frame from a `data` string

          }], [{
              key: 'unmarshallSingle',
              value: function unmarshallSingle(data) {
                  // search for 2 consecutives LF byte to split the command
                  // and headers from the body
                  var divider = data.search(new RegExp(BYTES.LF + BYTES.LF)),
                      headerLines = data.substring(0, divider).split(BYTES.LF),
                      command = headerLines.shift(),
                      headers = {},
                      body = '',

                  // skip the 2 LF bytes that divides the headers from the body
                  bodyIndex = divider + 2;

                  // Parse headers in reverse order so that for repeated headers, the 1st
                  // value is used
                  var _iteratorNormalCompletion = true;
                  var _didIteratorError = false;
                  var _iteratorError = undefined;

                  try {
                      for (var _iterator = headerLines.reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                          var line = _step.value;

                          var idx = line.indexOf(':');
                          headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));
                      }
                      // Parse body
                      // check for content-length or topping at the first NULL byte found.
                  } catch (err) {
                      _didIteratorError = true;
                      _iteratorError = err;
                  } finally {
                      try {
                          if (!_iteratorNormalCompletion && _iterator.return) {
                              _iterator.return();
                          }
                      } finally {
                          if (_didIteratorError) {
                              throw _iteratorError;
                          }
                      }
                  }

                  if (headers['content-length']) {
                      var len = parseInt(headers['content-length'], 10);
                      body = ('' + data).substring(bodyIndex, bodyIndex + len);
                  } else {
                      var chr = null;
                      for (var i = bodyIndex; i < data.length; i++) {
                          chr = data.charAt(i);
                          if (chr === BYTES.NULL) break;
                          body += chr;
                      }
                  }

                  return new Frame(command, headers, body);
              }

              // Split the data before unmarshalling every single STOMP frame.
              // Web socket servers can send multiple frames in a single websocket message.
              // If the message size exceeds the websocket message size, then a single
              // frame can be fragmented across multiple messages.
              //
              // `datas` is a string.
              //
              // returns an *array* of Frame objects

          }, {
              key: 'unmarshall',
              value: function unmarshall(datas) {
                  // split and unmarshall *multiple STOMP frames* contained in a *single WebSocket frame*.
                  // The data is split when a NULL byte (followed by zero or many LF bytes) is found
                  var frames = datas.split(new RegExp(BYTES.NULL + BYTES.LF + '*')),
                      firstFrames = frames.slice(0, -1),
                      lastFrame = frames.slice(-1)[0],
                      r = {
                      frames: firstFrames.map(function (f) {
                          return Frame.unmarshallSingle(f);
                      }),
                      partial: ''
                  };

                  // If this contains a final full message or just a acknowledgement of a PING
                  // without any other content, process this frame, otherwise return the
                  // contents of the buffer to the caller.
                  if (lastFrame === BYTES.LF || lastFrame.search(RegExp(BYTES.NULL + BYTES.LF + '*$')) !== -1) {
                      r.frames.push(Frame.unmarshallSingle(lastFrame));
                  } else {
                      r.partial = lastFrame;
                  }

                  return r;
              }

              // Marshall a Stomp frame

          }, {
              key: 'marshall',
              value: function marshall(command, headers, body) {
                  var frame = new Frame(command, headers, body);
                  return frame.toString() + BYTES.NULL;
              }
          }]);
          return Frame;
      }();

      // STOMP Client Class
      //
      // All STOMP protocol is exposed as methods of this class (`connect()`,
      // `send()`, etc.)

      var Client = function () {
          function Client(ws) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              classCallCheck(this, Client);

              // cannot have default options object + destructuring in the same time in method signature
              var _options$binary = options.binary,
                  binary = _options$binary === undefined ? false : _options$binary,
                  _options$heartbeat = options.heartbeat,
                  heartbeat = _options$heartbeat === undefined ? { outgoing: 10000, incoming: 10000 } : _options$heartbeat,
                  _options$debug = options.debug,
                  debug = _options$debug === undefined ? true : _options$debug,
                  _options$protocols = options.protocols,
                  protocols = _options$protocols === undefined ? [] : _options$protocols;


              this.ws = ws;
              this.ws.binaryType = 'arraybuffer';
              this.isBinary = !!binary;
              this.hasDebug = !!debug;
              this.connected = false;
              // Heartbeat properties of the client
              // outgoing: send heartbeat every 10s by default (value is in ms)
              // incoming: expect to receive server heartbeat at least every 10s by default
              // falsy value means no heartbeat hence 0,0
              this.heartbeat = heartbeat || { outgoing: 0, incoming: 0 };
              // maximum *WebSocket* frame size sent by the client. If the STOMP frame
              // is bigger than this value, the STOMP frame will be sent using multiple
              // WebSocket frames (default is 16KiB)
              this.maxWebSocketFrameSize = 16 * 1024;
              // subscription callbacks indexed by subscriber's ID
              this.subscriptions = {};
              this.partialData = '';
              this.protocols = protocols;
          }

          // //// Debugging
          //
          // By default, debug messages are logged in the window's console if it is defined.
          // This method is called for every actual transmission of the STOMP frames over the
          // WebSocket.
          //
          // It is possible to set a `debug(message, data)` method
          // on a client instance to handle differently the debug messages:
          //
          //     client.debug = function(str) {
          //         // append the debug log to a #debug div
          //         $("#debug").append(str + "\n");
          //     };


          createClass(Client, [{
              key: 'debug',
              value: function debug() {
                  var _console;

                  if (this.hasDebug) (_console = console).log.apply(_console, arguments);
              }

              // [CONNECT Frame](http://stomp.github.com/stomp-specification-1.1.html#CONNECT_or_STOMP_Frame)
              //
              // The `connect` method accepts different number of arguments and types:
              //
              // * `connect(headers, connectCallback)`
              // * `connect(headers, connectCallback, errorCallback)`
              // * `connect(login, passcode, connectCallback)`
              // * `connect(login, passcode, connectCallback, errorCallback)`
              // * `connect(login, passcode, connectCallback, errorCallback, host)`
              //
              // The errorCallback is optional and the 2 first forms allow to pass other
              // headers in addition to `client`, `passcode` and `host`.

          }, {
              key: 'connect',
              value: function connect() {
                  var _this = this;

                  var _parseConnect2 = this._parseConnect.apply(this, arguments),
                      _parseConnect3 = slicedToArray(_parseConnect2, 3),
                      headers = _parseConnect3[0],
                      connectCallback = _parseConnect3[1],
                      errorCallback = _parseConnect3[2];

                  this.connectCallback = connectCallback;
                  this.debug('Opening Web Socket...');
                  this.ws.onmessage = function (evt) {
                      var data = evt.data;
                      if (evt.data instanceof ArrayBuffer) {
                          data = typedArrayToUnicodeString(new Uint8Array(evt.data));
                      }
                      _this.serverActivity = Date.now();
                      // heartbeat
                      if (data === BYTES.LF) {
                          _this.debug('<<< PONG');
                          return;
                      }
                      _this.debug('<<< ' + data);
                      // Handle STOMP frames received from the server
                      // The unmarshall function returns the frames parsed and any remaining
                      // data from partial frames.
                      var unmarshalledData = Frame.unmarshall(_this.partialData + data);
                      _this.partialData = unmarshalledData.partial;
                      unmarshalledData.frames.forEach(function (frame) {
                          switch (frame.command) {
                              // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.1.html#CONNECTED_Frame)
                              case 'CONNECTED':
                                  _this.debug('connected to server ' + frame.headers.server);
                                  _this.connected = true;
                                  _this.version = frame.headers.version;
                                  _this._setupHeartbeat(frame.headers);
                                  if (connectCallback) connectCallback(frame);
                                  break;
                              // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.1.html#MESSAGE)
                              case 'MESSAGE':
                                  // the `onreceive` callback is registered when the client calls
                                  // `subscribe()`.
                                  // If there is registered subscription for the received message,
                                  // we used the default `onreceive` method that the client can set.
                                  // This is useful for subscriptions that are automatically created
                                  // on the browser side (e.g. [RabbitMQ's temporary
                                  // queues](http://www.rabbitmq.com/stomp.html)).
                                  var subscription = frame.headers.subscription;
                                  var onreceive = _this.subscriptions[subscription] || _this.onreceive;
                                  if (onreceive) {
                                      // 1.2 define ack header if ack is set to client
                                      // and this header must be used for ack/nack
                                      var messageID = _this.version === VERSIONS.V1_2 && frame.headers.ack || frame.headers['message-id'];
                                      // add `ack()` and `nack()` methods directly to the returned frame
                                      // so that a simple call to `message.ack()` can acknowledge the message.
                                      frame.ack = _this.ack.bind(_this, messageID, subscription);
                                      frame.nack = _this.nack.bind(_this, messageID, subscription);
                                      onreceive(frame);
                                  } else {
                                      _this.debug('Unhandled received MESSAGE: ' + frame);
                                  }
                                  break;
                              // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.1.html#RECEIPT)
                              //
                              // The client instance can set its `onreceipt` field to a function taking
                              // a frame argument that will be called when a receipt is received from
                              // the server:
                              //
                              //     client.onreceipt = function(frame) {
                              //       receiptID = frame.headers['receipt-id'];
                              //       ...
                              //     }
                              case 'RECEIPT':
                                  if (_this.onreceipt) _this.onreceipt(frame);
                                  break;
                              // [ERROR Frame](http://stomp.github.com/stomp-specification-1.1.html#ERROR)
                              case 'ERROR':
                                  if (errorCallback) errorCallback(frame);
                                  break;
                              default:
                                  _this.debug('Unhandled frame: ' + frame);
                          }
                      });
                  };
                  this.ws.onclose = function (event) {
                      _this.debug('Whoops! Lost connection to ' + _this.ws.url + ':', { event: event });
                      _this._cleanUp();
                      if (errorCallback) errorCallback(event);
                  };
                  this.ws.onopen = function () {
                      _this.debug('Web Socket Opened...');
                      // 1st protocol fallback on user 1st protocols options
                      // to prevent edge case where server does not comply and respond with a choosen protocol
                      // or when ws client does not handle protocol property very well
                      headers['accept-version'] = getSupportedVersion(_this.ws.protocol || _this.protocols[0], _this.debug.bind(_this));
                      // Check if we already have heart-beat in headers before adding them
                      if (!headers['heart-beat']) {
                          headers['heart-beat'] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',');
                      }
                      _this._transmit('CONNECT', headers);
                  };
                  if (this.ws.readyState === this.ws.OPEN) {
                      this.ws.onopen();
                  }
              }

              // [DISCONNECT Frame](http://stomp.github.com/stomp-specification-1.1.html#DISCONNECT)

          }, {
              key: 'disconnect',
              value: function disconnect(disconnectCallback) {
                  var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                  this._transmit('DISCONNECT', headers);
                  // Discard the onclose callback to avoid calling the errorCallback when
                  // the client is properly disconnected.
                  this.ws.onclose = null;
                  this.ws.close();
                  this._cleanUp();
                  // TODO: what's the point of this callback disconnect is not async
                  if (disconnectCallback) disconnectCallback();
              }

              // [SEND Frame](http://stomp.github.com/stomp-specification-1.1.html#SEND)
              //
              // * `destination` is MANDATORY.

          }, {
              key: 'send',
              value: function send(destination) {
                  var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
                  var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

                  var hdrs = Object.assign({}, headers);
                  hdrs.destination = destination;
                  this._transmit('SEND', hdrs, body);
              }

              // [BEGIN Frame](http://stomp.github.com/stomp-specification-1.1.html#BEGIN)
              //
              // If no transaction ID is passed, one will be created automatically

          }, {
              key: 'begin',
              value: function begin() {
                  var transaction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'tx-' + createId();

                  this._transmit('BEGIN', { transaction: transaction });
                  return {
                      id: transaction,
                      commit: this.commit.bind(this, transaction),
                      abort: this.abort.bind(this, transaction)
                  };
              }

              // [COMMIT Frame](http://stomp.github.com/stomp-specification-1.1.html#COMMIT)
              //
              // * `transaction` is MANDATORY.
              //
              // It is preferable to commit a transaction by calling `commit()` directly on
              // the object returned by `client.begin()`:
              //
              //     var tx = client.begin(txid);
              //     ...
              //     tx.commit();

          }, {
              key: 'commit',
              value: function commit(transaction) {
                  this._transmit('COMMIT', { transaction: transaction });
              }

              // [ABORT Frame](http://stomp.github.com/stomp-specification-1.1.html#ABORT)
              //
              // * `transaction` is MANDATORY.
              //
              // It is preferable to abort a transaction by calling `abort()` directly on
              // the object returned by `client.begin()`:
              //
              //     var tx = client.begin(txid);
              //     ...
              //     tx.abort();

          }, {
              key: 'abort',
              value: function abort(transaction) {
                  this._transmit('ABORT', { transaction: transaction });
              }

              // [ACK Frame](http://stomp.github.com/stomp-specification-1.1.html#ACK)
              //
              // * `messageID` & `subscription` are MANDATORY.
              //
              // It is preferable to acknowledge a message by calling `ack()` directly
              // on the message handled by a subscription callback:
              //
              //     client.subscribe(destination,
              //       function(message) {
              //         // process the message
              //         // acknowledge it
              //         message.ack();
              //       },
              //       {'ack': 'client'}
              //     );

          }, {
              key: 'ack',
              value: function ack(messageID, subscription) {
                  var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

                  var hdrs = Object.assign({}, headers);
                  // 1.2 change id header name from message-id to id
                  var idAttr = this.version === VERSIONS.V1_2 ? 'id' : 'message-id';
                  hdrs[idAttr] = messageID;
                  hdrs.subscription = subscription;
                  this._transmit('ACK', hdrs);
              }

              // [NACK Frame](http://stomp.github.com/stomp-specification-1.1.html#NACK)
              //
              // * `messageID` & `subscription` are MANDATORY.
              //
              // It is preferable to nack a message by calling `nack()` directly on the
              // message handled by a subscription callback:
              //
              //     client.subscribe(destination,
              //       function(message) {
              //         // process the message
              //         // an error occurs, nack it
              //         message.nack();
              //       },
              //       {'ack': 'client'}
              //     );

          }, {
              key: 'nack',
              value: function nack(messageID, subscription) {
                  var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

                  var hdrs = Object.assign({}, headers);
                  // 1.2 change id header name from message-id to id
                  var idAttr = this.version === VERSIONS.V1_2 ? 'id' : 'message-id';
                  hdrs[idAttr] = messageID;
                  hdrs.subscription = subscription;
                  this._transmit('NACK', hdrs);
              }

              // [SUBSCRIBE Frame](http://stomp.github.com/stomp-specification-1.1.html#SUBSCRIBE)

          }, {
              key: 'subscribe',
              value: function subscribe(destination, callback) {
                  var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

                  var hdrs = Object.assign({}, headers);
                  // for convenience if the `id` header is not set, we create a new one for this client
                  // that will be returned to be able to unsubscribe this subscription
                  if (!hdrs.id) hdrs.id = 'sub-' + createId();
                  hdrs.destination = destination;
                  this.subscriptions[hdrs.id] = callback;
                  this._transmit('SUBSCRIBE', hdrs);
                  return {
                      id: hdrs.id,
                      unsubscribe: this.unsubscribe.bind(this, hdrs.id)
                  };
              }

              // [UNSUBSCRIBE Frame](http://stomp.github.com/stomp-specification-1.1.html#UNSUBSCRIBE)
              //
              // * `id` is MANDATORY.
              //
              // It is preferable to unsubscribe from a subscription by calling
              // `unsubscribe()` directly on the object returned by `client.subscribe()`:
              //
              //     var subscription = client.subscribe(destination, onmessage);
              //     ...
              //     subscription.unsubscribe(headers);

          }, {
              key: 'unsubscribe',
              value: function unsubscribe(id) {
                  var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                  var hdrs = Object.assign({}, headers);
                  delete this.subscriptions[id];
                  hdrs.id = id;
                  this._transmit('UNSUBSCRIBE', hdrs);
              }

              // Clean up client resources when it is disconnected or the server did not
              // send heart beats in a timely fashion

          }, {
              key: '_cleanUp',
              value: function _cleanUp() {
                  this.connected = false;
                  clearInterval(this.pinger);
                  clearInterval(this.ponger);
              }

              // Base method to transmit any stomp frame

          }, {
              key: '_transmit',
              value: function _transmit(command, headers, body) {
                  var out = Frame.marshall(command, headers, body);
                  this.debug('>>> ' + out, { frame: { command: command, headers: headers, body: body } });
                  this._wsSend(out);
              }
          }, {
              key: '_wsSend',
              value: function _wsSend(data) {
                  if (this.isBinary) data = unicodeStringToTypedArray(data);
                  this.debug('>>> length ' + data.length);
                  // if necessary, split the *STOMP* frame to send it on many smaller
                  // *WebSocket* frames
                  while (true) {
                      if (data.length > this.maxWebSocketFrameSize) {
                          this.ws.send(data.slice(0, this.maxWebSocketFrameSize));
                          data = data.slice(this.maxWebSocketFrameSize);
                          this.debug('remaining = ' + data.length);
                      } else {
                          return this.ws.send(data);
                      }
                  }
              }

              // Heart-beat negotiation

          }, {
              key: '_setupHeartbeat',
              value: function _setupHeartbeat(headers) {
                  var _this2 = this;

                  if (this.version !== VERSIONS.V1_1 && this.version !== VERSIONS.V1_2) return;

                  // heart-beat header received from the server looks like:
                  //
                  //     heart-beat: sx, sy

                  var _split$map = (headers['heart-beat'] || '0,0').split(',').map(function (v) {
                      return parseInt(v, 10);
                  }),
                      _split$map2 = slicedToArray(_split$map, 2),
                      serverOutgoing = _split$map2[0],
                      serverIncoming = _split$map2[1];

                  if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {
                      var ttl = Math.max(this.heartbeat.outgoing, serverIncoming);
                      this.debug('send PING every ' + ttl + 'ms');
                      this.pinger = setInterval(function () {
                          _this2._wsSend(BYTES.LF);
                          _this2.debug('>>> PING');
                      }, ttl);
                  }

                  if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {
                      var _ttl = Math.max(this.heartbeat.incoming, serverOutgoing);
                      this.debug('check PONG every ' + _ttl + 'ms');
                      this.ponger = setInterval(function () {
                          var delta = Date.now() - _this2.serverActivity;
                          // We wait twice the TTL to be flexible on window's setInterval calls
                          if (delta > _ttl * 2) {
                              _this2.debug('did not receive server activity for the last ' + delta + 'ms');
                              _this2.ws.close();
                          }
                      }, _ttl);
                  }
              }

              // parse the arguments number and type to find the headers, connectCallback and
              // (eventually undefined) errorCallback

          }, {
              key: '_parseConnect',
              value: function _parseConnect() {
                  var headers = {},
                      connectCallback = void 0,
                      errorCallback = void 0;

                  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                  }

                  switch (args.length) {
                      case 2:
                          headers = args[0];
                          connectCallback = args[1];

                          break;
                      case 3:
                          if (args[1] instanceof Function) {
                              headers = args[0];
                              connectCallback = args[1];
                              errorCallback = args[2];
                          } else {
                              headers.login = args[0];
                              headers.passcode = args[1];
                              connectCallback = args[2];
                          }
                          break;
                      case 4:
                          headers.login = args[0];
                          headers.passcode = args[1];
                          connectCallback = args[2];
                          errorCallback = args[3];

                          break;
                      default:
                          headers.login = args[0];
                          headers.passcode = args[1];
                          connectCallback = args[2];
                          errorCallback = args[3];
                          headers.host = args[4];

                  }

                  return [headers, connectCallback, errorCallback];
              }
          }]);
          return Client;
      }();

      // The `webstomp` Object
      var webstomp = {
          Frame: Frame,
          VERSIONS: VERSIONS,
          // This method creates a WebSocket client that is connected to
          // the STOMP server located at the url.
          client: function client(url) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

              var ws = new WebSocket(url, options.protocols || VERSIONS.supportedProtocols());
              return new Client(ws, options);
          },

          // This method is an alternative to `webstomp.client()` to let the user
          // specify the WebSocket to use (either a standard HTML5 WebSocket or
          // a similar object).
          over: function over() {
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
              }

              return new (Function.prototype.bind.apply(Client, [null].concat(args)))();
          }
      };

      return webstomp;

    })));
    });
    var webstomp_1 = webstomp.over;

    var SCHEMA$5 = {
        "target": {
            "@id": C.target,
            "@type": "@id",
        },
    };
    var EventMessage = {
        SCHEMA: SCHEMA$5,
        is: function (value) {
            return Resource.is(value)
                && value.hasOwnProperty("target");
        },
    };

    var DEFAULT_OPTIONS = {
        maxReconnectAttempts: 10,
        reconnectDelay: 1000,
    };
    var MessagingService = (function () {
        function MessagingService(context) {
            this.context = context;
            this._options = DEFAULT_OPTIONS;
            this._attempts = 0;
            this._subscriptionsQueue = [];
        }
        MessagingService.prototype.setOptions = function (options) {
            this._options = __assign({}, DEFAULT_OPTIONS, options);
        };
        MessagingService.prototype.connect = function (onConnect, onError) {
            if (this._client) {
                var error = new IllegalStateError("The messaging service is already connect" + (this._client.connected ? "ed" : "ing") + ".");
                if (onError)
                    onError(error);
                throw error;
            }
            if (this._subscriptionsMap)
                this._subscriptionsMap.clear();
            this.reconnect(onConnect, onError);
        };
        MessagingService.prototype.reconnect = function (onConnect, onError) {
            var _this = this;
            if (onError === void 0) { onError = this.__broadcastError.bind(this); }
            if (!this._client)
                this._attempts = 0;
            else if (this._client.connected)
                this._client.disconnect();
            if (!this._subscriptionsMap)
                this._subscriptionsMap = new Map();
            var sock = new entry(this.context.resolve("/broker"));
            this._client = webstomp_1(sock, {
                debug: false,
                heartbeat: false,
            });
            this._client.connect({}, function () {
                _this._subscriptionsQueue.forEach(function (callback) { return callback(); });
                _this._subscriptionsQueue.length = 0;
                _this._attempts = 0;
                if (onConnect)
                    onConnect();
            }, function (errorFrameOrEvent) {
                var canReconnect = _this._options.maxReconnectAttempts === null || _this._options.maxReconnectAttempts >= _this._attempts;
                var errorMessage;
                if ("reason" in errorFrameOrEvent) {
                    if (canReconnect) {
                        if (++_this._attempts === 1)
                            _this.__saveSubscriptions();
                        setTimeout(function () { return _this.reconnect(onConnect, onError); }, _this._options.reconnectDelay);
                        return;
                    }
                    _this._client = undefined;
                    _this._subscriptionsQueue.length = 0;
                    errorMessage = "CloseEventError: " + errorFrameOrEvent.reason;
                }
                else if ("body" in errorFrameOrEvent) {
                    if (!_this._client || !_this._client.connected && canReconnect)
                        return;
                    errorMessage = errorFrameOrEvent.headers["message"] + ": " + errorFrameOrEvent.body.trim();
                }
                else {
                    errorMessage = "Unknown error: " + errorFrameOrEvent;
                }
                onError(new Error(errorMessage));
            });
        };
        MessagingService.prototype.subscribe = function (destination, onEvent, onError) {
            if (!this._client)
                this.connect();
            if (!this._subscriptionsMap.has(destination))
                this._subscriptionsMap.set(destination, new Map());
            var callbacksMap = this._subscriptionsMap.get(destination);
            if (callbacksMap.has(onEvent))
                return;
            var subscriptionID = UUIDUtils.generate();
            callbacksMap.set(onEvent, {
                id: subscriptionID,
                errorCallback: onError,
            });
            var subscribeTo = this.__makeSubscription(subscriptionID, destination, onEvent, onError);
            if (this._client.connected)
                return subscribeTo();
            this._subscriptionsQueue.push(subscribeTo);
        };
        MessagingService.prototype.unsubscribe = function (destination, onEvent) {
            if (!this._client || !this._subscriptionsMap || !this._subscriptionsMap.has(destination))
                return;
            var callbackMap = this._subscriptionsMap.get(destination);
            if (!callbackMap.has(onEvent))
                return;
            var subscriptionID = callbackMap.get(onEvent).id;
            callbackMap.delete(onEvent);
            if (callbackMap.size === 0)
                this._subscriptionsMap.delete(destination);
            this._client.unsubscribe(subscriptionID);
        };
        MessagingService.prototype.__broadcastError = function (error) {
            if (!this._subscriptionsMap)
                return;
            this._subscriptionsMap
                .forEach(function (callbacksMap) { return callbacksMap
                .forEach(function (subscription) {
                if (!subscription.errorCallback)
                    return;
                subscription.errorCallback(error);
            }); });
        };
        MessagingService.prototype.__makeSubscription = function (id, destination, eventCallback, errorCallback) {
            var _this = this;
            return function () { return _this._client.subscribe(destination, function (message) {
                new JSONLDParser()
                    .parse(message.body)
                    .then(function (data) {
                    var nodes = RDFDocument.getResources(data);
                    var freeResources = FreeResources
                        .parseFreeNodes(_this.context.registry, nodes);
                    var eventMessage = freeResources
                        .getPointers(true)
                        .find(EventMessage.is);
                    if (!eventMessage)
                        throw new Error("No message was returned by the notification.");
                    return eventMessage;
                })
                    .then(eventCallback)
                    .catch(errorCallback);
            }, { id: id }); };
        };
        MessagingService.prototype.__saveSubscriptions = function () {
            var _this = this;
            if (this._subscriptionsQueue.length || !this._subscriptionsMap)
                return;
            this._subscriptionsMap.forEach(function (callbackMap, destination) { return callbackMap.forEach(function (subscription, eventCallback) {
                var subscribeTo = _this.__makeSubscription(subscription.id, destination, eventCallback, subscription.errorCallback);
                _this._subscriptionsQueue.push(subscribeTo);
            }); });
        };
        return MessagingService;
    }());

    var SCHEMA$6 = {
        "relatedDocument": {
            "@id": C.relatedDocument,
            "@type": "@id",
        },
        "bNodesMap": {
            "@id": C.bNodesMap,
            "@type": "@id",
        },
    };
    var DocumentMetadata = {
        TYPE: C.DocumentMetadata,
        SCHEMA: SCHEMA$6,
    };

    var SCHEMA$7 = {
        "errorCode": {
            "@id": C.errorCode,
            "@type": XSD.string,
        },
        "errorMessage": {
            "@id": C.errorMessage,
            "@language": "en",
        },
        "errorParameters": {
            "@id": C.errorParameters,
            "@type": "@id",
        },
    };
    var Error$1 = {
        TYPE: C.Error,
        SCHEMA: SCHEMA$7,
    };

    var SCHEMA$8 = {
        "entries": {
            "@id": C.entry,
            "@type": "@id",
            "@container": "@set",
        },
    };
    var Map$1 = {
        TYPE: C.Map,
        SCHEMA: SCHEMA$8,
        is: function (object) {
            return Resource.is(object)
                && object.$hasType(Map$1.TYPE)
                && object.hasOwnProperty("entries");
        },
    };

    var SCHEMA$9 = {
        "entryKey": {
            "@id": C.entryKey,
        },
        "entryValue": {
            "@id": C.entryValue,
        },
    };
    var MapEntry = {
        SCHEMA: SCHEMA$9,
    };

    var SCHEMA$a = {
        "errorDetails": {
            "@id": C.errorDetails,
            "@type": "@id",
        },
    };
    var ValidationError = {
        TYPE: C.ValidationError,
        SCHEMA: SCHEMA$a,
    };

    var TYPE = C.ChildCreatedEvent;
    var SCHEMA$b = __assign({}, EventMessage.SCHEMA, { "details": {
            "@id": C.details,
            "@type": "@id",
        } });
    var ChildCreatedEvent = {
        TYPE: TYPE,
        SCHEMA: SCHEMA$b,
    };

    var SCHEMA$c = {
        "createdDocuments": {
            "@id": C.createdDocument,
            "@type": "@id",
            "@container": "@set",
        },
    };
    var DocumentCreatedEventDetails = {
        TYPE: C.DocumentCreatedEventDetails,
        SCHEMA: SCHEMA$c,
    };

    var TYPE$1 = C.DocumentDeletedEvent;
    var SCHEMA$d = EventMessage.SCHEMA;
    var DocumentDeletedEvent = {
        TYPE: TYPE$1,
        SCHEMA: SCHEMA$d,
    };

    var TYPE$2 = C.DocumentModifiedEvent;
    var SCHEMA$e = EventMessage.SCHEMA;
    var DocumentModifiedEvent = {
        TYPE: TYPE$2,
        SCHEMA: SCHEMA$e,
    };

    var TYPE$3 = C.MemberAddedEvent;
    var SCHEMA$f = __assign({}, EventMessage.SCHEMA, { "details": {
            "@id": C.details,
            "@type": "@id",
        } });
    var MemberAddedEvent = {
        TYPE: TYPE$3,
        SCHEMA: SCHEMA$f,
    };

    var SCHEMA$g = {
        "members": {
            "@id": C.member,
            "@type": "@id",
            "@container": "@set",
        },
    };
    var MemberEventDetails = {
        SCHEMA: SCHEMA$g,
    };

    var TYPE$4 = C.MemberAddedEventDetails;
    var SCHEMA$h = MemberEventDetails.SCHEMA;
    var MemberAddedEventDetails = {
        TYPE: TYPE$4,
        SCHEMA: SCHEMA$h,
    };

    var TYPE$5 = C.MemberRemovedEvent;
    var SCHEMA$i = __assign({}, EventMessage.SCHEMA, { "details": {
            "@id": C.details,
            "@type": "@id",
        } });
    var MemberRemovedEvent = {
        TYPE: TYPE$5,
        SCHEMA: SCHEMA$i,
    };

    var TYPE$6 = C.MemberRemovedEventDetails;
    var SCHEMA$j = MemberEventDetails.SCHEMA;
    var MemberRemovedEventDetails = {
        TYPE: TYPE$6,
        SCHEMA: SCHEMA$j,
    };

    var SHACL = {
        namespace: "http://www.w3.org/ns/shacl#",
        ValidationReport: "http://www.w3.org/ns/shacl#ValidationReport",
        ValidationResult: "http://www.w3.org/ns/shacl#ValidationResult",
        conforms: "http://www.w3.org/ns/shacl#conforms",
        detail: "http://www.w3.org/ns/shacl#detail",
        focusNode: "http://www.w3.org/ns/shacl#focusNode",
        result: "http://www.w3.org/ns/shacl#result",
        resultMessage: "http://www.w3.org/ns/shacl#resultMessage",
        resultPath: "http://www.w3.org/ns/shacl#resultPath",
        resultSeverity: "http://www.w3.org/ns/shacl#resultSeverity",
        shapesGraphWellFormed: "http://www.w3.org/ns/shacl#shapesGraphWellFormed",
        sourceConstraintComponent: "http://www.w3.org/ns/shacl#sourceConstraintComponent",
        sourceShape: "http://www.w3.org/ns/shacl#sourceShape",
        value: "http://www.w3.org/ns/shacl#value",
    };

    var SCHEMA$k = {
        "conforms": {
            "@id": SHACL.conforms,
            "@type": XSD.boolean,
        },
        "results": {
            "@id": SHACL.result,
            "@type": "@id",
            "@container": "@set",
        },
        "shapesGraphWellFormed": {
            "@id": SHACL.shapesGraphWellFormed,
            "@type": XSD.boolean,
        },
    };
    var ValidationReport = {
        TYPE: SHACL.ValidationReport,
        SCHEMA: SCHEMA$k,
    };

    var SCHEMA$l = {
        "focusNode": {
            "@id": SHACL.focusNode,
            "@type": "@id",
        },
        "resultPath": {
            "@id": SHACL.resultPath,
            "@type": "@id",
        },
        "value": {
            "@id": SHACL.value,
        },
        "sourceShape": {
            "@id": SHACL.sourceShape,
            "@type": "@id",
        },
        "sourceConstraintComponent": {
            "@id": SHACL.sourceConstraintComponent,
            "@type": "@id",
        },
        "detail": {
            "@id": SHACL.detail,
            "@type": "@id",
        },
        "resultMessage": {
            "@id": SHACL.resultMessage,
            "@type": XSD.string,
        },
        "resultSeverity": {
            "@id": SHACL.resultSeverity,
            "@type": "@id",
        },
    };
    var ValidationResult = {
        TYPE: SHACL.ValidationResult,
        SCHEMA: SCHEMA$l,
    };

    var SCHEMA$m = {
        "buildDate": {
            "@id": C.buildDate,
            "@type": XSD.dateTime,
        },
        "version": {
            "@id": C.version,
            "@type": XSD.string,
        },
    };
    var PlatformInstance = {
        TYPE: C.PlatformInstance,
        SCHEMA: SCHEMA$m,
    };

    var SCHEMA$n = {
        "instance": {
            "@id": C.instance,
            "@type": "@id",
        },
    };
    var PlatformMetadata = {
        TYPE: C.Platform,
        SCHEMA: SCHEMA$n,
    };

    var GlobalContext = (function (_super) {
        __extends(GlobalContext, _super);
        function GlobalContext() {
            var _this = _super.call(this, undefined) || this;
            _this._baseURI = "";
            _this._generalObjectSchema = new DigestedObjectSchema();
            _this.registry = GeneralRegistry.createFrom({ context: _this, __modelDecorator: RegisteredPointer });
            _this.__registerDefaultObjectSchemas();
            _this.__registerDefaultDecorators();
            return _this;
        }
        GlobalContext.prototype.__registerDefaultObjectSchemas = function () {
            this
                .extendObjectSchema(Document)
                .extendObjectSchema(PlatformMetadata)
                .extendObjectSchema(PlatformInstance)
                .extendObjectSchema(AddMemberAction)
                .extendObjectSchema(RemoveMemberAction)
                .extendObjectSchema(Error$1)
                .extendObjectSchema(Map$1)
                .extendObjectSchema(MapEntry.SCHEMA)
                .extendObjectSchema(DocumentMetadata)
                .extendObjectSchema(ErrorResponse)
                .extendObjectSchema(ResponseMetadata)
                .extendObjectSchema(ValidationError)
                .extendObjectSchema(ValidationReport)
                .extendObjectSchema(ValidationResult)
                .extendObjectSchema(QueryMetadata)
                .extendObjectSchema(ChildCreatedEvent)
                .extendObjectSchema(DocumentCreatedEventDetails)
                .extendObjectSchema(DocumentDeletedEvent)
                .extendObjectSchema(DocumentModifiedEvent)
                .extendObjectSchema(MemberAddedEvent)
                .extendObjectSchema(MemberAddedEventDetails)
                .extendObjectSchema(MemberRemovedEvent)
                .extendObjectSchema(MemberRemovedEventDetails);
        };
        GlobalContext.prototype.__registerDefaultDecorators = function () {
        };
        GlobalContext.instance = new GlobalContext();
        return GlobalContext;
    }(AbstractContext));

    var DocumentsContext = (function (_super) {
        __extends(DocumentsContext, _super);
        function DocumentsContext(url) {
            var _this = _super.call(this, GlobalContext.instance) || this;
            _this._baseURI = url;
            _this.registry = DocumentsRegistry.createFrom({ context: _this });
            _this.repository = DocumentsRepository.createFrom({ context: _this });
            _this.messaging = new MessagingService(_this);
            return _this;
        }
        DocumentsContext.__mergePaths = function (target, source) {
            if (!source)
                return target;
            if (!target)
                return ObjectUtils.clone(source, { objects: true });
            for (var _i = 0, _a = Object.keys(source); _i < _a.length; _i++) {
                var key = _a[_i];
                var sourcePath = source[key];
                if (sourcePath === null) {
                    delete target[key];
                    continue;
                }
                var targetPath = target[key];
                if (!targetPath) {
                    target[key] = isObject(sourcePath) ?
                        ObjectUtils.clone(sourcePath, { objects: true }) :
                        sourcePath;
                    continue;
                }
                if (isString(sourcePath)) {
                    if (isObject(targetPath)) {
                        targetPath.slug = sourcePath;
                    }
                    else {
                        target[key] = sourcePath;
                    }
                    continue;
                }
                if (sourcePath.slug === void 0 && sourcePath.paths === void 0)
                    continue;
                var targetDocPaths = isString(targetPath) ?
                    target[key] = { slug: targetPath } : targetPath;
                if (sourcePath.slug !== void 0)
                    targetDocPaths.slug = sourcePath.slug;
                if (sourcePath.paths !== void 0)
                    targetDocPaths.paths = DocumentsContext.__mergePaths(targetDocPaths.paths, sourcePath.paths);
            }
            return target;
        };
        DocumentsContext.prototype._resolvePath = function (path) {
            var leftSearchedPaths = path.split(".");
            var currentSearchedPaths = [];
            var url = "";
            var documentPaths = this._settings && this._settings.paths;
            while (leftSearchedPaths.length) {
                var containerKey = leftSearchedPaths.shift();
                currentSearchedPaths.push(containerKey);
                var containerPath = documentPaths ? documentPaths[containerKey] : null;
                if (!containerPath)
                    throw new IllegalStateError("The path \"" + currentSearchedPaths.join(".") + "\" hasn't been declared.");
                var slug = isString(containerPath) ? containerPath : containerPath.slug;
                if (!slug)
                    throw new IllegalStateError("The path \"" + currentSearchedPaths.join(".") + "\" doesn't have a slug set.");
                url = URI.resolve(url, slug);
                documentPaths = isObject(containerPath) ? containerPath.paths : undefined;
            }
            return this.resolve(url);
        };
        DocumentsContext.prototype._extendPaths = function (paths) {
            this._settings.paths = DocumentsContext.__mergePaths(this._settings.paths, paths);
        };
        DocumentsContext.prototype._extendsSettings = function (settings) {
            this._extendPaths(settings.paths);
            delete settings.paths;
            ObjectUtils.extend(this._settings, settings);
        };
        return DocumentsContext;
    }(AbstractContext));



    var Errors = /*#__PURE__*/Object.freeze({
        AbstractError: AbstractError,
        IDAlreadyInUseError: IDAlreadyInUseError,
        IllegalActionError: IllegalActionError,
        IllegalArgumentError: IllegalArgumentError,
        IllegalStateError: IllegalStateError,
        InvalidJSONLDSyntaxError: InvalidJSONLDSyntaxError,
        NotImplementedError: NotImplementedError
    });

    var StatusCode;
    (function (StatusCode) {
        StatusCode[StatusCode["CONTINUE"] = 100] = "CONTINUE";
        StatusCode[StatusCode["SWITCHING_PROTOCOLS"] = 101] = "SWITCHING_PROTOCOLS";
        StatusCode[StatusCode["OK"] = 200] = "OK";
        StatusCode[StatusCode["CREATED"] = 201] = "CREATED";
        StatusCode[StatusCode["ACCEPTED"] = 202] = "ACCEPTED";
        StatusCode[StatusCode["NON_AUTHORITATIVE_INFORMATION"] = 203] = "NON_AUTHORITATIVE_INFORMATION";
        StatusCode[StatusCode["NO_CONTENT"] = 204] = "NO_CONTENT";
        StatusCode[StatusCode["RESET_CONTENT"] = 205] = "RESET_CONTENT";
        StatusCode[StatusCode["PARTIAL_CONTENT"] = 206] = "PARTIAL_CONTENT";
        StatusCode[StatusCode["MULTIPLE_CHOICES"] = 300] = "MULTIPLE_CHOICES";
        StatusCode[StatusCode["MOVED_PERMANENTLY"] = 301] = "MOVED_PERMANENTLY";
        StatusCode[StatusCode["FOUND"] = 302] = "FOUND";
        StatusCode[StatusCode["SEE_OTHER"] = 303] = "SEE_OTHER";
        StatusCode[StatusCode["NOT_MODIFIED"] = 304] = "NOT_MODIFIED";
        StatusCode[StatusCode["USE_PROXY"] = 305] = "USE_PROXY";
        StatusCode[StatusCode["TEMPORARY_REDIRECT"] = 307] = "TEMPORARY_REDIRECT";
        StatusCode[StatusCode["BAD_REQUEST"] = 400] = "BAD_REQUEST";
        StatusCode[StatusCode["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
        StatusCode[StatusCode["PAYMENT_REQUIRED"] = 402] = "PAYMENT_REQUIRED";
        StatusCode[StatusCode["FORBIDDEN"] = 403] = "FORBIDDEN";
        StatusCode[StatusCode["NOT_FOUND"] = 404] = "NOT_FOUND";
        StatusCode[StatusCode["METHOD_NOT_ALLOWED"] = 405] = "METHOD_NOT_ALLOWED";
        StatusCode[StatusCode["NOT_ACCEPTABLE"] = 406] = "NOT_ACCEPTABLE";
        StatusCode[StatusCode["PROXY_AUTHENTICATION_REQUIRED"] = 407] = "PROXY_AUTHENTICATION_REQUIRED";
        StatusCode[StatusCode["REQUEST_TIME_OUT"] = 408] = "REQUEST_TIME_OUT";
        StatusCode[StatusCode["CONFLICT"] = 409] = "CONFLICT";
        StatusCode[StatusCode["GONE"] = 410] = "GONE";
        StatusCode[StatusCode["LENGTH_REQUIRED"] = 411] = "LENGTH_REQUIRED";
        StatusCode[StatusCode["PRECONDITION_FAILED"] = 412] = "PRECONDITION_FAILED";
        StatusCode[StatusCode["REQUEST_ENTITY_TOO_LARGE"] = 413] = "REQUEST_ENTITY_TOO_LARGE";
        StatusCode[StatusCode["REQUEST_URI_TOO_LARGE"] = 414] = "REQUEST_URI_TOO_LARGE";
        StatusCode[StatusCode["UNSUPPORTED_MEDIA_TYPE"] = 415] = "UNSUPPORTED_MEDIA_TYPE";
        StatusCode[StatusCode["REQUESTED_RANGE_NOT_SATISFIABLE"] = 416] = "REQUESTED_RANGE_NOT_SATISFIABLE";
        StatusCode[StatusCode["EXPECTATION_FAILED"] = 417] = "EXPECTATION_FAILED";
        StatusCode[StatusCode["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
        StatusCode[StatusCode["NOT_IMPLEMENTED"] = 501] = "NOT_IMPLEMENTED";
        StatusCode[StatusCode["BAD_GATEWAY"] = 502] = "BAD_GATEWAY";
        StatusCode[StatusCode["SERVICE_UNAVAILABLE"] = 503] = "SERVICE_UNAVAILABLE";
        StatusCode[StatusCode["GATEWAY_TIME_OUT"] = 504] = "GATEWAY_TIME_OUT";
        StatusCode[StatusCode["HTTP_VERSION_NOT_SUPPORTED"] = 505] = "HTTP_VERSION_NOT_SUPPORTED";
    })(StatusCode || (StatusCode = {}));



    var HTTP = /*#__PURE__*/Object.freeze({
        Errors: index$1,
        Header: Header,
        get HTTPMethod () { return HTTPMethod; },
        JSONParser: JSONParser,
        RequestService: RequestService,
        RequestUtils: RequestUtils,
        Response: Response,
        get StatusCode () { return StatusCode; },
        StringParser: StringParser
    });



    var JSONLD = /*#__PURE__*/Object.freeze({
        JSONLDConverter: JSONLDConverter,
        JSONLDParser: JSONLDParser,
        JSONLDProcessor: JSONLDProcessor,
        _guessXSDType: _guessXSDType
    });

    var DirectContainer = {
        TYPE: TransientDirectContainer.TYPE,
        is: function (value) {
            return TransientDirectContainer.is(value)
                && Document.is(value);
        },
        create: TransientDirectContainer.create,
        createFrom: TransientDirectContainer.createFrom,
    };



    var LDP$1 = /*#__PURE__*/Object.freeze({
        AddMemberAction: AddMemberAction,
        Error: Error$1,
        Map: Map$1,
        MapEntry: MapEntry,
        DirectContainer: DirectContainer,
        TransientDirectContainer: TransientDirectContainer,
        DocumentMetadata: DocumentMetadata,
        ErrorResponse: ErrorResponse,
        RemoveMemberAction: RemoveMemberAction,
        ResponseMetadata: ResponseMetadata,
        ValidationError: ValidationError,
        VolatileResource: VolatileResource
    });



    var LDPatch = /*#__PURE__*/Object.freeze({
        DeltaCreator: DeltaCreator,
        LDPatchToken: LDPatchToken,
        PrefixToken: PrefixToken$1,
        AddToken: AddToken,
        DeleteToken: DeleteToken,
        UpdateListToken: UpdateListToken,
        SliceToken: SliceToken
    });



    var Messaging = /*#__PURE__*/Object.freeze({
        ChildCreatedEvent: ChildCreatedEvent,
        DocumentCreatedEventDetails: DocumentCreatedEventDetails,
        DocumentDeletedEvent: DocumentDeletedEvent,
        DocumentModifiedEvent: DocumentModifiedEvent,
        get Event () { return Event; },
        EventMessage: EventMessage,
        MemberAddedEvent: MemberAddedEvent,
        MemberAddedEventDetails: MemberAddedEventDetails,
        MemberEventDetails: MemberEventDetails,
        MemberRemovedEvent: MemberRemovedEvent,
        MemberRemovedEventDetails: MemberRemovedEventDetails,
        MessagingService: MessagingService,
        _validateEventType: _validateEventType,
        _parseURIPattern: _parseURIPattern,
        _createDestination: _createDestination
    });



    var RDF = /*#__PURE__*/Object.freeze({
        RDFDocument: RDFDocument,
        RDFList: RDFList,
        Serializers: index,
        RDFLiteral: RDFLiteral,
        RDFNode: RDFNode,
        URI: URI,
        RDFValue: RDFValue
    });



    var SHACL$1 = /*#__PURE__*/Object.freeze({
        ValidationReport: ValidationReport,
        ValidationResult: ValidationResult
    });



    var SPARQL = /*#__PURE__*/Object.freeze({
        SPARQLService: SPARQLService,
        SPARQLBuilder: SPARQLBuilder,
        SPARQLRawResultsParser: SPARQLRawResultsParser
    });



    var System = /*#__PURE__*/Object.freeze({
        PlatformMetadata: PlatformMetadata,
        PlatformInstance: PlatformInstance
    });

    var RDF$1 = {
        namespace: "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
        type: "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
    };



    var Vocabularies = /*#__PURE__*/Object.freeze({
        C: C,
        LDP: LDP,
        RDF: RDF$1,
        SHACL: SHACL,
        XSD: XSD
    });

    var CarbonLDP = (function (_super) {
        __extends(CarbonLDP, _super);
        function CarbonLDP(urlOrSettings) {
            var _this = _super.call(this, __getURLFrom(urlOrSettings)) || this;
            _this._settings = {
                vocabulary: "vocabularies/main/#",
                paths: {
                    system: {
                        slug: ".system/",
                        paths: {
                            platform: "platform/",
                            credentials: "credentials/",
                            roles: "roles/",
                        },
                    },
                    users: {
                        slug: "users/",
                        paths: {
                            me: "me/",
                        },
                    },
                },
            };
            _this._extendsSettings(__getSettingsFrom(urlOrSettings));
            _this.documents = _this.registry.getPointer(_this._baseURI, true);
            return _this;
        }
        Object.defineProperty(CarbonLDP, "version", {
            get: function () { return "5.2.0"; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CarbonLDP.prototype, "version", {
            get: function () { return CarbonLDP.version; },
            enumerable: true,
            configurable: true
        });
        CarbonLDP.prototype.getPlatformMetadata = function () {
            var _this = this;
            return promiseMethod(function () {
                var uri = _this._resolvePath("system.platform");
                return _this.documents.$get(uri);
            });
        };
        CarbonLDP.AbstractContext = AbstractContext;
        CarbonLDP.AccessPoint = AccessPoint;
        CarbonLDP.TransientAccessPoint = TransientAccessPoint;
        CarbonLDP.Errors = Errors;
        CarbonLDP.FreeResources = FreeResources;
        CarbonLDP.HTTP = HTTP;
        CarbonLDP.JSONLD = JSONLD;
        CarbonLDP.LDP = LDP$1;
        CarbonLDP.LDPatch = LDPatch;
        CarbonLDP.Messaging = Messaging;
        CarbonLDP.Vocabularies = Vocabularies;
        CarbonLDP.ObjectSchemaUtils = ObjectSchemaUtils;
        CarbonLDP.ObjectSchemaDigester = ObjectSchemaDigester;
        CarbonLDP.DigestedObjectSchemaProperty = DigestedObjectSchemaProperty;
        CarbonLDP.PointerType = PointerType;
        CarbonLDP.ContainerType = ContainerType;
        CarbonLDP.DigestedObjectSchema = DigestedObjectSchema;
        CarbonLDP.Document = Document;
        CarbonLDP.Fragment = Fragment;
        CarbonLDP.TransientFragment = TransientFragment;
        CarbonLDP.Pointer = Pointer;
        CarbonLDP.RDF = RDF;
        CarbonLDP.Resource = Resource;
        CarbonLDP.GlobalContext = GlobalContext;
        CarbonLDP.SHACL = SHACL$1;
        CarbonLDP.SPARQL = SPARQL;
        CarbonLDP.System = System;
        CarbonLDP.Utils = Utils;
        return CarbonLDP;
    }(DocumentsContext));
    function __getURLFrom(urlOrSettings) {
        return isString(urlOrSettings) ?
            __getURLFromString(urlOrSettings) :
            __getURLFromSettings(urlOrSettings);
    }
    function __getURLFromString(url) {
        if (!URI.hasProtocol(url))
            throw new IllegalArgumentError("The URL must contain a valid protocol: \"http://\", \"https://\".");
        if (url.endsWith("/"))
            return url;
        return url + "/";
    }
    function __getURLFromSettings(settings) {
        if (!isString(settings.host))
            throw new IllegalArgumentError("The settings object must contains a valid host string.");
        if (hasProtocol(settings.host))
            throw new IllegalArgumentError("The host must not contain a protocol.");
        if (settings.host.includes(":"))
            throw new IllegalArgumentError("The host must not contain a port.");
        var protocol = settings.ssl === false ? "http://" : "https://";
        var host = settings.host.endsWith("/") ? settings.host.slice(0, -1) : settings.host;
        var url = "" + protocol + host + "/";
        if (!isNumber(settings.port))
            return url;
        return url.slice(0, -1) + (":" + settings.port + "/");
    }
    function __getSettingsFrom(urlOrSettings) {
        if (isString(urlOrSettings))
            return {};
        return Object.assign({}, urlOrSettings, { ssl: null, host: null, port: null });
    }

    return CarbonLDP;

}));
