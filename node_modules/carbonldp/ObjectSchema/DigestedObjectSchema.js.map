{"version":3,"sources":["ObjectSchema/DigestedObjectSchema.ts"],"names":[],"mappings":";;AAAA,kCAAiC;AAGjC,yDAAwD;AAMxD;IAsBC;QACC,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;QACf,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,EAAkB,CAAC;QAC1C,IAAI,CAAC,UAAU,GAAG,IAAI,GAAG,EAAwC,CAAC;IACnE,CAAC;IAsBD,yCAAU,GAAV,UAAY,GAAiB,EAAE,UAAiD;QAAjD,2BAAA,EAAA,eAAiD;QAC/E,IAAI,GAAG,KAAK,IAAI,IAAI,SAAG,CAAC,UAAU,CAAE,GAAG,CAAE,IAAI,SAAG,CAAC,SAAS,CAAE,GAAG,CAAE;YAAG,OAAO,GAAG,CAAC;QAEzE,IAAA,mBAAsF,EAApF,cAAM,EAAE,UAAc,EAAd,mCAA4E,CAAC;QAE7F,IAAM,gBAAgB,GAAiB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAE,MAAM,CAAE,CAAC,CAAC;YACnE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAE,MAAM,CAAG,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAE,MAAM,CAAE,CAAC,CAAC;YAC7D,IAAI,CAAC,UAAU,CAAC,GAAG,CAAE,MAAM,CAAG,CAAC,GAAG;YAClC,CAAC,CAAC,IAAI,CAAC;QAET,IAAI,gBAAgB,KAAK,IAAI,IAAI,gBAAgB,KAAK,MAAM,EAAG;YAC9D,OAAO,IAAI,CAAC,UAAU,CAAE,gBAAgB,GAAG,SAAS,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,CAAE,CAAC;SACxE;QAED,IAAI,SAAS;YAAG,OAAO,GAAG,CAAC;QAE3B,IAAI,UAAU,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK;YAAG,OAAO,IAAI,CAAC,KAAK,GAAG,GAAG,CAAC;QAC7D,IAAI,UAAU,CAAC,IAAI;YAAG,OAAO,SAAG,CAAC,OAAO,CAAE,IAAI,CAAC,IAAI,EAAE,GAAG,CAAE,CAAC;QAE3D,OAAO,GAAG,CAAC;IACZ,CAAC;IAUD,0CAAW,GAAX,UAAa,IAAW;QACvB,IAAI,CAAE,IAAI,CAAC,UAAU,CAAC,GAAG,CAAE,IAAI,CAAE;YAAG,OAAO,KAAK,CAAC,CAAC;QAClD,OAAO,qCAAiB,CAAC,gBAAgB,CAAE,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,GAAG,CAAE,IAAI,CAAG,CAAE,CAAC;IACjF,CAAC;IAEF,2BAAC;AAAD,CArFA,AAqFC,IAAA;AArFY,oDAAoB","file":"DigestedObjectSchema.js","sourcesContent":["import { URI } from \"../RDF/URI\";\n\nimport { DigestedObjectSchemaProperty } from \"./DigestedObjectSchemaProperty\";\nimport { ObjectSchemaUtils } from \"./ObjectSchemaUtils\";\n\n\n/**\n * Standardized schema that is used for the SDK for compact and expand JSON-LD objects.\n */\nexport class DigestedObjectSchema {\n\t/**\n\t * The base URI of the schema.\n\t */\n\tbase:string;\n\t/**\n\t * The default language of the string properties.\n\t */\n\tlanguage:string | null;\n\t/**\n\t * URI that will be used to resolve relative URIs that aren't defined in the schema.\n\t */\n\tvocab:string | undefined;\n\t/**\n\t * Map that contains the prefixes of absolutes URIs.\n\t */\n\tprefixes:Map<string, string>;\n\t/**\n\t * Map that contains the definitions of the properties in the schema.\n\t */\n\tproperties:Map<string, DigestedObjectSchemaProperty>;\n\n\tconstructor() {\n\t\tthis.base = \"\";\n\t\tthis.vocab = undefined;\n\t\tthis.language = null;\n\t\tthis.prefixes = new Map<string, string>();\n\t\tthis.properties = new Map<string, DigestedObjectSchemaProperty>();\n\t}\n\n\t/**\n\t * Tries to resolve a non absolute URI using the schema and the configuration provided.\n\t *\n\t * The configuration indicates if the `vocab` or the `base` URI must be used to resolve the URI;\n\t * if both are set, the `vocab` one takes preference before the `base`-\n\t *\n\t * @param uri Relative URI to resolve.\n\t * @param relativeTo Object with flags indicating which resolution mode to use.\n\t */\n\tresolveURI( uri:string, relativeTo?:{ vocab?:boolean, base?:boolean } ):string;\n\t/**\n\t * Tries to resolve a non absolute URI using the schema and the configuration provided.\n\t *\n\t * The configuration indicates if the `vocab` or the `base` URI must be used to resolve the URI;\n\t * if both are set, the `vocab` one takes preference before the `base`-\n\t *\n\t * @param uri Relative URI to resolve.\n\t * @param relativeTo Object with flags indicating which resolution mode to use.\n\t */\n\tresolveURI( uri:string | null, relativeTo?:{ vocab?:boolean, base?:boolean } ):string | null;\n\tresolveURI( uri:string | null, relativeTo:{ vocab?:boolean, base?:boolean } = {} ):string | null {\n\t\tif( uri === null || URI.isAbsolute( uri ) || URI.isBNodeID( uri ) ) return uri;\n\n\t\tconst [ prefix, localName = \"\" ]:[ string, string ] = uri.split( \":\" ) as [ string, string ];\n\n\t\tconst definedReference:string | null = this.prefixes.has( prefix ) ?\n\t\t\tthis.prefixes.get( prefix )! : this.properties.has( prefix ) ?\n\t\t\t\tthis.properties.get( prefix )!.uri\n\t\t\t\t: null;\n\n\t\tif( definedReference !== null && definedReference !== prefix ) {\n\t\t\treturn this.resolveURI( definedReference + localName, { vocab: true } );\n\t\t}\n\n\t\tif( localName ) return uri;\n\n\t\tif( relativeTo.vocab && this.vocab ) return this.vocab + uri;\n\t\tif( relativeTo.base ) return URI.resolve( this.base, uri );\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the definition of a property resolving internal URIs\n\t * using the current schema configuration.\n\t *\n\t * If no property exists with the name provided `undefined` is returned.\n\t *\n\t * @param name Property name to return its definition.\n\t */\n\tgetProperty( name:string ):DigestedObjectSchemaProperty | undefined {\n\t\tif( ! this.properties.has( name ) ) return void 0;\n\t\treturn ObjectSchemaUtils._resolveProperty( this, this.properties.get( name )! );\n\t}\n\n}\n"],"sourceRoot":"../../src"}