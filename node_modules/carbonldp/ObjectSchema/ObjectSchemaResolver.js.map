{"version":3,"sources":["ObjectSchema/ObjectSchemaResolver.ts"],"names":[],"mappings":";;AAEA,0DAAyD;AAKzD,oCAAsC;AACtC,kCAAiC;AAEjC,uCAAsC;AAEtC,+DAA8D;AAC9D,+DAA8D;AAoC9D,SAAS,kBAAkB,CAAa,QAA4B,EAAE,IAAyC;IAC9G,IAAM,KAAK,GAAY,cAAO,CAAC,QAAQ,CAAE,IAAW,CAAE,CAAC;IACvD,OAAO,WAAW,CAAE,QAAQ,EAAE,KAAK,EAAE,IAAI,CAAE,KAAK,CAAE,CAAE,CAAC;AACtD,CAAC;AAED,SAAS,sBAAsB,CAAa,QAA4B,EAAE,QAAyC;IAClH,IAAM,KAAK,GAAY,QAAQ,CAAC,KAAK,IAAI,EAAE,CAAC;IAC5C,OAAO,WAAW,CAAE,QAAQ,EAAE,KAAK,EAAE,QAAQ,CAAC,GAAG,CAAE,CAAC;AACrD,CAAC;AAED,SAAS,WAAW,CAAa,QAA4B,EAAE,WAAoB,EAAE,QAAgB;IACpG,IAAI,CAAE,QAAQ;QAAG,OAAO,IAAI,2CAAoB,EAAE,CAAC;IAEnD,IAAI,QAAQ,KAAK,KAAK,CAAC,IAAI,CAAE,SAAG,CAAC,WAAW,CAAE,QAAQ,CAAE,IAAI,CAAE,SAAG,CAAC,SAAS,CAAE,QAAQ,CAAE,IAAI,WAAW,CAAC,OAAO,CAAE,KAAC,CAAC,QAAQ,CAAE,KAAK,CAAE,CAAC;QACnI,WAAW,GAAG,WAAW,CAAC,MAAM,CAAE,KAAC,CAAC,QAAQ,CAAE,CAAC;IAEhD,IAAM,aAAa,GAA0B,WAAW;SACtD,MAAM,CAAE,UAAA,IAAI,IAAI,OAAA,QAAQ,CAAC,eAAe,CAAE,IAAI,CAAE,EAAhC,CAAgC,CAAE;SAClD,GAAG,CAAE,UAAA,IAAI,IAAI,OAAA,QAAQ,CAAC,eAAe,CAAE,IAAI,CAAE,EAAhC,CAAgC,CAAE,CAChD;IAED,OAAO,2CAAoB;SACzB,eAAe;QACf,QAAQ,CAAC,eAAe,EAAE;aACvB,aAAa,EACd,CAAC;AACN,CAAC;AAQY,QAAA,oBAAoB,GAA+B;IAC/D,SAAS,EAAE;QACV,OAAO,EAAE,SAAS;QAElB,gBAAgB,EAAhB;YACC,IAAI,CAAE,IAAI,CAAC,OAAO;gBAAG,OAAO,IAAI,2CAAoB,EAAE,CAAC;YACvD,OAAO,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE,CAAC;QACvC,CAAC;QAGD,YAAY,EAAZ,UAAyC,MAAa,EAAE,IAAY;YACnE,OAAO,CAAE,IAAI,CAAC;QACf,CAAC;QAED,YAAY,EAAZ,UAAyC,MAAgC;YACxE,OAAO,OAAO,IAAI,MAAM,IAAI,KAAK,IAAI,MAAM,CAAC,CAAC;gBAC5C,sBAAsB,CAAE,IAAI,CAAC,OAAO,EAAE,MAAM,CAAE,CAAC,CAAC;gBAChD,kBAAkB,CAAE,IAAI,CAAC,OAAO,EAAE,MAAM,CAAE,CAAC;QAC7C,CAAC;KACD;IAGD,WAAW,EAAX,UAAa,MAAa;QACzB,OAAO,+BAAc,CAAC,iBAAiB,CAAE,4BAAoB,CAAC,SAAS,EAAE,MAAM,CAAE,CAAC;IACnF,CAAC;IAED,QAAQ,EAAR,UAA4B,MAAQ;QACnC,OAAO,+BAAc,CAAC,oBAAoB,CAAE,4BAAoB,CAAC,SAAS,EAAE,MAAM,CAAE,CAAC;IACtF,CAAC;CACD,CAAC","file":"ObjectSchemaResolver.js","sourcesContent":["import { Context } from \"../Context/Context\";\n\nimport { ModelDecorator } from \"../Model/ModelDecorator\";\nimport { ModelPrototype } from \"../Model/ModelPrototype\";\n\nimport { QueryablePointer } from \"../QueryDocuments/QueryablePointer\";\n\nimport { RDFNode } from \"../RDF/Node\";\nimport { URI } from \"../RDF/URI\";\n\nimport { C } from \"../Vocabularies/C\";\n\nimport { DigestedObjectSchema } from \"./DigestedObjectSchema\";\nimport { ObjectSchemaDigester } from \"./ObjectSchemaDigester\";\n\n\n/**\n * Interface that defines the methods needed for an element that can provide object schemas.\n */\nexport interface ObjectSchemaResolver {\n\t/**\n\t * Optional context where to obtain the contexts.\n\t */\n\tcontext?:Context;\n\n\n\t/**\n\t * Returns the general object schema that applies to all the resources.\n\t */\n\tgetGeneralSchema():DigestedObjectSchema;\n\n\t// TODO: Remove path param\n\t/**\n\t * Returns true if the object provided has an specific schema for.\n\t * @param object The object to check if it has any associated schema.\n\t * @param path\n\t */\n\thasSchemaFor( object:object, path?:string ):boolean;\n\n\t// TODO: Remove path param\n\t/**\n\t * Returns the specific object schema that applies to the object provided.\n\t * @param object The object to look for its associated schema.\n\t * @param path\n\t */\n\tgetSchemaFor( object:object, path?:string ):DigestedObjectSchema;\n}\n\n\nfunction __getSchemaForNode( this:void, $context:Context | undefined, node:{ \"@id\"?:string, \"@type\"?:string[] } ):DigestedObjectSchema {\n\tconst types:string[] = RDFNode.getTypes( node as any );\n\treturn __getSchema( $context, types, node[ \"@id\" ] );\n}\n\nfunction __getSchemaForResource( this:void, $context:Context | undefined, resource:{ $id?:string, types?:string[] } ):DigestedObjectSchema {\n\tconst types:string[] = resource.types || [];\n\treturn __getSchema( $context, types, resource.$id );\n}\n\nfunction __getSchema( this:void, $context:Context | undefined, objectTypes:string[], objectID?:string ):DigestedObjectSchema {\n\tif( ! $context ) return new DigestedObjectSchema();\n\n\tif( objectID !== void 0 && ! URI.hasFragment( objectID ) && ! URI.isBNodeID( objectID ) && objectTypes.indexOf( C.Document ) === - 1 )\n\t\tobjectTypes = objectTypes.concat( C.Document );\n\n\tconst objectSchemas:DigestedObjectSchema[] = objectTypes\n\t\t.filter( type => $context.hasObjectSchema( type ) )\n\t\t.map( type => $context.getObjectSchema( type ) )\n\t;\n\n\treturn ObjectSchemaDigester\n\t\t._combineSchemas( [\n\t\t\t$context.getObjectSchema(),\n\t\t\t...objectSchemas,\n\t\t] );\n}\n\n\nexport type ObjectSchemaResolverFactory =\n\t& ModelPrototype<ObjectSchemaResolver>\n\t& ModelDecorator<ObjectSchemaResolver>\n\t;\n\nexport const ObjectSchemaResolver:ObjectSchemaResolverFactory = {\n\tPROTOTYPE: {\n\t\tcontext: undefined,\n\n\t\tgetGeneralSchema( this:ObjectSchemaResolver ):DigestedObjectSchema {\n\t\t\tif( ! this.context ) return new DigestedObjectSchema();\n\t\t\treturn this.context.getObjectSchema();\n\t\t},\n\n\n\t\thasSchemaFor( this:ObjectSchemaResolver, object:object, path?:string ):boolean {\n\t\t\treturn ! path;\n\t\t},\n\n\t\tgetSchemaFor( this:ObjectSchemaResolver, object:object | QueryablePointer ):DigestedObjectSchema {\n\t\t\treturn \"types\" in object || \"$id\" in object ?\n\t\t\t\t__getSchemaForResource( this.context, object ) :\n\t\t\t\t__getSchemaForNode( this.context, object );\n\t\t},\n\t},\n\n\n\tisDecorated( object:object ):object is ObjectSchemaResolver {\n\t\treturn ModelDecorator.hasPropertiesFrom( ObjectSchemaResolver.PROTOTYPE, object );\n\t},\n\n\tdecorate<T extends object>( object:T ):T & ObjectSchemaResolver {\n\t\treturn ModelDecorator.definePropertiesFrom( ObjectSchemaResolver.PROTOTYPE, object );\n\t},\n};\n"],"sourceRoot":"../../src"}