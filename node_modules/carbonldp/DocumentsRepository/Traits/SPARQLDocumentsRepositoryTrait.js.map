{"version":3,"sources":["DocumentsRepository/Traits/SPARQLDocumentsRepositoryTrait.ts"],"names":[],"mappings":"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","file":"SPARQLDocumentsRepositoryTrait.js","sourcesContent":["import { QueryClause } from \"sparqler/clauses\";\n\nimport { DocumentsContext } from \"../../Context/DocumentsContext\";\n\nimport { Document } from \"../../Document/Document\";\n\nimport { IllegalArgumentError } from \"../../Errors/IllegalArgumentError\";\n\nimport { GeneralRepository } from \"../../GeneralRepository/GeneralRepository\";\n\nimport { RequestOptions, RequestUtils } from \"../../HTTP/Request\";\n\nimport { ModelDecorator } from \"../../Model/ModelDecorator\";\nimport { ModelPrototype } from \"../../Model/ModelPrototype\";\n\nimport { DigestedObjectSchema } from \"../../ObjectSchema/DigestedObjectSchema\";\n\nimport { SPARQLSelectResults } from \"../../SPARQL/SelectResults\";\nimport { FinishSPARQLAsk, FinishSPARQLSelect, SPARQLBuilder } from \"../../SPARQL/SPARQLBuilder\";\nimport { SPARQLService } from \"../../SPARQL/SPARQLService\";\n\nimport { BaseDocumentsRepository } from \"../BaseDocumentsRepository\";\nimport { _getErrorResponseParserFn } from \"../Utils\";\n\nimport { HTTPRepositoryTrait } from \"./HTTPRepositoryTrait\";\n\n\n/**\n * Trait of a {@link DocumentsRepository} with methods for SPARQL requests.\n */\nexport interface SPARQLDocumentsRepositoryTrait extends GeneralRepository<Document> {\n\t/**\n\t * Context from where the repository is created.\n\t */\n\treadonly context:DocumentsContext;\n\n\n\t/**\n\t * Executes an ASK query on the document of the specified URI.\n\t * @param uri URI of the document where to execute the query.\n\t * @param askQuery ASK query to be executed.\n\t * @param requestOptions Customizable options for the request.\n\t */\n\texecuteASKQuery( uri:string, askQuery:string, requestOptions?:RequestOptions ):Promise<boolean>;\n\n\t/**\n\t * Executes a SELECT query on the document of the specified URI.\n\t * @param uri URI of the document where to execute the query.\n\t * @param selectQuery SELECT query to be executed.\n\t * @param requestOptions Customizable options for the request.\n\t */\n\texecuteSELECTQuery<T extends object>( uri:string, selectQuery:string, requestOptions?:RequestOptions ):Promise<SPARQLSelectResults<T>>;\n\n\t/**\n\t * Executes an UPDATE in the document of the specified URI.\n\t * @param uri URI of the document where to execute the update.\n\t * @param update UPDATE to be executed.\n\t * @param requestOptions Customizable options for the request.\n\t */\n\texecuteUPDATE( uri:string, update:string, requestOptions?:RequestOptions ):Promise<void>;\n\n\n\t/**\n\t * Creates an instance of [SPARQLER](https://github.com/CarbonLDP/sparqler) builder\n\t * for the current document or the one specified by the URI.\n\t * @param uri URI of the document from where to create the query builder.\n\t */\n\tsparql( uri:string ):QueryClause<FinishSPARQLSelect, FinishSPARQLAsk>;\n}\n\n\n/**\n * Factory, decorator and utils for {@link SPARQLDocumentsRepositoryTrait}.\n */\nexport type SPARQLDocumentsRepositoryTraitFactory =\n\t& ModelPrototype<SPARQLDocumentsRepositoryTrait, HTTPRepositoryTrait>\n\t& ModelDecorator<SPARQLDocumentsRepositoryTrait, BaseDocumentsRepository>\n\t;\n\n/**\n * Constant that implements {@link SPARQLDocumentsRepositoryTraitFactory}.\n */\nexport const SPARQLDocumentsRepositoryTrait:SPARQLDocumentsRepositoryTraitFactory = {\n\tPROTOTYPE: {\n\t\texecuteASKQuery( this:SPARQLDocumentsRepositoryTrait, uri:string, askQuery:string, requestOptions?:RequestOptions ):Promise<boolean> {\n\t\t\tif( ! this.context.registry.inScope( uri, true ) ) return Promise.reject( new IllegalArgumentError( `\"${uri}\" is out of scope.` ) );\n\t\t\tconst url:string = this.context.getObjectSchema().resolveURI( uri, { base: true } );\n\n\t\t\trequestOptions = requestOptions ? requestOptions : {};\n\n\t\t\t// Accept JSON-LD as secondary accepted format in case the platform returns an error message (hence the q=0.9)\n\t\t\tRequestUtils.setAcceptHeader( \"application/ld+json; q=0.9\", requestOptions! );\n\n\t\t\treturn SPARQLService\n\t\t\t\t.executeASKQuery( url, askQuery, requestOptions )\n\t\t\t\t.then( ( [ rawResults ] ) => rawResults )\n\t\t\t\t.catch( _getErrorResponseParserFn( this.context.registry ) );\n\t\t},\n\n\t\texecuteSELECTQuery<T extends object>( this:SPARQLDocumentsRepositoryTrait, uri:string, selectQuery:string, requestOptions?:RequestOptions ):Promise<SPARQLSelectResults<T>> {\n\t\t\tif( ! this.context.registry.inScope( uri, true ) ) return Promise.reject( new IllegalArgumentError( `\"${uri}\" is out of scope.` ) );\n\t\t\tconst url:string = this.context.getObjectSchema().resolveURI( uri, { base: true } );\n\n\t\t\trequestOptions = requestOptions ? requestOptions : {};\n\n\t\t\t// Accept JSON-LD as secondary accepted format in case the platform returns an error message (hence the q=0.9)\n\t\t\tRequestUtils.setAcceptHeader( \"application/ld+json; q=0.9\", requestOptions! );\n\n\t\t\treturn SPARQLService\n\t\t\t\t.executeSELECTQuery<T>( url, selectQuery, this.context.registry, requestOptions )\n\t\t\t\t.then( ( [ selectResults ] ) => selectResults )\n\t\t\t\t.catch( _getErrorResponseParserFn( this.context.registry ) );\n\t\t},\n\n\t\texecuteUPDATE( this:SPARQLDocumentsRepositoryTrait, uri:string, update:string, requestOptions?:RequestOptions ):Promise<void> {\n\t\t\tif( ! this.context.registry.inScope( uri, true ) ) return Promise.reject( new IllegalArgumentError( `\"${uri}\" is out of scope.` ) );\n\t\t\tconst url:string = this.context.getObjectSchema().resolveURI( uri, { base: true } );\n\n\t\t\treturn SPARQLService\n\t\t\t\t.executeUPDATE( url, update, requestOptions )\n\t\t\t\t.then( () => {} )\n\t\t\t\t.catch( _getErrorResponseParserFn( this.context.registry ) );\n\t\t},\n\n\n\t\tsparql( this:SPARQLDocumentsRepositoryTrait, uri:string ):QueryClause<FinishSPARQLSelect, FinishSPARQLAsk> {\n\t\t\tif( ! this.context.registry.inScope( uri, true ) ) throw new IllegalArgumentError( `\"${uri}\" is out of scope.` );\n\t\t\tconst url:string = this.context.getObjectSchema().resolveURI( uri, { base: true } );\n\n\t\t\tconst schema:DigestedObjectSchema = this.context.registry.getGeneralSchema();\n\t\t\tlet builder:QueryClause<FinishSPARQLSelect, FinishSPARQLAsk> = new SPARQLBuilder( this, url )\n\t\t\t\t.base( schema.base )\n\t\t\t\t.vocab( schema.vocab! );\n\n\t\t\tschema.prefixes.forEach( ( name:string, prefix:string ) => {\n\t\t\t\tbuilder = builder.prefix( prefix, name );\n\t\t\t} );\n\n\t\t\treturn builder;\n\t\t},\n\t},\n\n\n\tisDecorated( object:object ):object is SPARQLDocumentsRepositoryTrait {\n\t\treturn ModelDecorator\n\t\t\t.hasPropertiesFrom( SPARQLDocumentsRepositoryTrait.PROTOTYPE, object );\n\t},\n\n\tdecorate<T extends BaseDocumentsRepository>( object:T ):T & SPARQLDocumentsRepositoryTrait {\n\t\tif( SPARQLDocumentsRepositoryTrait.isDecorated( object ) ) return object;\n\n\t\tconst target:T & GeneralRepository<any> = ModelDecorator\n\t\t\t.decorateMultiple( object, GeneralRepository );\n\n\t\treturn ModelDecorator\n\t\t\t.definePropertiesFrom( SPARQLDocumentsRepositoryTrait.PROTOTYPE, target );\n\t},\n};\n"],"sourceRoot":"../../../src"}