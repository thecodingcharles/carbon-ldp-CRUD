{"version":3,"sources":["QueryDocuments/QueryContainer.ts"],"names":[],"mappings":"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","file":"QueryContainer.js","sourcesContent":["import { IRIResolver } from \"sparqler/data\";\nimport { isPrefixed } from \"sparqler/iri\";\nimport { DeniableFluentPath, FluentPath, FluentPathContainer } from \"sparqler/patterns\";\nimport { IRIRefToken, IRIToken, PrefixToken } from \"sparqler/tokens\";\n\nimport { AbstractContext } from \"../Context/AbstractContext\";\n\nimport { IllegalArgumentError } from \"../Errors/IllegalArgumentError\";\n\nimport { DigestedObjectSchema } from \"../ObjectSchema/DigestedObjectSchema\";\nimport { DigestedObjectSchemaProperty } from \"../ObjectSchema/DigestedObjectSchemaProperty\";\nimport { ObjectSchemaDigester } from \"../ObjectSchema/ObjectSchemaDigester\";\nimport { ObjectSchemaProperty } from \"../ObjectSchema/ObjectSchemaProperty\";\nimport { RegisteredPointer } from \"../Registry/RegisteredPointer\";\n\nimport { QueryContainerProperty } from \"./QueryContainerProperty\";\nimport { QueryContainerPropertyType } from \"./QueryContainerPropertyType\";\nimport { QueryRootProperty } from \"./QueryRootProperty\";\nimport { QueryVariable } from \"./QueryVariable\";\n\n\n/**\n * Container of the query data specialized with elements for the custom querying of documents.\n */\nexport class QueryContainer extends FluentPathContainer<undefined> {\n\treadonly context:AbstractContext<RegisteredPointer, any, any>;\n\treadonly _queryProperty:QueryRootProperty | QueryContainerProperty;\n\n\tprivate readonly _generalSchema:DigestedObjectSchema;\n\tprivate readonly _prefixesTuples:[ string, string ][];\n\n\tprivate readonly _variablesMap:Map<string, QueryVariable>;\n\tprivate _variablesCounter:number;\n\n\n\tconstructor( context:AbstractContext<any, any, any>, propertyData:{ uri:string, containerPropertyType:QueryContainerPropertyType } | { uris:string[] } ) {\n\t\tconst schema:DigestedObjectSchema = context.getObjectSchema();\n\t\tsuper( {\n\t\t\tiriResolver: __createIRIResolver( schema ),\n\t\t\ttargetToken: void 0,\n\t\t\tfluentPathFactory: FluentPath.createFrom,\n\t\t\tdeniableFluentPathFactory: DeniableFluentPath.createFrom,\n\t\t} );\n\n\t\tthis.context = context;\n\n\t\tthis._generalSchema = schema;\n\t\tthis._prefixesTuples = Array.from( schema.prefixes );\n\n\t\tthis._variablesCounter = 0;\n\t\tthis._variablesMap = new Map();\n\n\t\t// Create target property\n\t\tif( \"uris\" in propertyData ) {\n\t\t\tconst values:IRIToken[] = propertyData.uris.map( this.compactIRI, this );\n\t\t\tthis._queryProperty = new QueryRootProperty( {\n\t\t\t\tqueryContainer: this,\n\t\t\t\tvalues: values,\n\t\t\t} );\n\n\t\t} else {\n\t\t\tconst iri:IRIToken = this.compactIRI( propertyData.uri );\n\t\t\tthis._queryProperty = new QueryContainerProperty( {\n\t\t\t\tqueryContainer: this,\n\t\t\t\tcontainerIRI: iri,\n\t\t\t\tcontainerPropertyType: propertyData.containerPropertyType,\n\t\t\t} );\n\t\t}\n\t}\n\n\n\t/**\n\t * Returns a variable from the specified name.\n\t * If a variable with the same name has already been created, it will be returned.\n\t * @param name Name of the variable to get.\n\t */\n\tgetVariable( name:string ):QueryVariable {\n\t\tif( this._variablesMap.has( name ) )\n\t\t\treturn this._variablesMap.get( name )!;\n\n\t\tconst variable:QueryVariable = new QueryVariable( name, this._variablesCounter ++ );\n\t\tthis._variablesMap.set( name, variable );\n\n\t\treturn variable;\n\t}\n\n\n\t/**\n\t * Created the minimal form of the specified IRI,\n\t * and transform into its corresponding token.\n\t * @param iri The iri to compact into a token.\n\t */\n\tcompactIRI( iri:string ):IRIToken {\n\t\tconst compactedIRI:string = this.__getCompactedIRI( iri );\n\t\treturn this.iriResolver.resolve( compactedIRI );\n\t}\n\n\tprotected __getCompactedIRI( iri:string ):string {\n\t\tif( isPrefixed( iri ) ) return iri;\n\n\t\tconst prefix:[ string, string ] | undefined = this._prefixesTuples\n\t\t\t.find( ( [ , x ] ) => iri.startsWith( x ) );\n\n\t\tif( ! prefix ) return iri;\n\n\t\tconst [ namespace, prefixIRI ] = prefix;\n\t\treturn `${namespace}:${iri.substr( prefixIRI.length )}`;\n\t}\n\n\n\t/**\n\t * Returns an array with the used prefixes in all the query.\n\t */\n\tgetPrologues():PrefixToken[] {\n\t\treturn this._prefixesTuples\n\t\t\t.filter( this.__isUsedPrefix, this )\n\t\t\t.map( __createPrefixToken )\n\t\t\t;\n\t}\n\n\tprotected __isUsedPrefix( [ namespace, ]:[ string, string ] ):boolean {\n\t\treturn ! ! this.iriResolver.prefixes.get( namespace );\n\t}\n\n\n\t/**\n\t * Standardizes the provided property definition using the schema associated of the container.\n\t * @param name The name of the property to process.\n\t * @param definition The definition of the property to process.\n\t */\n\tdigestProperty( name:string, definition:ObjectSchemaProperty ):DigestedObjectSchemaProperty {\n\t\treturn ObjectSchemaDigester\n\t\t\t.digestProperty( name, definition, this._generalSchema );\n\t}\n\n\t/**\n\t * Gets a copy of the associated schema of the container.\n\t */\n\tgetGeneralSchema():DigestedObjectSchema {\n\t\treturn ObjectSchemaDigester\n\t\t\t.combineDigestedObjectSchemas( [ this._generalSchema ] );\n\t}\n\n\n\t/**\n\t * Serializes a value using the specified type and the associated context's serializers.\n\t * @param type The type of the value to serialize.\n\t * @param value The value to serialize.\n\t */\n\tserializeLiteral( type:string, value:any ):string {\n\t\tif( ! this.context.jsonldConverter.literalSerializers.has( type ) )\n\t\t\tthrow new IllegalArgumentError( `Type \"${type}\" hasn't a defined serializer.` );\n\n\t\treturn this.context.jsonldConverter\n\t\t\t.literalSerializers\n\t\t\t.get( type )!\n\t\t\t.serialize( value );\n\t}\n\n}\n\n\nfunction __createIRIResolver( schema:DigestedObjectSchema ):IRIResolver {\n\tconst iriResolver:IRIResolver = new IRIResolver( void 0, schema.vocab );\n\n\tArray.from( schema.prefixes.keys() )\n\t\t.forEach( key => iriResolver.prefixes.set( key, false ) );\n\n\treturn iriResolver;\n}\n\nfunction __createPrefixToken( [ namespace, iri ]:[ string, string ] ):PrefixToken {\n\treturn new PrefixToken( namespace, new IRIRefToken( iri ) );\n}\n"],"sourceRoot":"../../src"}