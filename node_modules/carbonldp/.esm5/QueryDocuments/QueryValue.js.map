{"version":3,"sources":["QueryDocuments/QueryValue.ts"],"names":[],"mappings":"AAAA,OAAO,EAAY,aAAa,EAAE,YAAY,EAAE,eAAe,EAAE,MAAM,iBAAiB,CAAC;AAEzF,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAElC,OAAO,EAAE,GAAG,EAAE,MAAM,qBAAqB,CAAC;AAQ1C;IAMC,oBAAa,cAA6B,EAAE,KAAsC;QACjF,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;QAEtC,IAAI,MAAM,CAAE,KAAK,CAAE,EAAG;YACrB,IAAI,CAAC,QAAQ,CAAE,GAAG,CAAC,QAAQ,CAAE,CAAC;SAC9B;aAAM;YACN,IAAI,CAAC,QAAQ,GAAG,IAAI,YAAY,CAAE,KAAK,CAAE,CAAC;SAC1C;IACF,CAAC;IAQD,6BAAQ,GAAR,UAAU,IAAW;QACpB,IAAI,GAAG,CAAC,cAAc,CAAE,IAAI,CAAE;YAAG,IAAI,GAAG,GAAG,CAAE,IAAI,CAAE,CAAC;QAEpD,IAAM,KAAK,GAAU,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAE,IAAI,EAAE,IAAI,CAAC,MAAM,CAAE,CAAC;QAChF,IAAM,SAAS,GAAY,IAAI,CAAC,eAAe,CAAC,UAAU,CAAE,IAAI,CAAE,CAAC;QACnE,IAAI,CAAC,QAAQ,GAAG,IAAI,eAAe,CAAE,KAAK,EAAE,SAAS,CAAE,CAAC;QAExD,OAAO,IAAI,CAAC;IACb,CAAC;IAMD,iCAAY,GAAZ,UAAc,QAAe;QAC5B,IAAM,KAAK,GAAU,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAE,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAE,CAAC;QACtF,IAAM,aAAa,GAAiB,IAAI,aAAa,CAAE,QAAQ,CAAE,CAAC;QAClE,IAAI,CAAC,QAAQ,GAAG,IAAI,eAAe,CAAE,KAAK,EAAE,aAAa,CAAE,CAAC;QAE5D,OAAO,IAAI,CAAC;IACb,CAAC;IAMD,6BAAQ,GAAR;QACC,OAAO,IAAI,CAAC,QAAS,CAAC;IACvB,CAAC;IAKD,6BAAQ,GAAR;QACC,OAAO,KAAG,IAAI,CAAC,QAAU,CAAC;IAC3B,CAAC;IACF,iBAAC;AAAD,CA3DA,AA2DC,IAAA","file":"QueryValue.js","sourcesContent":["import { IRIToken, LanguageToken, LiteralToken, RDFLiteralToken } from \"sparqler/tokens\";\n\nimport { isDate } from \"../Utils\";\n\nimport { XSD } from \"../Vocabularies/XSD\";\n\nimport { QueryContainer } from \"./QueryContainer\";\n\n\n/**\n * Wrapper for a safe query value of any standard JS value.\n */\nexport class QueryValue {\n\tprivate readonly _queryContainer:QueryContainer;\n\n\tprivate readonly _value:string | number | boolean | Date;\n\tprivate _literal?:LiteralToken;\n\n\tconstructor( queryContainer:QueryContainer, value:string | number | boolean | Date ) {\n\t\tthis._value = value;\n\t\tthis._queryContainer = queryContainer;\n\n\t\tif( isDate( value ) ) {\n\t\t\tthis.withType( XSD.dateTime );\n\t\t} else {\n\t\t\tthis._literal = new LiteralToken( value );\n\t\t}\n\t}\n\n\n\t/**\n\t * Sets an specific type to the query value.\n\t * If the value is not string, it will be serialized.\n\t * @param type The type to be assigned to the literal value.\n\t */\n\twithType( type:string ):this {\n\t\tif( XSD.hasOwnProperty( type ) ) type = XSD[ type ];\n\n\t\tconst value:string = this._queryContainer.serializeLiteral( type, this._value );\n\t\tconst typeToken:IRIToken = this._queryContainer.compactIRI( type );\n\t\tthis._literal = new RDFLiteralToken( value, typeToken );\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets an specific language to the query value.\n\t * @param language The language to be assigned to the string literal value.\n\t */\n\twithLanguage( language:string ):this {\n\t\tconst value:string = this._queryContainer.serializeLiteral( XSD.string, this._value );\n\t\tconst languageToken:LanguageToken = new LanguageToken( language );\n\t\tthis._literal = new RDFLiteralToken( value, languageToken );\n\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Returns the SPARQL token of the value.\n\t */\n\tgetToken():LiteralToken {\n\t\treturn this._literal!;\n\t}\n\n\t/**\n\t * Returns the SPARQL string representation of the value.\n\t */\n\ttoString():string {\n\t\treturn `${this._literal}`;\n\t}\n}\n"],"sourceRoot":"../../src"}