import * as tslib_1 from "tslib";
import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { DigestedObjectSchemaProperty } from "../ObjectSchema/DigestedObjectSchemaProperty";
import { Pointer } from "../Pointer/Pointer";
import { RDFNode } from "../RDF/Node";
import { _isExistingValue } from "../Utils";
import { C } from "../Vocabularies/C";
import { XSD } from "../Vocabularies/XSD";
import { QueryableProperty } from "./QueryableProperty";
import { QueryableRootProperty } from "./QueryableRootProperty";
import { QueryPropertyType } from "./QueryPropertyType";
var QueryResultCompacter = (function () {
    function QueryResultCompacter(registry, queryContainer) {
        this.registry = registry;
        this.queryContainer = queryContainer;
    }
    Object.defineProperty(QueryResultCompacter.prototype, "jsonldConverter", {
        get: function () {
            return this.queryContainer.context.jsonldConverter;
        },
        enumerable: true,
        configurable: true
    });
    QueryResultCompacter.prototype.compactDocuments = function (rdfDocuments, targetDocuments) {
        var _this = this;
        if (!targetDocuments)
            targetDocuments = rdfDocuments.map(function (x) { return x["@id"]; });
        var compactionMap = new Map();
        rdfDocuments.forEach(function (rdfDocument) {
            var document = _this.registry.getPointer(rdfDocument["@id"], true);
            if (!document.$_queryableMetadata) {
                document.$_queryableMetadata = new QueryableRootProperty({
                    uri: document.$id,
                    propertyType: QueryPropertyType.PARTIAL,
                });
            }
            var previousFragments = new Set();
            document
                .$getPointers(true)
                .forEach(function (pointer) { return previousFragments.add(pointer.$id); });
            rdfDocument["@graph"].forEach(function (rdfNode) {
                var nodeID = rdfNode["@id"];
                var resource = nodeID !== rdfDocument["@id"]
                    ? document.$getPointer(nodeID, true)
                    : document;
                compactionMap.set(nodeID, {
                    node: rdfNode,
                    document: document,
                    resource: resource,
                });
                previousFragments.delete(nodeID);
            });
            previousFragments
                .forEach(function (pointer) { return document.$removePointer(pointer); });
        });
        targetDocuments.forEach(function (documentID) {
            var compactionNode = compactionMap.get(documentID);
            if (!compactionNode)
                throw new IllegalArgumentError("Invalid data provided.");
            var queryProperty = _this.queryContainer._queryProperty;
            var metadataProperty = compactionNode.resource.$_queryableMetadata;
            _this.__processNode(compactionMap, compactionNode, queryProperty, metadataProperty);
        });
        compactionMap.forEach(function (_a) {
            var node = _a.node, resource = _a.resource, document = _a.document, isCompacted = _a.isCompacted;
            var _b;
            if (!isCompacted) {
                var targetNode = tslib_1.__assign({}, node, (_b = {}, _b[C.document] = undefined, _b[C.checksum] = undefined, _b));
                var targetSchema = _this.queryContainer.context.registry.getSchemaFor(targetNode);
                _this.jsonldConverter.update(resource, targetNode, targetSchema, document);
                resource.$_queryableMetadata = void 0;
            }
            _this.registry.decorate(resource);
        });
        rdfDocuments
            .map(RDFNode.getID)
            .map(function (id) { return compactionMap.get(id); })
            .filter(_isExistingValue)
            .forEach(function (_a) {
            var resource = _a.resource, node = _a.node;
            resource.$_syncSnapshot();
            var rawValues = node[C.checksum];
            if (!rawValues || typeof rawValues === "string")
                return;
            var eTag = RDFNode.getPropertyLiterals(rawValues, XSD.string)[0];
            if (!eTag)
                return;
            resource.$eTag = "\"" + eTag + "\"";
            resource.$_resolved = true;
        });
        return targetDocuments.map(function (id) {
            return compactionMap
                .get(id)
                .resource;
        });
    };
    QueryResultCompacter.prototype.__processNode = function (compactionMap, compactionNode, queryProperty, metadataProperty) {
        var _this = this;
        var _a;
        var node = compactionNode.node, document = compactionNode.document, resource = compactionNode.resource;
        compactionNode.isCompacted = true;
        var targetSchema = queryProperty.getSchemaFor(node);
        var pointerLibrary = __createPointerLibrary(compactionMap, document);
        var targetNode = tslib_1.__assign({}, node, (_a = {}, _a[C.document] = undefined, _a[C.checksum] = undefined, _a));
        this.jsonldConverter
            .update(resource, targetNode, targetSchema, pointerLibrary, !queryProperty._isComplete());
        if (!queryProperty._isPartial()) {
            resource.$_queryableMetadata = void 0;
            return;
        }
        queryProperty.subProperties.forEach(function (subQueryProperty, propertyName) {
            if (resource.hasOwnProperty(propertyName) && subQueryProperty.pathBuilderFn) {
                Object.defineProperty(resource, propertyName, {
                    enumerable: false,
                    configurable: true,
                    writable: true,
                });
            }
            var subMetadataProperty = metadataProperty
                .getProperty(propertyName, subQueryProperty);
            if (!resource.hasOwnProperty(propertyName))
                return;
            if (subQueryProperty.propertyType === void 0)
                return;
            var values = Array.isArray(resource[propertyName])
                ? resource[propertyName]
                : [resource[propertyName]];
            values.forEach(function (value) {
                if (!Pointer.is(value))
                    return;
                var subCompactionNode = compactionMap.get(value.$id);
                if (!subCompactionNode)
                    throw new IllegalArgumentError("Invalid data provided.");
                if (subCompactionNode.resource.$_queryableMetadata) {
                    subCompactionNode.resource.$_queryableMetadata
                        .mergeData(propertyName, subMetadataProperty);
                    if (subCompactionNode.document === document && !subCompactionNode.isCompacted) {
                        metadataProperty
                            .setProperty(propertyName, subCompactionNode.resource.$_queryableMetadata);
                    }
                    else {
                        subMetadataProperty.propertyType = void 0;
                    }
                }
                else {
                    if (subCompactionNode.document === document) {
                        subCompactionNode.resource.$_queryableMetadata = subMetadataProperty;
                    }
                    else {
                        subCompactionNode.resource.$_queryableMetadata = new QueryableProperty({
                            propertyType: subMetadataProperty.propertyType,
                            optional: subMetadataProperty.optional,
                            definition: Object.assign(new DigestedObjectSchemaProperty(), subMetadataProperty.definition, {
                                uri: null,
                            }),
                        });
                        subMetadataProperty.propertyType = void 0;
                    }
                }
                _this.__processNode(compactionMap, subCompactionNode, subQueryProperty, subCompactionNode.resource.$_queryableMetadata);
            });
        });
    };
    return QueryResultCompacter;
}());
export { QueryResultCompacter };
function __createPointerLibrary(compactionMap, document) {
    return {
        hasPointer: function (id) {
            if (compactionMap.has(id))
                return true;
            return document.$hasPointer(id);
        },
        getPointer: function (id) {
            if (compactionMap.has(id))
                return compactionMap
                    .get(id)
                    .resource;
            return document
                .$getPointer(id);
        },
    };
}

//# sourceMappingURL=QueryResultCompacter.js.map
