import * as tslib_1 from "tslib";
import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { ModelDecorator } from "../Model/ModelDecorator";
import { ObjectSchemaResolver } from "../ObjectSchema/ObjectSchemaResolver";
import { URI } from "../RDF/URI";
import { Registry } from "../Registry/Registry";
import { MapUtils } from "../Utils";
export var GeneralRegistry = {
    PROTOTYPE: {
        get context() {
            throw new IllegalArgumentError("Property context is required.");
        },
        get registry() {
            if (!this.context || !this.context.parentContext)
                return;
            return this.context.parentContext.registry;
        },
        set registry(value) { },
        get __modelDecorators() { return new Map(); },
        addDecorator: function (decorator) {
            if (!decorator.TYPE)
                throw new IllegalArgumentError("No TYPE specified in the model decorator.");
            this.__modelDecorators.set(decorator.TYPE, decorator);
            return this;
        },
        decorate: function (object) {
            var _this = this;
            if (!object.types)
                return;
            object.types
                .filter(function (type) { return _this.__modelDecorators.has(type); })
                .map(function (type) { return _this.__modelDecorators.get(type); })
                .forEach(function (decorator) { return decorator.decorate(object); });
        },
        _addPointer: function (pointer) {
            if (this.context.repository)
                Object.assign(pointer, { $repository: this.context.repository });
            var resource = Registry.PROTOTYPE._addPointer.call(this, pointer);
            resource.$id = this.context.getObjectSchema().resolveURI(resource.$id, { base: true });
            return resource;
        },
        _getLocalID: function (id) {
            var uri = this.context.getObjectSchema().resolveURI(id, { base: true });
            if (!URI.isAbsolute(uri) || !URI.isBaseOf(this.context.baseURI, uri))
                throw new IllegalArgumentError("\"" + uri + "\" is out of scope.");
            return URI.getRelativeURI(uri, this.context.baseURI);
        },
    },
    isDecorated: function (object) {
        return ModelDecorator
            .hasPropertiesFrom(GeneralRegistry.PROTOTYPE, object);
    },
    decorate: function (object) {
        if (GeneralRegistry.isDecorated(object))
            return object;
        var target = ModelDecorator
            .decorateMultiple(object, Registry, ObjectSchemaResolver);
        if (!target.context)
            delete target.context;
        return ModelDecorator
            .definePropertiesFrom(GeneralRegistry.PROTOTYPE, target);
    },
    create: function (data) {
        return GeneralRegistry.createFrom(tslib_1.__assign({}, data));
    },
    createFrom: function (object) {
        var registry = GeneralRegistry.decorate(object);
        if (registry.registry)
            MapUtils.extend(registry.__modelDecorators, registry.registry.__modelDecorators);
        return registry;
    },
};

//# sourceMappingURL=GeneralRegistry.js.map
