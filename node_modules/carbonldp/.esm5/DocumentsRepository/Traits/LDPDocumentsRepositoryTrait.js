import { TransientDocument } from "../../Document/TransientDocument";
import { IllegalArgumentError } from "../../Errors/IllegalArgumentError";
import { FreeResources } from "../../FreeResources/FreeResources";
import { BadResponseError } from "../../HTTP/Errors/ServerErrors/BadResponseError";
import { RequestService, RequestUtils } from "../../HTTP/Request";
import { JSONLDParser } from "../../JSONLD/JSONLDParser";
import { AddMemberAction } from "../../LDP/AddMemberAction";
import { RemoveMemberAction } from "../../LDP/RemoveMemberAction";
import { ResponseMetadata } from "../../LDP/ResponseMetadata";
import { DeltaCreator } from "../../LDPatch/DeltaCreator";
import { ModelDecorator } from "../../Model/ModelDecorator";
import { Pointer } from "../../Pointer/Pointer";
import { RDFDocument } from "../../RDF/Document";
import { ResolvablePointer } from "../../Repository/ResolvablePointer";
import { isString } from "../../Utils";
import { C } from "../../Vocabularies/C";
import { LDP } from "../../Vocabularies/LDP";
import { _getErrorResponseParserFn } from "../Utils";
import { HTTPRepositoryTrait } from "./HTTPRepositoryTrait";
var __JSONLD_PARSER = new JSONLDParser();
function __setDefaultRequestOptions(requestOptions, interactionModel) {
    if (interactionModel)
        RequestUtils.setPreferredInteractionModel(interactionModel, requestOptions);
    RequestUtils.setAcceptHeader("application/ld+json", requestOptions);
}
function __getTargetID(id, response) {
    var locationHeader = response.getHeader("Content-Location");
    if (!locationHeader)
        return id;
    if (locationHeader.values.length !== 1)
        throw new BadResponseError("The response must contain one Content-Location header.", response);
    var locationString = "" + locationHeader;
    if (!locationString)
        throw new BadResponseError("The response doesn't contain a valid 'Content-Location' header.", response);
    return locationString;
}
function __getErrorResponseParserFnFrom(repository) {
    return _getErrorResponseParserFn(repository.context.registry);
}
function __changeNodesID(resource, map) {
    map
        .entries
        .forEach(function (_a) {
        var entryKey = _a.entryKey, entryValue = _a.entryValue;
        var node = resource
            .$getPointer(entryKey.$id, true);
        resource.$removePointer(entryKey.$id);
        node.$id = entryValue.$id;
        resource.$_addPointer(node);
    });
}
function __applyResponseMetadata(repository, freeNodes) {
    if (!freeNodes.length)
        return;
    var freeResources = FreeResources.parseFreeNodes(repository.context.registry, freeNodes);
    var responseMetadata = freeResources
        .getPointers(true)
        .find(ResponseMetadata.is);
    if (!responseMetadata)
        return;
    responseMetadata
        .documentsMetadata
        .forEach(function (metadata) { return __changeNodesID(metadata.relatedDocument, metadata.bNodesMap); });
}
function __applyResponseRepresentation(repository, resource, response) {
    if (response.status === 204 || !response.data)
        return resource;
    return __JSONLD_PARSER
        .parse(response.data)
        .then(function (expandedResult) {
        var freeNodes = RDFDocument.getFreeNodes(expandedResult);
        __applyResponseMetadata(repository, freeNodes);
        var preferenceHeader = response.getHeader("Preference-Applied");
        if (preferenceHeader === null || !preferenceHeader.hasValue("return=representation"))
            return resource;
        return repository._parseResponseData(response, resource.$id);
    });
}
function __isInvalidChild(child) {
    return ResolvablePointer.is(child);
}
function __isPersistingChild(object) {
    return object["__CarbonLDP_persisting__"];
}
function __createChild(repository, parentURI, requestOptions, child, slug) {
    if (ResolvablePointer.is(child))
        throw new IllegalArgumentError("Cannot persist an already resolvable pointer.");
    var transient = TransientDocument.is(child) ?
        child : TransientDocument.decorate(child);
    transient.$_normalize();
    transient.$registry = repository.context.registry;
    var body = JSON.stringify(transient);
    if (!!slug)
        RequestUtils.setSlug(slug, requestOptions);
    Object.defineProperty(transient, "__CarbonLDP_persisting__", { configurable: true, value: true });
    return RequestService
        .post(parentURI, body, requestOptions)
        .then(function (response) {
        delete transient["__CarbonLDP_persisting__"];
        var locationHeader = response.getHeader("Location");
        if (locationHeader === null || locationHeader.values.length < 1)
            throw new BadResponseError("The response is missing a Location header.", response);
        if (locationHeader.values.length !== 1)
            throw new BadResponseError("The response contains more than one Location header.", response);
        transient.$id = locationHeader.values[0].toString();
        var document = repository.context.registry._addPointer(transient);
        document
            .$getFragments()
            .forEach(document.$__modelDecorator.decorate);
        return __applyResponseRepresentation(repository, document, response);
    })
        .catch(function (error) {
        delete transient["__CarbonLDP_persisting__"];
        return __getErrorResponseParserFnFrom(repository)(error);
    });
}
function __createChildren(retrievalType, repository, uri, children, slugsOrOptions, requestOptions) {
    if (!repository.context.registry.inScope(uri, true))
        return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
    var url = repository.context.getObjectSchema().resolveURI(uri, { base: true });
    requestOptions = RequestUtils.isOptions(slugsOrOptions) ?
        slugsOrOptions :
        requestOptions ? requestOptions : {};
    var slugs = isString(slugsOrOptions) || Array.isArray(slugsOrOptions) ?
        slugsOrOptions : null;
    __setDefaultRequestOptions(requestOptions, LDP.Container);
    RequestUtils.setPreferredRetrieval(retrievalType, requestOptions);
    RequestUtils.setContentTypeHeader("application/ld+json", requestOptions);
    if (!Array.isArray(children)) {
        if (__isInvalidChild(children))
            return Promise.reject(new IllegalArgumentError("The object is already a resolvable pointer."));
        if (__isPersistingChild(children))
            return Promise.reject(new IllegalArgumentError("The object is already being persisted."));
        return __createChild(repository, url, requestOptions, children, slugs ? slugs.toString() : undefined);
    }
    var invalidChild = children
        .findIndex(function (child) { return __isInvalidChild(child); });
    if (invalidChild !== -1)
        return Promise.reject(new IllegalArgumentError("The object in \"" + invalidChild + "\" is already a resolvable pointer."));
    var persistingChild = children
        .findIndex(function (child) { return __isPersistingChild(child); });
    if (persistingChild !== -1)
        return Promise.reject(new IllegalArgumentError("The object in \"" + persistingChild + "\" is already being persisted."));
    var promises = children.map(function (child, index) {
        var cloneOptions = RequestUtils.cloneOptions(requestOptions);
        var slug = slugs && index < slugs.length ? slugs[index] : void 0;
        return __createChild(repository, url, cloneOptions, child, slug);
    });
    return Promise.all(promises);
}
function __sendPatch(repository, document, requestOptions) {
    if (!ResolvablePointer.is(document))
        return Promise.reject(new IllegalArgumentError("The document isn't a resolvable pointer."));
    if (!repository.context.registry.inScope(document.$id))
        return Promise.reject(new IllegalArgumentError("\"" + document.$id + "\" is out of scope."));
    var url = repository.context.getObjectSchema().resolveURI(document.$id, { base: true });
    if (!document.$isDirty())
        return Promise.resolve(document);
    document.$_normalize();
    __setDefaultRequestOptions(requestOptions);
    RequestUtils.setContentTypeHeader("text/ldpatch", requestOptions);
    RequestUtils.setIfMatchHeader(document.$eTag, requestOptions);
    var deltaCreator = new DeltaCreator(repository.context);
    deltaCreator.addResource(document.$id, document.$_snapshot, document);
    document
        .$getPointers(true)
        .forEach(function (pointer) {
        deltaCreator.addResource(pointer.$id, pointer.$_snapshot, pointer);
    });
    document.$__savedFragments
        .filter(function (pointer) { return !document.$hasPointer(pointer.$id); })
        .forEach(function (pointer) {
        deltaCreator.addResource(pointer.$id, pointer.$_snapshot, {});
    });
    var body = deltaCreator.getPatch();
    return RequestService
        .patch(url, body, requestOptions)
        .then(function (response) {
        return __applyResponseRepresentation(repository, document, response);
    })
        .catch(__getErrorResponseParserFnFrom(repository));
}
function __parseMembers(registry, pointers) {
    return pointers
        .map(function (pointer) {
        if (isString(pointer))
            return registry.getPointer(pointer);
        if (Pointer.is(pointer))
            return pointer;
    })
        .filter(function (pointer) { return !!pointer; });
}
function __sendAddAction(repository, uri, members, requestOptions) {
    if (requestOptions === void 0) { requestOptions = {}; }
    if (!repository.context.registry.inScope(uri, true))
        return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
    var url = repository.context.getObjectSchema().resolveURI(uri, { base: true });
    __setDefaultRequestOptions(requestOptions, LDP.Container);
    RequestUtils.setContentTypeHeader("application/ld+json", requestOptions);
    var freeResources = FreeResources.createFrom({ registry: repository.context.registry });
    var targetMembers = __parseMembers(repository.context.registry, members);
    freeResources._addPointer(AddMemberAction.createFrom({ targetMembers: targetMembers }));
    var body = JSON.stringify(freeResources);
    return RequestService
        .put(url, body, requestOptions)
        .then(function () { })
        .catch(__getErrorResponseParserFnFrom(repository));
}
function __sendRemoveAction(repository, uri, members, requestOptions) {
    if (requestOptions === void 0) { requestOptions = {}; }
    if (!repository.context.registry.inScope(uri, true))
        return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
    var url = repository.context.getObjectSchema().resolveURI(uri, { base: true });
    __setDefaultRequestOptions(requestOptions, LDP.Container);
    RequestUtils.setContentTypeHeader("application/ld+json", requestOptions);
    RequestUtils.setRetrievalPreferences({
        include: [C.PreferSelectedMembershipTriples],
        omit: [C.PreferMembershipTriples],
    }, requestOptions);
    var freeResources = FreeResources.createFrom({ registry: repository.context.registry });
    var targetMembers = __parseMembers(repository.context.registry, members);
    freeResources._addPointer(RemoveMemberAction.createFrom({ targetMembers: targetMembers }));
    var body = JSON.stringify(freeResources);
    return RequestService
        .delete(url, body, requestOptions)
        .then(function () { })
        .catch(__getErrorResponseParserFnFrom(repository));
}
function __sendRemoveAll(repository, uri, requestOptions) {
    if (requestOptions === void 0) { requestOptions = {}; }
    if (!repository.context.registry.inScope(uri, true))
        return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
    var url = repository.context.getObjectSchema().resolveURI(uri, { base: true });
    __setDefaultRequestOptions(requestOptions, LDP.Container);
    RequestUtils.setRetrievalPreferences({
        include: [
            C.PreferMembershipTriples,
        ],
        omit: [
            C.PreferMembershipResources,
            C.PreferContainmentTriples,
            C.PreferContainmentResources,
            C.PreferContainer,
        ],
    }, requestOptions);
    return RequestService
        .delete(url, requestOptions)
        .then(function () { })
        .catch(__getErrorResponseParserFnFrom(repository));
}
export var LDPDocumentsRepositoryTrait = {
    PROTOTYPE: {
        get: function (uri, requestOptions) {
            if (requestOptions === void 0) { requestOptions = {}; }
            __setDefaultRequestOptions(requestOptions, LDP.RDFSource);
            return HTTPRepositoryTrait.PROTOTYPE
                .get.call(this, uri, requestOptions)
                .catch(__getErrorResponseParserFnFrom(this));
        },
        exists: function (uri, requestOptions) {
            if (requestOptions === void 0) { requestOptions = {}; }
            __setDefaultRequestOptions(requestOptions, LDP.RDFSource);
            return HTTPRepositoryTrait.PROTOTYPE
                .exists.call(this, uri, requestOptions)
                .catch(__getErrorResponseParserFnFrom(this));
        },
        create: function (uri, children, slugsOrOptions, requestOptions) {
            return __createChildren("minimal", this, uri, children, slugsOrOptions, requestOptions);
        },
        createAndRetrieve: function (uri, children, slugsOrOptions, requestOptions) {
            return __createChildren("representation", this, uri, children, slugsOrOptions, requestOptions);
        },
        refresh: function (document, requestOptions) {
            if (requestOptions === void 0) { requestOptions = {}; }
            __setDefaultRequestOptions(requestOptions, LDP.RDFSource);
            RequestUtils.setIfNoneMatchHeader(document.$eTag, requestOptions);
            return HTTPRepositoryTrait.PROTOTYPE
                .refresh.call(this, document, requestOptions)
                .catch(__getErrorResponseParserFnFrom(this));
        },
        save: function (document, requestOptions) {
            if (requestOptions === void 0) { requestOptions = {}; }
            RequestUtils.setPreferredRetrieval("minimal", requestOptions);
            return __sendPatch(this, document, requestOptions);
        },
        saveAndRefresh: function (document, requestOptions) {
            if (requestOptions === void 0) { requestOptions = {}; }
            RequestUtils.setPreferredRetrieval("representation", requestOptions);
            return __sendPatch(this, document, requestOptions);
        },
        delete: function (uri, requestOptions) {
            if (requestOptions === void 0) { requestOptions = {}; }
            __setDefaultRequestOptions(requestOptions, LDP.RDFSource);
            return HTTPRepositoryTrait.PROTOTYPE
                .delete.call(this, uri, requestOptions)
                .catch(__getErrorResponseParserFnFrom(this));
        },
        addMember: function (uri, member, requestOptions) {
            return __sendAddAction(this, uri, [member], requestOptions);
        },
        addMembers: function (uri, members, requestOptions) {
            return __sendAddAction(this, uri, members, requestOptions);
        },
        removeMember: function (uri, member, requestOptions) {
            return __sendRemoveAction(this, uri, [member], requestOptions);
        },
        removeMembers: function (uri, membersOrOptions, requestOptions) {
            if (Array.isArray(membersOrOptions))
                return __sendRemoveAction(this, uri, membersOrOptions, requestOptions);
            return __sendRemoveAll(this, uri, membersOrOptions || requestOptions);
        },
        _parseResponseData: function (response, id) {
            var _this = this;
            return __JSONLD_PARSER
                .parse(response.data)
                .then(function (rdfNodes) {
                var rdfDocuments = RDFDocument
                    .getDocuments(rdfNodes);
                id = __getTargetID(id, response);
                var rdfDocument = rdfDocuments.find(function (doc) { return doc["@id"] === id; });
                if (!rdfDocument)
                    throw new BadResponseError("No document \"" + id + "\" was returned.", response);
                var document = _this.context.registry.register(id);
                var previousFragments = new Set();
                document
                    .$getPointers(true)
                    .forEach(function (pointer) { return previousFragments.add(pointer.$id); });
                var elements = rdfDocument["@graph"].map(function (node) {
                    var target = document.$getPointer(node["@id"]);
                    var schema = _this.context.registry.getSchemaFor(node);
                    _this.context.jsonldConverter.update(target, node, schema, document);
                    if ("$document" in target)
                        previousFragments.delete(target.$id);
                    return target;
                });
                previousFragments
                    .forEach(function (pointer) { return document.$removePointer(pointer); });
                elements.forEach(function (element) {
                    element.$_syncSnapshot();
                    _this.context.registry.decorate(element);
                });
                document.$eTag = response.getETag();
                document.$_resolved = true;
                return document;
            });
        },
    },
    isDecorated: function (object) {
        return ModelDecorator
            .hasPropertiesFrom(LDPDocumentsRepositoryTrait.PROTOTYPE, object);
    },
    decorate: function (object) {
        if (LDPDocumentsRepositoryTrait.isDecorated(object))
            return object;
        var target = ModelDecorator
            .decorateMultiple(object, HTTPRepositoryTrait);
        return ModelDecorator
            .definePropertiesFrom(LDPDocumentsRepositoryTrait.PROTOTYPE, target);
    },
};

//# sourceMappingURL=LDPDocumentsRepositoryTrait.js.map
