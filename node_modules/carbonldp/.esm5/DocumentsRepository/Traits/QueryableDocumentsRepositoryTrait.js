import { ConstructToken, IRIRefToken, PropertyToken, QueryToken, SubjectToken } from "sparqler/tokens";
import { IllegalArgumentError } from "../../Errors/IllegalArgumentError";
import { IllegalStateError } from "../../Errors/IllegalStateError";
import { FreeResources } from "../../FreeResources/FreeResources";
import { RequestUtils } from "../../HTTP/Request";
import { JSONLDParser } from "../../JSONLD/JSONLDParser";
import { ModelDecorator } from "../../Model/ModelDecorator";
import { Pointer } from "../../Pointer/Pointer";
import { QueryContainer } from "../../QueryDocuments/QueryContainer";
import { QueryContainerPropertyType } from "../../QueryDocuments/QueryContainerPropertyType";
import { QueryDocumentBuilder } from "../../QueryDocuments/QueryDocumentBuilder";
import { QueryDocumentsBuilder } from "../../QueryDocuments/QueryDocumentsBuilder";
import { QueryMetadata } from "../../QueryDocuments/QueryMetadata";
import { QueryPropertyType } from "../../QueryDocuments/QueryPropertyType";
import { QueryResultCompacter } from "../../QueryDocuments/QueryResultCompacter";
import { _areDifferentType, _getPathProperty } from "../../QueryDocuments/Utils";
import { RDFDocument } from "../../RDF/Document";
import { URI } from "../../RDF/URI";
import { SPARQLService } from "../../SPARQL/SPARQLService";
import { isBoolean, isDate, isFunction, isNumber, isString, UUIDUtils } from "../../Utils";
import { C } from "../../Vocabularies/C";
import { _getErrorResponseParserFn } from "../Utils";
import { LDPDocumentsRepositoryTrait } from "./LDPDocumentsRepositoryTrait";
function __executeQueryBuilder(queryContainer, queryData) {
    var queryBuilder = "containerPropertyType" in queryContainer._queryProperty
        ? new QueryDocumentsBuilder(queryContainer, queryContainer._queryProperty)
        : new QueryDocumentBuilder(queryContainer, queryContainer._queryProperty);
    if (queryData.rootType !== void 0)
        queryContainer._queryProperty
            .setType(queryData.rootType);
    if (queryData.queryBuilderFn && queryData.queryBuilderFn.call(void 0, queryBuilder) !== queryBuilder)
        throw new IllegalArgumentError("The provided query builder was not returned");
}
function __sortQueryDocuments(queryContainer, documents) {
    if (!("order" in queryContainer._queryProperty) || !queryContainer._queryProperty.order)
        return documents;
    var _a = queryContainer._queryProperty.order, path = _a.path, flow = _a.flow;
    var inverter = flow === "DESC" ? -1 : 1;
    return documents.sort(function (a, b) {
        a = _getPathProperty(a, path);
        b = _getPathProperty(b, path);
        var aValue = Pointer.is(a) ? a.$id : a;
        var bValue = Pointer.is(b) ? b.$id : b;
        if (aValue === bValue)
            return 0;
        if (aValue === void 0)
            return -1 * inverter;
        if (bValue === void 0)
            return inverter;
        if (!_areDifferentType(a, b)) {
            if (Pointer.is(a)) {
                var aIsBNode = URI.isBNodeID(aValue);
                var bIsBNode = URI.isBNodeID(bValue);
                if (aIsBNode && !bIsBNode)
                    return -1 * inverter;
                if (bIsBNode && !aIsBNode)
                    return inverter;
            }
        }
        else {
            if (Pointer.is(a))
                return -1 * inverter;
            if (Pointer.is(b))
                return inverter;
            if (isNumber(a))
                return -1 * inverter;
            if (isNumber(b))
                return inverter;
            if (isDate(a))
                return -1 * inverter;
            if (isDate(b))
                return inverter;
            if (isBoolean(a))
                return -1 * inverter;
            if (isBoolean(b))
                return inverter;
            if (isString(a))
                return -1 * inverter;
            if (isString(b))
                return inverter;
        }
        if (aValue < bValue)
            return -1 * inverter;
        if (aValue > bValue)
            return inverter;
        return 0;
    });
}
function __requestQueryDocuments(repository, url, requestOptions, queryContainer) {
    var _a, _b, _c;
    var construct = (_a = (_b = new ConstructToken()
        .addTriple(new SubjectToken(new IRIRefToken("cldp-sdk://metadata-" + UUIDUtils.generate()))
        .addProperty(new PropertyToken("a")
        .addObject(queryContainer.compactIRI(C.VolatileResource))
        .addObject(queryContainer.compactIRI(C.QueryMetadata)))
        .addProperty(new PropertyToken(queryContainer.compactIRI(C.target))
        .addObject(queryContainer._queryProperty.identifier)))).addTriple.apply(_b, queryContainer._queryProperty.getConstructPatterns())).addPattern.apply(_a, queryContainer._queryProperty.getSearchPatterns());
    var query = (_c = new QueryToken(construct)).addPrologues.apply(_c, queryContainer.getPrologues());
    RequestUtils.setRetrievalPreferences({ include: [C.PreferResultsContexts] }, requestOptions);
    return SPARQLService
        .executeRawCONSTRUCTQuery(url, query.toString(), requestOptions)
        .then(function (_a) {
        var strConstruct = _a[0];
        return strConstruct;
    })
        .then(function (jsonldString) {
        return new JSONLDParser().parse(jsonldString);
    })
        .then(function (rdfNodes) {
        var freeNodes = RDFDocument.getFreeNodes(rdfNodes);
        var freeResources = FreeResources
            .parseFreeNodes(repository.context.registry, freeNodes);
        var targetDocuments = freeResources
            .getPointers(true)
            .filter(QueryMetadata.is)
            .map(function (x) { return x.targets; })
            .reduce(function (targets, x) { return targets.concat(x); }, [])
            .map(function (x) { return x.$id; });
        var rdfDocuments = rdfNodes
            .filter(RDFDocument.is);
        return new QueryResultCompacter(repository.context.registry, queryContainer)
            .compactDocuments(rdfDocuments, targetDocuments);
    })
        .then(function (documents) { return __sortQueryDocuments(queryContainer, documents); })
        .catch(_getErrorResponseParserFn(repository.context.registry));
}
function __requestRelations(repository, uri, requestOptions, queryData) {
    if (!repository.context.registry.inScope(uri, true))
        return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
    var url = repository.context
        .getObjectSchema()
        .resolveURI(uri, { base: true });
    var queryContainer = new QueryContainer(repository.context, {
        containerPropertyType: queryData.containerPropertyType,
        uri: url,
    });
    __executeQueryBuilder(queryContainer, queryData);
    return __requestQueryDocuments(repository, url, requestOptions, queryContainer);
}
function __requestDocuments(repository, uris, requestOptions, queryData) {
    for (var _i = 0, uris_1 = uris; _i < uris_1.length; _i++) {
        var uri = uris_1[_i];
        if (!repository.context.registry.inScope(uri, true))
            return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
    }
    var urls = uris.map(function (uri) { return repository.context
        .getObjectSchema()
        .resolveURI(uri, { base: true }); });
    var queryContainer = new QueryContainer(repository.context, {
        uris: urls,
    });
    __executeQueryBuilder(queryContainer, queryData);
    var url = urls.length === 1 ? urls[0] : repository.context.baseURI;
    RequestUtils.setRetrievalPreferences({ include: [C.PreferDocumentChecksums] }, requestOptions);
    return __requestQueryDocuments(repository, url, requestOptions, queryContainer);
}
function __getQueryable(repository, uri, requestOptions, queryBuilderFn) {
    return __requestDocuments(repository, [uri], requestOptions, { queryBuilderFn: queryBuilderFn })
        .then(function (documents) { return documents[0]; });
}
function __addRefreshProperties(parentProperty, queryableProperty) {
    queryableProperty.subProperties.forEach(function (subProperty, propertyName) {
        var queryProperty = parentProperty._addSubProperty(propertyName, subProperty);
        __addRefreshProperties(queryProperty, subProperty);
    });
}
function __refreshQueryable(repository, document, requestOptions) {
    if (requestOptions === void 0) { requestOptions = {}; }
    if (!repository.context.registry.inScope(document.$id, true))
        return Promise.reject(new IllegalArgumentError("\"" + document.$id + "\" is out of scope."));
    var url = repository.context
        .getObjectSchema()
        .resolveURI(document.$id, { base: true });
    var queryContainer = new QueryContainer(repository.context, { uris: [url] });
    __addRefreshProperties(queryContainer._queryProperty, document.$_queryableMetadata);
    RequestUtils.setRetrievalPreferences({ include: [C.PreferDocumentChecksums] }, requestOptions);
    return __requestQueryDocuments(repository, url, requestOptions, queryContainer)
        .then(function (documents) { return documents[0]; });
}
export var QueryableDocumentsRepositoryTrait = {
    PROTOTYPE: {
        get: function (uriOrURIs, requestOptionsOrQueryBuilderFn, queryBuilderFn) {
            var requestOptions = typeof requestOptionsOrQueryBuilderFn === "object" ?
                requestOptionsOrQueryBuilderFn : {};
            queryBuilderFn = isFunction(requestOptionsOrQueryBuilderFn) ?
                requestOptionsOrQueryBuilderFn : queryBuilderFn;
            if (typeof uriOrURIs !== "string") {
                return __requestDocuments(this, uriOrURIs, requestOptions, {
                    rootType: queryBuilderFn ? void 0 : QueryPropertyType.FULL,
                    queryBuilderFn: queryBuilderFn,
                });
            }
            var uri = uriOrURIs;
            var target = this.context.registry.hasPointer(uri) ?
                this.context.registry.getPointer(uri, true) :
                void 0;
            if (queryBuilderFn) {
                var types_1 = target ? target.types : [];
                return __getQueryable(this, uri, requestOptions, function (_) {
                    types_1.forEach(function (type) { return _.withType(type); });
                    return queryBuilderFn.call(void 0, _);
                });
            }
            if (target && target.$isQueried())
                requestOptions.ensureLatest = true;
            return LDPDocumentsRepositoryTrait.PROTOTYPE
                .get.call(this, uri, requestOptions)
                .then(function (document) {
                if (!document.$_queryableMetadata)
                    return document;
                var resources = document.$getFragments();
                resources.push(document);
                resources.forEach(function (resource) {
                    resource.$_queryableMetadata = void 0;
                });
                return document;
            });
        },
        resolve: function (document, requestOptionsOrQueryBuilderFn, queryBuilderFn) {
            return this.get(document.$id, requestOptionsOrQueryBuilderFn, queryBuilderFn);
        },
        refresh: function (document, requestOptions) {
            if (!document.$isQueried())
                return LDPDocumentsRepositoryTrait.PROTOTYPE
                    .refresh.call(this, document, requestOptions);
            return __refreshQueryable(this, document, requestOptions);
        },
        saveAndRefresh: function (document, requestOptions) {
            var _this = this;
            if (!document.$_queryableMetadata)
                return LDPDocumentsRepositoryTrait.PROTOTYPE
                    .saveAndRefresh.call(this, document, requestOptions);
            if (document.$eTag === null)
                return Promise.reject(new IllegalStateError("The document \"" + document.$id + "\" is locally outdated and cannot be saved."));
            var cloneOptions = RequestUtils.cloneOptions(requestOptions || {});
            return this.save(document, cloneOptions)
                .then(function (doc) {
                return __refreshQueryable(_this, doc, requestOptions);
            });
        },
        getChildren: function (uri, requestOptionsOrQueryBuilderFn, queryBuilderFn) {
            var requestOptions = typeof requestOptionsOrQueryBuilderFn === "object" ?
                requestOptionsOrQueryBuilderFn : {};
            queryBuilderFn = isFunction(requestOptionsOrQueryBuilderFn) ?
                requestOptionsOrQueryBuilderFn : queryBuilderFn;
            RequestUtils.setRetrievalPreferences({ include: [C.PreferDocumentChecksums] }, requestOptions);
            return __requestRelations(this, uri, requestOptions, {
                rootType: queryBuilderFn ? void 0 : QueryPropertyType.FULL,
                containerPropertyType: QueryContainerPropertyType.CHILD,
                queryBuilderFn: queryBuilderFn,
            });
        },
        getMembers: function (uri, requestOptionsOrQueryBuilderFn, queryBuilderFn) {
            var requestOptions = typeof requestOptionsOrQueryBuilderFn === "object" ?
                requestOptionsOrQueryBuilderFn : {};
            queryBuilderFn = isFunction(requestOptionsOrQueryBuilderFn) ?
                requestOptionsOrQueryBuilderFn : queryBuilderFn;
            RequestUtils.setRetrievalPreferences({ include: [C.PreferDocumentChecksums] }, requestOptions);
            return __requestRelations(this, uri, requestOptions, {
                rootType: queryBuilderFn ? void 0 : QueryPropertyType.FULL,
                containerPropertyType: QueryContainerPropertyType.MEMBER,
                queryBuilderFn: queryBuilderFn,
            });
        },
        listChildren: function (uri, requestOptions) {
            if (requestOptions === void 0) { requestOptions = {}; }
            return __requestRelations(this, uri, requestOptions, {
                containerPropertyType: QueryContainerPropertyType.CHILD,
                rootType: QueryPropertyType.EMPTY,
            });
        },
        listMembers: function (uri, requestOptions) {
            if (requestOptions === void 0) { requestOptions = {}; }
            return __requestRelations(this, uri, requestOptions, {
                rootType: QueryPropertyType.EMPTY,
                containerPropertyType: QueryContainerPropertyType.MEMBER,
            });
        },
    },
    isDecorated: function (object) {
        return ModelDecorator
            .hasPropertiesFrom(QueryableDocumentsRepositoryTrait.PROTOTYPE, object);
    },
    decorate: function (object) {
        if (QueryableDocumentsRepositoryTrait.isDecorated(object))
            return object;
        var target = ModelDecorator
            .decorateMultiple(object, LDPDocumentsRepositoryTrait);
        return ModelDecorator
            .definePropertiesFrom(QueryableDocumentsRepositoryTrait.PROTOTYPE, target);
    },
};

//# sourceMappingURL=QueryableDocumentsRepositoryTrait.js.map
