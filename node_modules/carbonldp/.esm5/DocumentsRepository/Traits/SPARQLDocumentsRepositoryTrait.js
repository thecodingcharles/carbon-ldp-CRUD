import { IllegalArgumentError } from "../../Errors/IllegalArgumentError";
import { GeneralRepository } from "../../GeneralRepository/GeneralRepository";
import { RequestUtils } from "../../HTTP/Request";
import { ModelDecorator } from "../../Model/ModelDecorator";
import { SPARQLBuilder } from "../../SPARQL/SPARQLBuilder";
import { SPARQLService } from "../../SPARQL/SPARQLService";
import { _getErrorResponseParserFn } from "../Utils";
export var SPARQLDocumentsRepositoryTrait = {
    PROTOTYPE: {
        executeASKQuery: function (uri, askQuery, requestOptions) {
            if (!this.context.registry.inScope(uri, true))
                return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
            var url = this.context.getObjectSchema().resolveURI(uri, { base: true });
            requestOptions = requestOptions ? requestOptions : {};
            RequestUtils.setAcceptHeader("application/ld+json; q=0.9", requestOptions);
            return SPARQLService
                .executeASKQuery(url, askQuery, requestOptions)
                .then(function (_a) {
                var rawResults = _a[0];
                return rawResults;
            })
                .catch(_getErrorResponseParserFn(this.context.registry));
        },
        executeSELECTQuery: function (uri, selectQuery, requestOptions) {
            if (!this.context.registry.inScope(uri, true))
                return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
            var url = this.context.getObjectSchema().resolveURI(uri, { base: true });
            requestOptions = requestOptions ? requestOptions : {};
            RequestUtils.setAcceptHeader("application/ld+json; q=0.9", requestOptions);
            return SPARQLService
                .executeSELECTQuery(url, selectQuery, this.context.registry, requestOptions)
                .then(function (_a) {
                var selectResults = _a[0];
                return selectResults;
            })
                .catch(_getErrorResponseParserFn(this.context.registry));
        },
        executeUPDATE: function (uri, update, requestOptions) {
            if (!this.context.registry.inScope(uri, true))
                return Promise.reject(new IllegalArgumentError("\"" + uri + "\" is out of scope."));
            var url = this.context.getObjectSchema().resolveURI(uri, { base: true });
            return SPARQLService
                .executeUPDATE(url, update, requestOptions)
                .then(function () { })
                .catch(_getErrorResponseParserFn(this.context.registry));
        },
        sparql: function (uri) {
            if (!this.context.registry.inScope(uri, true))
                throw new IllegalArgumentError("\"" + uri + "\" is out of scope.");
            var url = this.context.getObjectSchema().resolveURI(uri, { base: true });
            var schema = this.context.registry.getGeneralSchema();
            var builder = new SPARQLBuilder(this, url)
                .base(schema.base)
                .vocab(schema.vocab);
            schema.prefixes.forEach(function (name, prefix) {
                builder = builder.prefix(prefix, name);
            });
            return builder;
        },
    },
    isDecorated: function (object) {
        return ModelDecorator
            .hasPropertiesFrom(SPARQLDocumentsRepositoryTrait.PROTOTYPE, object);
    },
    decorate: function (object) {
        if (SPARQLDocumentsRepositoryTrait.isDecorated(object))
            return object;
        var target = ModelDecorator
            .decorateMultiple(object, GeneralRepository);
        return ModelDecorator
            .definePropertiesFrom(SPARQLDocumentsRepositoryTrait.PROTOTYPE, target);
    },
};

//# sourceMappingURL=SPARQLDocumentsRepositoryTrait.js.map
