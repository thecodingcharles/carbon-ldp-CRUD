{"version":3,"sources":["DocumentsRepository/Utils.ts"],"names":[],"mappings":"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","file":"Utils.js","sourcesContent":["import { DocumentsRegistry } from \"../DocumentsRegistry/DocumentsRegistry\";\n\nimport { FreeResources } from \"../FreeResources/FreeResources\";\n\nimport { HTTPError } from \"../HTTP/Errors/HTTPError\";\n\nimport { JSONLDParser } from \"../JSONLD/JSONLDParser\";\n\nimport { ErrorResponse } from \"../LDP/ErrorResponse\";\n\nimport { Pointer } from \"../Pointer/Pointer\";\n\nimport { RDFDocument } from \"../RDF/Document\";\nimport { RDFNode } from \"../RDF/Node\";\n\nimport { URI } from \"../RDF/URI\";\n\nimport { ResolvablePointer } from \"../Repository/ResolvablePointer\";\n\nimport { isString } from \"../Utils\";\n\n\n/**\n * Parse the arguments of a relative repository method detecting if has a valid URI\n * if not, the URI will be taken from the resource provided.\n * @param resource The resource from where is executing the repository method.\n * @param uri The possible URI to be selected or another argument.\n * @param args All the arguments of the repository method that is been executed.\n * @returns An object with the target URI detected and the rest of the arguments to be applied in the repository method.\n */\nexport function _parseURIParams<T>( this:void, resource:ResolvablePointer, uri?:string | T, args?:IArguments ):{ _uri:string, _args:any[] } {\n\tconst _uri:string = isString( uri ) ?\n\t\tURI.resolve( resource.$id, uri ) : resource.$id;\n\n\tconst _args:any[] = ! isString( uri ) ?\n\t\tArray.from( args! ) :\n\t\tArray.prototype.slice.call( args, 1 );\n\n\treturn { _uri, _args };\n}\n\n/**\n * Parse the arguments of a relative repository method detecting if has a valid resource\n * if not, the resource will be the one provided by the param {@param resource}.\n * @param resource The resource from where is executing the repository method.\n * @param $resource The possible target resource to be selected or another argument.\n * @param args All the arguments of the repository method that is been executed.\n * @returns An object with the target resource detected and the rest of the argument to be applied in the repository method.\n */\nexport function _parseResourceParams<T>( this:void, resource:ResolvablePointer, $resource?:ResolvablePointer | T, args?:IArguments ):{ _resource:ResolvablePointer, _args:any[] } {\n\tconst _resource:ResolvablePointer = Pointer.is( $resource ) ?\n\t\t$resource : resource;\n\n\tconst _args:any[] = ! Pointer.is( $resource ) ?\n\t\tArray.from( args! ) :\n\t\tArray.prototype.slice.call( args, 1 );\n\n\treturn { _resource, _args };\n}\n\n\n/**\n * Returns a function that can parse a {@link HTTPError} into a {@link ErrorResponse} inside a rejected Promise.\n * @param registry The registry from where to get the information to convert the {@link HTTPError.response}'s data.\n */\nexport function _getErrorResponseParserFn( this:void, registry:DocumentsRegistry ):( error:HTTPError | Error ) => Promise<never> {\n\treturn ( error:HTTPError | Error ) => {\n\t\tif( ! (\"response\" in error) ) return Promise.reject( error );\n\t\tif( ! error.response.data ) return Promise.reject( error );\n\n\t\treturn new JSONLDParser()\n\t\t\t.parse( error.response.data )\n\t\t\t.then( ( rdfNodes:object[] ) => {\n\t\t\t\tconst freeNodes:RDFNode[] = RDFDocument.getFreeNodes( rdfNodes );\n\t\t\t\tconst freeResources:FreeResources = FreeResources.parseFreeNodes( registry, freeNodes );\n\n\t\t\t\tconst errorResponses:ErrorResponse[] = freeResources\n\t\t\t\t\t.getPointers( true )\n\t\t\t\t\t.filter( ErrorResponse.is );\n\n\t\t\t\tif( errorResponses.length === 0 )\n\t\t\t\t\treturn Promise.reject( error );\n\n\t\t\t\tconst errorResponse:ErrorResponse = Object.assign( error, errorResponses[ 0 ] );\n\t\t\t\terror.message = ErrorResponse.getMessage( errorResponse );\n\n\t\t\t\treturn Promise.reject( error );\n\t\t\t}, () => {\n\t\t\t\treturn Promise.reject( error );\n\t\t\t} );\n\t};\n}\n"],"sourceRoot":"../../src"}