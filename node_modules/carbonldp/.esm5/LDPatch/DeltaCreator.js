import { isBNodeLabel } from "sparqler/iri";
import { BlankNodeToken, CollectionToken, IRIRefToken, LanguageToken, LiteralToken, PrefixedNameToken, PropertyToken, RDFLiteralToken, SubjectToken, } from "sparqler/tokens";
import { _guessXSDType } from "../JSONLD/Utils";
import { ContainerType } from "../ObjectSchema/ContainerType";
import { DigestedObjectSchemaProperty } from "../ObjectSchema/DigestedObjectSchemaProperty";
import { ObjectSchemaDigester } from "../ObjectSchema/ObjectSchemaDigester";
import { PointerType } from "../ObjectSchema/PointerType";
import { Pointer } from "../Pointer/Pointer";
import { _isExistingValue, isString } from "../Utils";
import { XSD } from "../Vocabularies/XSD";
import { AddToken, DeleteToken, LDPatchToken, PrefixToken, SliceToken, UpdateListToken } from "./Tokens";
var typesDefinition = new DigestedObjectSchemaProperty();
typesDefinition.literal = false;
typesDefinition.pointerType = PointerType.ID;
typesDefinition.containerType = ContainerType.SET;
var DeltaCreator = (function () {
    function DeltaCreator(context) {
        this.prefixesMap = new Map();
        this.context = context;
        this.addToken = new AddToken();
        this.deleteToken = new DeleteToken();
        this.updateLists = [];
    }
    DeltaCreator.prototype.getPatch = function () {
        var _a;
        var patch = new LDPatchToken();
        this.prefixesMap.forEach(function (prefix) { return patch.prologues.push(prefix); });
        (_a = patch.statements).push.apply(_a, this.updateLists);
        if (this.addToken.triples.length)
            patch.statements.push(this.addToken);
        if (this.deleteToken.triples.length)
            patch.statements.push(this.deleteToken);
        return "" + patch;
    };
    DeltaCreator.prototype.addResource = function (id, previousResource, currentResource) {
        var _this = this;
        var _a;
        var schema = this.__getSchema(id, previousResource, currentResource);
        var resource = isBNodeLabel(id) ?
            new BlankNodeToken(id) : this.__compactIRI(schema, id);
        var updateLists = [];
        var addTriples = new SubjectToken(resource);
        var deleteTriples = new SubjectToken(resource);
        new Set([
            "types"
        ].concat(Object.keys(previousResource), Object.keys(currentResource))).forEach(function (propertyName) {
            if (propertyName === "$id")
                return;
            var predicateURI = propertyName === "types" ?
                "a" : _this._getPropertyIRI(schema, propertyName);
            var definition = predicateURI === "a" ?
                typesDefinition : schema.getProperty(propertyName);
            var oldValue = previousResource[propertyName];
            var newValue = currentResource[propertyName];
            if (definition && definition.containerType === ContainerType.LIST && _isExistingValue(oldValue)) {
                var listUpdates = [];
                if (!_isExistingValue(newValue)) {
                    deleteTriples.addProperty(new PropertyToken(predicateURI).addObject(new CollectionToken()));
                    listUpdates.push({ slice: [0, void 0], objects: [] });
                }
                else {
                    definition.containerType = ContainerType.SET;
                    listUpdates.push.apply(listUpdates, __getListDelta(_this.__getObjects(oldValue, schema, definition), _this.__getObjects(newValue, schema, definition)));
                }
                if (!listUpdates.length)
                    return;
                _this.__addPrefixFrom(predicateURI, schema);
                listUpdates.forEach(function (updateDelta) {
                    var collection = new CollectionToken();
                    updateDelta.objects.forEach(function (object) {
                        collection.addObject(object);
                        _this.__addPrefixFrom(object, schema);
                    });
                    updateLists.push(new UpdateListToken(resource, predicateURI, updateDelta.objects.length ?
                        new SliceToken(updateDelta.slice[0], updateDelta.slice[0]) : new (SliceToken.bind.apply(SliceToken, [void 0].concat(updateDelta.slice)))(), collection));
                });
            }
            else {
                var oldObjects = _this.__getObjects(oldValue, schema, definition);
                var newObjects = _this.__getObjects(newValue, schema, definition);
                var setDelta = __getArrayDelta(oldObjects, newObjects);
                var addValues = function (objects, triple) {
                    if (!objects.length)
                        return;
                    var property = new PropertyToken(predicateURI);
                    objects.forEach(function (object) {
                        property.addObject(object);
                        _this.__addPrefixFrom(object, schema);
                    });
                    triple.addProperty(property);
                };
                addValues(setDelta.toAdd, addTriples);
                addValues(setDelta.toDelete, deleteTriples);
            }
        });
        (_a = this.updateLists).push.apply(_a, updateLists);
        updateLists.forEach(function (x) { return _this.__addPrefixFrom(x.predicate, schema); });
        if (addTriples.properties.length)
            this.addToken.triples.push(addTriples);
        addTriples.properties.forEach(function (x) { return _this.__addPrefixFrom(x.verb, schema); });
        if (deleteTriples.properties.length)
            this.deleteToken.triples.push(deleteTriples);
        deleteTriples.properties.forEach(function (x) { return _this.__addPrefixFrom(x.verb, schema); });
        this.__addPrefixFrom(resource, schema);
    };
    DeltaCreator.prototype.__getSchema = function ($id, previousResource, currentResource) {
        var typesSet = new Set();
        if ("types" in previousResource)
            previousResource
                .types.forEach(typesSet.add, typesSet);
        if ("types" in currentResource)
            currentResource
                .types.forEach(typesSet.add, typesSet);
        var mergedResource = { $id: $id, types: Array.from(typesSet) };
        var baseSchema = this.context.registry
            .getSchemaFor(mergedResource);
        var queryableProperty = previousResource.$_queryableMetadata || previousResource.$_queryableMetadata;
        if (!queryableProperty)
            return baseSchema;
        return ObjectSchemaDigester._combineSchemas([
            baseSchema,
            queryableProperty.getSchema(),
        ]);
    };
    DeltaCreator.prototype._getPropertyIRI = function (schema, propertyName) {
        var propertyDefinition = schema.properties.get(propertyName);
        var uri = propertyDefinition && propertyDefinition.uri ?
            propertyDefinition.uri :
            propertyName;
        return this.__compactIRI(schema, uri);
    };
    DeltaCreator.prototype.__getObjects = function (value, schema, definition) {
        var _a;
        var values = (Array.isArray(value) ?
            !definition || definition.containerType !== null ? value : value.slice(0, 1) :
            [value]).filter(_isExistingValue);
        if (definition && definition.containerType === ContainerType.LIST) {
            if (!_isExistingValue(value))
                return [];
            var collection = new CollectionToken();
            (_a = collection.objects).push.apply(_a, this.__expandValues(values, schema, definition));
            return [collection];
        }
        if (definition && definition.containerType === ContainerType.LANGUAGE) {
            return this.__expandLanguageMap(values, schema);
        }
        return this.__expandValues(values, schema, definition);
    };
    DeltaCreator.prototype.__expandValues = function (values, schema, definition) {
        var _this = this;
        var areDefinedLiteral = definition && definition.literal !== null ? definition.literal : null;
        return values
            .map(function (value) {
            var isLiteral = areDefinedLiteral !== null ? areDefinedLiteral : !Pointer.is(value);
            if (isLiteral)
                return _this.__expandLiteral(value, schema, definition);
            return _this.__expandPointer(value, schema);
        })
            .filter(_isExistingValue);
    };
    DeltaCreator.prototype.__expandLanguageMap = function (values, schema) {
        var _this = this;
        if (!values.length)
            return [];
        var languageMap = values[0];
        return Object
            .keys(languageMap)
            .map(function (key) {
            var value = languageMap[key];
            var tempDefinition = new DigestedObjectSchemaProperty();
            tempDefinition.language = key;
            tempDefinition.literalType = XSD.string;
            return _this.__expandLiteral(value, schema, tempDefinition);
        })
            .filter(_isExistingValue);
    };
    DeltaCreator.prototype.__expandPointer = function (value, schema) {
        var id = Pointer.is(value) ? value.$id : value;
        if (!isString(id))
            return null;
        return isBNodeLabel(id) ?
            new BlankNodeToken(id) :
            this.__compactIRI(schema, id);
    };
    DeltaCreator.prototype.__expandLiteral = function (value, schema, definition) {
        var type = definition && definition.literalType ?
            definition.literalType :
            _guessXSDType(value);
        if (type === null || !this.context.jsonldConverter.literalSerializers.has(type))
            return null;
        value = this.context.jsonldConverter.literalSerializers.get(type).serialize(value);
        if (type !== XSD.string)
            return new RDFLiteralToken(value, this.__compactIRI(schema, type));
        if (definition && typeof definition.language === "string")
            return new RDFLiteralToken(value, new LanguageToken(definition.language));
        return new LiteralToken(value);
    };
    DeltaCreator.prototype.__compactIRI = function (schema, iri) {
        iri = schema.resolveURI(iri, { vocab: true });
        var matchPrefix = Array.from(schema.prefixes.entries())
            .find(function (_a) {
            var prefixURI = _a[1];
            return iri.startsWith(prefixURI);
        });
        if (!matchPrefix)
            return new IRIRefToken(iri);
        return new PrefixedNameToken(matchPrefix[0], iri.substr(matchPrefix[1].length));
    };
    DeltaCreator.prototype.__addPrefixFrom = function (object, schema) {
        var _this = this;
        if (object === "a")
            return;
        if ("objects" in object)
            return object.objects.forEach(function (collectionObject) {
                _this.__addPrefixFrom(collectionObject, schema);
            });
        if ("type" in object)
            return this.__addPrefixFrom(object.type, schema);
        if (object.token !== "prefixedName")
            return;
        var namespace = object.namespace;
        if (this.prefixesMap.has(namespace))
            return;
        var iri = schema.prefixes.get(namespace);
        this.prefixesMap.set(namespace, new PrefixToken(namespace, new IRIRefToken(iri)));
    };
    return DeltaCreator;
}());
export { DeltaCreator };
function __getArrayDelta(oldValues, newValues) {
    var objectMapper = function (object) { return ["" + object, object]; };
    var toAdd = new Map(newValues.map(objectMapper));
    var toDelete = new Map(oldValues.map(objectMapper));
    toAdd.forEach(function (value, identifier) {
        if (!toDelete.has(identifier))
            return;
        toDelete.delete(identifier);
        toAdd.delete(identifier);
    });
    return {
        toAdd: Array.from(toAdd.values()),
        toDelete: Array.from(toDelete.values()),
    };
}
function __getListDelta(oldValues, newValues) {
    var nodeMapper = function (object, index) { return ({
        identifier: "" + object,
        object: object,
        index: index,
    }); };
    var oldPositions = oldValues.map(nodeMapper);
    var newPositions = newValues.map(nodeMapper);
    var addsSet = new Set(newPositions);
    var deletes = [];
    var offset = 0;
    var remnants = newPositions;
    oldPositions.forEach(function (oldNode) {
        var currentIndex = remnants.findIndex(function (newNode) { return newNode.identifier === oldNode.identifier; });
        if (currentIndex === -1) {
            oldNode.index -= offset++;
            deletes.push(oldNode);
        }
        else {
            addsSet.delete(remnants[currentIndex]);
            remnants = remnants.slice(currentIndex + 1);
        }
    });
    var updates = [];
    var last;
    deletes.forEach(function (node) {
        if (last && last.slice[0] === node.index) {
            last.slice = [last.slice[0], last.slice[1] + 1];
            return;
        }
        updates.push(last = {
            slice: [node.index, node.index + 1],
            objects: [],
        });
    });
    last = void 0;
    addsSet.forEach(function (node) {
        if (last && last.slice[1] === node.index) {
            last.slice = [last.slice[0], node.index + 1];
            last.objects.push(node.object);
            return;
        }
        updates.push(last = {
            slice: [node.index, node.index + 1],
            objects: [node.object],
        });
    });
    return updates;
}

//# sourceMappingURL=DeltaCreator.js.map
