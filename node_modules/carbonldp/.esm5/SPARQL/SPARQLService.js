import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { NotImplementedError } from "../Errors/NotImplementedError";
import { RequestService, RequestUtils } from "../HTTP/Request";
import { StringParser } from "../HTTP/StringParser";
import { _getPointer } from "../Pointer/PointerLibrary";
import { RDFLiteral } from "../RDF/Literal";
import { SPARQLRawResultsParser } from "./RawResultsParser";
var SPARQLService = (function () {
    function SPARQLService() {
    }
    SPARQLService.executeRawASKQuery = function (url, askQuery, options) {
        if (options === void 0) { options = {}; }
        options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
        RequestUtils.setAcceptHeader("application/sparql-results+json", options);
        RequestUtils.setContentTypeHeader("application/sparql-query", options);
        return RequestService.post(url, askQuery, options, SPARQLService.RESULTS_PARSER);
    };
    SPARQLService.executeASKQuery = function (url, askQuery, options) {
        if (options === void 0) { options = {}; }
        return SPARQLService
            .executeRawASKQuery(url, askQuery, options)
            .then(function (_a) {
            var rawResults = _a[0], response = _a[1];
            return [rawResults.boolean, response];
        });
    };
    SPARQLService.executeRawSELECTQuery = function (url, selectQuery, options) {
        if (options === void 0) { options = {}; }
        options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
        RequestUtils.setAcceptHeader("application/sparql-results+json", options);
        RequestUtils.setContentTypeHeader("application/sparql-query", options);
        return RequestService.post(url, selectQuery, options, SPARQLService.RESULTS_PARSER);
    };
    SPARQLService.executeSELECTQuery = function (url, selectQuery, pointerLibrary, options) {
        if (options === void 0) { options = {}; }
        return SPARQLService
            .executeRawSELECTQuery(url, selectQuery, options)
            .then(function (_a) {
            var rawResults = _a[0], response = _a[1];
            var rawBindings = rawResults.results.bindings;
            var bindings = [];
            for (var _i = 0, rawBindings_1 = rawBindings; _i < rawBindings_1.length; _i++) {
                var bindingColumn = rawBindings_1[_i];
                var binding = {};
                for (var bindingRow in bindingColumn) {
                    var bindingCell = bindingColumn[bindingRow];
                    binding[bindingRow] = SPARQLService.__parseRawBindingProperty(bindingCell, pointerLibrary);
                }
                bindings.push(binding);
            }
            var results = {
                vars: rawResults.head.vars,
                bindings: bindings,
            };
            return [results, response];
        });
    };
    SPARQLService.executeRawCONSTRUCTQuery = function (url, constructQuery, options) {
        if (options === void 0) { options = {}; }
        options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
        RequestUtils.setAcceptHeader("application/ld+json", options);
        RequestUtils.setContentTypeHeader("application/sparql-query", options);
        return RequestService.post(url, constructQuery, options, SPARQLService.STRING_PARSER);
    };
    SPARQLService.executeRawDESCRIBEQuery = function (url, describeQuery, options) {
        if (options === void 0) { options = {}; }
        options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
        RequestUtils.setAcceptHeader("application/ld+json", options);
        RequestUtils.setContentTypeHeader("application/sparql-query", options);
        return RequestService.post(url, describeQuery, options, SPARQLService.STRING_PARSER);
    };
    SPARQLService.executeUPDATE = function (url, updateQuery, options) {
        if (options === void 0) { options = {}; }
        options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
        RequestUtils.setAcceptHeader("application/ld+json", options);
        RequestUtils.setContentTypeHeader("application/sparql-update", options);
        return RequestService.post(url, updateQuery, options);
    };
    SPARQLService.__parseRawBindingProperty = function (rawBindingProperty, pointerLibrary) {
        switch (rawBindingProperty.type) {
            case "uri":
                return _getPointer(pointerLibrary, rawBindingProperty.value);
            case "bnode":
                throw new NotImplementedError("BNodes cannot be queried directly");
            case "literal":
                if ("datatype" in rawBindingProperty) {
                    return RDFLiteral.parse(rawBindingProperty.value, rawBindingProperty.datatype);
                }
                else {
                    return RDFLiteral.parse(rawBindingProperty.value);
                }
            default:
                throw new IllegalArgumentError("The bindingProperty has an unsupported type");
        }
    };
    SPARQLService.DEFAULT_OPTIONS = {};
    SPARQLService.RESULTS_PARSER = new SPARQLRawResultsParser();
    SPARQLService.STRING_PARSER = new StringParser();
    return SPARQLService;
}());
export { SPARQLService };

//# sourceMappingURL=SPARQLService.js.map
