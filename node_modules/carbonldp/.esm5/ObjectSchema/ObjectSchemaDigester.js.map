{"version":3,"sources":["ObjectSchema/ObjectSchemaDigester.ts"],"names":[],"mappings":"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","file":"ObjectSchemaDigester.js","sourcesContent":["import { IllegalArgumentError } from \"../Errors/IllegalArgumentError\";\nimport { InvalidJSONLDSyntaxError } from \"../Errors/InvalidJSONLDSyntaxError\";\n\nimport { URI } from \"../RDF/URI\";\n\nimport * as Utils from \"../Utils\";\n\nimport { XSD } from \"../Vocabularies/XSD\";\n\nimport { ContainerType } from \"./ContainerType\";\nimport { DigestedObjectSchema } from \"./DigestedObjectSchema\";\nimport { DigestedObjectSchemaProperty } from \"./DigestedObjectSchemaProperty\";\nimport { ObjectSchema } from \"./ObjectSchema\";\nimport { ObjectSchemaProperty } from \"./ObjectSchemaProperty\";\nimport { ObjectSchemaUtils } from \"./ObjectSchemaUtils\";\nimport { PointerType } from \"./PointerType\";\n\n\n/**\n * Service with static methods to standardize a JSON-LD Context Schema.\n */\nexport class ObjectSchemaDigester {\n\n\t/**\n\t * Processes a schema to standardize it before using it.\n\t * @param schema The object schema to process.\n\t */\n\tstatic digestSchema( schema:ObjectSchema ):DigestedObjectSchema;\n\t/**\n\t * Processes multiple schemas into a single one to standardize it before using it.\n\t * @param schemas The object schemas to process.\n\t */\n\tstatic digestSchema( schemas:ObjectSchema[] ):DigestedObjectSchema;\n\tstatic digestSchema( schemas:ObjectSchema | ObjectSchema[] ):DigestedObjectSchema {\n\t\tif( ! Array.isArray( schemas ) ) return ObjectSchemaDigester._digestSchema( schemas );\n\n\t\tconst digestedSchemas:DigestedObjectSchema[] = schemas\n\t\t\t.map( schema => ObjectSchemaDigester._digestSchema( schema ) );\n\n\t\treturn ObjectSchemaDigester._combineSchemas( digestedSchemas );\n\t}\n\n\t/**\n\t * Processes a schema property definition before using it.\n\t * @param name The name of the property.\n\t * @param definition The definition object of the property.\n\t * @param digestedSchema Optional schema used to resolve relative URIs in the definition.\n\t */\n\tstatic digestProperty( name:string, definition:ObjectSchemaProperty, digestedSchema?:DigestedObjectSchema ):DigestedObjectSchemaProperty {\n\t\tconst digestedDefinition:DigestedObjectSchemaProperty = new DigestedObjectSchemaProperty();\n\n\t\tif( \"@id\" in definition ) {\n\t\t\tconst uri:any = definition[ \"@id\" ];\n\n\t\t\tif( URI.isPrefixed( name ) ) throw new IllegalArgumentError( \"A prefixed property cannot have assigned another URI.\" );\n\t\t\tif( ! Utils.isString( uri ) ) throw new IllegalArgumentError( \"@id needs to point to a string\" );\n\n\t\t\tdigestedDefinition.uri = uri;\n\t\t} else {\n\t\t\tdigestedDefinition.uri = name;\n\t\t}\n\n\t\tif( \"@type\" in definition ) {\n\t\t\tlet type:any = definition[ \"@type\" ];\n\t\t\tif( ! Utils.isString( type ) ) throw new IllegalArgumentError( \"@type needs to point to a string\" );\n\n\t\t\tif( type === \"@id\" || type === \"@vocab\" ) {\n\t\t\t\tdigestedDefinition.literal = false;\n\t\t\t\tdigestedDefinition.pointerType = type === \"@id\" ? PointerType.ID : PointerType.VOCAB;\n\n\t\t\t} else {\n\t\t\t\tif( URI.isRelative( type ) && type in XSD ) type = XSD[ type ];\n\n\t\t\t\tdigestedDefinition.literal = true;\n\t\t\t\tdigestedDefinition.literalType = type;\n\t\t\t}\n\t\t}\n\n\t\tif( \"@language\" in definition ) {\n\t\t\tconst language:string | undefined | null = definition[ \"@language\" ];\n\t\t\tif( language !== null && ! Utils.isString( language ) ) throw new IllegalArgumentError( \"@language needs to point to a string or null.\" );\n\n\t\t\tdigestedDefinition.literal = true;\n\t\t\tdigestedDefinition.language = language;\n\t\t}\n\n\t\tif( \"@container\" in definition ) {\n\t\t\tswitch( definition[ \"@container\" ] ) {\n\t\t\t\tcase \"@set\":\n\t\t\t\t\tdigestedDefinition.containerType = ContainerType.SET;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"@list\":\n\t\t\t\t\tdigestedDefinition.containerType = ContainerType.LIST;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"@language\":\n\t\t\t\t\tif( Utils.isString( digestedDefinition.language ) ) throw new IllegalArgumentError( \"@container cannot be set to @language when the property definition already contains an @language tag.\" );\n\t\t\t\t\tdigestedDefinition.containerType = ContainerType.LANGUAGE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalArgumentError( \"@container needs to be equal to '@list', '@set', or '@language'\" );\n\t\t\t}\n\t\t}\n\n\t\treturn digestedSchema ?\n\t\t\tObjectSchemaUtils._resolveProperty( digestedSchema, digestedDefinition, true ) :\n\t\t\tdigestedDefinition;\n\t}\n\n\t/**\n\t * Combines several standardized schemas into one.\n\t * @param digestedSchemas The schemas to combine.\n\t */\n\tstatic combineDigestedObjectSchemas( digestedSchemas:DigestedObjectSchema[] ):DigestedObjectSchema {\n\t\tif( digestedSchemas.length === 0 ) throw new IllegalArgumentError( \"At least one DigestedObjectSchema needs to be specified.\" );\n\n\t\tdigestedSchemas.unshift( new DigestedObjectSchema() );\n\t\treturn ObjectSchemaDigester._combineSchemas( digestedSchemas );\n\t}\n\n\t/**\n\t * Actual implementation of the standardization of a schema.\n\t * @param schema The schema to process.\n\t */\n\tstatic _digestSchema( schema:ObjectSchema ):DigestedObjectSchema {\n\t\tconst digestedSchema:DigestedObjectSchema = new DigestedObjectSchema();\n\n\t\tfor( const propertyName of [ \"@base\", \"@vocab\" ] as [ \"@base\", \"@vocab\" ] ) {\n\t\t\tif( ! (propertyName in schema) ) continue;\n\t\t\tconst value:string | undefined | null = schema[ propertyName ];\n\n\t\t\tif( value !== null && ! Utils.isString( value ) ) throw new IllegalArgumentError( `The value of '${ propertyName }' must be a string or null.` );\n\t\t\tif( (propertyName === \"@vocab\" && value === \"\") || (value && ! URI.isAbsolute( value ) && ! URI.isBNodeID( value )) ) throw new IllegalArgumentError( `The value of '${ propertyName }' must be an absolute URI${ propertyName === \"@base\" ? \" or an empty string\" : \"\" }.` );\n\n\t\t\tdigestedSchema[ propertyName.substr( 1 ) ] = value;\n\t\t}\n\t\tdigestedSchema.base = digestedSchema.base || \"\";\n\n\t\tif( \"@language\" in schema ) {\n\t\t\tconst value:string | undefined | null = schema[ \"@language\" ];\n\t\t\tif( value !== null && ! Utils.isString( value ) ) throw new InvalidJSONLDSyntaxError( `The value of '@language' must be a string or null.` );\n\t\t\tdigestedSchema.language = value;\n\t\t}\n\n\t\tfor( const propertyName in schema ) {\n\t\t\tif( ! schema.hasOwnProperty( propertyName ) ) continue;\n\n\t\t\tif( propertyName === \"@reverse\" ) continue;\n\t\t\tif( propertyName === \"@index\" ) continue;\n\t\t\tif( propertyName === \"@base\" ) continue;\n\t\t\tif( propertyName === \"@vocab\" ) continue;\n\t\t\tif( propertyName === \"@language\" ) continue;\n\n\t\t\tlet propertyValue:string | ObjectSchemaProperty | null | undefined = schema[ propertyName ];\n\n\t\t\tif( Utils.isString( propertyValue ) ) {\n\t\t\t\tif( URI.isPrefixed( propertyName ) ) throw new IllegalArgumentError( \"A prefixed property cannot be equal to another URI.\" );\n\t\t\t\tdigestedSchema.prefixes.set( propertyName, propertyValue );\n\n\t\t\t} else if( ! ! propertyValue && Utils.isObject( propertyValue ) ) {\n\t\t\t\tconst definition:DigestedObjectSchemaProperty = ObjectSchemaDigester.digestProperty( propertyName, propertyValue );\n\t\t\t\tdigestedSchema.properties.set( propertyName, definition );\n\n\t\t\t} else {\n\t\t\t\tthrow new IllegalArgumentError( \"ObjectSchema Properties can only have string values or object values.\" );\n\t\t\t}\n\t\t}\n\n\t\treturn digestedSchema;\n\t}\n\n\t/**\n\t * Actual implementation of the schema combination.\n\t * This method uses the first schema as the target schema where to combine the data.\n\t *\n\t * @param digestedSchemas The schemas to combine.\n\t */\n\tstatic _combineSchemas( digestedSchemas:DigestedObjectSchema[] ):DigestedObjectSchema {\n\t\tconst [ targetSchema, ...restSchemas ] = digestedSchemas;\n\n\t\trestSchemas.forEach( schema => {\n\t\t\tif( schema.vocab !== void 0 ) targetSchema.vocab = schema.vocab;\n\t\t\tif( schema.base !== \"\" ) targetSchema.base = schema.base;\n\t\t\tif( schema.language !== null ) targetSchema.language = schema.language;\n\n\t\t\tUtils.MapUtils.extend( targetSchema.prefixes, schema.prefixes );\n\t\t\tUtils.MapUtils.extend( targetSchema.properties, schema.properties );\n\t\t} );\n\n\t\treturn targetSchema;\n\t}\n\n}\n"],"sourceRoot":"../../src"}