import { isRelative } from "sparqler/iri";
import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { TransientFragment } from "../Fragment/TransientFragment";
import { ModelDecorator } from "../Model/ModelDecorator";
import { Pointer } from "../Pointer/Pointer";
import { URI } from "../RDF/URI";
import { Registry } from "../Registry/Registry";
import { Resource } from "../Resource/Resource";
import { isObject, isPlainObject, isString } from "../Utils";
function __getLabelFrom(slug) {
    if (!isRelative(slug) || slug.startsWith("#"))
        return slug;
    return "#" + slug;
}
function __getObjectId(object) {
    if ("$id" in object)
        return object.$id;
    if ("$slug" in object)
        return URI.hasFragment(object.$slug) ?
            object.$slug : __getLabelFrom(object.$slug);
    return URI.generateBNodeID();
}
function __convertNested(resource, target, tracker) {
    if (tracker === void 0) { tracker = new Set(); }
    Object
        .keys(target)
        .map(function (key) { return target[key]; })
        .forEach(function (next) {
        if (Array.isArray(next))
            return __convertNested(resource, next, tracker);
        if (!isPlainObject(next))
            return;
        if (TransientDocument.is(next))
            return;
        if (next._registry && next._registry !== resource)
            return;
        var idOrSlug = __getObjectId(next);
        if (tracker.has(idOrSlug))
            return;
        if (!resource.$inScope(idOrSlug, true))
            return;
        var fragment = resource.$hasPointer(idOrSlug, true) ?
            resource.$getPointer(idOrSlug, true) :
            resource.$createFragment(next, idOrSlug);
        tracker.add(fragment.$id);
        __convertNested(resource, fragment, tracker);
    });
}
export var TransientDocument = {
    PROTOTYPE: {
        $registry: void 0,
        $_normalize: function () {
            var usedFragments = new Set();
            __convertNested(this, this, usedFragments);
            this.$getPointers(true)
                .map(Pointer.getID)
                .filter(URI.isBNodeID)
                .filter(function (id) { return !usedFragments.has(id); })
                .forEach(this.$removePointer, this);
        },
        $_getLocalID: function (id) {
            if (URI.isBNodeID(id))
                return id;
            if (URI.isFragmentOf(id, this.$id))
                return URI.getFragment(id);
            throw new IllegalArgumentError("\"" + id + "\" is out of scope.");
        },
        $getPointer: function (id, local) {
            id = URI.resolve(this.$id, id);
            return Registry.PROTOTYPE.getPointer.call(this, id, local);
        },
        $hasFragment: function (id) {
            id = __getLabelFrom(id);
            if (!this.$inScope(id, true))
                return false;
            var localID = this.$_getLocalID(id);
            return this.$__resourcesMap.has(localID);
        },
        $getFragment: function (id) {
            id = __getLabelFrom(id);
            var localID = this.$_getLocalID(id);
            var resource = this.$__resourcesMap.get(localID);
            if (!resource)
                return null;
            return resource;
        },
        $getFragments: function () {
            return this.$getPointers(true);
        },
        $createFragment: function (isOrObject, id) {
            var object = isObject(isOrObject) ? isOrObject : {};
            if (isString(isOrObject))
                id = isOrObject;
            var $id = id ? __getLabelFrom(id) : __getObjectId(object);
            var fragment = this.$_addPointer(Object
                .assign(object, { $id: $id }));
            __convertNested(this, fragment);
            return fragment;
        },
        $removeFragment: function (fragmentOrSlug) {
            var id = __getLabelFrom(Pointer.getID(fragmentOrSlug));
            if (!this.$inScope(id, true))
                return false;
            return this.$removePointer(id);
        },
        toJSON: function (contextOrKey) {
            var nodes = [
                Resource.PROTOTYPE.toJSON.call(this, contextOrKey)
            ].concat(this
                .$getFragments()
                .map(function (resource) { return resource.toJSON(contextOrKey); }));
            return {
                "@id": this.$id,
                "@graph": nodes,
            };
        },
    },
    isDecorated: function (object) {
        return ModelDecorator
            .hasPropertiesFrom(TransientDocument.PROTOTYPE, object);
    },
    decorate: function (object) {
        if (TransientDocument.isDecorated(object))
            return object;
        var base = ModelDecorator.definePropertiesFrom({
            $__modelDecorator: TransientFragment,
        }, object);
        var resource = ModelDecorator
            .decorateMultiple(base, Resource, Registry);
        return ModelDecorator
            .definePropertiesFrom(TransientDocument.PROTOTYPE, resource);
    },
    is: function (value) {
        return Resource.is(value) &&
            Registry.isDecorated(value) &&
            TransientDocument.isDecorated(value);
    },
    createFrom: function (object) {
        if (TransientDocument.is(object))
            throw new IllegalArgumentError("The object provided is already a Document.");
        var document = TransientDocument.decorate(object);
        __convertNested(document, document);
        return document;
    },
    create: function (data) {
        var copy = Object.assign({}, data);
        return TransientDocument.createFrom(copy);
    },
};

//# sourceMappingURL=TransientDocument.js.map
