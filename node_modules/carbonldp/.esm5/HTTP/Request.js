import * as tslib_1 from "tslib";
import HTTP from "http";
import HTTPS from "https";
import URL from "url";
import { hasProperty, hasPropertyDefined, isNumber, isString } from "../Utils";
import { statusCodeMap } from "./Errors/index";
import { BadResponseError } from "./Errors/ServerErrors/BadResponseError";
import { UnknownError } from "./Errors/UnknownError";
import { Header } from "./Header";
import { HTTPMethod } from "./HTTPMethod";
import { Response } from "./Response";
function __onResolve(resolve, reject, response) {
    if (response.status >= 200 && response.status <= 299) {
        resolve(response);
    }
    else {
        if (!statusCodeMap.has(response.status))
            return reject(new UnknownError(response.data, response));
        reject(new (statusCodeMap.get(response.status))(response.data, response));
    }
}
function __sendWithBrowser(method, url, body, options) {
    return new Promise(function (resolve, reject) {
        var request = options.request ? options.request : new XMLHttpRequest();
        request.open(method, url, true);
        if (options.headers)
            options.headers
                .forEach(function (header, name) { return request.setRequestHeader(name, header.toString()); });
        request.withCredentials = !!options.sendCredentialsOnCORS;
        if (options.timeout)
            request.timeout = options.timeout;
        request.onload = request.onerror = function () {
            var response = new Response(request);
            __onResolve(resolve, reject, response);
        };
        if (body) {
            request.send(body);
        }
        else {
            request.send();
        }
    });
}
function __sendWithNode(method, url, body, options) {
    return new Promise(function (resolve, reject) {
        function returnResponse(request, res) {
            var rawData = [];
            res.on("data", function (chunk) {
                if (typeof chunk === "string")
                    chunk = Buffer.from(chunk, "utf-8");
                rawData.push(chunk);
            }).on("end", function () {
                var data = Buffer.concat(rawData).toString("utf8");
                var response = new Response(request, data, res);
                __onResolve(resolve, reject, response);
            });
        }
        var numberOfRedirects = 0;
        function sendRequestWithRedirect(_url) {
            var parsedURL = URL.parse(_url);
            var Adapter = parsedURL.protocol === "http:" ? HTTP : HTTPS;
            var requestOptions = {
                protocol: parsedURL.protocol,
                hostname: parsedURL.hostname,
                port: parsedURL.port,
                path: parsedURL.path,
                method: method,
                headers: {},
            };
            if (options.headers)
                options.headers
                    .forEach(function (header, name) { return requestOptions.headers[name] = header.toString(); });
            var request = Adapter.request(requestOptions);
            if (options.timeout)
                request.setTimeout(options.timeout);
            request.on("response", function (res) {
                if (res.statusCode >= 300 && res.statusCode <= 399 && "location" in res.headers) {
                    if (++numberOfRedirects < 10)
                        return sendRequestWithRedirect(URL.resolve(_url, res.headers.location));
                }
                returnResponse(request, res);
            });
            request.on("error", function (error) {
                var response = new Response(request, error.message);
                __onResolve(resolve, reject, response);
            });
            if (body) {
                if (method === "DELETE")
                    request.useChunkedEncodingByDefault = true;
                request.write(body);
            }
            request.end();
        }
        sendRequestWithRedirect(url);
    });
}
function __sendRequest(method, url, body, options) {
    return typeof XMLHttpRequest !== "undefined" ?
        __sendWithBrowser(method, url, body, options) :
        __sendWithNode(method, url, body, options);
}
function __isBody(data) {
    return isString(data)
        || typeof Blob !== "undefined" && data instanceof Blob
        || typeof Buffer !== "undefined" && data instanceof Buffer;
}
var RequestService = (function () {
    function RequestService() {
    }
    RequestService.send = function (method, url, bodyOrOptions, optionsOrParser, parser) {
        var _this = this;
        var body = undefined;
        var options = hasProperty(optionsOrParser, "parse") ? bodyOrOptions : optionsOrParser;
        parser = hasProperty(optionsOrParser, "parse") ? optionsOrParser : parser;
        if (!bodyOrOptions || __isBody(bodyOrOptions)) {
            body = bodyOrOptions;
        }
        else {
            options = bodyOrOptions ? bodyOrOptions : options;
        }
        options = Object.assign({}, RequestService.defaultOptions, options);
        if (isNumber(method))
            method = HTTPMethod[method];
        var requestPromise = __sendRequest(method, url, body, options)
            .then(function (response) {
            if (method === "GET" && options.headers)
                return _this.__handleGETResponse(url, options, response);
            else
                return response;
        });
        if (!parser)
            return requestPromise;
        return requestPromise.then(function (response) {
            return parser.parse(response.data).then(function (parsedBody) {
                return [parsedBody, response];
            });
        });
    };
    RequestService.options = function (url, options) {
        if (options === void 0) { options = RequestService.defaultOptions; }
        return RequestService.send(HTTPMethod.OPTIONS, url, options);
    };
    RequestService.head = function (url, options) {
        if (options === void 0) { options = RequestService.defaultOptions; }
        return RequestService.send(HTTPMethod.HEAD, url, options);
    };
    RequestService.get = function (url, options, parser) {
        if (options === void 0) { options = RequestService.defaultOptions; }
        return RequestService.send(HTTPMethod.GET, url, undefined, options, parser);
    };
    RequestService.post = function (url, bodyOrOptions, options, parser) {
        if (bodyOrOptions === void 0) { bodyOrOptions = RequestService.defaultOptions; }
        if (options === void 0) { options = RequestService.defaultOptions; }
        return RequestService.send(HTTPMethod.POST, url, bodyOrOptions, options, parser);
    };
    RequestService.put = function (url, bodyOrOptions, options, parser) {
        if (bodyOrOptions === void 0) { bodyOrOptions = RequestService.defaultOptions; }
        if (options === void 0) { options = RequestService.defaultOptions; }
        return RequestService.send(HTTPMethod.PUT, url, bodyOrOptions, options, parser);
    };
    RequestService.patch = function (url, bodyOrOptions, options, parser) {
        if (bodyOrOptions === void 0) { bodyOrOptions = RequestService.defaultOptions; }
        if (options === void 0) { options = RequestService.defaultOptions; }
        return RequestService.send(HTTPMethod.PATCH, url, bodyOrOptions, options, parser);
    };
    RequestService.delete = function (url, bodyOrOptions, optionsOrParser, parser) {
        if (bodyOrOptions === void 0) { bodyOrOptions = RequestService.defaultOptions; }
        if (optionsOrParser === void 0) { optionsOrParser = RequestService.defaultOptions; }
        return RequestService.send(HTTPMethod.DELETE, url, bodyOrOptions, optionsOrParser, parser);
    };
    RequestService.__handleGETResponse = function (url, requestOptions, response) {
        var _this = this;
        return Promise.resolve()
            .then(function () {
            if (_this.__contentTypeIsAccepted(requestOptions, response))
                return response;
            _this.__setNoCacheHeaders(requestOptions);
            if (!_this.__isChromiumAgent())
                _this.__setFalseETag(requestOptions);
            return __sendRequest("GET", url, undefined, requestOptions)
                .then(function (noCachedResponse) {
                if (!_this.__contentTypeIsAccepted(requestOptions, response)) {
                    throw new BadResponseError("The server responded with an unacceptable Content-Type", response);
                }
                return noCachedResponse;
            });
        });
    };
    RequestService.__contentTypeIsAccepted = function (requestOptions, response) {
        if (!requestOptions.headers)
            return true;
        var accepts = requestOptions.headers.has("accept") ?
            requestOptions.headers.get("accept").values :
            [];
        var contentType = response.headers.has("content-type") ?
            response.headers.get("content-type") :
            undefined;
        return !contentType || accepts.some(contentType.hasValue, contentType);
    };
    RequestService.__setNoCacheHeaders = function (requestOptions) {
        requestOptions.headers
            .set("pragma", new Header("no-cache"))
            .set("cache-control", new Header("no-cache, max-age=0"));
    };
    RequestService.__isChromiumAgent = function () {
        return typeof window !== "undefined" && !!window["chrome"];
    };
    RequestService.__setFalseETag = function (requestOptions) {
        requestOptions.headers.set("if-none-match", new Header());
    };
    RequestService.defaultOptions = {
        sendCredentialsOnCORS: true,
    };
    return RequestService;
}());
export { RequestService };
var RequestUtils = (function () {
    function RequestUtils() {
    }
    RequestUtils.getHeader = function (headerName, requestOptions, initialize) {
        if (!requestOptions.headers) {
            if (!initialize)
                return undefined;
            requestOptions.headers = new Map();
        }
        headerName = headerName.toLowerCase();
        var header = requestOptions.headers.get(headerName);
        if (!header) {
            if (!initialize)
                return undefined;
            header = new Header();
            requestOptions.headers.set(headerName, header);
        }
        return header;
    };
    RequestUtils.setAcceptHeader = function (accept, requestOptions) {
        RequestUtils.__addHeaderValue("accept", accept, requestOptions);
        return requestOptions;
    };
    RequestUtils.setContentTypeHeader = function (contentType, requestOptions) {
        RequestUtils.__addHeaderValue("content-type", contentType, requestOptions);
        return requestOptions;
    };
    RequestUtils.setIfMatchHeader = function (eTag, requestOptions) {
        if (!eTag)
            return requestOptions;
        RequestUtils.__addHeaderValue("if-match", eTag, requestOptions);
        return requestOptions;
    };
    RequestUtils.setIfNoneMatchHeader = function (eTag, requestOptions) {
        if (!eTag)
            return requestOptions;
        RequestUtils.__addHeaderValue("if-none-match", eTag, requestOptions);
        return requestOptions;
    };
    RequestUtils.setPreferredInteractionModel = function (interactionModelURI, requestOptions) {
        var headerValue = interactionModelURI + "; rel=interaction-model";
        RequestUtils.__addHeaderValue("prefer", headerValue, requestOptions);
        return requestOptions;
    };
    RequestUtils.setPreferredRetrieval = function (retrievalType, requestOptions) {
        var headerValue = "return=" + retrievalType;
        RequestUtils.__addHeaderValue("prefer", headerValue, requestOptions);
        return requestOptions;
    };
    RequestUtils.setRetrievalPreferences = function (preferences, requestOptions) {
        var prefer = RequestUtils.getHeader("prefer", requestOptions, true);
        var keys = ["include", "omit"];
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            if (!(key in preferences))
                continue;
            if (preferences[key].length <= 0)
                continue;
            var strPreferences = preferences[key].join(" ");
            prefer.values.push(key + "=\"" + strPreferences + "\"");
        }
        return requestOptions;
    };
    RequestUtils.setSlug = function (slug, requestOptions) {
        RequestUtils.__addHeaderValue("slug", slug, requestOptions);
        return requestOptions;
    };
    RequestUtils.isOptions = function (value) {
        return hasPropertyDefined(value, "headers")
            || hasPropertyDefined(value, "sendCredentialsOnCORS")
            || hasPropertyDefined(value, "timeout")
            || hasPropertyDefined(value, "request");
    };
    RequestUtils.cloneOptions = function (options) {
        var clone = tslib_1.__assign({}, options, { headers: new Map() });
        if (options.headers)
            options.headers
                .forEach(function (value, key) { return clone.headers.set(key, new Header(value.values.slice())); });
        return clone;
    };
    RequestUtils.__addHeaderValue = function (headerName, headerValue, requestOptions) {
        var header = RequestUtils.getHeader(headerName, requestOptions, true);
        header.addValue(headerValue);
    };
    return RequestUtils;
}());
export { RequestUtils };

//# sourceMappingURL=Request.js.map
