import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { JSONLDConverter } from "../JSONLD/JSONLDConverter";
import { ModelSchema } from "../Model/ModelSchema";
import { DigestedObjectSchema } from "../ObjectSchema/DigestedObjectSchema";
import { ObjectSchemaDigester } from "../ObjectSchema/ObjectSchemaDigester";
import { URI } from "../RDF/URI";
import { isString } from "../Utils";
var AbstractContext = (function () {
    function AbstractContext(parentContext) {
        this._parentContext = parentContext;
        this._typeObjectSchemaMap = new Map();
        this.jsonldConverter = new JSONLDConverter(parentContext && parentContext.jsonldConverter.literalSerializers);
    }
    Object.defineProperty(AbstractContext.prototype, "baseURI", {
        get: function () { return this._baseURI; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractContext.prototype, "parentContext", {
        get: function () { return this._parentContext; },
        enumerable: true,
        configurable: true
    });
    AbstractContext.prototype.resolve = function (relativeURI) {
        return URI.resolve(this.baseURI, relativeURI);
    };
    AbstractContext.prototype.hasObjectSchema = function (type) {
        type = this.__resolveTypeURI(type);
        if (this._typeObjectSchemaMap.has(type))
            return true;
        return !!this.parentContext && this.parentContext.hasObjectSchema(type);
    };
    AbstractContext.prototype.getObjectSchema = function (type) {
        if (!!type) {
            type = this.__resolveTypeURI(type);
            if (this._typeObjectSchemaMap.has(type))
                return this._typeObjectSchemaMap.get(type);
            if (this.parentContext && this.parentContext.hasObjectSchema(type))
                return this.parentContext.getObjectSchema(type);
            throw new IllegalArgumentError("\"" + type + "\" hasn't an object schema.");
        }
        else {
            var generalSchema = !this._generalObjectSchema ?
                this.parentContext ?
                    this.parentContext.getObjectSchema() :
                    new DigestedObjectSchema() :
                ObjectSchemaDigester
                    .combineDigestedObjectSchemas([this._generalObjectSchema]);
            if (generalSchema.vocab === void 0 && this._settings && this._settings.vocabulary)
                generalSchema.vocab = this.resolve(this._settings.vocabulary);
            if (!generalSchema.base)
                generalSchema.base = this.baseURI;
            return generalSchema;
        }
    };
    AbstractContext.prototype.extendObjectSchema = function (objectSchemaOrTypeOrModelSchema, objectSchema) {
        if (isString(objectSchemaOrTypeOrModelSchema)) {
            if (!objectSchema)
                throw new IllegalArgumentError("An object schema is required.");
            return this.__extendTypeSchema(objectSchema, objectSchemaOrTypeOrModelSchema);
        }
        if (ModelSchema.is(objectSchemaOrTypeOrModelSchema))
            return this.__extendTypeSchema(objectSchemaOrTypeOrModelSchema.SCHEMA, objectSchemaOrTypeOrModelSchema.TYPE);
        if (Array.isArray(objectSchemaOrTypeOrModelSchema)) {
            objectSchemaOrTypeOrModelSchema.forEach(this.extendObjectSchema, this);
            return this;
        }
        return this.__extendGeneralSchema(objectSchemaOrTypeOrModelSchema);
    };
    AbstractContext.prototype.clearObjectSchema = function (type) {
        if (type === void 0) {
            this._generalObjectSchema = this.parentContext ? undefined : new DigestedObjectSchema();
        }
        else {
            type = this.__resolveTypeURI(type);
            this._typeObjectSchemaMap.delete(type);
        }
    };
    AbstractContext.prototype._getTypeObjectSchemas = function (excepts) {
        if (excepts === void 0) { excepts = []; }
        var exceptsSet = new Set(excepts);
        var types = this
            .__getObjectSchemasTypes()
            .filter(function (type) { return !exceptsSet.has(type); });
        return types.map(this.getObjectSchema, this);
    };
    AbstractContext.prototype.__getObjectSchemasTypes = function () {
        var localTypes = [];
        this._typeObjectSchemaMap
            .forEach(function (_, key) { return localTypes.push(key); });
        if (!this._parentContext)
            return localTypes;
        var allTypes = this._parentContext.__getObjectSchemasTypes();
        for (var _i = 0, localTypes_1 = localTypes; _i < localTypes_1.length; _i++) {
            var type = localTypes_1[_i];
            if (allTypes.indexOf(type) !== -1)
                continue;
            allTypes.push(type);
        }
        return allTypes;
    };
    AbstractContext.prototype.__extendGeneralSchema = function (objectSchema) {
        var digestedSchemaToExtend = this.__getInheritGeneralSchema();
        this._generalObjectSchema = ObjectSchemaDigester._combineSchemas([
            digestedSchemaToExtend,
            ObjectSchemaDigester.digestSchema(objectSchema),
        ]);
        return this;
    };
    AbstractContext.prototype.__extendTypeSchema = function (objectSchema, type) {
        type = this.__resolveTypeURI(type);
        var digestedSchemaToExtend = this.__getInheritTypeSchema(type);
        var extendedDigestedSchema = ObjectSchemaDigester
            .combineDigestedObjectSchemas([
            digestedSchemaToExtend,
            ObjectSchemaDigester.digestSchema(objectSchema),
        ]);
        this._typeObjectSchemaMap
            .set(type, extendedDigestedSchema);
        return this;
    };
    AbstractContext.prototype.__getInheritGeneralSchema = function () {
        if (this._generalObjectSchema)
            return this._generalObjectSchema;
        if (this.parentContext)
            return this.parentContext.getObjectSchema();
        return new DigestedObjectSchema();
    };
    AbstractContext.prototype.__getInheritTypeSchema = function (type) {
        if (this._typeObjectSchemaMap.has(type))
            return this._typeObjectSchemaMap.get(type);
        if (this.parentContext && this.parentContext.hasObjectSchema(type))
            return this.parentContext.getObjectSchema(type);
        return new DigestedObjectSchema();
    };
    AbstractContext.prototype.__resolveTypeURI = function (uri) {
        return this.getObjectSchema()
            .resolveURI(uri, { vocab: true });
    };
    return AbstractContext;
}());
export { AbstractContext };

//# sourceMappingURL=AbstractContext.js.map
