{"version":3,"sources":["RDF/Node.ts"],"names":[],"mappings":"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","file":"Node.js","sourcesContent":["import * as Utils from \"../Utils\";\nimport { XSD } from \"../Vocabularies/XSD\";\n\nimport { RDFList } from \"./List\";\nimport { RDFLiteral } from \"./Literal\";\nimport { URI } from \"./URI\";\nimport { RDFValue } from \"./Value\";\n\n\n/**\n * Type for any possible value an {@link RDFNode} can have.\n */\nexport type RDFNodePropertyValue = string | RDFNode | RDFList | RDFValue | RDFLiteral;\n\n/**\n * Model represents an RDF Node.\n */\nexport type RDFNode = {\n\t/**\n\t * The ID URI of the current node.\n\t */\n\t\"@id\":string;\n\t\"@type\"?:string[];\n\n\t[ propertyURI:string ]:string | RDFNodePropertyValue[] | undefined;\n};\n\n\n/**\n * Factory and utils for {@link RDFNode}.\n */\nexport interface RDFNodeFactory {\n\t/**\n\t * Returns true if the object provided is considered a {@link RDFNode} object.\n\t * @param value\n\t */\n\tis( value:any ):value is RDFNode;\n\n\t/**\n\t * Creates a {@link RDFNode} object with the URI provided.\n\t * @param uri\n\t */\n\tcreate( uri:string ):RDFNode;\n\n\n\t/**\n\t * Returns the `@id` of the node.\n\t * @param node\n\t */\n\tgetID( node:RDFNode ):string;\n\n\t/**\n\t * Returns the relative `@id` of the node when it is a fragment node.\n\t * @param node\n\t */\n\tgetRelativeID( node:RDFNode ):string;\n\n\t/**\n\t * Returns true if the objects represent the same resource.\n\t * @param node1\n\t * @param node2\n\t */\n\tareEqual( node1:RDFNode, node2:RDFNode ):boolean;\n\n\t/**\n\t * Returns true if the node has a fragment `@id`, i.e. a named fragment or a blank node label.\n\t * @param node\n\t */\n\tisFragment( node:RDFNode ):boolean;\n\n\t/**\n\t * Returns true if the {@link RDFNode} provided has the specified type.\n\t * @param node The node to evaluate.\n\t * @param type The type to look for it existence.\n\t */\n\thasType( node:RDFNode, type:string ):boolean;\n\n\t/**\n\t * Returns an array with the types of the {@link RDFNode} provided.\n\t * @param node The node to evaluate.\n\t */\n\tgetTypes( node:RDFNode ):string[];\n\n\t/**\n\t * Returns the {@link RDFList} object from the provided property of an expanded JSON-LD object.\n\t * Returns `undefined` if no {@link RDFList} object is found.\n\t * @param propertyValues\n\t */\n\tgetList( propertyValues:RDFNodePropertyValue[] ):RDFList | undefined;\n\n\t/**\n\t * Returns the property array with the parsed {@link RDFLiteral}s.\n\t * Returns `undefined` if it cannot be parsed.\n\t * @param propertyValues\n\t * @param literalType\n\t */\n\tgetPropertyLiterals( propertyValues:RDFNodePropertyValue[], literalType:string ):any[] | undefined;\n\n\t/**\n\t * Returns an object associating the language with the parsed string literal.\n\t * Returns an empty object if it is not a property with language.\n\t * @param propertyValues\n\t */\n\tgetPropertyLanguageMap( propertyValues:RDFNodePropertyValue[] ):object | undefined;\n}\n\n/**\n * Constant that implements {@link RDFNodeFactory}.\n */\nexport const RDFNode:RDFNodeFactory = {\n\tis( value:any ):value is RDFNode {\n\t\treturn Utils.hasProperty( value, \"@id\" )\n\t\t\t&& Utils.isString( value[ \"@id\" ] );\n\t},\n\n\tcreate( uri:string ):RDFNode {\n\t\treturn {\n\t\t\t\"@id\": uri,\n\t\t};\n\t},\n\n\n\tgetID( node:RDFNode ):string {\n\t\treturn node[ \"@id\" ];\n\t},\n\n\tgetRelativeID( node:RDFNode ):string {\n\t\tconst id:string = RDFNode.getID( node );\n\t\treturn URI.hasFragment( id ) ? URI.getFragment( id ) : id;\n\t},\n\n\tareEqual( node1:RDFNode, node2:RDFNode ):boolean {\n\t\treturn RDFNode.getID( node1 ) === RDFNode.getID( node2 );\n\t},\n\n\tisFragment( node:RDFNode ):boolean {\n\t\tconst id:string = RDFNode.getID( node );\n\t\treturn URI.hasFragment( id ) || URI.isBNodeID( id );\n\t},\n\n\thasType( node:RDFNode, type:string ):boolean {\n\t\treturn RDFNode.getTypes( node ).indexOf( type ) !== - 1;\n\t},\n\n\tgetTypes( node:RDFNode ):string[] {\n\t\tif( ! (\"@type\" in node) ) return [];\n\t\treturn node[ \"@type\" ]!;\n\t},\n\n\tgetList( propertyValues:RDFNodePropertyValue[] ):RDFList | undefined {\n\t\tif( ! Array.isArray( propertyValues ) ) return;\n\n\t\treturn propertyValues\n\t\t\t.find( RDFList.is )\n\t\t\t;\n\t},\n\n\tgetPropertyLiterals( propertyValues:RDFNodePropertyValue[], literalType:string ):any[] | undefined {\n\t\tif( ! Array.isArray( propertyValues ) ) return;\n\n\t\treturn propertyValues\n\t\t\t.filter( RDFLiteral.is )\n\t\t\t.filter( literal => RDFLiteral.hasType( literal, literalType ) )\n\t\t\t.map( RDFLiteral.parse )\n\t\t\t;\n\t},\n\n\tgetPropertyLanguageMap( propertyValues:RDFNodePropertyValue[] ):object | undefined {\n\t\tif( ! Array.isArray( propertyValues ) ) return;\n\n\t\tconst propertyLanguageMap:object = {};\n\t\tfor( const propertyValue of propertyValues ) {\n\t\t\tif( ! RDFLiteral.is( propertyValue ) ) continue;\n\t\t\tif( ! RDFLiteral.hasType( propertyValue, XSD.string ) ) continue;\n\n\t\t\tconst languageTag:string | undefined = propertyValue[ \"@language\" ];\n\t\t\tif( ! languageTag ) continue;\n\n\t\t\tpropertyLanguageMap[ languageTag ] = RDFLiteral.parse( propertyValue );\n\t\t}\n\n\t\treturn propertyLanguageMap;\n\t},\n\n};\n"],"sourceRoot":"../../src"}