import { JSONLDConverter } from "../JSONLD/JSONLDConverter";
import { ModelDecorator } from "../Model/ModelDecorator";
import { DigestedObjectSchema } from "../ObjectSchema/DigestedObjectSchema";
import { Pointer } from "../Pointer/Pointer";
import { URI } from "../RDF/URI";
import { RegisteredPointer } from "../Registry/RegisteredPointer";
import { isObject } from "../Utils";
function __getContext(registry) {
    if (!registry)
        return;
    if ("context" in registry && registry.context)
        return registry.context;
    return __getContext("$id" in registry ? registry.$registry : registry.registry);
}
function __resolveURI(resource, uri) {
    if (URI.isAbsolute(uri))
        return uri;
    const context = __getContext(resource.$registry);
    if (!context)
        return uri;
    return context
        .getObjectSchema()
        .resolveURI(uri, { vocab: true });
}
export const Resource = {
    PROTOTYPE: {
        get types() { return []; },
        get $slug() {
            if (URI.isBNodeID(this.$id))
                return this.$id;
            return URI.getSlug(this.$id);
        },
        set $slug(slug) { },
        $addType(type) {
            type = __resolveURI(this, type);
            if (this.types.indexOf(type) !== -1)
                return;
            this.types.push(type);
        },
        $hasType(type) {
            type = __resolveURI(this, type);
            return this.types.indexOf(type) !== -1;
        },
        $removeType(type) {
            type = __resolveURI(this, type);
            const index = this.types.indexOf(type);
            if (index !== -1)
                this.types.splice(index, 1);
        },
        toJSON(contextOrKey) {
            const context = typeof contextOrKey === "object" ?
                contextOrKey : __getContext(this.$registry);
            const generalSchema = context ?
                context.registry.getGeneralSchema() : new DigestedObjectSchema();
            const resourceSchema = context && context.registry ?
                context.registry.getSchemaFor(this) : generalSchema;
            const jsonldConverter = context ?
                context.jsonldConverter : new JSONLDConverter();
            return jsonldConverter.expand(this, generalSchema, resourceSchema);
        },
    },
    isDecorated(object) {
        return isObject(object)
            && ModelDecorator
                .hasPropertiesFrom(Resource.PROTOTYPE, object);
    },
    is(value) {
        return Pointer.is(value)
            && Resource.isDecorated(value);
    },
    create(data) {
        const clone = Object.assign({}, data);
        return Resource.createFrom(clone);
    },
    createFrom(object) {
        return Resource.decorate(object);
    },
    decorate(object) {
        if (Resource.isDecorated(object))
            return object;
        if (!object.hasOwnProperty("$registry"))
            object.$registry = void 0;
        const resource = ModelDecorator
            .decorateMultiple(object, RegisteredPointer);
        return ModelDecorator
            .definePropertiesFrom(Resource.PROTOTYPE, resource);
    },
};

//# sourceMappingURL=Resource.js.map
