import { IllegalArgumentError } from "../../../Errors/IllegalArgumentError";
import * as Utils from "./../../../Utils";
function pad(value) {
    let paddedValue = String(value);
    if (paddedValue.length === 1)
        paddedValue = "0" + paddedValue;
    return paddedValue;
}
const notNumberError = "The value is not a number.";
export class DateSerializer {
    serialize(value) {
        if (!Utils.isDate(value))
            throw new IllegalArgumentError("The value is not a Date object.");
        return value.getUTCFullYear() + "-" + pad((value.getUTCMonth() + 1)) + "-" + pad(value.getUTCDate());
    }
}
export let dateSerializer = new DateSerializer();
export class DateTimeSerializer {
    serialize(value) {
        if (!Utils.isDate(value))
            throw new IllegalArgumentError("The value is not a Date object.");
        return value.toISOString();
    }
}
export let dateTimeSerializer = new DateTimeSerializer();
export class TimeSerializer {
    serialize(value) {
        if (!Utils.isDate(value))
            throw new IllegalArgumentError("The value is not a Date object.");
        return pad(value.getUTCHours())
            + ":" + pad(value.getUTCMinutes())
            + ":" + pad(value.getUTCSeconds())
            + "." + String((value.getUTCMilliseconds() / 1000).toFixed(3)).slice(2, 5)
            + "Z";
    }
}
export let timeSerializer = new TimeSerializer();
export class IntegerSerializer {
    serialize(value) {
        if (!Utils.isNumber(value))
            throw new IllegalArgumentError(notNumberError);
        return (~~value).toString();
    }
}
export let integerSerializer = new IntegerSerializer();
export class LongSerializer {
    serialize(value) {
        if (!Utils.isNumber(value))
            throw new IllegalArgumentError(notNumberError);
        if (value === Number.POSITIVE_INFINITY)
            return "0";
        if (value === Number.NEGATIVE_INFINITY)
            return "0";
        if (Number.isNaN(value))
            return "0";
        return Math.trunc(value).toString();
    }
}
export const longSerializer = new LongSerializer();
export class UnsignedIntegerSerializer extends IntegerSerializer {
    serialize(value) {
        let stringValue = super.serialize(value);
        stringValue = Utils.StringUtils.startsWith(stringValue, "-") ? stringValue.substring(1) : stringValue;
        return stringValue;
    }
}
export let unsignedIntegerSerializer = new UnsignedIntegerSerializer();
export class UnsignedLongSerializer {
    serialize(value) {
        if (!Utils.isNumber(value))
            throw new IllegalArgumentError(notNumberError);
        if (value === Number.POSITIVE_INFINITY)
            return "0";
        if (value === Number.NEGATIVE_INFINITY)
            return "0";
        if (Number.isNaN(value))
            return "0";
        return Math.trunc(Math.abs(value)).toString();
    }
}
export const unsignedLongSerializer = new UnsignedLongSerializer();
export class FloatSerializer {
    serialize(value) {
        if (value === Number.POSITIVE_INFINITY)
            return "INF";
        if (value === Number.NEGATIVE_INFINITY)
            return "-INF";
        if (!Utils.isNumber(value))
            throw new IllegalArgumentError(notNumberError);
        return value.toString();
    }
}
export let floatSerializer = new FloatSerializer();
export class BooleanSerializer {
    serialize(value) {
        return (!!value).toString();
    }
}
export let booleanSerializer = new BooleanSerializer();
export class StringSerializer {
    serialize(value) {
        return String(value);
    }
}
export let stringSerializer = new StringSerializer();

//# sourceMappingURL=XSD.js.map
