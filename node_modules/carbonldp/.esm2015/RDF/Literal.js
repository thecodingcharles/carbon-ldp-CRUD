import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import * as Utils from "../Utils";
import { XSD } from "../Vocabularies/XSD";
import * as Serializers from "./Literal/Serializers";
export { Serializers };
export const RDFLiteral = {
    from(value) {
        if (Utils.isNull(value))
            throw new IllegalArgumentError("Null cannot be converted into a Literal");
        if (!Utils.isDefined(value))
            throw new IllegalArgumentError("The value is undefined");
        let type;
        switch (true) {
            case Utils.isDate(value):
                type = XSD.dateTime;
                value = value.toISOString();
                break;
            case Utils.isNumber(value):
                if (Utils.isInteger(value)) {
                    type = XSD.integer;
                }
                else {
                    type = XSD.double;
                }
                break;
            case Utils.isString(value):
                type = XSD.string;
                break;
            case Utils.isBoolean(value):
                type = XSD.boolean;
                break;
            default:
                type = XSD.object;
                value = JSON.stringify(value);
                break;
        }
        let literal = { "@value": value.toString() };
        if (type)
            literal["@type"] = type;
        return literal;
    },
    parse(valueOrLiteral, type) {
        let literalValue;
        if (Utils.isString(valueOrLiteral)) {
            literalValue = valueOrLiteral;
        }
        else {
            let literal = valueOrLiteral;
            if (!literal)
                return null;
            if (!Utils.hasProperty(literal, "@value"))
                return null;
            type = "@type" in literal ? literal["@type"] : null;
            literalValue = literal["@value"];
        }
        let value = literalValue;
        switch (type) {
            case XSD.date:
            case XSD.dateTime:
                value = new Date(literalValue);
                break;
            case XSD.time:
                const parts = literalValue.match(/(\d+):(\d+):(\d+)\.(\d+)Z/);
                if (!parts)
                    throw new IllegalArgumentError(`Invalid value for type ${XSD.time}.`);
                value = new Date();
                value.setUTCHours(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4]));
                break;
            case XSD.duration:
                break;
            case XSD.gDay:
            case XSD.gMonth:
            case XSD.gMonthDay:
            case XSD.gYear:
            case XSD.gYearMonth:
                break;
            case XSD.byte:
            case XSD.decimal:
            case XSD.int:
            case XSD.integer:
            case XSD.long:
            case XSD.negativeInteger:
            case XSD.nonNegativeInteger:
            case XSD.nonPositiveInteger:
            case XSD.positiveInteger:
            case XSD.short:
            case XSD.unsignedLong:
            case XSD.unsignedInt:
            case XSD.unsignedShort:
            case XSD.unsignedByte:
            case XSD.double:
            case XSD.float:
                value = parseFloat(literalValue);
                break;
            case XSD.boolean:
                value = Utils.parseBoolean(literalValue);
                break;
            case XSD.string:
                value = literalValue;
                break;
            case XSD.object:
                value = JSON.parse(literalValue);
                break;
            default:
                break;
        }
        return value;
    },
    is(value) {
        return Utils.hasProperty(value, "@value")
            && Utils.isString(value["@value"]);
    },
    hasType(value, type) {
        if (!value["@type"] && type === XSD.string)
            return true;
        return value["@type"] === type;
    },
};

//# sourceMappingURL=Literal.js.map
