import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { isString, StringUtils, UUIDUtils } from "../Utils";
export const URI = {
    hasFragment(uri) {
        return uri.indexOf("#") !== -1;
    },
    hasQuery(uri) {
        return uri.indexOf("?") !== -1;
    },
    hasProtocol(uri) {
        return StringUtils.startsWith(uri, "https://") || StringUtils.startsWith(uri, "http://");
    },
    isAbsolute(uri) {
        return StringUtils.startsWith(uri, "http://")
            || StringUtils.startsWith(uri, "https://")
            || StringUtils.startsWith(uri, "://");
    },
    isRelative(uri) {
        return !URI.isAbsolute(uri);
    },
    isBNodeID(uri) {
        return StringUtils.startsWith(uri, "_:");
    },
    generateBNodeID() {
        return "_:" + UUIDUtils.generate();
    },
    isPrefixed(uri) {
        return !URI.isAbsolute(uri) && !URI.isBNodeID(uri) && StringUtils.contains(uri, ":");
    },
    isFragmentOf(fragmentURI, uri) {
        if (!URI.hasFragment(fragmentURI))
            return false;
        const documentURI = URI.getDocumentURI(fragmentURI);
        return documentURI === "" || documentURI === uri;
    },
    isBaseOf(baseURI, uri) {
        if (baseURI === uri)
            return true;
        if (baseURI === "")
            return true;
        if (URI.isRelative(uri) && !URI.isPrefixed(uri))
            return true;
        if (uri.startsWith(baseURI)) {
            if (StringUtils.endsWith(baseURI, "/") || StringUtils.endsWith(baseURI, "#"))
                return true;
            let relativeURI = uri.substring(baseURI.length);
            if (StringUtils.startsWith(relativeURI, "/") || StringUtils.startsWith(relativeURI, "#"))
                return true;
        }
        return false;
    },
    getRelativeURI(absoluteURI, base) {
        if (!absoluteURI.startsWith(base))
            return absoluteURI;
        return absoluteURI.substring(base.length);
    },
    getDocumentURI(uri) {
        let parts = uri.split("#");
        if (parts.length > 2)
            throw new IllegalArgumentError("The URI provided has more than one # sign.");
        return parts[0];
    },
    getFragment(uri) {
        let parts = uri.split("#");
        if (parts.length < 2)
            throw new IllegalArgumentError("The URI provided hasn't a # sign.");
        if (parts.length > 2)
            throw new IllegalArgumentError("The URI provided has more than one # sign.");
        return parts[1];
    },
    getSlug(uri) {
        let uriParts = uri.split("#");
        if (uriParts.length === 2)
            return URI.getSlug(uriParts[1]);
        if (uriParts.length > 2)
            throw new IllegalArgumentError("Invalid URI: The uri contains two '#' symbols.");
        uri = uriParts[0];
        if (uri === "")
            return uri;
        if (uri === "/")
            return "";
        let parts = uri.split("/");
        if (parts[parts.length - 1] === "") {
            return parts[parts.length - 2];
        }
        else {
            return parts[parts.length - 1];
        }
    },
    getParameters(uri) {
        const parameters = new Map();
        if (!URI.hasQuery(uri))
            return parameters;
        uri.replace(/^.*\?/, "").split("&").forEach((param) => {
            const parts = param
                .replace(/\+/g, " ")
                .split("=");
            const key = parts.shift();
            const val = parts.length > 0 ? parts.join("=") : "";
            if (!parameters.has(key)) {
                parameters.set(key, val);
            }
            else {
                parameters.set(key, new Array().concat(parameters.get(key), val));
            }
        });
        return parameters;
    },
    resolve(parentURI, childURI) {
        if (!parentURI || URI.isAbsolute(childURI) || URI.isBNodeID(childURI) || URI.isPrefixed(childURI))
            return childURI;
        let protocol = parentURI.substr(0, parentURI.indexOf("://") + 3);
        let path = parentURI.substr(parentURI.indexOf("://") + 3, parentURI.length - 1);
        if (path.lastIndexOf("/") === -1)
            path += "/";
        if (StringUtils.startsWith(childURI, "?") || StringUtils.startsWith(childURI, "#")) {
            if (URI.hasQuery(path))
                path = path.substr(0, path.indexOf("?"));
            if (URI.hasFragment(path) && (!StringUtils.startsWith(childURI, "?") || StringUtils.endsWith(path, "#")))
                path = URI.getDocumentURI(path);
        }
        else {
            path = path.substr(0, path.lastIndexOf("/") + 1);
            if (!StringUtils.endsWith(path, "?") && !StringUtils.endsWith(path, "#") && !StringUtils.endsWith(path, "/"))
                path += "/";
        }
        if (StringUtils.startsWith(childURI, "/")) {
            childURI = childURI.substr(1, childURI.length);
        }
        return protocol + path + childURI;
    },
    removeProtocol(uri) {
        if (!URI.hasProtocol(uri))
            return uri;
        return uri.substring(uri.indexOf("://") + 3);
    },
    prefix(uri, prefixOrObjectSchema, prefixURI) {
        if (!isString(prefixOrObjectSchema))
            return prefixWithObjectSchema(uri, prefixOrObjectSchema);
        const prefix = prefixOrObjectSchema;
        if (URI.isPrefixed(uri) || !uri.startsWith(prefixURI))
            return uri;
        return `${prefix}:${uri.substring(prefixURI.length)}`;
    },
};
function prefixWithObjectSchema(uri, objectSchema) {
    const prefixEntries = objectSchema.prefixes.entries();
    while (true) {
        const result = prefixEntries.next();
        if (result.done)
            return uri;
        let [prefix, prefixURI] = result.value;
        if (!URI.isAbsolute(prefixURI))
            continue;
        if (!uri.startsWith(prefixURI))
            continue;
        return URI.prefix(uri, prefix, prefixURI);
    }
}

//# sourceMappingURL=URI.js.map
