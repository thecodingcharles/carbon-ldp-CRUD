{"version":3,"sources":["RDF/Literal.ts"],"names":[],"mappings":"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","file":"Literal.js","sourcesContent":["import { IllegalArgumentError } from \"../Errors/IllegalArgumentError\";\n\nimport * as Utils from \"../Utils\";\n\nimport { XSD } from \"../Vocabularies/XSD\";\n\nimport * as Serializers from \"./Literal/Serializers\";\n\n\nexport * from \"./Literal/Serializer\";\nexport { Serializers };\n\n\n/**\n * Interface that represents an RDF Literal Value.\n */\nexport interface RDFLiteral {\n\t/**\n\t * The URI of the XSD type of the literal.\n\t */\n\t\"@type\"?:string;\n\t/**\n\t * The actual string value if the literal.\n\t */\n\t\"@value\":string;\n\t/**\n\t * The specific language of the string value.\n\t */\n\t\"@language\"?:string;\n}\n\n\n/**\n * Factory and utils for {@link RDFLiteral}.\n */\nexport interface RDFLiteralFactory {\n\t/**\n\t * Convert the value provided to a {@link RDFLiteral} object.\n\t * @param value\n\t */\n\tfrom( value:any ):RDFLiteral;\n\n\n\t/**\n\t * Parses the value string into the respective type specified.\n\t * If no type provided, the same string will be returned.\n\t * @param value\n\t * @param type\n\t */\n\tparse( value:string, type?:string ):any;\n\t/**\n\t * Parses the {@link RDFLiteral} object to the respective JavaScript type.\n\t * Returns `null` if the Literal can't be parsed.\n\t * @param literal\n\t */\n\tparse( literal:RDFLiteral ):any;\n\n\n\t/**\n\t * Returns true if the object provided is considered a {@link RDFLiteral} object.\n\t * @param value\n\t */\n\tis( value:any ):value is RDFLiteral;\n\n\n\t/**\n\t * Returns true if the {@link RDFLiteral} has the type specified.\n\t * @param value\n\t * @param type\n\t */\n\thasType( value:RDFLiteral, type:string ):boolean;\n}\n\n/**\n * Constant that implements {@link RDFLiteralFactory}.\n */\nexport const RDFLiteral:RDFLiteralFactory = {\n\tfrom( value:any ):RDFLiteral {\n\t\tif( Utils.isNull( value ) )\n\t\t\tthrow new IllegalArgumentError( \"Null cannot be converted into a Literal\" );\n\t\tif( ! Utils.isDefined( value ) )\n\t\t\tthrow new IllegalArgumentError( \"The value is undefined\" );\n\n\t\tlet type:any;\n\n\t\tswitch( true ) {\n\t\t\tcase Utils.isDate( value ):\n\t\t\t\ttype = XSD.dateTime;\n\t\t\t\tvalue = value.toISOString();\n\t\t\t\tbreak;\n\t\t\tcase Utils.isNumber( value ):\n\t\t\t\tif( Utils.isInteger( value ) ) {\n\t\t\t\t\ttype = XSD.integer;\n\t\t\t\t} else {\n\t\t\t\t\ttype = XSD.double;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Utils.isString( value ):\n\t\t\t\ttype = XSD.string;\n\t\t\t\tbreak;\n\t\t\tcase Utils.isBoolean( value ):\n\t\t\t\ttype = XSD.boolean;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Treat it as an unknown object\n\t\t\t\ttype = XSD.object;\n\t\t\t\tvalue = JSON.stringify( value );\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet literal:RDFLiteral = { \"@value\": value.toString() };\n\t\tif( type ) literal[ \"@type\" ] = type;\n\n\t\treturn literal;\n\t},\n\n\tparse( valueOrLiteral:string | RDFLiteral, type?:string | null ):any | null {\n\t\tlet literalValue:string;\n\t\tif( Utils.isString( valueOrLiteral ) ) {\n\t\t\tliteralValue = valueOrLiteral;\n\t\t} else {\n\t\t\tlet literal:RDFLiteral = valueOrLiteral;\n\t\t\tif( ! literal ) return null;\n\t\t\tif( ! Utils.hasProperty( literal, \"@value\" ) ) return null;\n\n\t\t\ttype = \"@type\" in literal ? literal[ \"@type\" ] : null;\n\t\t\tliteralValue = literal[ \"@value\" ];\n\t\t}\n\n\t\tlet value:any = literalValue;\n\t\tswitch( type ) {\n\t\t\t// Dates\n\t\t\tcase XSD.date:\n\t\t\tcase XSD.dateTime:\n\t\t\t\tvalue = new Date( literalValue );\n\t\t\t\tbreak;\n\t\t\tcase XSD.time:\n\t\t\t\tconst parts:string[] | null = literalValue.match( /(\\d+):(\\d+):(\\d+)\\.(\\d+)Z/ );\n\t\t\t\tif( ! parts ) throw new IllegalArgumentError( `Invalid value for type ${ XSD.time }.` );\n\t\t\t\tvalue = new Date();\n\t\t\t\tvalue.setUTCHours( parseFloat( parts[ 1 ] ), parseFloat( parts[ 2 ] ), parseFloat( parts[ 3 ] ), parseFloat( parts[ 4 ] ) );\n\t\t\t\tbreak;\n\t\t\tcase XSD.duration:\n\t\t\t\t// TODO: Support duration values (create a class or something...)\n\t\t\t\tbreak;\n\t\t\tcase XSD.gDay:\n\t\t\tcase XSD.gMonth:\n\t\t\tcase XSD.gMonthDay:\n\t\t\tcase XSD.gYear:\n\t\t\tcase XSD.gYearMonth:\n\t\t\t\t// TODO: Decide. Should we return it as a Date?\n\t\t\t\tbreak;\n\n\t\t\t// Numbers\n\t\t\tcase XSD.byte :\n\t\t\tcase XSD.decimal :\n\t\t\tcase XSD.int :\n\t\t\tcase XSD.integer :\n\t\t\tcase XSD.long :\n\t\t\tcase XSD.negativeInteger :\n\t\t\tcase XSD.nonNegativeInteger :\n\t\t\tcase XSD.nonPositiveInteger :\n\t\t\tcase XSD.positiveInteger :\n\t\t\tcase XSD.short :\n\t\t\tcase XSD.unsignedLong :\n\t\t\tcase XSD.unsignedInt :\n\t\t\tcase XSD.unsignedShort :\n\t\t\tcase XSD.unsignedByte :\n\t\t\tcase XSD.double :\n\t\t\tcase XSD.float :\n\t\t\t\tvalue = parseFloat( literalValue );\n\t\t\t\tbreak;\n\n\t\t\t// Misc\n\t\t\tcase XSD.boolean :\n\t\t\t\tvalue = Utils.parseBoolean( literalValue );\n\t\t\t\tbreak;\n\t\t\tcase XSD.string:\n\t\t\t\tvalue = literalValue;\n\t\t\t\tbreak;\n\t\t\tcase XSD.object:\n\t\t\t\tvalue = JSON.parse( literalValue );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn value;\n\t},\n\n\tis( value:any ):value is RDFLiteral {\n\t\treturn Utils.hasProperty( value, \"@value\" )\n\t\t\t&& Utils.isString( value[ \"@value\" ] );\n\t},\n\n\thasType( value:RDFLiteral, type:string ):boolean {\n\t\tif( ! value[ \"@type\" ] && type === XSD.string ) return true;\n\t\treturn value[ \"@type\" ] === type;\n\t},\n};\n"],"sourceRoot":"../../src"}