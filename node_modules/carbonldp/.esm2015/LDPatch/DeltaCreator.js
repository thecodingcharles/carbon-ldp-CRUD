import { isBNodeLabel } from "sparqler/iri";
import { BlankNodeToken, CollectionToken, IRIRefToken, LanguageToken, LiteralToken, PrefixedNameToken, PropertyToken, RDFLiteralToken, SubjectToken, } from "sparqler/tokens";
import { _guessXSDType } from "../JSONLD/Utils";
import { ContainerType } from "../ObjectSchema/ContainerType";
import { DigestedObjectSchemaProperty } from "../ObjectSchema/DigestedObjectSchemaProperty";
import { ObjectSchemaDigester } from "../ObjectSchema/ObjectSchemaDigester";
import { PointerType } from "../ObjectSchema/PointerType";
import { Pointer } from "../Pointer/Pointer";
import { _isExistingValue, isString } from "../Utils";
import { XSD } from "../Vocabularies/XSD";
import { AddToken, DeleteToken, LDPatchToken, PrefixToken, SliceToken, UpdateListToken } from "./Tokens";
const typesDefinition = new DigestedObjectSchemaProperty();
typesDefinition.literal = false;
typesDefinition.pointerType = PointerType.ID;
typesDefinition.containerType = ContainerType.SET;
export class DeltaCreator {
    constructor(context) {
        this.prefixesMap = new Map();
        this.context = context;
        this.addToken = new AddToken();
        this.deleteToken = new DeleteToken();
        this.updateLists = [];
    }
    getPatch() {
        const patch = new LDPatchToken();
        this.prefixesMap.forEach(prefix => patch.prologues.push(prefix));
        patch.statements.push(...this.updateLists);
        if (this.addToken.triples.length)
            patch.statements.push(this.addToken);
        if (this.deleteToken.triples.length)
            patch.statements.push(this.deleteToken);
        return `${patch}`;
    }
    addResource(id, previousResource, currentResource) {
        const schema = this.__getSchema(id, previousResource, currentResource);
        const resource = isBNodeLabel(id) ?
            new BlankNodeToken(id) : this.__compactIRI(schema, id);
        const updateLists = [];
        const addTriples = new SubjectToken(resource);
        const deleteTriples = new SubjectToken(resource);
        new Set([
            "types",
            ...Object.keys(previousResource),
            ...Object.keys(currentResource),
        ]).forEach(propertyName => {
            if (propertyName === "$id")
                return;
            const predicateURI = propertyName === "types" ?
                "a" : this._getPropertyIRI(schema, propertyName);
            const definition = predicateURI === "a" ?
                typesDefinition : schema.getProperty(propertyName);
            const oldValue = previousResource[propertyName];
            const newValue = currentResource[propertyName];
            if (definition && definition.containerType === ContainerType.LIST && _isExistingValue(oldValue)) {
                const listUpdates = [];
                if (!_isExistingValue(newValue)) {
                    deleteTriples.addProperty(new PropertyToken(predicateURI).addObject(new CollectionToken()));
                    listUpdates.push({ slice: [0, void 0], objects: [] });
                }
                else {
                    definition.containerType = ContainerType.SET;
                    listUpdates.push(...__getListDelta(this.__getObjects(oldValue, schema, definition), this.__getObjects(newValue, schema, definition)));
                }
                if (!listUpdates.length)
                    return;
                this.__addPrefixFrom(predicateURI, schema);
                listUpdates.forEach(updateDelta => {
                    const collection = new CollectionToken();
                    updateDelta.objects.forEach(object => {
                        collection.addObject(object);
                        this.__addPrefixFrom(object, schema);
                    });
                    updateLists.push(new UpdateListToken(resource, predicateURI, updateDelta.objects.length ?
                        new SliceToken(updateDelta.slice[0], updateDelta.slice[0]) :
                        new SliceToken(...updateDelta.slice), collection));
                });
            }
            else {
                const oldObjects = this.__getObjects(oldValue, schema, definition);
                const newObjects = this.__getObjects(newValue, schema, definition);
                const setDelta = __getArrayDelta(oldObjects, newObjects);
                const addValues = (objects, triple) => {
                    if (!objects.length)
                        return;
                    const property = new PropertyToken(predicateURI);
                    objects.forEach(object => {
                        property.addObject(object);
                        this.__addPrefixFrom(object, schema);
                    });
                    triple.addProperty(property);
                };
                addValues(setDelta.toAdd, addTriples);
                addValues(setDelta.toDelete, deleteTriples);
            }
        });
        this.updateLists.push(...updateLists);
        updateLists.forEach(x => this.__addPrefixFrom(x.predicate, schema));
        if (addTriples.properties.length)
            this.addToken.triples.push(addTriples);
        addTriples.properties.forEach(x => this.__addPrefixFrom(x.verb, schema));
        if (deleteTriples.properties.length)
            this.deleteToken.triples.push(deleteTriples);
        deleteTriples.properties.forEach(x => this.__addPrefixFrom(x.verb, schema));
        this.__addPrefixFrom(resource, schema);
    }
    __getSchema($id, previousResource, currentResource) {
        const typesSet = new Set();
        if ("types" in previousResource)
            previousResource
                .types.forEach(typesSet.add, typesSet);
        if ("types" in currentResource)
            currentResource
                .types.forEach(typesSet.add, typesSet);
        const mergedResource = { $id, types: Array.from(typesSet) };
        const baseSchema = this.context.registry
            .getSchemaFor(mergedResource);
        const queryableProperty = previousResource.$_queryableMetadata || previousResource.$_queryableMetadata;
        if (!queryableProperty)
            return baseSchema;
        return ObjectSchemaDigester._combineSchemas([
            baseSchema,
            queryableProperty.getSchema(),
        ]);
    }
    _getPropertyIRI(schema, propertyName) {
        const propertyDefinition = schema.properties.get(propertyName);
        const uri = propertyDefinition && propertyDefinition.uri ?
            propertyDefinition.uri :
            propertyName;
        return this.__compactIRI(schema, uri);
    }
    __getObjects(value, schema, definition) {
        const values = (Array.isArray(value) ?
            !definition || definition.containerType !== null ? value : value.slice(0, 1) :
            [value]).filter(_isExistingValue);
        if (definition && definition.containerType === ContainerType.LIST) {
            if (!_isExistingValue(value))
                return [];
            const collection = new CollectionToken();
            collection.objects.push(...this.__expandValues(values, schema, definition));
            return [collection];
        }
        if (definition && definition.containerType === ContainerType.LANGUAGE) {
            return this.__expandLanguageMap(values, schema);
        }
        return this.__expandValues(values, schema, definition);
    }
    __expandValues(values, schema, definition) {
        const areDefinedLiteral = definition && definition.literal !== null ? definition.literal : null;
        return values
            .map(value => {
            const isLiteral = areDefinedLiteral !== null ? areDefinedLiteral : !Pointer.is(value);
            if (isLiteral)
                return this.__expandLiteral(value, schema, definition);
            return this.__expandPointer(value, schema);
        })
            .filter(_isExistingValue);
    }
    __expandLanguageMap(values, schema) {
        if (!values.length)
            return [];
        const languageMap = values[0];
        return Object
            .keys(languageMap)
            .map(key => {
            const value = languageMap[key];
            const tempDefinition = new DigestedObjectSchemaProperty();
            tempDefinition.language = key;
            tempDefinition.literalType = XSD.string;
            return this.__expandLiteral(value, schema, tempDefinition);
        })
            .filter(_isExistingValue);
    }
    __expandPointer(value, schema) {
        const id = Pointer.is(value) ? value.$id : value;
        if (!isString(id))
            return null;
        return isBNodeLabel(id) ?
            new BlankNodeToken(id) :
            this.__compactIRI(schema, id);
    }
    __expandLiteral(value, schema, definition) {
        const type = definition && definition.literalType ?
            definition.literalType :
            _guessXSDType(value);
        if (type === null || !this.context.jsonldConverter.literalSerializers.has(type))
            return null;
        value = this.context.jsonldConverter.literalSerializers.get(type).serialize(value);
        if (type !== XSD.string)
            return new RDFLiteralToken(value, this.__compactIRI(schema, type));
        if (definition && typeof definition.language === "string")
            return new RDFLiteralToken(value, new LanguageToken(definition.language));
        return new LiteralToken(value);
    }
    __compactIRI(schema, iri) {
        iri = schema.resolveURI(iri, { vocab: true });
        const matchPrefix = Array.from(schema.prefixes.entries())
            .find(([, prefixURI]) => iri.startsWith(prefixURI));
        if (!matchPrefix)
            return new IRIRefToken(iri);
        return new PrefixedNameToken(matchPrefix[0], iri.substr(matchPrefix[1].length));
    }
    __addPrefixFrom(object, schema) {
        if (object === "a")
            return;
        if ("objects" in object)
            return object.objects.forEach(collectionObject => {
                this.__addPrefixFrom(collectionObject, schema);
            });
        if ("type" in object)
            return this.__addPrefixFrom(object.type, schema);
        if (object.token !== "prefixedName")
            return;
        const namespace = object.namespace;
        if (this.prefixesMap.has(namespace))
            return;
        const iri = schema.prefixes.get(namespace);
        this.prefixesMap.set(namespace, new PrefixToken(namespace, new IRIRefToken(iri)));
    }
}
function __getArrayDelta(oldValues, newValues) {
    const objectMapper = object => [`${object}`, object];
    const toAdd = new Map(newValues.map(objectMapper));
    const toDelete = new Map(oldValues.map(objectMapper));
    toAdd.forEach((value, identifier) => {
        if (!toDelete.has(identifier))
            return;
        toDelete.delete(identifier);
        toAdd.delete(identifier);
    });
    return {
        toAdd: Array.from(toAdd.values()),
        toDelete: Array.from(toDelete.values()),
    };
}
function __getListDelta(oldValues, newValues) {
    const nodeMapper = (object, index) => ({
        identifier: `${object}`,
        object,
        index,
    });
    const oldPositions = oldValues.map(nodeMapper);
    const newPositions = newValues.map(nodeMapper);
    const addsSet = new Set(newPositions);
    const deletes = [];
    let offset = 0;
    let remnants = newPositions;
    oldPositions.forEach(oldNode => {
        const currentIndex = remnants.findIndex(newNode => newNode.identifier === oldNode.identifier);
        if (currentIndex === -1) {
            oldNode.index -= offset++;
            deletes.push(oldNode);
        }
        else {
            addsSet.delete(remnants[currentIndex]);
            remnants = remnants.slice(currentIndex + 1);
        }
    });
    const updates = [];
    let last;
    deletes.forEach(node => {
        if (last && last.slice[0] === node.index) {
            last.slice = [last.slice[0], last.slice[1] + 1];
            return;
        }
        updates.push(last = {
            slice: [node.index, node.index + 1],
            objects: [],
        });
    });
    last = void 0;
    addsSet.forEach(node => {
        if (last && last.slice[1] === node.index) {
            last.slice = [last.slice[0], node.index + 1];
            last.objects.push(node.object);
            return;
        }
        updates.push(last = {
            slice: [node.index, node.index + 1],
            objects: [node.object],
        });
    });
    return updates;
}

//# sourceMappingURL=DeltaCreator.js.map
