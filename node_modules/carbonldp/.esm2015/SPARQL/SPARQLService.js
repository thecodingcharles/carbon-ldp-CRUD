import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { NotImplementedError } from "../Errors/NotImplementedError";
import { RequestService, RequestUtils } from "../HTTP/Request";
import { StringParser } from "../HTTP/StringParser";
import { _getPointer } from "../Pointer/PointerLibrary";
import { RDFLiteral } from "../RDF/Literal";
import { SPARQLRawResultsParser } from "./RawResultsParser";
export class SPARQLService {
    static executeRawASKQuery(url, askQuery, options = {}) {
        options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
        RequestUtils.setAcceptHeader("application/sparql-results+json", options);
        RequestUtils.setContentTypeHeader("application/sparql-query", options);
        return RequestService.post(url, askQuery, options, SPARQLService.RESULTS_PARSER);
    }
    static executeASKQuery(url, askQuery, options = {}) {
        return SPARQLService
            .executeRawASKQuery(url, askQuery, options)
            .then(([rawResults, response]) => {
            return [rawResults.boolean, response];
        });
    }
    static executeRawSELECTQuery(url, selectQuery, options = {}) {
        options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
        RequestUtils.setAcceptHeader("application/sparql-results+json", options);
        RequestUtils.setContentTypeHeader("application/sparql-query", options);
        return RequestService.post(url, selectQuery, options, SPARQLService.RESULTS_PARSER);
    }
    static executeSELECTQuery(url, selectQuery, pointerLibrary, options = {}) {
        return SPARQLService
            .executeRawSELECTQuery(url, selectQuery, options)
            .then(([rawResults, response]) => {
            let rawBindings = rawResults.results.bindings;
            let bindings = [];
            for (let bindingColumn of rawBindings) {
                let binding = {};
                for (let bindingRow in bindingColumn) {
                    let bindingCell = bindingColumn[bindingRow];
                    binding[bindingRow] = SPARQLService.__parseRawBindingProperty(bindingCell, pointerLibrary);
                }
                bindings.push(binding);
            }
            const results = {
                vars: rawResults.head.vars,
                bindings: bindings,
            };
            return [results, response];
        });
    }
    static executeRawCONSTRUCTQuery(url, constructQuery, options = {}) {
        options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
        RequestUtils.setAcceptHeader("application/ld+json", options);
        RequestUtils.setContentTypeHeader("application/sparql-query", options);
        return RequestService.post(url, constructQuery, options, SPARQLService.STRING_PARSER);
    }
    static executeRawDESCRIBEQuery(url, describeQuery, options = {}) {
        options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
        RequestUtils.setAcceptHeader("application/ld+json", options);
        RequestUtils.setContentTypeHeader("application/sparql-query", options);
        return RequestService.post(url, describeQuery, options, SPARQLService.STRING_PARSER);
    }
    static executeUPDATE(url, updateQuery, options = {}) {
        options = Object.assign(options, SPARQLService.DEFAULT_OPTIONS);
        RequestUtils.setAcceptHeader("application/ld+json", options);
        RequestUtils.setContentTypeHeader("application/sparql-update", options);
        return RequestService.post(url, updateQuery, options);
    }
    static __parseRawBindingProperty(rawBindingProperty, pointerLibrary) {
        switch (rawBindingProperty.type) {
            case "uri":
                return _getPointer(pointerLibrary, rawBindingProperty.value);
            case "bnode":
                throw new NotImplementedError("BNodes cannot be queried directly");
            case "literal":
                if ("datatype" in rawBindingProperty) {
                    return RDFLiteral.parse(rawBindingProperty.value, rawBindingProperty.datatype);
                }
                else {
                    return RDFLiteral.parse(rawBindingProperty.value);
                }
            default:
                throw new IllegalArgumentError("The bindingProperty has an unsupported type");
        }
    }
}
SPARQLService.DEFAULT_OPTIONS = {};
SPARQLService.RESULTS_PARSER = new SPARQLRawResultsParser();
SPARQLService.STRING_PARSER = new StringParser();

//# sourceMappingURL=SPARQLService.js.map
