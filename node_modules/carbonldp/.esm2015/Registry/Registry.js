import { IDAlreadyInUseError } from "../Errors/IDAlreadyInUseError";
import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { BiModelDecorator } from "../Model/BiModelDecorator";
import { Pointer } from "../Pointer/Pointer";
function __getResourcesMaps(registry) {
    return "$id" in registry ? registry.$__resourcesMap : registry.__resourcesMap;
}
function __getParentResource(registry) {
    return "$id" in registry ? registry.$registry : registry.registry;
}
function __getDecorator(registry) {
    return "$id" in registry ?
        registry.$__modelDecorator : registry.__modelDecorator;
}
function __getLocalID(registry, id) {
    return "$id" in registry ?
        registry.$_getLocalID(id) : registry._getLocalID(id);
}
function __addPointer(registry, pointer) {
    return "$id" in registry ?
        registry.$_addPointer(pointer) : registry._addPointer(pointer);
}
function __inScope(idOrPointer, local) {
    if (!this)
        return false;
    try {
        const id = Pointer.getID(idOrPointer);
        __getLocalID(this, id);
        return true;
    }
    catch (_a) {
        if (local === true)
            return false;
        const parentRegistry = __getParentResource(this);
        return __inScope.call(parentRegistry, idOrPointer);
    }
}
function __hasPointer(id, local) {
    if (!this)
        return false;
    if (__inScope.call(this, id, true)) {
        const localID = __getLocalID(this, id);
        const resourcesMap = __getResourcesMaps(this);
        if (resourcesMap.has(localID))
            return true;
    }
    if (local === true)
        return false;
    const parentRegistry = __getParentResource(this);
    return __hasPointer.call(parentRegistry, id);
}
function __getPointer(id, local) {
    const parentRegistry = __getParentResource(this);
    if (!__inScope.call(this, id, true)) {
        if (local === true || !parentRegistry)
            throw new IllegalArgumentError(`"${id}" is out of scope.`);
        return __getPointer.call(parentRegistry, id);
    }
    const localID = __getLocalID(this, id);
    const resourcesMap = __getResourcesMaps(this);
    if (resourcesMap.has(localID))
        return resourcesMap.get(localID);
    if (local !== true && __hasPointer.call(parentRegistry, id))
        return __getPointer.call(parentRegistry, id);
    return __addPointer(this, { $id: id });
}
function __getPointers(local) {
    const resourcesMap = __getResourcesMaps(this);
    const pointers = Array.from(resourcesMap.values());
    const parentRegistry = __getParentResource(this);
    if (local === true || !parentRegistry)
        return pointers;
    return [
        ...__getPointers.call(parentRegistry),
        ...pointers,
    ];
}
function __removePointer(idOrPointer, local) {
    if (!this)
        return false;
    const id = Pointer.getID(idOrPointer);
    if (__inScope.call(this, id, true)) {
        const localID = __getLocalID(this, id);
        const resourcesMap = __getResourcesMaps(this);
        if (resourcesMap.delete(localID))
            return true;
    }
    if (local === true)
        return false;
    const parentRegistry = __getParentResource(this);
    return __removePointer.call(parentRegistry, idOrPointer);
}
export const Registry = {
    PROTOTYPE: {
        registry: void 0,
        get __modelDecorator() {
            throw new IllegalArgumentError(`Property "__modelDecorator" is required`);
        },
        get __resourcesMap() { return new Map(); },
        inScope: __inScope,
        hasPointer: __hasPointer,
        getPointer: __getPointer,
        getPointers: __getPointers,
        removePointer: __removePointer,
        _addPointer(pointer) {
            if (!pointer.$id)
                throw new IllegalArgumentError("The pointer $id cannot be empty.");
            const localID = __getLocalID(this, pointer.$id);
            const resourcesMap = __getResourcesMaps(this);
            if (resourcesMap.has(localID))
                throw new IDAlreadyInUseError(`"${pointer.$id}" is already being used.`);
            const resource = __getDecorator(this)
                .decorate(Object.assign(pointer, {
                $registry: this,
            }));
            resourcesMap.set(localID, resource);
            return resource;
        },
        _getLocalID(id) {
            return id;
        },
    },
    isDecorated(object) {
        return BiModelDecorator
            .hasPropertiesFrom(Registry.PROTOTYPE, object);
    },
    decorate(object) {
        if (Registry.isDecorated(object))
            return object;
        return BiModelDecorator
            .definePropertiesFrom(Registry.PROTOTYPE, object);
    },
};

//# sourceMappingURL=Registry.js.map
