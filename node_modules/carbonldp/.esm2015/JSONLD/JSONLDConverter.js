import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { ContainerType } from "../ObjectSchema/ContainerType";
import { Pointer } from "../Pointer/Pointer";
import { _getPointer } from "../Pointer/PointerLibrary";
import { RDFList } from "../RDF/List";
import * as XSDSerializers from "../RDF/Literal/Serializers/XSD";
import { RDFNode } from "../RDF/Node";
import { URI } from "../RDF/URI";
import { RDFValue } from "../RDF/Value";
import { _isExistingValue, isFunction, isNull, isObject, isString, MapUtils } from "../Utils";
import { XSD } from "../Vocabularies/XSD";
import { _guessXSDType } from "./Utils";
export class JSONLDConverter {
    get literalSerializers() { return this._literalSerializers; }
    static getDefaultSerializers() {
        let literalSerializers = new Map();
        literalSerializers.set(XSD.date, XSDSerializers.dateSerializer);
        literalSerializers.set(XSD.dateTime, XSDSerializers.dateTimeSerializer);
        literalSerializers.set(XSD.time, XSDSerializers.timeSerializer);
        literalSerializers.set(XSD.integer, XSDSerializers.integerSerializer);
        literalSerializers.set(XSD.int, XSDSerializers.integerSerializer);
        literalSerializers.set(XSD.unsignedInt, XSDSerializers.unsignedIntegerSerializer);
        literalSerializers.set(XSD.long, XSDSerializers.longSerializer);
        literalSerializers.set(XSD.unsignedLong, XSDSerializers.unsignedLongSerializer);
        literalSerializers.set(XSD.float, XSDSerializers.floatSerializer);
        literalSerializers.set(XSD.double, XSDSerializers.floatSerializer);
        literalSerializers.set(XSD.boolean, XSDSerializers.booleanSerializer);
        literalSerializers.set(XSD.string, XSDSerializers.stringSerializer);
        return literalSerializers;
    }
    constructor(literalSerializers) {
        this._literalSerializers = literalSerializers ?
            MapUtils.extend(new Map(), literalSerializers) :
            JSONLDConverter.getDefaultSerializers();
    }
    compact(expandedObjectOrObjects, targetObjectOrObjectsOrDigestedContext, digestedSchemaOrPointerLibrary, pointerLibrary, strict) {
        let targetObjectOrObjects = !pointerLibrary ? null : targetObjectOrObjectsOrDigestedContext;
        let digestedSchema = !pointerLibrary ? targetObjectOrObjectsOrDigestedContext : digestedSchemaOrPointerLibrary;
        pointerLibrary = !pointerLibrary ? digestedSchemaOrPointerLibrary : pointerLibrary;
        if (!Array.isArray(expandedObjectOrObjects))
            return this.__compactSingle(expandedObjectOrObjects, targetObjectOrObjects, digestedSchema, pointerLibrary, strict);
        let expandedObjects = expandedObjectOrObjects;
        let targetObjects = !!targetObjectOrObjects ? targetObjectOrObjects : [];
        for (let i = 0, length = expandedObjects.length; i < length; i++) {
            let expandedObject = expandedObjects[i];
            let targetObject = targetObjects[i] = !!targetObjects[i] ? targetObjects[i] : {};
            this.__compactSingle(expandedObject, targetObject, digestedSchema, pointerLibrary, strict);
        }
        return targetObjects;
    }
    expand(compactedObjectOrObjects, generalSchema, digestedSchema) {
        if (!Array.isArray(compactedObjectOrObjects))
            return this.__expandSingle(compactedObjectOrObjects, generalSchema, digestedSchema);
    }
    update(target, node, digestedSchema, pointerLibrary, strict) {
        const compactedData = this.compact(node, {}, digestedSchema, pointerLibrary, strict);
        new Set([
            ...Object.getOwnPropertyNames(target),
            ...Object.keys(compactedData),
        ]).forEach(key => {
            if (key.startsWith("$"))
                return;
            if (isFunction(target[key]))
                return;
            if (!compactedData.hasOwnProperty(key)) {
                if (!strict || digestedSchema.properties.has(key))
                    delete target[key];
                return;
            }
            if (!Array.isArray(target[key])) {
                target[key] = compactedData[key];
                return;
            }
            const values = Array.isArray(compactedData[key]) ? compactedData[key] : [compactedData[key]];
            target[key].length = 0;
            target[key].push(...values);
        });
    }
    __expandSingle(compactedObject, generalSchema, digestedSchema) {
        let expandedObject = {};
        expandedObject["@id"] = !!compactedObject["$id"] ? compactedObject["$id"] : "";
        if (compactedObject["types"]) {
            const types = Array.isArray(compactedObject["types"]) ?
                compactedObject["types"] : [compactedObject["types"]];
            if (types.length)
                expandedObject["@type"] = types
                    .map(type => generalSchema.resolveURI(type, { vocab: true, base: true }));
        }
        for (const propertyName of Object.keys(compactedObject)) {
            if (propertyName === "$id")
                continue;
            if (propertyName === "types")
                continue;
            const expandedPropertyName = digestedSchema.resolveURI(propertyName, { vocab: true });
            if (URI.isRelative(expandedPropertyName))
                continue;
            const expandedValue = this.__expandProperty(propertyName, compactedObject[propertyName], digestedSchema, generalSchema);
            if (expandedValue === null)
                continue;
            expandedObject[expandedPropertyName] = expandedValue;
        }
        return expandedObject;
    }
    __expandProperty(propertyName, propertyValue, digestedSchema, generalSchema) {
        const definition = digestedSchema.properties.get(propertyName);
        const propertyContainer = definition ? definition.containerType : void 0;
        if (propertyContainer === ContainerType.LANGUAGE)
            return this.__expandPropertyLanguageMap(propertyValue);
        propertyValue = Array.isArray(propertyValue) ? propertyValue : [propertyValue];
        if (propertyContainer === null)
            propertyValue = [propertyValue[0]];
        const propertyType = definition ? definition.literal : null;
        const expandedValues = propertyType === true ?
            this.__expandPropertyLiteral(propertyValue, definition, digestedSchema) :
            propertyType === false ?
                this.__expandPropertyPointer(propertyValue, digestedSchema, generalSchema) :
                this.__expandPropertyValue(propertyValue, digestedSchema, generalSchema);
        const filteredValues = expandedValues.filter(value => value !== null);
        if (!filteredValues.length)
            return null;
        if (propertyContainer === ContainerType.LIST)
            return [
                { "@list": filteredValues },
            ];
        return filteredValues;
    }
    __expandPropertyValue(propertyValue, digestedSchema, generalSchema) {
        return propertyValue.map(value => this.__expandValue(value, digestedSchema, generalSchema));
    }
    __expandPropertyPointer(propertyValue, digestedSchema, generalSchema) {
        return propertyValue.map(value => this.__expandPointerValue(value, digestedSchema, generalSchema));
    }
    __expandPropertyLiteral(propertyValue, definition, digestedSchema) {
        const literalType = digestedSchema.resolveURI(definition.literalType, { vocab: true, base: true });
        const expandedValues = propertyValue.map(value => this.__expandLiteralValue(value, literalType));
        if (definition.language)
            expandedValues.forEach(value => value["@language"] = definition.language);
        return expandedValues;
    }
    __expandPropertyLanguageMap(propertyValue) {
        if (!isObject(propertyValue)) {
            return null;
        }
        let mapValues = [];
        for (const languageTag of Object.keys(propertyValue)) {
            let serializedValue = this.literalSerializers.get(XSD.string).serialize(propertyValue[languageTag]);
            mapValues.push({ "@value": serializedValue, "@type": XSD.string, "@language": languageTag });
        }
        return mapValues;
    }
    __expandPointerValue(propertyValue, digestedSchema, generalSchema) {
        const isStringID = isString(propertyValue);
        const id = Pointer.is(propertyValue) ?
            propertyValue.$id :
            isStringID ?
                propertyValue :
                null;
        if (!id)
            return null;
        const resolved = generalSchema.resolveURI(id, { vocab: isStringID });
        return { "@id": resolved };
    }
    __expandValue(propertyValue, digestedSchema, generalSchema) {
        if (Array.isArray(propertyValue))
            return null;
        return Pointer.is(propertyValue) ?
            this.__expandPointerValue(propertyValue, generalSchema, digestedSchema) :
            this.__expandLiteralValue(propertyValue, _guessXSDType(propertyValue));
    }
    __expandLiteralValue(literalValue, literalType) {
        if (literalType === null)
            return null;
        if (!this.literalSerializers.has(literalType))
            return null;
        const serializedValue = this.literalSerializers
            .get(literalType)
            .serialize(literalValue);
        return { "@value": serializedValue, "@type": literalType };
    }
    __compactSingle(expandedObject, targetObject, digestedSchema, pointerLibrary, strict) {
        if (!expandedObject["@id"])
            throw new IllegalArgumentError("The expandedObject doesn't have an @id defined.");
        targetObject["$id"] = expandedObject["@id"];
        targetObject["types"] = !!expandedObject["@type"] ? expandedObject["@type"] : [];
        const propertyURINameMap = this.__getPropertyURINameMap(digestedSchema);
        for (const propertyURI of Object.keys(expandedObject)) {
            if (propertyURI === "@id")
                continue;
            if (propertyURI === "@type")
                continue;
            const propertyValues = expandedObject[propertyURI];
            if (!_isExistingValue(propertyValues))
                continue;
            if (!propertyURINameMap.has(propertyURI) && strict)
                continue;
            const propertyName = propertyURINameMap.has(propertyURI) ?
                propertyURINameMap.get(propertyURI) :
                digestedSchema.vocab ?
                    URI.getRelativeURI(propertyURI, digestedSchema.vocab) :
                    propertyURI;
            const targetValue = this.__getPropertyValue(propertyName, propertyValues, digestedSchema, pointerLibrary);
            if (targetValue === null || targetValue === void 0)
                continue;
            targetObject[propertyName] = targetValue;
        }
        return targetObject;
    }
    __getPropertyContainerType(propertyValues) {
        if (propertyValues.length === 1) {
            if (RDFList.is(propertyValues[0]))
                return ContainerType.LIST;
        }
        else {
            return ContainerType.SET;
        }
        return null;
    }
    __getPropertyValue(propertyName, propertyValues, digestedSchema, pointerLibrary) {
        const definition = digestedSchema.properties.get(propertyName);
        const propertyContainer = definition ?
            definition.containerType :
            this.__getPropertyContainerType(propertyValues);
        if (propertyContainer === ContainerType.LANGUAGE) {
            return RDFNode.getPropertyLanguageMap(propertyValues);
        }
        if (propertyContainer === ContainerType.LIST) {
            const list = RDFNode.getList(propertyValues);
            if (!list)
                return null;
            propertyValues = list["@list"];
        }
        const propertyType = definition ? definition.literal : null;
        if (propertyType === true && (definition && definition.language)) {
            propertyValues = propertyValues.filter(value => value["@language"] === definition.language);
        }
        if (propertyContainer === null)
            propertyValues = [propertyValues[0]];
        const compactedValues = propertyType === true ?
            this.__compactPropertyLiteral(propertyValues, definition, digestedSchema) :
            propertyType === false ?
                this.__getPropertyPointers(propertyValues, pointerLibrary) :
                this.__getProperties(propertyValues, pointerLibrary);
        if (!compactedValues)
            return null;
        const filteredValues = compactedValues.filter(value => value !== null);
        if (!filteredValues.length)
            return null;
        if (propertyContainer === null)
            return filteredValues[0];
        return filteredValues;
    }
    __getPropertyURINameMap(digestedSchema) {
        const map = new Map();
        digestedSchema.properties.forEach((definition, propertyName) => {
            const uri = digestedSchema.resolveURI(definition.uri, { vocab: true });
            map.set(uri, propertyName);
        });
        return map;
    }
    __compactPropertyLiteral(propertyValues, definition, digestedSchema) {
        const literalType = definition.literalType === null ?
            XSD.string : digestedSchema.resolveURI(definition.literalType, { vocab: true, base: true });
        return RDFNode.getPropertyLiterals(propertyValues, literalType);
    }
    __getProperties(propertyValues, pointerLibrary) {
        if (!Array.isArray(propertyValues))
            return;
        return propertyValues
            .map(RDFValue.parse.bind(null, pointerLibrary))
            .filter(value => !isNull(value));
    }
    __getPropertyPointers(propertyValues, pointerLibrary) {
        if (!Array.isArray(propertyValues))
            return;
        return propertyValues
            .filter(RDFNode.is)
            .map(RDFNode.getID)
            .map(_getPointer.bind(null, pointerLibrary))
            .filter(pointer => !isNull(pointer));
    }
}

//# sourceMappingURL=JSONLDConverter.js.map
