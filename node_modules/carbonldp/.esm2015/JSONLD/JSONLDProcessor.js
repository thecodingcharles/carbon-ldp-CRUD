import { InvalidJSONLDSyntaxError } from "../Errors/InvalidJSONLDSyntaxError";
import { NotImplementedError } from "../Errors/NotImplementedError";
import { JSONParser } from "../HTTP/JSONParser";
import { RequestService, RequestUtils } from "../HTTP/Request";
import { ContainerType } from "../ObjectSchema/ContainerType";
import { DigestedObjectSchema } from "../ObjectSchema/DigestedObjectSchema";
import { DigestedObjectSchemaProperty } from "../ObjectSchema/DigestedObjectSchemaProperty";
import { ObjectSchemaDigester } from "../ObjectSchema/ObjectSchemaDigester";
import { PointerType } from "../ObjectSchema/PointerType";
import { RDFList } from "../RDF/List";
import { URI } from "../RDF/URI";
import * as Utils from "./../Utils";
const MAX_CONTEXT_URLS = 10;
const LINK_HEADER_REL = "http://www.w3.org/ns/json-ld#context";
export class JSONLDProcessor {
    static expand(input) {
        return JSONLDProcessor.__retrieveContexts(input, Object.create(null), "").then(() => {
            let expanded = JSONLDProcessor.__process(new DigestedObjectSchema(), input);
            if (Utils.isObject(expanded) && "@graph" in expanded && Object.keys(expanded).length === 1) {
                expanded = expanded["@graph"];
            }
            else if (expanded === null) {
                expanded = [];
            }
            if (!Utils.isArray(expanded))
                expanded = [expanded];
            return expanded;
        });
    }
    static __getTargetFromLinkHeader(header) {
        let rLinkHeader = /\s*<([^>]*?)>\s*(?:;\s*(.*))?/;
        for (let value of header.values) {
            let match = value.toString().match(rLinkHeader);
            if (!match)
                continue;
            let target = match[1];
            let params = match[2];
            let rParams = /(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g;
            let result = {};
            while (true) {
                match = rParams.exec(params);
                if (!match)
                    break;
                result[match[1]] = (match[2] === undefined) ? match[3] : match[2];
            }
            if (result["rel"] === LINK_HEADER_REL)
                return target;
        }
    }
    static __findContextURLs(input, contexts, base, replace = false) {
        let previousContexts = Object.keys(contexts).length;
        if (Utils.isArray(input)) {
            for (let element of input) {
                JSONLDProcessor.__findContextURLs(element, contexts, base);
            }
        }
        else if (Utils.isPlainObject(input)) {
            for (let key in input) {
                if ("@context" !== key) {
                    JSONLDProcessor.__findContextURLs(input[key], contexts, base);
                    continue;
                }
                let urlOrArrayOrContext = input[key];
                if (Utils.isArray(urlOrArrayOrContext)) {
                    let contextArray = urlOrArrayOrContext;
                    for (let index = 0, length = contextArray.length; index < length; ++index) {
                        let urlOrContext = contextArray[index];
                        if (!Utils.isString(urlOrContext))
                            continue;
                        let url = urlOrContext;
                        url = URI.resolve(base, url);
                        if (replace) {
                            if (Utils.isArray(contexts[url])) {
                                contextArray.splice(index, 1, ...[].concat(contexts[url]));
                                index += contexts[url].length - 1;
                                length = contextArray.length;
                            }
                            else {
                                contextArray[index] = contexts[url];
                            }
                        }
                        else if (!(url in contexts)) {
                            contexts[url] = true;
                        }
                    }
                }
                else if (Utils.isString(urlOrArrayOrContext)) {
                    let url = urlOrArrayOrContext;
                    url = URI.resolve(base, url);
                    if (replace) {
                        input[key] = contexts[url];
                    }
                    else if (!(url in contexts)) {
                        contexts[url] = null;
                    }
                }
            }
        }
        return previousContexts < Object.keys(contexts).length;
    }
    static __retrieveContexts(input, contextsRequested, base) {
        if (Object.keys(contextsRequested).length > MAX_CONTEXT_URLS)
            return Promise.reject(new InvalidJSONLDSyntaxError("Maximum number of @context URLs exceeded."));
        let contextToResolved = Object.create(null);
        if (!JSONLDProcessor.__findContextURLs(input, contextToResolved, base))
            return Promise.resolve();
        function resolved(url, promise) {
            return promise.then(([object, response]) => {
                let _contextsRequested = Utils.ObjectUtils.clone(contextsRequested);
                _contextsRequested[url] = true;
                let contextWrapper = { "@context": {} };
                let header = response.getHeader("Content-Type");
                if (!header || !header.toString().includes("application/ld+json")) {
                    let link;
                    header = response.getHeader("Link");
                    if (header)
                        link = JSONLDProcessor.__getTargetFromLinkHeader(header);
                    if (link)
                        contextWrapper["@context"] = link;
                }
                else {
                    contextWrapper["@context"] = "@context" in object ? object["@context"] : {};
                }
                contextToResolved[url] = contextWrapper["@context"];
                return JSONLDProcessor.__retrieveContexts(contextWrapper, _contextsRequested, url);
            });
        }
        let promises = [];
        for (let url in contextToResolved) {
            if (url in contextsRequested)
                return Promise.reject(new InvalidJSONLDSyntaxError("Cyclical @context URLs detected."));
            let requestOptions = { sendCredentialsOnCORS: false };
            RequestUtils.setAcceptHeader("application/ld+json, application/json", requestOptions);
            let promise = RequestService
                .get(url, requestOptions, new JSONParser())
                .catch((response) => Promise.reject(new InvalidJSONLDSyntaxError(`Unable to resolve context from "${url}". Status code: ${response.status}`)));
            promises.push(resolved(url, promise));
        }
        return Promise.all(promises).then(() => {
            JSONLDProcessor.__findContextURLs(input, contextToResolved, base, true);
        });
    }
    static __isKeyword(value) {
        if (!Utils.isString(value))
            return false;
        switch (value) {
            case "@base":
            case "@context":
            case "@container":
            case "@default":
            case "@embed":
            case "@explicit":
            case "@graph":
            case "@id":
            case "@index":
            case "@language":
            case "@list":
            case "@omitDefault":
            case "@preserve":
            case "@requireAll":
            case "@reverse":
            case "@set":
            case "@type":
            case "@value":
            case "@vocab":
                return true;
            default:
                return false;
        }
    }
    static __isValidType(value) {
        if (Utils.isString(value))
            return true;
        if (!Utils.isArray(value))
            return false;
        for (let element of value) {
            if (!Utils.isString(element))
                return false;
        }
        return true;
    }
    static __expandURI(schema, uri, relativeTo) {
        if (JSONLDProcessor.__isKeyword(uri))
            return uri;
        return schema.resolveURI(uri, relativeTo);
    }
    static __expandLanguageMap(languageMap) {
        let expandedLanguage = [];
        let keys = Object.keys(languageMap).sort();
        for (let key of keys) {
            let values = languageMap[key];
            if (!Utils.isArray(values))
                values = [values];
            for (let item of values) {
                if (item === null)
                    continue;
                if (!Utils.isString(item))
                    throw new InvalidJSONLDSyntaxError("Language map values must be strings.");
                expandedLanguage.push({
                    "@value": item,
                    "@language": key.toLowerCase(),
                });
            }
        }
        return expandedLanguage;
    }
    static __getContainer(context, property) {
        if (!property || !context.properties.has(property))
            return null;
        return context.properties.get(property).containerType;
    }
    static __expandValue(context, value, propertyName) {
        if (value === null || !Utils.isDefined(value))
            return null;
        if (propertyName === "@id") {
            return JSONLDProcessor.__expandURI(context, value, { base: true });
        }
        else if (propertyName === "@type") {
            return JSONLDProcessor.__expandURI(context, value, { vocab: true, base: true });
        }
        const definition = propertyName && context.properties.has(propertyName)
            ? context.properties.get(propertyName)
            : new DigestedObjectSchemaProperty();
        if (definition.literal === false || (propertyName === "@graph" && Utils.isString(value))) {
            let options = { base: true };
            if (definition.pointerType === PointerType.VOCAB)
                options.vocab = true;
            return { "@id": JSONLDProcessor.__expandURI(context, value, options) };
        }
        if (JSONLDProcessor.__isKeyword(propertyName))
            return value;
        let expandedValue = {};
        if (definition.literalType) {
            expandedValue["@type"] = context.resolveURI(definition.literalType, { vocab: true, base: true });
        }
        else if (Utils.isString(value)) {
            let language = Utils.isDefined(definition.language) ? definition.language : context.language;
            if (language)
                expandedValue["@language"] = language;
        }
        if (["boolean", "number", "string"].indexOf(typeof value) === -1)
            value = value.toString();
        expandedValue["@value"] = value;
        return expandedValue;
    }
    static __process(context, element, activeProperty, insideList) {
        if (element === null || !Utils.isDefined(element))
            return null;
        if (!Utils.isArray(element) && !Utils.isObject(element)) {
            if (!insideList && (activeProperty === null || activeProperty === "@graph"))
                return null;
            return JSONLDProcessor.__expandValue(context, element, activeProperty);
        }
        if (Utils.isArray(element)) {
            let container = JSONLDProcessor.__getContainer(context, activeProperty);
            insideList = insideList || container === ContainerType.LIST;
            const expanded = [];
            for (let item of element) {
                let expandedItem = JSONLDProcessor.__process(context, item, activeProperty);
                if (expandedItem === null)
                    continue;
                if (insideList && (Utils.isArray(expandedItem) || RDFList.is(expandedItem)))
                    throw new InvalidJSONLDSyntaxError("Lists of lists are not permitted.");
                if (!Utils.isArray(expandedItem))
                    expandedItem = [expandedItem];
                expanded.push(...expandedItem);
            }
            return expanded;
        }
        if ("@context" in element) {
            context = ObjectSchemaDigester
                .combineDigestedObjectSchemas([
                context,
                ObjectSchemaDigester.digestSchema(element["@context"]),
            ]);
        }
        let expandedElement = {};
        let keys = Object.keys(element);
        for (let key of keys) {
            if (key === "@context")
                continue;
            let uri = JSONLDProcessor.__expandURI(context, key, { vocab: true });
            if (!uri || !(URI.isAbsolute(uri) || URI.isBNodeID(uri) || JSONLDProcessor.__isKeyword(uri)))
                continue;
            let value = element[key];
            if (JSONLDProcessor.__isKeyword(uri)) {
                if (uri === "@id" && !Utils.isString(value))
                    throw new InvalidJSONLDSyntaxError(`"@id" value must a string.`);
                if (uri === "@type" && !JSONLDProcessor.__isValidType(value))
                    throw new InvalidJSONLDSyntaxError(`"@type" value must a string, an array of strings.`);
                if (uri === "@graph" && !(Utils.isObject(value) || Utils.isArray(value)))
                    throw new InvalidJSONLDSyntaxError(`"@graph" value must not be an object or an array.`);
                if (uri === "@value" && (Utils.isObject(value) || Utils.isArray(value)))
                    throw new InvalidJSONLDSyntaxError(`"@value" value must not be an object or an array.`);
                if (uri === "@language") {
                    if (value === null)
                        continue;
                    if (!Utils.isString(value))
                        throw new InvalidJSONLDSyntaxError(`"@language" value must be a string.`);
                    value = value.toLowerCase();
                }
                if (uri === "@index" && !Utils.isString(value))
                    throw new InvalidJSONLDSyntaxError(`"@index" value must be a string.`);
                if (uri === "@reverse" && !Utils.isObject(value))
                    throw new InvalidJSONLDSyntaxError(`"@reverse" value must be an object.`);
                if (uri === "@index" || uri === "@reverse")
                    throw new NotImplementedError(`The SDK does not support "@index" and "@reverse" tags.`);
            }
            let expandedValue;
            let container = JSONLDProcessor.__getContainer(context, key);
            if (container === ContainerType.LANGUAGE && Utils.isObject(value)) {
                expandedValue = JSONLDProcessor.__expandLanguageMap(value);
            }
            else {
                let nextActiveProperty = key;
                let isList = uri === "@list";
                if (isList || uri === "@set") {
                    nextActiveProperty = activeProperty;
                    if (isList && activeProperty === "@graph")
                        nextActiveProperty = null;
                }
                expandedValue = JSONLDProcessor.__process(context, value, nextActiveProperty, isList);
            }
            if (expandedValue === null && uri !== "@value")
                continue;
            if (uri !== "@list" && !RDFList.is(expandedValue) && container === ContainerType.LIST) {
                if (!Utils.isArray(expandedValue))
                    expandedValue = [expandedValue];
                expandedValue = { "@list": expandedValue };
            }
            let useArray = ["@type", "@id", "@value", "@language"].indexOf(uri) === -1;
            JSONLDProcessor.__addValue(expandedElement, uri, expandedValue, { propertyIsArray: useArray });
        }
        if ("@value" in expandedElement) {
            if (expandedElement["@value"] === null)
                expandedElement = null;
        }
        else if ("@type" in expandedElement) {
            if (!Utils.isArray(expandedElement["@type"]))
                expandedElement["@type"] = [expandedElement["@type"]];
        }
        else if ("@set" in expandedElement) {
            expandedElement = expandedElement["@set"];
        }
        return expandedElement;
    }
    static __addValue(element, propertyName, value, options) {
        if (Utils.isArray(value)) {
            let values = value;
            if (values.length === 0 && options.propertyIsArray && !Utils.hasProperty(element, propertyName))
                element[propertyName] = [];
            for (let item of values) {
                JSONLDProcessor.__addValue(element, propertyName, item, options);
            }
        }
        else if (propertyName in element) {
            if (!JSONLDProcessor.__hasValue(element, propertyName, value)) {
                let items = element[propertyName];
                if (!Utils.isArray(items))
                    items = element[propertyName] = [items];
                items.push(value);
            }
        }
        else {
            element[propertyName] = options.propertyIsArray ? [value] : value;
        }
    }
    static __hasProperty(element, propertyName) {
        if (propertyName in element) {
            let item = element[propertyName];
            return !Utils.isArray(item) || item.length > 0;
        }
        return false;
    }
    static __compareValues(value1, value2) {
        if (value1 === value2)
            return true;
        if (Utils.isObject(value1) && Utils.isObject(value2)) {
            if ("@value" in value1
                && value1["@value"] === value2["@value"]
                && value1["@type"] === value2["@type"]
                && value1["@language"] === value2["@language"]
                && value1["@index"] === value2["@index"])
                return true;
            if ("@id" in value1)
                return value1["@id"] === value2["@id"];
        }
        return false;
    }
    static __hasValue(element, propertyName, value) {
        if (JSONLDProcessor.__hasProperty(element, propertyName)) {
            let item = element[propertyName];
            let isList = RDFList.is(item);
            if (isList || Utils.isArray(item)) {
                let items = isList ? item["@list"] : item;
                for (let entry of items) {
                    if (JSONLDProcessor.__compareValues(entry, value))
                        return true;
                }
            }
            else if (!Utils.isArray(value)) {
                return JSONLDProcessor.__compareValues(item, value);
            }
        }
        return false;
    }
}

//# sourceMappingURL=JSONLDProcessor.js.map
