{"version":3,"sources":["Messaging/MessagingService.ts"],"names":[],"mappings":"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","file":"MessagingService.js","sourcesContent":["import SockJS from \"sockjs-client\";\nimport * as webstomp from \"webstomp-client\";\n\nimport { DocumentsContext } from \"../Context/DocumentsContext\";\n\nimport { IllegalStateError } from \"../Errors/IllegalStateError\";\n\nimport { FreeResources } from \"../FreeResources/FreeResources\";\n\nimport { JSONLDParser } from \"../JSONLD/JSONLDParser\";\nimport { RDFDocument } from \"../RDF/Document\";\n\nimport { RDFNode } from \"../RDF/Node\";\n\nimport { UUIDUtils } from \"../Utils\";\n\nimport { EventMessage } from \"./EventMessage\";\nimport { MessagingOptions } from \"./MessagingOptions\";\n\n\nconst DEFAULT_OPTIONS:Readonly<MessagingOptions> = {\n\tmaxReconnectAttempts: 10,\n\treconnectDelay: 1000,\n};\n\ninterface Subscription {\n\tid:string;\n\terrorCallback?:( error:Error ) => void;\n}\n\n/**\n * Service that manages the messaging client, connecting and subscriptions.\n */\nexport class MessagingService {\n\treadonly context:DocumentsContext;\n\n\tprivate _options:MessagingOptions;\n\tprivate _attempts:number;\n\tprivate _client?:webstomp.Client;\n\tprivate _subscriptionsMap!:Map<string, Map<( data:EventMessage ) => void, Subscription>>;\n\tprivate _subscriptionsQueue:Function[];\n\n\tconstructor( context:DocumentsContext ) {\n\t\tthis.context = context;\n\n\t\tthis._options = DEFAULT_OPTIONS;\n\t\tthis._attempts = 0;\n\n\t\tthis._subscriptionsQueue = [];\n\t}\n\n\t/**\n\t * Updates the messaging service options.\n\t *\n\t * If any property is no defined the default is used:\n\t * ```typescript\n\t * {\n\t *     maxReconnectAttempts: 10,\n\t *     reconnectDelay: 1000\n\t * }\n\t * ```\n\t *\n\t * @param options The options to be updated.\n\t */\n\tsetOptions( options:MessagingOptions ):void {\n\t\tthis._options = {\n\t\t\t...DEFAULT_OPTIONS,\n\t\t\t...options,\n\t\t};\n\t}\n\n\t/**\n\t * Connects to the platform's messaging broker.\n\t * If the service is already connected, an error will be thrown.\n\t * @param onConnect Callback to be invoked when the client has established a connection. It will be invoked again when a reconnection is been executed.\n\t * @param onError Callback to be invoked when a error has occurred in the connection or server. If none is provided, the errors will be broadcasted to every connected subscription.\n\t */\n\tconnect( onConnect?:() => void, onError?:( error:Error ) => void ):void {\n\t\tif( this._client ) {\n\t\t\tconst error:Error = new IllegalStateError( `The messaging service is already connect${ this._client.connected ? \"ed\" : \"ing\" }.` );\n\t\t\tif( onError ) onError( error );\n\t\t\tthrow error;\n\t\t}\n\n\t\tif( this._subscriptionsMap ) this._subscriptionsMap.clear();\n\t\tthis.reconnect( onConnect, onError );\n\t}\n\n\t/**\n\t * Reconnects the service to the platform broker.\n\t * If the service is already connected, it will be closed and opened again.\n\t * @param onConnect Callback to be invoked when the client has established a connection. It will be invoked again when a reconnection is been executed.\n\t * @param onError Callback to be invoked when a error has occurred in the connection or server. If none is provided, the errors will be broadcasted to every connected subscription.\n\t */\n\treconnect( onConnect?:() => void, onError:( error:Error ) => void = this.__broadcastError.bind( this ) ):void {\n\t\tif( ! this._client ) this._attempts = 0;\n\t\telse if( this._client.connected ) this._client.disconnect();\n\t\tif( ! this._subscriptionsMap ) this._subscriptionsMap = new Map();\n\n\t\tconst sock:WebSocket = new SockJS( this.context.resolve( \"/broker\" ) );\n\t\tthis._client = webstomp.over( sock, {\n\t\t\tdebug: false,\n\t\t\theartbeat: false,\n\t\t} );\n\n\t\tthis._client.connect( {}, () => {\n\t\t\tthis._subscriptionsQueue.forEach( callback => callback() );\n\t\t\tthis._subscriptionsQueue.length = 0;\n\t\t\tthis._attempts = 0;\n\t\t\tif( onConnect ) onConnect();\n\n\t\t}, ( errorFrameOrEvent:webstomp.Frame | CloseEvent ) => {\n\t\t\tconst canReconnect:boolean = this._options.maxReconnectAttempts === null || this._options.maxReconnectAttempts! >= this._attempts;\n\t\t\tlet errorMessage:string;\n\t\t\tif( \"reason\" in errorFrameOrEvent ) {\n\t\t\t\tif( canReconnect ) {\n\t\t\t\t\tif( ++ this._attempts === 1 ) this.__saveSubscriptions();\n\t\t\t\t\tsetTimeout( () => this.reconnect( onConnect, onError ), this._options.reconnectDelay );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._client = undefined;\n\t\t\t\tthis._subscriptionsQueue.length = 0;\n\t\t\t\terrorMessage = `CloseEventError: ${ errorFrameOrEvent.reason }`;\n\t\t\t} else if( \"body\" in errorFrameOrEvent ) {\n\t\t\t\tif( ! this._client || ! this._client.connected && canReconnect ) return;\n\t\t\t\terrorMessage = `${ errorFrameOrEvent.headers[ \"message\" ] }: ${ errorFrameOrEvent.body.trim() }`;\n\t\t\t} else {\n\t\t\t\terrorMessage = `Unknown error: ${ errorFrameOrEvent }`;\n\t\t\t}\n\t\t\tonError( new Error( errorMessage ) );\n\t\t} );\n\t}\n\n\t/**\n\t * Subscribes to the destination provided.\n\t * @param destination The destination to subscribe.\n\t * @param onEvent Callback to be invoked in every notification and will be provided with the data message of the notification.\n\t * @param onError Callback to be invoked when a error has occurred in the subscription.\n\t */\n\tsubscribe( destination:string, onEvent:( data:EventMessage ) => void, onError?:( error:Error ) => void ):void {\n\t\tif( ! this._client ) this.connect();\n\t\tif( ! this._subscriptionsMap.has( destination ) ) this._subscriptionsMap.set( destination, new Map() );\n\t\tconst callbacksMap:Map<( data:EventMessage ) => void, Subscription> = this._subscriptionsMap.get( destination )!;\n\n\t\tif( callbacksMap.has( onEvent ) ) return;\n\t\tconst subscriptionID:string = UUIDUtils.generate();\n\t\tcallbacksMap.set( onEvent, {\n\t\t\tid: subscriptionID,\n\t\t\terrorCallback: onError,\n\t\t} );\n\n\t\tconst subscribeTo:() => void = this.__makeSubscription( subscriptionID, destination, onEvent, onError );\n\t\tif( this._client!.connected ) return subscribeTo();\n\t\tthis._subscriptionsQueue.push( subscribeTo );\n\t}\n\n\t/**\n\t * Removes the subscription set for the specific destination and onEvent callback.\n\t * @param destination The destination of the subscription to remove.\n\t * @param onEvent Callback used in the subscription to remove.\n\t */\n\tunsubscribe( destination:string, onEvent:( data:EventMessage ) => void ):void {\n\t\tif( ! this._client || ! this._subscriptionsMap || ! this._subscriptionsMap.has( destination ) ) return;\n\n\t\tconst callbackMap:Map<( data:EventMessage ) => void, Subscription> = this._subscriptionsMap.get( destination )!;\n\t\tif( ! callbackMap.has( onEvent ) ) return;\n\n\t\tconst subscriptionID:string = callbackMap.get( onEvent )!.id;\n\t\tcallbackMap.delete( onEvent );\n\n\t\tif( callbackMap.size === 0 ) this._subscriptionsMap.delete( destination );\n\n\t\tthis._client.unsubscribe( subscriptionID );\n\t}\n\n\tprivate __broadcastError( error:Error ):void {\n\t\tif( ! this._subscriptionsMap ) return;\n\n\t\tthis._subscriptionsMap\n\t\t\t.forEach( callbacksMap => callbacksMap\n\t\t\t\t.forEach( subscription => {\n\t\t\t\t\t// TODO: Warn error not been broadcasted\n\t\t\t\t\tif( ! subscription.errorCallback ) return;\n\n\t\t\t\t\tsubscription.errorCallback( error );\n\t\t\t\t} )\n\t\t\t);\n\t}\n\n\tprivate __makeSubscription( id:string, destination:string, eventCallback:( data:EventMessage ) => void, errorCallback?:( error:Error ) => void ):() => void {\n\t\treturn () => this._client!.subscribe( destination, message => {\n\t\t\tnew JSONLDParser()\n\t\t\t\t.parse( message.body )\n\t\t\t\t.then( ( data:object[] ) => {\n\t\t\t\t\tconst nodes:RDFNode[] = RDFDocument.getResources( data );\n\n\t\t\t\t\tconst freeResources:FreeResources = FreeResources\n\t\t\t\t\t\t.parseFreeNodes( this.context.registry, nodes );\n\n\t\t\t\t\tconst eventMessage:EventMessage | undefined = freeResources\n\t\t\t\t\t\t.getPointers( true )\n\t\t\t\t\t\t.find( EventMessage.is );\n\n\t\t\t\t\t// TODO: Implement specific error\n\t\t\t\t\tif( ! eventMessage )\n\t\t\t\t\t\tthrow new Error( \"No message was returned by the notification.\" );\n\n\t\t\t\t\treturn eventMessage;\n\t\t\t\t} )\n\t\t\t\t.then( eventCallback )\n\t\t\t\t.catch( errorCallback );\n\t\t}, { id } );\n\t}\n\n\tprivate __saveSubscriptions():void {\n\t\tif( this._subscriptionsQueue.length || ! this._subscriptionsMap ) return;\n\t\tthis._subscriptionsMap.forEach( ( callbackMap, destination ) => callbackMap.forEach( ( subscription, eventCallback ) => {\n\t\t\tconst subscribeTo:() => void = this.__makeSubscription( subscription.id, destination, eventCallback, subscription.errorCallback );\n\t\t\tthis._subscriptionsQueue.push( subscribeTo );\n\t\t} ) );\n\t}\n\n}\n"],"sourceRoot":"../../src"}