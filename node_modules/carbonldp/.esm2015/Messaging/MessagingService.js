import SockJS from "sockjs-client";
import * as webstomp from "webstomp-client";
import { IllegalStateError } from "../Errors/IllegalStateError";
import { FreeResources } from "../FreeResources/FreeResources";
import { JSONLDParser } from "../JSONLD/JSONLDParser";
import { RDFDocument } from "../RDF/Document";
import { UUIDUtils } from "../Utils";
import { EventMessage } from "./EventMessage";
const DEFAULT_OPTIONS = {
    maxReconnectAttempts: 10,
    reconnectDelay: 1000,
};
export class MessagingService {
    constructor(context) {
        this.context = context;
        this._options = DEFAULT_OPTIONS;
        this._attempts = 0;
        this._subscriptionsQueue = [];
    }
    setOptions(options) {
        this._options = Object.assign({}, DEFAULT_OPTIONS, options);
    }
    connect(onConnect, onError) {
        if (this._client) {
            const error = new IllegalStateError(`The messaging service is already connect${this._client.connected ? "ed" : "ing"}.`);
            if (onError)
                onError(error);
            throw error;
        }
        if (this._subscriptionsMap)
            this._subscriptionsMap.clear();
        this.reconnect(onConnect, onError);
    }
    reconnect(onConnect, onError = this.__broadcastError.bind(this)) {
        if (!this._client)
            this._attempts = 0;
        else if (this._client.connected)
            this._client.disconnect();
        if (!this._subscriptionsMap)
            this._subscriptionsMap = new Map();
        const sock = new SockJS(this.context.resolve("/broker"));
        this._client = webstomp.over(sock, {
            debug: false,
            heartbeat: false,
        });
        this._client.connect({}, () => {
            this._subscriptionsQueue.forEach(callback => callback());
            this._subscriptionsQueue.length = 0;
            this._attempts = 0;
            if (onConnect)
                onConnect();
        }, (errorFrameOrEvent) => {
            const canReconnect = this._options.maxReconnectAttempts === null || this._options.maxReconnectAttempts >= this._attempts;
            let errorMessage;
            if ("reason" in errorFrameOrEvent) {
                if (canReconnect) {
                    if (++this._attempts === 1)
                        this.__saveSubscriptions();
                    setTimeout(() => this.reconnect(onConnect, onError), this._options.reconnectDelay);
                    return;
                }
                this._client = undefined;
                this._subscriptionsQueue.length = 0;
                errorMessage = `CloseEventError: ${errorFrameOrEvent.reason}`;
            }
            else if ("body" in errorFrameOrEvent) {
                if (!this._client || !this._client.connected && canReconnect)
                    return;
                errorMessage = `${errorFrameOrEvent.headers["message"]}: ${errorFrameOrEvent.body.trim()}`;
            }
            else {
                errorMessage = `Unknown error: ${errorFrameOrEvent}`;
            }
            onError(new Error(errorMessage));
        });
    }
    subscribe(destination, onEvent, onError) {
        if (!this._client)
            this.connect();
        if (!this._subscriptionsMap.has(destination))
            this._subscriptionsMap.set(destination, new Map());
        const callbacksMap = this._subscriptionsMap.get(destination);
        if (callbacksMap.has(onEvent))
            return;
        const subscriptionID = UUIDUtils.generate();
        callbacksMap.set(onEvent, {
            id: subscriptionID,
            errorCallback: onError,
        });
        const subscribeTo = this.__makeSubscription(subscriptionID, destination, onEvent, onError);
        if (this._client.connected)
            return subscribeTo();
        this._subscriptionsQueue.push(subscribeTo);
    }
    unsubscribe(destination, onEvent) {
        if (!this._client || !this._subscriptionsMap || !this._subscriptionsMap.has(destination))
            return;
        const callbackMap = this._subscriptionsMap.get(destination);
        if (!callbackMap.has(onEvent))
            return;
        const subscriptionID = callbackMap.get(onEvent).id;
        callbackMap.delete(onEvent);
        if (callbackMap.size === 0)
            this._subscriptionsMap.delete(destination);
        this._client.unsubscribe(subscriptionID);
    }
    __broadcastError(error) {
        if (!this._subscriptionsMap)
            return;
        this._subscriptionsMap
            .forEach(callbacksMap => callbacksMap
            .forEach(subscription => {
            if (!subscription.errorCallback)
                return;
            subscription.errorCallback(error);
        }));
    }
    __makeSubscription(id, destination, eventCallback, errorCallback) {
        return () => this._client.subscribe(destination, message => {
            new JSONLDParser()
                .parse(message.body)
                .then((data) => {
                const nodes = RDFDocument.getResources(data);
                const freeResources = FreeResources
                    .parseFreeNodes(this.context.registry, nodes);
                const eventMessage = freeResources
                    .getPointers(true)
                    .find(EventMessage.is);
                if (!eventMessage)
                    throw new Error("No message was returned by the notification.");
                return eventMessage;
            })
                .then(eventCallback)
                .catch(errorCallback);
        }, { id });
    }
    __saveSubscriptions() {
        if (this._subscriptionsQueue.length || !this._subscriptionsMap)
            return;
        this._subscriptionsMap.forEach((callbackMap, destination) => callbackMap.forEach((subscription, eventCallback) => {
            const subscribeTo = this.__makeSubscription(subscription.id, destination, eventCallback, subscription.errorCallback);
            this._subscriptionsQueue.push(subscribeTo);
        }));
    }
}

//# sourceMappingURL=MessagingService.js.map
