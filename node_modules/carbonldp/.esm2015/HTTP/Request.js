import HTTP from "http";
import HTTPS from "https";
import URL from "url";
import { hasProperty, hasPropertyDefined, isNumber, isString } from "../Utils";
import { statusCodeMap } from "./Errors/index";
import { BadResponseError } from "./Errors/ServerErrors/BadResponseError";
import { UnknownError } from "./Errors/UnknownError";
import { Header } from "./Header";
import { HTTPMethod } from "./HTTPMethod";
import { Response } from "./Response";
function __onResolve(resolve, reject, response) {
    if (response.status >= 200 && response.status <= 299) {
        resolve(response);
    }
    else {
        if (!statusCodeMap.has(response.status))
            return reject(new UnknownError(response.data, response));
        reject(new (statusCodeMap.get(response.status))(response.data, response));
    }
}
function __sendWithBrowser(method, url, body, options) {
    return new Promise((resolve, reject) => {
        let request = options.request ? options.request : new XMLHttpRequest();
        request.open(method, url, true);
        if (options.headers)
            options.headers
                .forEach((header, name) => request.setRequestHeader(name, header.toString()));
        request.withCredentials = !!options.sendCredentialsOnCORS;
        if (options.timeout)
            request.timeout = options.timeout;
        request.onload = request.onerror = () => {
            let response = new Response(request);
            __onResolve(resolve, reject, response);
        };
        if (body) {
            request.send(body);
        }
        else {
            request.send();
        }
    });
}
function __sendWithNode(method, url, body, options) {
    return new Promise((resolve, reject) => {
        function returnResponse(request, res) {
            let rawData = [];
            res.on("data", (chunk) => {
                if (typeof chunk === "string")
                    chunk = Buffer.from(chunk, "utf-8");
                rawData.push(chunk);
            }).on("end", () => {
                let data = Buffer.concat(rawData).toString("utf8");
                let response = new Response(request, data, res);
                __onResolve(resolve, reject, response);
            });
        }
        let numberOfRedirects = 0;
        function sendRequestWithRedirect(_url) {
            let parsedURL = URL.parse(_url);
            let Adapter = parsedURL.protocol === "http:" ? HTTP : HTTPS;
            let requestOptions = {
                protocol: parsedURL.protocol,
                hostname: parsedURL.hostname,
                port: parsedURL.port,
                path: parsedURL.path,
                method: method,
                headers: {},
            };
            if (options.headers)
                options.headers
                    .forEach((header, name) => requestOptions.headers[name] = header.toString());
            let request = Adapter.request(requestOptions);
            if (options.timeout)
                request.setTimeout(options.timeout);
            request.on("response", (res) => {
                if (res.statusCode >= 300 && res.statusCode <= 399 && "location" in res.headers) {
                    if (++numberOfRedirects < 10)
                        return sendRequestWithRedirect(URL.resolve(_url, res.headers.location));
                }
                returnResponse(request, res);
            });
            request.on("error", (error) => {
                let response = new Response(request, error.message);
                __onResolve(resolve, reject, response);
            });
            if (body) {
                if (method === "DELETE")
                    request.useChunkedEncodingByDefault = true;
                request.write(body);
            }
            request.end();
        }
        sendRequestWithRedirect(url);
    });
}
function __sendRequest(method, url, body, options) {
    return typeof XMLHttpRequest !== "undefined" ?
        __sendWithBrowser(method, url, body, options) :
        __sendWithNode(method, url, body, options);
}
function __isBody(data) {
    return isString(data)
        || typeof Blob !== "undefined" && data instanceof Blob
        || typeof Buffer !== "undefined" && data instanceof Buffer;
}
export class RequestService {
    static send(method, url, bodyOrOptions, optionsOrParser, parser) {
        let body = undefined;
        let options = hasProperty(optionsOrParser, "parse") ? bodyOrOptions : optionsOrParser;
        parser = hasProperty(optionsOrParser, "parse") ? optionsOrParser : parser;
        if (!bodyOrOptions || __isBody(bodyOrOptions)) {
            body = bodyOrOptions;
        }
        else {
            options = bodyOrOptions ? bodyOrOptions : options;
        }
        options = Object.assign({}, RequestService.defaultOptions, options);
        if (isNumber(method))
            method = HTTPMethod[method];
        const requestPromise = __sendRequest(method, url, body, options)
            .then(response => {
            if (method === "GET" && options.headers)
                return this.__handleGETResponse(url, options, response);
            else
                return response;
        });
        if (!parser)
            return requestPromise;
        return requestPromise.then((response) => {
            return parser.parse(response.data).then((parsedBody) => {
                return [parsedBody, response];
            });
        });
    }
    static options(url, options = RequestService.defaultOptions) {
        return RequestService.send(HTTPMethod.OPTIONS, url, options);
    }
    static head(url, options = RequestService.defaultOptions) {
        return RequestService.send(HTTPMethod.HEAD, url, options);
    }
    static get(url, options = RequestService.defaultOptions, parser) {
        return RequestService.send(HTTPMethod.GET, url, undefined, options, parser);
    }
    static post(url, bodyOrOptions = RequestService.defaultOptions, options = RequestService.defaultOptions, parser) {
        return RequestService.send(HTTPMethod.POST, url, bodyOrOptions, options, parser);
    }
    static put(url, bodyOrOptions = RequestService.defaultOptions, options = RequestService.defaultOptions, parser) {
        return RequestService.send(HTTPMethod.PUT, url, bodyOrOptions, options, parser);
    }
    static patch(url, bodyOrOptions = RequestService.defaultOptions, options = RequestService.defaultOptions, parser) {
        return RequestService.send(HTTPMethod.PATCH, url, bodyOrOptions, options, parser);
    }
    static delete(url, bodyOrOptions = RequestService.defaultOptions, optionsOrParser = RequestService.defaultOptions, parser) {
        return RequestService.send(HTTPMethod.DELETE, url, bodyOrOptions, optionsOrParser, parser);
    }
    static __handleGETResponse(url, requestOptions, response) {
        return Promise.resolve()
            .then(() => {
            if (this.__contentTypeIsAccepted(requestOptions, response))
                return response;
            this.__setNoCacheHeaders(requestOptions);
            if (!this.__isChromiumAgent())
                this.__setFalseETag(requestOptions);
            return __sendRequest("GET", url, undefined, requestOptions)
                .then(noCachedResponse => {
                if (!this.__contentTypeIsAccepted(requestOptions, response)) {
                    throw new BadResponseError("The server responded with an unacceptable Content-Type", response);
                }
                return noCachedResponse;
            });
        });
    }
    static __contentTypeIsAccepted(requestOptions, response) {
        if (!requestOptions.headers)
            return true;
        const accepts = requestOptions.headers.has("accept") ?
            requestOptions.headers.get("accept").values :
            [];
        const contentType = response.headers.has("content-type") ?
            response.headers.get("content-type") :
            undefined;
        return !contentType || accepts.some(contentType.hasValue, contentType);
    }
    static __setNoCacheHeaders(requestOptions) {
        requestOptions.headers
            .set("pragma", new Header("no-cache"))
            .set("cache-control", new Header("no-cache, max-age=0"));
    }
    static __isChromiumAgent() {
        return typeof window !== "undefined" && !!window["chrome"];
    }
    static __setFalseETag(requestOptions) {
        requestOptions.headers.set("if-none-match", new Header());
    }
}
RequestService.defaultOptions = {
    sendCredentialsOnCORS: true,
};
export class RequestUtils {
    static getHeader(headerName, requestOptions, initialize) {
        if (!requestOptions.headers) {
            if (!initialize)
                return undefined;
            requestOptions.headers = new Map();
        }
        headerName = headerName.toLowerCase();
        let header = requestOptions.headers.get(headerName);
        if (!header) {
            if (!initialize)
                return undefined;
            header = new Header();
            requestOptions.headers.set(headerName, header);
        }
        return header;
    }
    static setAcceptHeader(accept, requestOptions) {
        RequestUtils.__addHeaderValue("accept", accept, requestOptions);
        return requestOptions;
    }
    static setContentTypeHeader(contentType, requestOptions) {
        RequestUtils.__addHeaderValue("content-type", contentType, requestOptions);
        return requestOptions;
    }
    static setIfMatchHeader(eTag, requestOptions) {
        if (!eTag)
            return requestOptions;
        RequestUtils.__addHeaderValue("if-match", eTag, requestOptions);
        return requestOptions;
    }
    static setIfNoneMatchHeader(eTag, requestOptions) {
        if (!eTag)
            return requestOptions;
        RequestUtils.__addHeaderValue("if-none-match", eTag, requestOptions);
        return requestOptions;
    }
    static setPreferredInteractionModel(interactionModelURI, requestOptions) {
        const headerValue = `${interactionModelURI}; rel=interaction-model`;
        RequestUtils.__addHeaderValue("prefer", headerValue, requestOptions);
        return requestOptions;
    }
    static setPreferredRetrieval(retrievalType, requestOptions) {
        const headerValue = `return=${retrievalType}`;
        RequestUtils.__addHeaderValue("prefer", headerValue, requestOptions);
        return requestOptions;
    }
    static setRetrievalPreferences(preferences, requestOptions) {
        const prefer = RequestUtils.getHeader("prefer", requestOptions, true);
        const keys = ["include", "omit"];
        for (const key of keys) {
            if (!(key in preferences))
                continue;
            if (preferences[key].length <= 0)
                continue;
            const strPreferences = preferences[key].join(" ");
            prefer.values.push(`${key}="${strPreferences}"`);
        }
        return requestOptions;
    }
    static setSlug(slug, requestOptions) {
        RequestUtils.__addHeaderValue("slug", slug, requestOptions);
        return requestOptions;
    }
    static isOptions(value) {
        return hasPropertyDefined(value, "headers")
            || hasPropertyDefined(value, "sendCredentialsOnCORS")
            || hasPropertyDefined(value, "timeout")
            || hasPropertyDefined(value, "request");
    }
    static cloneOptions(options) {
        const clone = Object.assign({}, options, { headers: new Map() });
        if (options.headers)
            options.headers
                .forEach((value, key) => clone.headers.set(key, new Header(value.values.slice())));
        return clone;
    }
    static __addHeaderValue(headerName, headerValue, requestOptions) {
        const header = RequestUtils.getHeader(headerName, requestOptions, true);
        header.addValue(headerValue);
    }
}

//# sourceMappingURL=Request.js.map
