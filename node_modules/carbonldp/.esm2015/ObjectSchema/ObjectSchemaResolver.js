import { ModelDecorator } from "../Model/ModelDecorator";
import { RDFNode } from "../RDF/Node";
import { URI } from "../RDF/URI";
import { C } from "../Vocabularies/C";
import { DigestedObjectSchema } from "./DigestedObjectSchema";
import { ObjectSchemaDigester } from "./ObjectSchemaDigester";
function __getSchemaForNode($context, node) {
    const types = RDFNode.getTypes(node);
    return __getSchema($context, types, node["@id"]);
}
function __getSchemaForResource($context, resource) {
    const types = resource.types || [];
    return __getSchema($context, types, resource.$id);
}
function __getSchema($context, objectTypes, objectID) {
    if (!$context)
        return new DigestedObjectSchema();
    if (objectID !== void 0 && !URI.hasFragment(objectID) && !URI.isBNodeID(objectID) && objectTypes.indexOf(C.Document) === -1)
        objectTypes = objectTypes.concat(C.Document);
    const objectSchemas = objectTypes
        .filter(type => $context.hasObjectSchema(type))
        .map(type => $context.getObjectSchema(type));
    return ObjectSchemaDigester
        ._combineSchemas([
        $context.getObjectSchema(),
        ...objectSchemas,
    ]);
}
export const ObjectSchemaResolver = {
    PROTOTYPE: {
        context: undefined,
        getGeneralSchema() {
            if (!this.context)
                return new DigestedObjectSchema();
            return this.context.getObjectSchema();
        },
        hasSchemaFor(object, path) {
            return !path;
        },
        getSchemaFor(object) {
            return "types" in object || "$id" in object ?
                __getSchemaForResource(this.context, object) :
                __getSchemaForNode(this.context, object);
        },
    },
    isDecorated(object) {
        return ModelDecorator.hasPropertiesFrom(ObjectSchemaResolver.PROTOTYPE, object);
    },
    decorate(object) {
        return ModelDecorator.definePropertiesFrom(ObjectSchemaResolver.PROTOTYPE, object);
    },
};

//# sourceMappingURL=ObjectSchemaResolver.js.map
