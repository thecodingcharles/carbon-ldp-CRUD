import { Fragment } from "../Fragment/Fragment";
import { ModelDecorator } from "../Model/ModelDecorator";
import { ResolvablePointer } from "../Repository/ResolvablePointer";
import { isObject } from "../Utils";
import { C } from "../Vocabularies/C";
import { LDP } from "../Vocabularies/LDP";
import { XSD } from "../Vocabularies/XSD";
import { EventEmitterDocumentTrait } from "./Traits/EventEmitterDocumentTrait";
import { QueryableDocumentTrait } from "./Traits/QueryableDocumentTrait";
import { SPARQLDocumentTrait } from "./Traits/SPARQLDocumentTrait";
import { TransientDocument } from "./TransientDocument";
export const Document = {
    TYPE: C.Document,
    SCHEMA: {
        "contains": {
            "@id": LDP.contains,
            "@container": "@set",
            "@type": "@id",
        },
        "members": {
            "@id": LDP.member,
            "@container": "@set",
            "@type": "@id",
        },
        "membershipResource": {
            "@id": LDP.membershipResource,
            "@type": "@id",
        },
        "isMemberOfRelation": {
            "@id": LDP.isMemberOfRelation,
            "@type": "@id",
        },
        "hasMemberRelation": {
            "@id": LDP.hasMemberRelation,
            "@type": "@id",
        },
        "insertedContentRelation": {
            "@id": LDP.insertedContentRelation,
            "@type": "@id",
        },
        "created": {
            "@id": C.created,
            "@type": XSD.dateTime,
        },
        "modified": {
            "@id": C.modified,
            "@type": XSD.dateTime,
        },
        "defaultInteractionModel": {
            "@id": C.defaultInteractionModel,
            "@type": "@id",
        },
        "accessPoints": {
            "@id": C.accessPoint,
            "@type": "@id",
            "@container": "@set",
        },
    },
    PROTOTYPE: {
        get $__savedFragments() { return []; },
        $_syncSavedFragments() {
            this.$__savedFragments = Array
                .from(this.$__resourcesMap.values());
            this.$__savedFragments
                .forEach(fragment => fragment.$_syncSnapshot());
        },
        $_syncSnapshot() {
            ResolvablePointer.PROTOTYPE.$_syncSnapshot.call(this);
            this.$_syncSavedFragments();
        },
        $isDirty() {
            const isSelfDirty = ResolvablePointer.PROTOTYPE.$isDirty.call(this);
            if (isSelfDirty)
                return true;
            const hasRemovedFragments = this
                .$__savedFragments
                .some(fragment => !this.$hasFragment(fragment.$id));
            if (hasRemovedFragments)
                return true;
            const hasNewFragments = this
                .$__savedFragments.length !== this.$__resourcesMap.size;
            if (hasNewFragments)
                return true;
            return this
                .$__savedFragments
                .some(fragment => fragment.$isDirty());
        },
        $revert() {
            ResolvablePointer.PROTOTYPE.$revert.call(this);
            this.$__resourcesMap.clear();
            this
                .$__savedFragments
                .forEach(fragment => {
                fragment.$revert();
                this.$__resourcesMap.set(fragment.$slug, fragment);
            });
        },
    },
    isDecorated(object) {
        return isObject(object)
            && ModelDecorator
                .hasPropertiesFrom(Document.PROTOTYPE, object);
    },
    is(object) {
        return TransientDocument.is(object)
            && SPARQLDocumentTrait.isDecorated(object)
            && EventEmitterDocumentTrait.isDecorated(object)
            && QueryableDocumentTrait.isDecorated(object)
            && Document.isDecorated(object);
    },
    decorate(object) {
        if (Document.isDecorated(object))
            return object;
        const base = Object.assign(object, {
            $__modelDecorator: Fragment,
        });
        const target = ModelDecorator
            .decorateMultiple(base, SPARQLDocumentTrait, EventEmitterDocumentTrait, QueryableDocumentTrait);
        return ModelDecorator
            .definePropertiesFrom(Document.PROTOTYPE, target);
    },
    create: TransientDocument.create,
    createFrom: TransientDocument.createFrom,
};

//# sourceMappingURL=Document.js.map
