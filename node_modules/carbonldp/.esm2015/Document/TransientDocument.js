import { isRelative } from "sparqler/iri";
import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { TransientFragment } from "../Fragment/TransientFragment";
import { ModelDecorator } from "../Model/ModelDecorator";
import { Pointer } from "../Pointer/Pointer";
import { URI } from "../RDF/URI";
import { Registry } from "../Registry/Registry";
import { Resource } from "../Resource/Resource";
import { isObject, isPlainObject, isString } from "../Utils";
function __getLabelFrom(slug) {
    if (!isRelative(slug) || slug.startsWith("#"))
        return slug;
    return "#" + slug;
}
function __getObjectId(object) {
    if ("$id" in object)
        return object.$id;
    if ("$slug" in object)
        return URI.hasFragment(object.$slug) ?
            object.$slug : __getLabelFrom(object.$slug);
    return URI.generateBNodeID();
}
function __convertNested(resource, target, tracker = new Set()) {
    Object
        .keys(target)
        .map(key => target[key])
        .forEach(next => {
        if (Array.isArray(next))
            return __convertNested(resource, next, tracker);
        if (!isPlainObject(next))
            return;
        if (TransientDocument.is(next))
            return;
        if (next._registry && next._registry !== resource)
            return;
        const idOrSlug = __getObjectId(next);
        if (tracker.has(idOrSlug))
            return;
        if (!resource.$inScope(idOrSlug, true))
            return;
        const fragment = resource.$hasPointer(idOrSlug, true) ?
            resource.$getPointer(idOrSlug, true) :
            resource.$createFragment(next, idOrSlug);
        tracker.add(fragment.$id);
        __convertNested(resource, fragment, tracker);
    });
}
export const TransientDocument = {
    PROTOTYPE: {
        $registry: void 0,
        $_normalize() {
            const usedFragments = new Set();
            __convertNested(this, this, usedFragments);
            this.$getPointers(true)
                .map(Pointer.getID)
                .filter(URI.isBNodeID)
                .filter(id => !usedFragments.has(id))
                .forEach(this.$removePointer, this);
        },
        $_getLocalID(id) {
            if (URI.isBNodeID(id))
                return id;
            if (URI.isFragmentOf(id, this.$id))
                return URI.getFragment(id);
            throw new IllegalArgumentError(`"${id}" is out of scope.`);
        },
        $getPointer(id, local) {
            id = URI.resolve(this.$id, id);
            return Registry.PROTOTYPE.getPointer.call(this, id, local);
        },
        $hasFragment(id) {
            id = __getLabelFrom(id);
            if (!this.$inScope(id, true))
                return false;
            const localID = this.$_getLocalID(id);
            return this.$__resourcesMap.has(localID);
        },
        $getFragment(id) {
            id = __getLabelFrom(id);
            const localID = this.$_getLocalID(id);
            const resource = this.$__resourcesMap.get(localID);
            if (!resource)
                return null;
            return resource;
        },
        $getFragments() {
            return this.$getPointers(true);
        },
        $createFragment(isOrObject, id) {
            const object = isObject(isOrObject) ? isOrObject : {};
            if (isString(isOrObject))
                id = isOrObject;
            const $id = id ? __getLabelFrom(id) : __getObjectId(object);
            const fragment = this.$_addPointer(Object
                .assign(object, { $id }));
            __convertNested(this, fragment);
            return fragment;
        },
        $removeFragment(fragmentOrSlug) {
            const id = __getLabelFrom(Pointer.getID(fragmentOrSlug));
            if (!this.$inScope(id, true))
                return false;
            return this.$removePointer(id);
        },
        toJSON(contextOrKey) {
            const nodes = [
                Resource.PROTOTYPE.toJSON.call(this, contextOrKey),
                ...this
                    .$getFragments()
                    .map(resource => resource.toJSON(contextOrKey)),
            ];
            return {
                "@id": this.$id,
                "@graph": nodes,
            };
        },
    },
    isDecorated(object) {
        return ModelDecorator
            .hasPropertiesFrom(TransientDocument.PROTOTYPE, object);
    },
    decorate(object) {
        if (TransientDocument.isDecorated(object))
            return object;
        const base = ModelDecorator.definePropertiesFrom({
            $__modelDecorator: TransientFragment,
        }, object);
        const resource = ModelDecorator
            .decorateMultiple(base, Resource, Registry);
        return ModelDecorator
            .definePropertiesFrom(TransientDocument.PROTOTYPE, resource);
    },
    is: (value) => Resource.is(value) &&
        Registry.isDecorated(value) &&
        TransientDocument.isDecorated(value),
    createFrom: (object) => {
        if (TransientDocument.is(object))
            throw new IllegalArgumentError("The object provided is already a Document.");
        const document = TransientDocument.decorate(object);
        __convertNested(document, document);
        return document;
    },
    create: (data) => {
        const copy = Object.assign({}, data);
        return TransientDocument.createFrom(copy);
    },
};

//# sourceMappingURL=TransientDocument.js.map
