import { IllegalArgumentError } from "../../Errors/IllegalArgumentError";
import { GeneralRepository } from "../../GeneralRepository/GeneralRepository";
import { RequestUtils } from "../../HTTP/Request";
import { ModelDecorator } from "../../Model/ModelDecorator";
import { SPARQLBuilder } from "../../SPARQL/SPARQLBuilder";
import { SPARQLService } from "../../SPARQL/SPARQLService";
import { _getErrorResponseParserFn } from "../Utils";
export const SPARQLDocumentsRepositoryTrait = {
    PROTOTYPE: {
        executeASKQuery(uri, askQuery, requestOptions) {
            if (!this.context.registry.inScope(uri, true))
                return Promise.reject(new IllegalArgumentError(`"${uri}" is out of scope.`));
            const url = this.context.getObjectSchema().resolveURI(uri, { base: true });
            requestOptions = requestOptions ? requestOptions : {};
            RequestUtils.setAcceptHeader("application/ld+json; q=0.9", requestOptions);
            return SPARQLService
                .executeASKQuery(url, askQuery, requestOptions)
                .then(([rawResults]) => rawResults)
                .catch(_getErrorResponseParserFn(this.context.registry));
        },
        executeSELECTQuery(uri, selectQuery, requestOptions) {
            if (!this.context.registry.inScope(uri, true))
                return Promise.reject(new IllegalArgumentError(`"${uri}" is out of scope.`));
            const url = this.context.getObjectSchema().resolveURI(uri, { base: true });
            requestOptions = requestOptions ? requestOptions : {};
            RequestUtils.setAcceptHeader("application/ld+json; q=0.9", requestOptions);
            return SPARQLService
                .executeSELECTQuery(url, selectQuery, this.context.registry, requestOptions)
                .then(([selectResults]) => selectResults)
                .catch(_getErrorResponseParserFn(this.context.registry));
        },
        executeUPDATE(uri, update, requestOptions) {
            if (!this.context.registry.inScope(uri, true))
                return Promise.reject(new IllegalArgumentError(`"${uri}" is out of scope.`));
            const url = this.context.getObjectSchema().resolveURI(uri, { base: true });
            return SPARQLService
                .executeUPDATE(url, update, requestOptions)
                .then(() => { })
                .catch(_getErrorResponseParserFn(this.context.registry));
        },
        sparql(uri) {
            if (!this.context.registry.inScope(uri, true))
                throw new IllegalArgumentError(`"${uri}" is out of scope.`);
            const url = this.context.getObjectSchema().resolveURI(uri, { base: true });
            const schema = this.context.registry.getGeneralSchema();
            let builder = new SPARQLBuilder(this, url)
                .base(schema.base)
                .vocab(schema.vocab);
            schema.prefixes.forEach((name, prefix) => {
                builder = builder.prefix(prefix, name);
            });
            return builder;
        },
    },
    isDecorated(object) {
        return ModelDecorator
            .hasPropertiesFrom(SPARQLDocumentsRepositoryTrait.PROTOTYPE, object);
    },
    decorate(object) {
        if (SPARQLDocumentsRepositoryTrait.isDecorated(object))
            return object;
        const target = ModelDecorator
            .decorateMultiple(object, GeneralRepository);
        return ModelDecorator
            .definePropertiesFrom(SPARQLDocumentsRepositoryTrait.PROTOTYPE, target);
    },
};

//# sourceMappingURL=SPARQLDocumentsRepositoryTrait.js.map
