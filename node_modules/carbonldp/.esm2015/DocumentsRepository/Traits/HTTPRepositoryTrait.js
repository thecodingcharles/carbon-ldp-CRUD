import * as tslib_1 from "tslib";
import { IllegalArgumentError } from "../../Errors/IllegalArgumentError";
import { GeneralRepository } from "../../GeneralRepository/GeneralRepository";
import { RequestService } from "../../HTTP/Request";
import { ModelDecorator } from "../../Model/ModelDecorator";
import { ResolvablePointer } from "../../Repository/ResolvablePointer";
export const HTTPRepositoryTrait = {
    PROTOTYPE: {
        get(uri, requestOptions) {
            if (!this.context.registry.inScope(uri, true))
                return Promise.reject(new IllegalArgumentError(`"${uri}" is out of scope.`));
            const url = this.context.getObjectSchema().resolveURI(uri, { base: true });
            if (this.context.registry.hasPointer(url, true)) {
                const resource = this.context.registry.getPointer(url, true);
                if (resource.$isResolved() && !(requestOptions && requestOptions.ensureLatest))
                    return Promise.resolve(resource);
            }
            return RequestService
                .get(url, requestOptions)
                .then((response) => {
                return this._parseResponseData(response, url);
            });
        },
        resolve(resource, requestOptions) {
            return this.get(resource.$id, requestOptions);
        },
        exists(uri, requestOptions) {
            if (!this.context.registry.inScope(uri, true))
                return Promise.reject(new IllegalArgumentError(`"${uri}" is out of scope.`));
            const url = this.context.getObjectSchema().resolveURI(uri, { base: true });
            return RequestService
                .head(url, requestOptions)
                .then(() => true)
                .catch((error) => {
                if ("response" in error && error.response.status === 404)
                    return false;
                return Promise.reject(error);
            });
        },
        refresh(resource, requestOptions) {
            if (!ResolvablePointer.is(resource))
                return Promise.reject(new IllegalArgumentError("The resource isn't a resolvable pointer."));
            if (!this.context.registry.inScope(resource.$id, true))
                return Promise.reject(new IllegalArgumentError(`"${resource.$id}" is out of scope.`));
            const url = this.context.getObjectSchema().resolveURI(resource.$id, { base: true });
            return RequestService
                .get(url, requestOptions)
                .then((response) => {
                return this._parseResponseData(response, url);
            })
                .catch((error) => {
                if ("response" in error && error.response.status === 304)
                    return resource;
                return Promise.reject(error);
            });
        },
        save(resource, requestOptions) {
            if (!ResolvablePointer.is(resource))
                return Promise.reject(new IllegalArgumentError("The resource isn't a resolvable pointer."));
            if (!this.context.registry.inScope(resource.$id, true))
                return Promise.reject(new IllegalArgumentError(`"${resource.$id}" is out of scope.`));
            const url = this.context.getObjectSchema().resolveURI(resource.$id, { base: true });
            if (!resource.$isDirty())
                return Promise.resolve(resource);
            const body = JSON.stringify(resource);
            return RequestService
                .put(url, body, requestOptions)
                .then(() => resource);
        },
        saveAndRefresh(resource, requestOptions) {
            return this
                .save(resource, requestOptions)
                .then(() => this.refresh(resource, requestOptions));
        },
        delete(uri, requestOptions) {
            if (!this.context.registry.inScope(uri, true))
                return Promise.reject(new IllegalArgumentError(`"${uri}" is out of scope.`));
            const url = this.context.getObjectSchema().resolveURI(uri, { base: true });
            return RequestService
                .delete(url, requestOptions)
                .then(() => {
                this.context.registry.removePointer(url);
            });
        },
        _parseResponseData(response, id) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const resolvable = this.context.registry
                    .getPointer(id, true);
                resolvable.$eTag = response.getETag();
                resolvable.$_resolved = true;
                return resolvable;
            });
        },
    },
    isDecorated(object) {
        return ModelDecorator
            .hasPropertiesFrom(HTTPRepositoryTrait.PROTOTYPE, object);
    },
    decorate(object) {
        if (HTTPRepositoryTrait.isDecorated(object))
            return object;
        const resource = ModelDecorator
            .decorateMultiple(object, GeneralRepository);
        return ModelDecorator
            .definePropertiesFrom(HTTPRepositoryTrait.PROTOTYPE, resource);
    },
};

//# sourceMappingURL=HTTPRepositoryTrait.js.map
