import { ConstructToken, IRIRefToken, PropertyToken, QueryToken, SubjectToken } from "sparqler/tokens";
import { IllegalArgumentError } from "../../Errors/IllegalArgumentError";
import { IllegalStateError } from "../../Errors/IllegalStateError";
import { FreeResources } from "../../FreeResources/FreeResources";
import { RequestUtils } from "../../HTTP/Request";
import { JSONLDParser } from "../../JSONLD/JSONLDParser";
import { ModelDecorator } from "../../Model/ModelDecorator";
import { Pointer } from "../../Pointer/Pointer";
import { QueryContainer } from "../../QueryDocuments/QueryContainer";
import { QueryContainerPropertyType } from "../../QueryDocuments/QueryContainerPropertyType";
import { QueryDocumentBuilder } from "../../QueryDocuments/QueryDocumentBuilder";
import { QueryDocumentsBuilder } from "../../QueryDocuments/QueryDocumentsBuilder";
import { QueryMetadata } from "../../QueryDocuments/QueryMetadata";
import { QueryPropertyType } from "../../QueryDocuments/QueryPropertyType";
import { QueryResultCompacter } from "../../QueryDocuments/QueryResultCompacter";
import { _areDifferentType, _getPathProperty } from "../../QueryDocuments/Utils";
import { RDFDocument } from "../../RDF/Document";
import { URI } from "../../RDF/URI";
import { SPARQLService } from "../../SPARQL/SPARQLService";
import { isBoolean, isDate, isFunction, isNumber, isString, UUIDUtils } from "../../Utils";
import { C } from "../../Vocabularies/C";
import { _getErrorResponseParserFn } from "../Utils";
import { LDPDocumentsRepositoryTrait } from "./LDPDocumentsRepositoryTrait";
function __executeQueryBuilder(queryContainer, queryData) {
    const queryBuilder = "containerPropertyType" in queryContainer._queryProperty
        ? new QueryDocumentsBuilder(queryContainer, queryContainer._queryProperty)
        : new QueryDocumentBuilder(queryContainer, queryContainer._queryProperty);
    if (queryData.rootType !== void 0)
        queryContainer._queryProperty
            .setType(queryData.rootType);
    if (queryData.queryBuilderFn && queryData.queryBuilderFn.call(void 0, queryBuilder) !== queryBuilder)
        throw new IllegalArgumentError("The provided query builder was not returned");
}
function __sortQueryDocuments(queryContainer, documents) {
    if (!("order" in queryContainer._queryProperty) || !queryContainer._queryProperty.order)
        return documents;
    const { path, flow } = queryContainer._queryProperty.order;
    const inverter = flow === "DESC" ? -1 : 1;
    return documents.sort((a, b) => {
        a = _getPathProperty(a, path);
        b = _getPathProperty(b, path);
        const aValue = Pointer.is(a) ? a.$id : a;
        const bValue = Pointer.is(b) ? b.$id : b;
        if (aValue === bValue)
            return 0;
        if (aValue === void 0)
            return -1 * inverter;
        if (bValue === void 0)
            return inverter;
        if (!_areDifferentType(a, b)) {
            if (Pointer.is(a)) {
                const aIsBNode = URI.isBNodeID(aValue);
                const bIsBNode = URI.isBNodeID(bValue);
                if (aIsBNode && !bIsBNode)
                    return -1 * inverter;
                if (bIsBNode && !aIsBNode)
                    return inverter;
            }
        }
        else {
            if (Pointer.is(a))
                return -1 * inverter;
            if (Pointer.is(b))
                return inverter;
            if (isNumber(a))
                return -1 * inverter;
            if (isNumber(b))
                return inverter;
            if (isDate(a))
                return -1 * inverter;
            if (isDate(b))
                return inverter;
            if (isBoolean(a))
                return -1 * inverter;
            if (isBoolean(b))
                return inverter;
            if (isString(a))
                return -1 * inverter;
            if (isString(b))
                return inverter;
        }
        if (aValue < bValue)
            return -1 * inverter;
        if (aValue > bValue)
            return inverter;
        return 0;
    });
}
function __requestQueryDocuments(repository, url, requestOptions, queryContainer) {
    const construct = new ConstructToken()
        .addTriple(new SubjectToken(new IRIRefToken(`cldp-sdk://metadata-${UUIDUtils.generate()}`))
        .addProperty(new PropertyToken("a")
        .addObject(queryContainer.compactIRI(C.VolatileResource))
        .addObject(queryContainer.compactIRI(C.QueryMetadata)))
        .addProperty(new PropertyToken(queryContainer.compactIRI(C.target))
        .addObject(queryContainer._queryProperty.identifier)))
        .addTriple(...queryContainer._queryProperty.getConstructPatterns())
        .addPattern(...queryContainer._queryProperty.getSearchPatterns());
    const query = new QueryToken(construct)
        .addPrologues(...queryContainer.getPrologues());
    RequestUtils.setRetrievalPreferences({ include: [C.PreferResultsContexts] }, requestOptions);
    return SPARQLService
        .executeRawCONSTRUCTQuery(url, query.toString(), requestOptions)
        .then(([strConstruct]) => strConstruct)
        .then((jsonldString) => {
        return new JSONLDParser().parse(jsonldString);
    })
        .then((rdfNodes) => {
        const freeNodes = RDFDocument.getFreeNodes(rdfNodes);
        const freeResources = FreeResources
            .parseFreeNodes(repository.context.registry, freeNodes);
        const targetDocuments = freeResources
            .getPointers(true)
            .filter(QueryMetadata.is)
            .map(x => x.targets)
            .reduce((targets, x) => targets.concat(x), [])
            .map(x => x.$id);
        const rdfDocuments = rdfNodes
            .filter(RDFDocument.is);
        return new QueryResultCompacter(repository.context.registry, queryContainer)
            .compactDocuments(rdfDocuments, targetDocuments);
    })
        .then(documents => __sortQueryDocuments(queryContainer, documents))
        .catch(_getErrorResponseParserFn(repository.context.registry));
}
function __requestRelations(repository, uri, requestOptions, queryData) {
    if (!repository.context.registry.inScope(uri, true))
        return Promise.reject(new IllegalArgumentError(`"${uri}" is out of scope.`));
    const url = repository.context
        .getObjectSchema()
        .resolveURI(uri, { base: true });
    const queryContainer = new QueryContainer(repository.context, {
        containerPropertyType: queryData.containerPropertyType,
        uri: url,
    });
    __executeQueryBuilder(queryContainer, queryData);
    return __requestQueryDocuments(repository, url, requestOptions, queryContainer);
}
function __requestDocuments(repository, uris, requestOptions, queryData) {
    for (const uri of uris) {
        if (!repository.context.registry.inScope(uri, true))
            return Promise.reject(new IllegalArgumentError(`"${uri}" is out of scope.`));
    }
    const urls = uris.map(uri => repository.context
        .getObjectSchema()
        .resolveURI(uri, { base: true }));
    const queryContainer = new QueryContainer(repository.context, {
        uris: urls,
    });
    __executeQueryBuilder(queryContainer, queryData);
    const url = urls.length === 1 ? urls[0] : repository.context.baseURI;
    RequestUtils.setRetrievalPreferences({ include: [C.PreferDocumentChecksums] }, requestOptions);
    return __requestQueryDocuments(repository, url, requestOptions, queryContainer);
}
function __getQueryable(repository, uri, requestOptions, queryBuilderFn) {
    return __requestDocuments(repository, [uri], requestOptions, { queryBuilderFn })
        .then((documents) => documents[0]);
}
function __addRefreshProperties(parentProperty, queryableProperty) {
    queryableProperty.subProperties.forEach((subProperty, propertyName) => {
        const queryProperty = parentProperty._addSubProperty(propertyName, subProperty);
        __addRefreshProperties(queryProperty, subProperty);
    });
}
function __refreshQueryable(repository, document, requestOptions = {}) {
    if (!repository.context.registry.inScope(document.$id, true))
        return Promise.reject(new IllegalArgumentError(`"${document.$id}" is out of scope.`));
    const url = repository.context
        .getObjectSchema()
        .resolveURI(document.$id, { base: true });
    const queryContainer = new QueryContainer(repository.context, { uris: [url] });
    __addRefreshProperties(queryContainer._queryProperty, document.$_queryableMetadata);
    RequestUtils.setRetrievalPreferences({ include: [C.PreferDocumentChecksums] }, requestOptions);
    return __requestQueryDocuments(repository, url, requestOptions, queryContainer)
        .then((documents) => documents[0]);
}
export const QueryableDocumentsRepositoryTrait = {
    PROTOTYPE: {
        get(uriOrURIs, requestOptionsOrQueryBuilderFn, queryBuilderFn) {
            const requestOptions = typeof requestOptionsOrQueryBuilderFn === "object" ?
                requestOptionsOrQueryBuilderFn : {};
            queryBuilderFn = isFunction(requestOptionsOrQueryBuilderFn) ?
                requestOptionsOrQueryBuilderFn : queryBuilderFn;
            if (typeof uriOrURIs !== "string") {
                return __requestDocuments(this, uriOrURIs, requestOptions, {
                    rootType: queryBuilderFn ? void 0 : QueryPropertyType.FULL,
                    queryBuilderFn,
                });
            }
            const uri = uriOrURIs;
            const target = this.context.registry.hasPointer(uri) ?
                this.context.registry.getPointer(uri, true) :
                void 0;
            if (queryBuilderFn) {
                const types = target ? target.types : [];
                return __getQueryable(this, uri, requestOptions, _ => {
                    types.forEach(type => _.withType(type));
                    return queryBuilderFn.call(void 0, _);
                });
            }
            if (target && target.$isQueried())
                requestOptions.ensureLatest = true;
            return LDPDocumentsRepositoryTrait.PROTOTYPE
                .get.call(this, uri, requestOptions)
                .then(document => {
                if (!document.$_queryableMetadata)
                    return document;
                const resources = document.$getFragments();
                resources.push(document);
                resources.forEach(resource => {
                    resource.$_queryableMetadata = void 0;
                });
                return document;
            });
        },
        resolve(document, requestOptionsOrQueryBuilderFn, queryBuilderFn) {
            return this.get(document.$id, requestOptionsOrQueryBuilderFn, queryBuilderFn);
        },
        refresh(document, requestOptions) {
            if (!document.$isQueried())
                return LDPDocumentsRepositoryTrait.PROTOTYPE
                    .refresh.call(this, document, requestOptions);
            return __refreshQueryable(this, document, requestOptions);
        },
        saveAndRefresh(document, requestOptions) {
            if (!document.$_queryableMetadata)
                return LDPDocumentsRepositoryTrait.PROTOTYPE
                    .saveAndRefresh.call(this, document, requestOptions);
            if (document.$eTag === null)
                return Promise.reject(new IllegalStateError(`The document "${document.$id}" is locally outdated and cannot be saved.`));
            const cloneOptions = RequestUtils.cloneOptions(requestOptions || {});
            return this.save(document, cloneOptions)
                .then(doc => {
                return __refreshQueryable(this, doc, requestOptions);
            });
        },
        getChildren(uri, requestOptionsOrQueryBuilderFn, queryBuilderFn) {
            const requestOptions = typeof requestOptionsOrQueryBuilderFn === "object" ?
                requestOptionsOrQueryBuilderFn : {};
            queryBuilderFn = isFunction(requestOptionsOrQueryBuilderFn) ?
                requestOptionsOrQueryBuilderFn : queryBuilderFn;
            RequestUtils.setRetrievalPreferences({ include: [C.PreferDocumentChecksums] }, requestOptions);
            return __requestRelations(this, uri, requestOptions, {
                rootType: queryBuilderFn ? void 0 : QueryPropertyType.FULL,
                containerPropertyType: QueryContainerPropertyType.CHILD,
                queryBuilderFn,
            });
        },
        getMembers(uri, requestOptionsOrQueryBuilderFn, queryBuilderFn) {
            const requestOptions = typeof requestOptionsOrQueryBuilderFn === "object" ?
                requestOptionsOrQueryBuilderFn : {};
            queryBuilderFn = isFunction(requestOptionsOrQueryBuilderFn) ?
                requestOptionsOrQueryBuilderFn : queryBuilderFn;
            RequestUtils.setRetrievalPreferences({ include: [C.PreferDocumentChecksums] }, requestOptions);
            return __requestRelations(this, uri, requestOptions, {
                rootType: queryBuilderFn ? void 0 : QueryPropertyType.FULL,
                containerPropertyType: QueryContainerPropertyType.MEMBER,
                queryBuilderFn,
            });
        },
        listChildren(uri, requestOptions = {}) {
            return __requestRelations(this, uri, requestOptions, {
                containerPropertyType: QueryContainerPropertyType.CHILD,
                rootType: QueryPropertyType.EMPTY,
            });
        },
        listMembers(uri, requestOptions = {}) {
            return __requestRelations(this, uri, requestOptions, {
                rootType: QueryPropertyType.EMPTY,
                containerPropertyType: QueryContainerPropertyType.MEMBER,
            });
        },
    },
    isDecorated(object) {
        return ModelDecorator
            .hasPropertiesFrom(QueryableDocumentsRepositoryTrait.PROTOTYPE, object);
    },
    decorate(object) {
        if (QueryableDocumentsRepositoryTrait.isDecorated(object))
            return object;
        const target = ModelDecorator
            .decorateMultiple(object, LDPDocumentsRepositoryTrait);
        return ModelDecorator
            .definePropertiesFrom(QueryableDocumentsRepositoryTrait.PROTOTYPE, target);
    },
};

//# sourceMappingURL=QueryableDocumentsRepositoryTrait.js.map
