import { TransientDocument } from "../../Document/TransientDocument";
import { IllegalArgumentError } from "../../Errors/IllegalArgumentError";
import { FreeResources } from "../../FreeResources/FreeResources";
import { BadResponseError } from "../../HTTP/Errors/ServerErrors/BadResponseError";
import { RequestService, RequestUtils } from "../../HTTP/Request";
import { JSONLDParser } from "../../JSONLD/JSONLDParser";
import { AddMemberAction } from "../../LDP/AddMemberAction";
import { RemoveMemberAction } from "../../LDP/RemoveMemberAction";
import { ResponseMetadata } from "../../LDP/ResponseMetadata";
import { DeltaCreator } from "../../LDPatch/DeltaCreator";
import { ModelDecorator } from "../../Model/ModelDecorator";
import { Pointer } from "../../Pointer/Pointer";
import { RDFDocument } from "../../RDF/Document";
import { ResolvablePointer } from "../../Repository/ResolvablePointer";
import { isString } from "../../Utils";
import { C } from "../../Vocabularies/C";
import { LDP } from "../../Vocabularies/LDP";
import { _getErrorResponseParserFn } from "../Utils";
import { HTTPRepositoryTrait } from "./HTTPRepositoryTrait";
const __JSONLD_PARSER = new JSONLDParser();
function __setDefaultRequestOptions(requestOptions, interactionModel) {
    if (interactionModel)
        RequestUtils.setPreferredInteractionModel(interactionModel, requestOptions);
    RequestUtils.setAcceptHeader("application/ld+json", requestOptions);
}
function __getTargetID(id, response) {
    const locationHeader = response.getHeader("Content-Location");
    if (!locationHeader)
        return id;
    if (locationHeader.values.length !== 1)
        throw new BadResponseError("The response must contain one Content-Location header.", response);
    const locationString = "" + locationHeader;
    if (!locationString)
        throw new BadResponseError(`The response doesn't contain a valid 'Content-Location' header.`, response);
    return locationString;
}
function __getErrorResponseParserFnFrom(repository) {
    return _getErrorResponseParserFn(repository.context.registry);
}
function __changeNodesID(resource, map) {
    map
        .entries
        .forEach(({ entryKey, entryValue }) => {
        const node = resource
            .$getPointer(entryKey.$id, true);
        resource.$removePointer(entryKey.$id);
        node.$id = entryValue.$id;
        resource.$_addPointer(node);
    });
}
function __applyResponseMetadata(repository, freeNodes) {
    if (!freeNodes.length)
        return;
    const freeResources = FreeResources.parseFreeNodes(repository.context.registry, freeNodes);
    const responseMetadata = freeResources
        .getPointers(true)
        .find(ResponseMetadata.is);
    if (!responseMetadata)
        return;
    responseMetadata
        .documentsMetadata
        .forEach(metadata => __changeNodesID(metadata.relatedDocument, metadata.bNodesMap));
}
function __applyResponseRepresentation(repository, resource, response) {
    if (response.status === 204 || !response.data)
        return resource;
    return __JSONLD_PARSER
        .parse(response.data)
        .then((expandedResult) => {
        const freeNodes = RDFDocument.getFreeNodes(expandedResult);
        __applyResponseMetadata(repository, freeNodes);
        const preferenceHeader = response.getHeader("Preference-Applied");
        if (preferenceHeader === null || !preferenceHeader.hasValue("return=representation"))
            return resource;
        return repository._parseResponseData(response, resource.$id);
    });
}
function __isInvalidChild(child) {
    return ResolvablePointer.is(child);
}
function __isPersistingChild(object) {
    return object["__CarbonLDP_persisting__"];
}
function __createChild(repository, parentURI, requestOptions, child, slug) {
    if (ResolvablePointer.is(child))
        throw new IllegalArgumentError("Cannot persist an already resolvable pointer.");
    const transient = TransientDocument.is(child) ?
        child : TransientDocument.decorate(child);
    transient.$_normalize();
    transient.$registry = repository.context.registry;
    const body = JSON.stringify(transient);
    if (!!slug)
        RequestUtils.setSlug(slug, requestOptions);
    Object.defineProperty(transient, "__CarbonLDP_persisting__", { configurable: true, value: true });
    return RequestService
        .post(parentURI, body, requestOptions)
        .then((response) => {
        delete transient["__CarbonLDP_persisting__"];
        const locationHeader = response.getHeader("Location");
        if (locationHeader === null || locationHeader.values.length < 1)
            throw new BadResponseError("The response is missing a Location header.", response);
        if (locationHeader.values.length !== 1)
            throw new BadResponseError("The response contains more than one Location header.", response);
        transient.$id = locationHeader.values[0].toString();
        const document = repository.context.registry._addPointer(transient);
        document
            .$getFragments()
            .forEach(document.$__modelDecorator.decorate);
        return __applyResponseRepresentation(repository, document, response);
    })
        .catch((error) => {
        delete transient["__CarbonLDP_persisting__"];
        return __getErrorResponseParserFnFrom(repository)(error);
    });
}
function __createChildren(retrievalType, repository, uri, children, slugsOrOptions, requestOptions) {
    if (!repository.context.registry.inScope(uri, true))
        return Promise.reject(new IllegalArgumentError(`"${uri}" is out of scope.`));
    const url = repository.context.getObjectSchema().resolveURI(uri, { base: true });
    requestOptions = RequestUtils.isOptions(slugsOrOptions) ?
        slugsOrOptions :
        requestOptions ? requestOptions : {};
    const slugs = isString(slugsOrOptions) || Array.isArray(slugsOrOptions) ?
        slugsOrOptions : null;
    __setDefaultRequestOptions(requestOptions, LDP.Container);
    RequestUtils.setPreferredRetrieval(retrievalType, requestOptions);
    RequestUtils.setContentTypeHeader("application/ld+json", requestOptions);
    if (!Array.isArray(children)) {
        if (__isInvalidChild(children))
            return Promise.reject(new IllegalArgumentError(`The object is already a resolvable pointer.`));
        if (__isPersistingChild(children))
            return Promise.reject(new IllegalArgumentError(`The object is already being persisted.`));
        return __createChild(repository, url, requestOptions, children, slugs ? slugs.toString() : undefined);
    }
    const invalidChild = children
        .findIndex(child => __isInvalidChild(child));
    if (invalidChild !== -1)
        return Promise.reject(new IllegalArgumentError(`The object in "${invalidChild}" is already a resolvable pointer.`));
    const persistingChild = children
        .findIndex(child => __isPersistingChild(child));
    if (persistingChild !== -1)
        return Promise.reject(new IllegalArgumentError(`The object in "${persistingChild}" is already being persisted.`));
    const promises = children.map((child, index) => {
        const cloneOptions = RequestUtils.cloneOptions(requestOptions);
        const slug = slugs && index < slugs.length ? slugs[index] : void 0;
        return __createChild(repository, url, cloneOptions, child, slug);
    });
    return Promise.all(promises);
}
function __sendPatch(repository, document, requestOptions) {
    if (!ResolvablePointer.is(document))
        return Promise.reject(new IllegalArgumentError("The document isn't a resolvable pointer."));
    if (!repository.context.registry.inScope(document.$id))
        return Promise.reject(new IllegalArgumentError(`"${document.$id}" is out of scope.`));
    const url = repository.context.getObjectSchema().resolveURI(document.$id, { base: true });
    if (!document.$isDirty())
        return Promise.resolve(document);
    document.$_normalize();
    __setDefaultRequestOptions(requestOptions);
    RequestUtils.setContentTypeHeader("text/ldpatch", requestOptions);
    RequestUtils.setIfMatchHeader(document.$eTag, requestOptions);
    const deltaCreator = new DeltaCreator(repository.context);
    deltaCreator.addResource(document.$id, document.$_snapshot, document);
    document
        .$getPointers(true)
        .forEach((pointer) => {
        deltaCreator.addResource(pointer.$id, pointer.$_snapshot, pointer);
    });
    document.$__savedFragments
        .filter(pointer => !document.$hasPointer(pointer.$id))
        .forEach(pointer => {
        deltaCreator.addResource(pointer.$id, pointer.$_snapshot, {});
    });
    const body = deltaCreator.getPatch();
    return RequestService
        .patch(url, body, requestOptions)
        .then((response) => {
        return __applyResponseRepresentation(repository, document, response);
    })
        .catch(__getErrorResponseParserFnFrom(repository));
}
function __parseMembers(registry, pointers) {
    return pointers
        .map(pointer => {
        if (isString(pointer))
            return registry.getPointer(pointer);
        if (Pointer.is(pointer))
            return pointer;
    })
        .filter((pointer) => !!pointer);
}
function __sendAddAction(repository, uri, members, requestOptions = {}) {
    if (!repository.context.registry.inScope(uri, true))
        return Promise.reject(new IllegalArgumentError(`"${uri}" is out of scope.`));
    const url = repository.context.getObjectSchema().resolveURI(uri, { base: true });
    __setDefaultRequestOptions(requestOptions, LDP.Container);
    RequestUtils.setContentTypeHeader("application/ld+json", requestOptions);
    const freeResources = FreeResources.createFrom({ registry: repository.context.registry });
    const targetMembers = __parseMembers(repository.context.registry, members);
    freeResources._addPointer(AddMemberAction.createFrom({ targetMembers }));
    const body = JSON.stringify(freeResources);
    return RequestService
        .put(url, body, requestOptions)
        .then(() => { })
        .catch(__getErrorResponseParserFnFrom(repository));
}
function __sendRemoveAction(repository, uri, members, requestOptions = {}) {
    if (!repository.context.registry.inScope(uri, true))
        return Promise.reject(new IllegalArgumentError(`"${uri}" is out of scope.`));
    const url = repository.context.getObjectSchema().resolveURI(uri, { base: true });
    __setDefaultRequestOptions(requestOptions, LDP.Container);
    RequestUtils.setContentTypeHeader("application/ld+json", requestOptions);
    RequestUtils.setRetrievalPreferences({
        include: [C.PreferSelectedMembershipTriples],
        omit: [C.PreferMembershipTriples],
    }, requestOptions);
    const freeResources = FreeResources.createFrom({ registry: repository.context.registry });
    const targetMembers = __parseMembers(repository.context.registry, members);
    freeResources._addPointer(RemoveMemberAction.createFrom({ targetMembers }));
    const body = JSON.stringify(freeResources);
    return RequestService
        .delete(url, body, requestOptions)
        .then(() => { })
        .catch(__getErrorResponseParserFnFrom(repository));
}
function __sendRemoveAll(repository, uri, requestOptions = {}) {
    if (!repository.context.registry.inScope(uri, true))
        return Promise.reject(new IllegalArgumentError(`"${uri}" is out of scope.`));
    const url = repository.context.getObjectSchema().resolveURI(uri, { base: true });
    __setDefaultRequestOptions(requestOptions, LDP.Container);
    RequestUtils.setRetrievalPreferences({
        include: [
            C.PreferMembershipTriples,
        ],
        omit: [
            C.PreferMembershipResources,
            C.PreferContainmentTriples,
            C.PreferContainmentResources,
            C.PreferContainer,
        ],
    }, requestOptions);
    return RequestService
        .delete(url, requestOptions)
        .then(() => { })
        .catch(__getErrorResponseParserFnFrom(repository));
}
export const LDPDocumentsRepositoryTrait = {
    PROTOTYPE: {
        get(uri, requestOptions = {}) {
            __setDefaultRequestOptions(requestOptions, LDP.RDFSource);
            return HTTPRepositoryTrait.PROTOTYPE
                .get.call(this, uri, requestOptions)
                .catch(__getErrorResponseParserFnFrom(this));
        },
        exists(uri, requestOptions = {}) {
            __setDefaultRequestOptions(requestOptions, LDP.RDFSource);
            return HTTPRepositoryTrait.PROTOTYPE
                .exists.call(this, uri, requestOptions)
                .catch(__getErrorResponseParserFnFrom(this));
        },
        create(uri, children, slugsOrOptions, requestOptions) {
            return __createChildren("minimal", this, uri, children, slugsOrOptions, requestOptions);
        },
        createAndRetrieve(uri, children, slugsOrOptions, requestOptions) {
            return __createChildren("representation", this, uri, children, slugsOrOptions, requestOptions);
        },
        refresh(document, requestOptions = {}) {
            __setDefaultRequestOptions(requestOptions, LDP.RDFSource);
            RequestUtils.setIfNoneMatchHeader(document.$eTag, requestOptions);
            return HTTPRepositoryTrait.PROTOTYPE
                .refresh.call(this, document, requestOptions)
                .catch(__getErrorResponseParserFnFrom(this));
        },
        save(document, requestOptions = {}) {
            RequestUtils.setPreferredRetrieval("minimal", requestOptions);
            return __sendPatch(this, document, requestOptions);
        },
        saveAndRefresh(document, requestOptions = {}) {
            RequestUtils.setPreferredRetrieval("representation", requestOptions);
            return __sendPatch(this, document, requestOptions);
        },
        delete(uri, requestOptions = {}) {
            __setDefaultRequestOptions(requestOptions, LDP.RDFSource);
            return HTTPRepositoryTrait.PROTOTYPE
                .delete.call(this, uri, requestOptions)
                .catch(__getErrorResponseParserFnFrom(this));
        },
        addMember(uri, member, requestOptions) {
            return __sendAddAction(this, uri, [member], requestOptions);
        },
        addMembers(uri, members, requestOptions) {
            return __sendAddAction(this, uri, members, requestOptions);
        },
        removeMember(uri, member, requestOptions) {
            return __sendRemoveAction(this, uri, [member], requestOptions);
        },
        removeMembers(uri, membersOrOptions, requestOptions) {
            if (Array.isArray(membersOrOptions))
                return __sendRemoveAction(this, uri, membersOrOptions, requestOptions);
            return __sendRemoveAll(this, uri, membersOrOptions || requestOptions);
        },
        _parseResponseData(response, id) {
            return __JSONLD_PARSER
                .parse(response.data)
                .then((rdfNodes) => {
                const rdfDocuments = RDFDocument
                    .getDocuments(rdfNodes);
                id = __getTargetID(id, response);
                const rdfDocument = rdfDocuments.find(doc => doc["@id"] === id);
                if (!rdfDocument)
                    throw new BadResponseError(`No document "${id}" was returned.`, response);
                const document = this.context.registry.register(id);
                const previousFragments = new Set();
                document
                    .$getPointers(true)
                    .forEach(pointer => previousFragments.add(pointer.$id));
                const elements = rdfDocument["@graph"].map(node => {
                    const target = document.$getPointer(node["@id"]);
                    const schema = this.context.registry.getSchemaFor(node);
                    this.context.jsonldConverter.update(target, node, schema, document);
                    if ("$document" in target)
                        previousFragments.delete(target.$id);
                    return target;
                });
                previousFragments
                    .forEach(pointer => document.$removePointer(pointer));
                elements.forEach(element => {
                    element.$_syncSnapshot();
                    this.context.registry.decorate(element);
                });
                document.$eTag = response.getETag();
                document.$_resolved = true;
                return document;
            });
        },
    },
    isDecorated(object) {
        return ModelDecorator
            .hasPropertiesFrom(LDPDocumentsRepositoryTrait.PROTOTYPE, object);
    },
    decorate(object) {
        if (LDPDocumentsRepositoryTrait.isDecorated(object))
            return object;
        const target = ModelDecorator
            .decorateMultiple(object, HTTPRepositoryTrait);
        return ModelDecorator
            .definePropertiesFrom(LDPDocumentsRepositoryTrait.PROTOTYPE, target);
    },
};

//# sourceMappingURL=LDPDocumentsRepositoryTrait.js.map
