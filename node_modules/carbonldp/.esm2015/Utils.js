export function hasFunction(object, functionName) {
    return typeof object[functionName] === "function";
}
export function hasProperty(object, property) {
    if (!object)
        return false;
    return isDefined(object[property]);
}
export function hasPropertyDefined(object, property) {
    if (!object)
        return false;
    return !!Object.getOwnPropertyDescriptor(object, property);
}
export function isDefined(value) {
    return void 0 !== value;
}
export function isNull(value) {
    return value === null;
}
export function isArray(object) {
    return Array.isArray(object);
}
export function isString(value) {
    return typeof value === "string" || value instanceof String;
}
export function isBoolean(value) {
    return typeof value === "boolean";
}
export function isNumber(value) {
    return typeof value === "number" || value instanceof Number;
}
export function isInteger(value) {
    if (!isNumber(value))
        return false;
    return value % 1 === 0;
}
export function isDouble(value) {
    if (!isNumber(value))
        return false;
    return value % 1 !== 0;
}
export function isDate(date) {
    return date instanceof Date || (typeof date === "object" && Object.prototype.toString.call(date) === "[object Date]");
}
export function isObject(object) {
    return typeof object === "object" && (!!object);
}
export function isPlainObject(object) {
    return isObject(object)
        && !isArray(object)
        && !isDate(object)
        && !isMap(object)
        && !(typeof Blob !== "undefined" && object instanceof Blob)
        && !(Object.prototype.toString.call(object) === "[object Set]");
}
export function isFunction(value) {
    return typeof value === "function";
}
export function isMap(value) {
    return (isObject(value) &&
        hasFunction(value, "get") &&
        hasFunction(value, "has") &&
        hasProperty(value, "size") &&
        hasFunction(value, "clear") &&
        hasFunction(value, "delete") &&
        hasFunction(value, "entries") &&
        hasFunction(value, "forEach") &&
        hasFunction(value, "get") &&
        hasFunction(value, "has") &&
        hasFunction(value, "keys") &&
        hasFunction(value, "set") &&
        hasFunction(value, "values"));
}
export function parseBoolean(value) {
    if (!isString(value))
        return false;
    switch (value.toLowerCase()) {
        case "true":
        case "yes":
        case "y":
        case "1":
            return true;
        case "false":
        case "no":
        case "n":
        case "0":
        default:
            return false;
    }
}
export function promiseMethod(fn) {
    return new Promise(resolve => resolve(fn ? fn() : void 0));
}
export class ArrayUtils {
    static from(iterator) {
        let array = [];
        let next = iterator.next();
        while (!next.done) {
            array.push(next.value);
            next = iterator.next();
        }
        return array;
    }
    static joinWithoutDuplicates(...arrays) {
        let result = arrays[0].slice();
        for (let i = 1, length = arrays.length; i < length; i++) {
            result = result.concat(arrays[i].filter(function (item) {
                return result.indexOf(item) < 0;
            }));
        }
        return result;
    }
}
export class ObjectUtils {
    static extend(target, source, config = { arrays: false, objects: false }) {
        if (!isArray(source) && !isPlainObject(source) || !isArray(target) && !isPlainObject(target))
            return;
        source.__CarbonSDK_circularReferenceFlag = target;
        for (const key of Object.keys(source)) {
            if (isFunction(source[key]) || key === "__CarbonSDK_circularReferenceFlag")
                continue;
            let property = source[key];
            if (isArray(property) && config.arrays || isPlainObject(property) && config.objects) {
                if ("__CarbonSDK_circularReferenceFlag" in property) {
                    property = property.__CarbonSDK_circularReferenceFlag;
                }
                else {
                    property = !(key in target) || target[key].constructor !== property.constructor ?
                        ObjectUtils.clone(property, config) :
                        ObjectUtils.extend(target[key], property, config);
                }
            }
            if (property === null) {
                if (target[key])
                    delete target[key];
                continue;
            }
            target[key] = property;
        }
        delete source.__CarbonSDK_circularReferenceFlag;
        return target;
    }
    static clone(object, config = { arrays: false, objects: false }) {
        let isAnArray = isArray(object);
        if (!isAnArray && !isPlainObject(object))
            return;
        let clone = (isAnArray ? [] : Object.create(Object.getPrototypeOf(object)));
        return ObjectUtils.extend(clone, object, config);
    }
    static areEqual(object1, object2, config = { arrays: false, objects: false }, ignore = {}) {
        return internalAreEqual(object1, object2, config, [object1], [object2], ignore);
    }
    static areShallowlyEqual(object1, object2) {
        if (object1 === object2)
            return true;
        if (!isObject(object1) || !isObject(object2))
            return false;
        let properties = [];
        for (let propertyName in object1) {
            if (!object1.hasOwnProperty(propertyName))
                continue;
            if (isFunction(object1[propertyName]))
                continue;
            if (!(propertyName in object2))
                return false;
            if (object1[propertyName] !== object2[propertyName])
                return false;
            properties.push(propertyName);
        }
        for (let propertyName in object2) {
            if (!object2.hasOwnProperty(propertyName))
                continue;
            if (isFunction(object2[propertyName]))
                continue;
            if (!(propertyName in object1))
                return false;
            if (properties.indexOf(propertyName) === -1)
                return false;
        }
        return true;
    }
}
function internalAreEqual(object1, object2, config, stack1, stack2, ignore = {}) {
    if (object1 === object2)
        return true;
    if (!isObject(object1) || !isObject(object2))
        return false;
    if (isDate(object1))
        return object1.getTime() === object2.getTime();
    let keys = ArrayUtils.joinWithoutDuplicates(Object.keys(object1), Object.keys(object2));
    for (let key of keys) {
        if (key in ignore)
            continue;
        if (!(key in object1) || !(key in object2))
            return false;
        if (typeof object1[key] !== typeof object2[key])
            return false;
        if (isFunction(object1[key]))
            continue;
        let firstIsPlainObject = isPlainObject(object1[key]);
        if (isArray(object1[key]) && config.arrays ||
            firstIsPlainObject && config.objects ||
            isDate(object1[key])) {
            if (firstIsPlainObject) {
                let lengthStack = stack1.length;
                while (lengthStack--) {
                    if (stack1[lengthStack] === object1[key])
                        return stack2[lengthStack] === object2[key];
                }
                stack1.push(object1[key]);
                stack2.push(object2[key]);
            }
            if (!internalAreEqual(object1[key], object2[key], config, stack1, stack2))
                return false;
            if (firstIsPlainObject) {
                stack1.pop();
                stack2.pop();
            }
        }
        else {
            if (object1[key] !== object2[key])
                return false;
        }
    }
    return true;
}
export class StringUtils {
    static startsWith(str, substring) {
        return str.lastIndexOf(substring, 0) === 0;
    }
    static endsWith(str, substring) {
        return str.indexOf(substring, str.length - substring.length) !== -1;
    }
    static contains(str, substring) {
        return str.indexOf(substring) !== -1;
    }
}
export class MapUtils {
    static from(object) {
        let map = new Map();
        for (const name of Object.keys(object)) {
            map.set(name, object[name]);
        }
        return map;
    }
    static extend(toExtend, ...extenders) {
        for (const extender of extenders) {
            if (!extender)
                continue;
            extender.forEach((value, key) => toExtend.set(key, value));
        }
        return toExtend;
    }
}
export class UUIDUtils {
    static is(uuid) {
        return UUIDUtils.regExp.test(uuid);
    }
    static generate() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
            let r = Math.random() * 16 | 0;
            let v = c === "x" ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
}
UUIDUtils.regExp = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
export function _isExistingValue(value) {
    return value !== null && value !== void 0;
}

//# sourceMappingURL=Utils.js.map
