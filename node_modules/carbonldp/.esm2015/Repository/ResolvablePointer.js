import { _parseResourceParams, _parseURIParams } from "../DocumentsRepository/Utils";
import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { ModelDecorator } from "../Model/ModelDecorator";
import { Pointer } from "../Pointer/Pointer";
import { isFunction, isObject, ObjectUtils } from "../Utils";
function __internalRevert(target, source) {
    if (!isObject(target) || !isObject(source))
        return;
    new Set([
        ...Object.keys(target),
        ...Object.keys(source),
    ]).forEach(key => {
        const sourceValue = Array.isArray(source[key]) ?
            [...source[key]] : source[key];
        if (sourceValue === null || sourceValue === void 0) {
            delete target[key];
            return;
        }
        if (isFunction(sourceValue))
            return;
        target[key] = sourceValue;
    });
}
export const ResolvablePointer = {
    PROTOTYPE: {
        get $repository() {
            throw new IllegalArgumentError(`Property "$repository" is required.`);
        },
        $eTag: void 0,
        $_resolved: false,
        $isResolved() {
            return this.$_resolved;
        },
        $_snapshot: {},
        $_syncSnapshot() {
            const clone = ObjectUtils.clone(this, { arrays: true });
            if (this.types)
                clone.types = [...this.types];
            this.$_snapshot = clone;
        },
        $isDirty() {
            return !ObjectUtils
                .areEqual(this, this.$_snapshot, { arrays: true });
        },
        $revert() {
            __internalRevert(this, this.$_snapshot);
            if (!this.types)
                this.types = [];
        },
        $get(uri) {
            const { _uri, _args } = _parseURIParams(this, uri, arguments);
            return "$id" in this.$repository ?
                this.$repository.$get(_uri, ..._args) :
                this.$repository.get(_uri, ..._args);
        },
        $resolve(resource) {
            const { _resource, _args } = _parseResourceParams(this, resource, arguments);
            return "$id" in this.$repository ?
                this.$repository.$resolve(_resource, ..._args) :
                this.$repository.resolve(_resource, ..._args);
        },
        $exists(uri) {
            const { _uri, _args } = _parseURIParams(this, uri, arguments);
            return "$id" in this.$repository ?
                this.$repository.$exists(_uri, ..._args) :
                this.$repository.exists(_uri, ..._args);
        },
        $refresh(resource, ...args) {
            const { _resource, _args } = _parseResourceParams(this, resource, arguments);
            return "$id" in this.$repository ?
                this.$repository.$refresh(_resource, ..._args) :
                this.$repository.refresh(_resource, ..._args);
        },
        $save(resource, ...args) {
            const { _resource, _args } = _parseResourceParams(this, resource, arguments);
            return "$id" in this.$repository ?
                this.$repository.$save(_resource, ..._args) :
                this.$repository.save(_resource, ..._args);
        },
        $saveAndRefresh(resource, ...args) {
            const { _resource, _args } = _parseResourceParams(this, resource, arguments);
            return "$id" in this.$repository ?
                this.$repository.$saveAndRefresh(_resource, ..._args) :
                this.$repository.saveAndRefresh(_resource, ..._args);
        },
        $delete(uri, ...args) {
            const { _uri, _args } = _parseURIParams(this, uri, arguments);
            return "$id" in this.$repository ?
                this.$repository.$delete(_uri, ..._args) :
                this.$repository.delete(_uri, ..._args);
        },
    },
    isDecorated(object) {
        return ModelDecorator
            .hasPropertiesFrom(ResolvablePointer.PROTOTYPE, object);
    },
    decorate(object) {
        if (ResolvablePointer.isDecorated(object))
            return object;
        const resource = ModelDecorator
            .decorateMultiple(object, Pointer);
        return ModelDecorator
            .definePropertiesFrom(ResolvablePointer.PROTOTYPE, resource);
    },
    is(value) {
        return Pointer.is(value)
            && ResolvablePointer.isDecorated(value);
    },
};

//# sourceMappingURL=ResolvablePointer.js.map
