import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { IllegalStateError } from "../Errors/IllegalStateError";
import { Pointer } from "../Pointer/Pointer";
import { isObject } from "../Utils";
import { QueryObject } from "./QueryObject";
import { QueryPropertyType } from "./QueryPropertyType";
import { QueryValue } from "./QueryValue";
export class QueryDocumentBuilder {
    constructor(queryContainer, queryProperty) {
        this.inherit = QueryDocumentBuilder.INHERIT;
        this.all = QueryDocumentBuilder.ALL;
        this._queryContainer = queryContainer;
        this._queryProperty = queryProperty;
    }
    property(name) {
        let parent = this._queryProperty;
        while (parent) {
            const property = parent.getProperty(name, { create: true });
            if (property)
                return property.identifier;
            parent = parent.parent;
        }
        throw new IllegalArgumentError(`The property "${name}" was not declared.`);
    }
    value(value) {
        return new QueryValue(this._queryContainer, value);
    }
    object(object) {
        const id = Pointer.getID(object);
        return new QueryObject(this._queryContainer, id);
    }
    withType(type) {
        if (this._queryProperty.hasProperties())
            throw new IllegalStateError("Types must be specified before the properties.");
        this._queryProperty.addType(type);
        return this;
    }
    properties(propertiesSchema) {
        if (propertiesSchema === QueryDocumentBuilder.ALL) {
            this._queryProperty.setType(QueryPropertyType.ALL);
            return this;
        }
        if (propertiesSchema === QueryDocumentBuilder.FULL) {
            this._queryProperty.setType(QueryPropertyType.FULL);
            return this;
        }
        this._queryProperty.setType(QueryPropertyType.PARTIAL);
        for (const propertyName in propertiesSchema) {
            const queryPropertySchema = propertiesSchema[propertyName];
            const querySchemaProperty = isObject(queryPropertySchema)
                ? queryPropertySchema : { "@id": queryPropertySchema };
            const property = this._queryProperty
                .addProperty(propertyName, querySchemaProperty);
            const subQuery = querySchemaProperty.query;
            if (!subQuery)
                continue;
            const builder = new SubQueryDocumentsBuilder(this._queryContainer, property);
            if (builder !== subQuery.call(void 0, builder))
                throw new IllegalArgumentError("The provided query builder was not returned");
        }
        return this;
    }
}
QueryDocumentBuilder.ALL = Object.freeze({});
QueryDocumentBuilder.FULL = Object.freeze({});
QueryDocumentBuilder.INHERIT = Object.freeze({});
export class SubQueryDocumentsBuilder extends QueryDocumentBuilder {
    filter(constraint) {
        this._queryProperty
            .addFilter(constraint);
        return this;
    }
    values(...values) {
        const tokens = values
            .map(value => {
            const token = value.getToken();
            if (token.token === "blankNode")
                throw new IllegalArgumentError(`Cannot assign blank nodes ("${token.label}").`);
            if (this._queryProperty.definition.literal) {
                if (token.token !== "literal")
                    throw new IllegalArgumentError(`"${token}" is not a literal value.`);
            }
            if (this._queryProperty.definition.pointerType !== null) {
                if (token.token === "literal")
                    throw new IllegalArgumentError(`"${token}" is not a resource value.`);
            }
            return token;
        });
        this._queryProperty.addValues(tokens);
        this._queryProperty.setObligatory({ inheritParents: true });
        return this;
    }
}

//# sourceMappingURL=QueryDocumentBuilder.js.map
