import { LimitToken, OffsetToken, OrderToken, PropertyToken, SubjectToken, SubSelectToken } from "sparqler/tokens";
import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { IllegalStateError } from "../Errors/IllegalStateError";
import { DigestedObjectSchemaProperty } from "../ObjectSchema/DigestedObjectSchemaProperty";
import { LDP } from "../Vocabularies/LDP";
import { QueryContainerPropertyType } from "./QueryContainerPropertyType";
import { QueryProperty } from "./QueryProperty";
import { QueryPropertyType } from "./QueryPropertyType";
export class QueryContainerProperty extends QueryProperty {
    constructor(data) {
        super({
            queryContainer: data.queryContainer,
            name: data.containerPropertyType,
            definition: new DigestedObjectSchemaProperty(),
            optional: false,
            propertyType: QueryPropertyType.PARTIAL,
        });
        this.containerIRI = data.containerIRI;
        this.containerPropertyType = data.containerPropertyType;
    }
    __createSelfPattern() {
        const subSelect = new SubSelectToken("DISTINCT")
            .addVariable(this.variable);
        switch (this.containerPropertyType) {
            case QueryContainerPropertyType.CHILD:
                subSelect.addPattern(this.__createChildSelfPattern());
                break;
            case QueryContainerPropertyType.MEMBER:
                subSelect.addPattern(...this.__createMemberSelfPattern());
                break;
            default:
                throw new IllegalStateError(`Invalid container type.`);
        }
        const valuedPatterns = this.__getValuedPatterns();
        if (valuedPatterns)
            subSelect.addPattern(...valuedPatterns);
        this.__addOrderTo(subSelect);
        this.__addLimitTo(subSelect);
        this.__addOffsetTo(subSelect);
        return subSelect;
    }
    __createChildSelfPattern() {
        return new SubjectToken(this.containerIRI)
            .addProperty(new PropertyToken(this.queryContainer.compactIRI(LDP.contains))
            .addObject(this.identifier));
    }
    __createMemberSelfPattern() {
        const membershipResource = this.queryContainer.getVariable("membershipResource");
        const hasMemberRelation = this.queryContainer.getVariable("hasMemberRelation");
        const memberRelations = new SubSelectToken()
            .addVariable(membershipResource, hasMemberRelation)
            .addPattern(new SubjectToken(this.containerIRI)
            .addProperty(new PropertyToken(this.queryContainer.compactIRI(LDP.membershipResource))
            .addObject(membershipResource))
            .addProperty(new PropertyToken(this.queryContainer.compactIRI(LDP.hasMemberRelation))
            .addObject(hasMemberRelation)));
        const memberSelection = new SubjectToken(membershipResource)
            .addProperty(new PropertyToken(hasMemberRelation)
            .addObject(this.identifier));
        return [memberRelations, memberSelection];
    }
    __addLimitTo(subSelect) {
        if (this._limit === void 0)
            return;
        subSelect.addModifier(new LimitToken(this._limit));
    }
    __addOffsetTo(subSelect) {
        if (this._offset === void 0)
            return;
        subSelect.addModifier(new OffsetToken(this._offset));
    }
    __addOrderTo(subSelect) {
        if (!this.order)
            return;
        const targetProperty = this.getProperty(this.order.path, { create: true });
        if (!targetProperty)
            throw new IllegalArgumentError(`Property "${this.order.path}" hasn't been defined.`);
        const identifier = targetProperty.identifier;
        const constraint = identifier.token === "variable"
            ? identifier
            : `( ${identifier} )`;
        subSelect.addModifier(new OrderToken(constraint, this.order.flow));
        const orderPatterns = this.__createSubPatternsFrom(targetProperty);
        orderPatterns
            .filter(pattern => {
            if (pattern.token !== "subject")
                return true;
            const targetSubject = subSelect
                .where.groupPattern.patterns
                .find((selectPattern) => {
                if (selectPattern.token !== "subject")
                    return false;
                return selectPattern.subject === pattern.subject;
            });
            if (!targetSubject)
                return true;
            pattern.properties.forEach(property => {
                const targetPredicate = targetSubject
                    .properties
                    .find((selectProperty) => {
                    return property.toString() === selectProperty.toString();
                });
                if (!targetPredicate)
                    targetSubject.addProperty(property);
                property.objects.forEach(object => {
                    const targetObject = targetPredicate
                        .objects
                        .find((selectObject) => {
                        return selectObject.toString() === object.toString();
                    });
                    if (!targetObject)
                        targetPredicate.addObject(object);
                });
            });
        })
            .forEach(pattern => {
            subSelect.addPattern(pattern);
        });
    }
    __createSubPatternsFrom(targetProperty) {
        let matchPatterns = [];
        while (targetProperty !== this) {
            const subTargetPattern = targetProperty.getSelfPattern();
            if (subTargetPattern.token !== "optional") {
                matchPatterns.unshift(subTargetPattern);
            }
            else {
                matchPatterns = [
                    subTargetPattern
                        .addPattern(...matchPatterns),
                ];
            }
            if (!targetProperty.parent)
                break;
            targetProperty = targetProperty.parent;
        }
        return matchPatterns;
    }
    __addTypesTo(pattern) { }
    setOrder(order) {
        this.order = order;
    }
    setLimit(limit) {
        this._limit = limit;
    }
    setOffset(offset) {
        this._offset = offset;
    }
}

//# sourceMappingURL=QueryContainerProperty.js.map
