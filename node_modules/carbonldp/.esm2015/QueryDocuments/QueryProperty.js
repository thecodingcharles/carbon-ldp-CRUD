import { PathBuilder } from "sparqler/patterns";
import { FilterToken, GraphToken, OptionalToken, PropertyToken, SubjectToken, ValuesToken } from "sparqler/tokens";
import { IllegalActionError } from "../Errors/IllegalActionError";
import { DigestedObjectSchema } from "../ObjectSchema/DigestedObjectSchema";
import { ObjectSchemaDigester } from "../ObjectSchema/ObjectSchemaDigester";
import { C } from "../Vocabularies/C";
import { QueryPropertyType } from "./QueryPropertyType";
import { _getBestType, _getMatchingDefinition, _getRootPath } from "./Utils";
export class QueryProperty {
    get variable() {
        return this.queryContainer
            .getVariable(this.fullName);
    }
    get identifier() {
        if (this.values.length === 1) {
            return this.values[0];
        }
        return this.queryContainer
            .getVariable(this.fullName);
    }
    constructor(data) {
        this.queryContainer = data.queryContainer;
        this.parent = data.parent;
        this.name = data.name;
        this.fullName = data.parent
            ? data.parent.fullName + "." + data.name
            : data.name;
        this.definition = data.definition;
        this.pathBuilderFn = data.pathBuilderFn;
        this.propertyType = data.propertyType;
        this.optional = data.optional === void 0
            ? true
            : data.optional;
        this.subProperties = new Map();
        this.values = data.values ? data.values : [];
        this._types = [];
        this._filters = [];
    }
    hasProperties() {
        return this.subProperties.size !== 0
            || this._isComplete();
    }
    getProperty(path, flags) {
        if (!path)
            return this;
        const rootPath = _getRootPath(path);
        const property = this.subProperties.get(rootPath);
        if (!property) {
            if (rootPath === path && flags && flags.create && this._isComplete()) {
                const newProperty = this.addProperty(rootPath, flags);
                if (this.propertyType === QueryPropertyType.FULL)
                    newProperty.setType(QueryPropertyType.ALL);
                return newProperty;
            }
            return;
        }
        const restPath = path.substr(rootPath.length + 1);
        return property.getProperty(restPath);
    }
    addProperty(propertyName, propertyDefinition) {
        const definition = this
            .__getDefinition(propertyName, propertyDefinition);
        return this._addSubProperty(propertyName, {
            definition,
            pathBuilderFn: propertyDefinition.path,
            optional: !propertyDefinition.required,
        });
    }
    _addSubProperty(propertyName, data) {
        const property = new QueryProperty(Object.assign({}, data, { name: propertyName, queryContainer: this.queryContainer, parent: this }));
        this.subProperties.set(propertyName, property);
        return property;
    }
    __getDefinition(propertyName, propertyDefinition) {
        const digestedDefinition = this.queryContainer
            .digestProperty(propertyName, propertyDefinition);
        if (propertyDefinition.inherit === false)
            return digestedDefinition;
        const propertyURI = "@id" in propertyDefinition ? digestedDefinition.uri : void 0;
        const inheritDefinition = this
            .__getInheritDefinition(propertyName, propertyURI);
        if (inheritDefinition) {
            for (const key in inheritDefinition) {
                if (digestedDefinition[key] !== null && key !== "uri")
                    continue;
                digestedDefinition[key] = inheritDefinition[key];
            }
        }
        return digestedDefinition;
    }
    __getInheritDefinition(propertyName, propertyURI) {
        const searchSchema = this._getSearchSchema();
        const localDefinition = _getMatchingDefinition(searchSchema, searchSchema, propertyName, propertyURI);
        if (localDefinition)
            return localDefinition;
        const schemas = this.queryContainer.context
            ._getTypeObjectSchemas(this._types);
        for (const targetSchema of schemas) {
            const definition = _getMatchingDefinition(searchSchema, targetSchema, propertyName, propertyURI);
            if (definition)
                return definition;
        }
    }
    _isComplete() {
        return this.propertyType === QueryPropertyType.ALL
            || this.propertyType === QueryPropertyType.FULL;
    }
    _isPartial() {
        return this.propertyType === QueryPropertyType.PARTIAL
            || this.propertyType === QueryPropertyType.ALL
            || !!this.subProperties.size;
    }
    _isEmpty() {
        return this.propertyType === undefined
            || this.propertyType === QueryPropertyType.EMPTY;
    }
    setType(type) {
        this.propertyType = _getBestType(this.propertyType, type);
    }
    addType(type) {
        const schema = this._getSearchSchema();
        const iri = schema.resolveURI(type, { vocab: true });
        this._types.push(iri);
        if (!this.queryContainer.context.hasObjectSchema(iri))
            return;
        const typedSchema = this.queryContainer.context.getObjectSchema(iri);
        ObjectSchemaDigester._combineSchemas([schema, typedSchema]);
    }
    addValues(values) {
        this.values.push(...values);
    }
    addFilter(constraint) {
        this._filters.push(constraint);
    }
    setObligatory(flags) {
        if (!this.optional)
            return;
        this.optional = false;
        if (flags && flags.inheritParents && this.parent)
            this.parent.setObligatory(flags);
    }
    _getVariable(name) {
        return this.queryContainer
            .getVariable(`${this.fullName}.${name}`);
    }
    __createIRIToken() {
        return this
            .queryContainer
            .compactIRI(this.definition.uri);
    }
    __createPathToken() {
        if (!this.pathBuilderFn)
            return this.__createIRIToken();
        const pathBuilder = PathBuilder
            .createFrom(this.queryContainer, {});
        return this.pathBuilderFn
            .call(void 0, pathBuilder)
            .getPath();
    }
    _getContextVariable() {
        if (this.propertyType === QueryPropertyType.FULL)
            return this.__getSelfToken();
        return this._getVariable("_graph");
    }
    _getContextGraph() {
        return new GraphToken(this._getContextVariable());
    }
    getSelfPattern() {
        const pattern = this.__createSelfPattern();
        if (!pattern)
            return;
        if (!this.optional)
            return pattern;
        return new OptionalToken()
            .addPattern(pattern);
    }
    __createSelfPattern() {
        if (!this.parent)
            throw new IllegalActionError("Cannot create pattern without a parent.");
        return this
            .__addPropertyTo(new SubjectToken(this.parent.identifier));
    }
    __addPropertyTo(subject) {
        return subject
            .addProperty(new PropertyToken(this.__createPathToken())
            .addObject(this.identifier));
    }
    getSearchPatterns() {
        const patterns = this
            .__createSearchPatterns();
        if (!this.optional)
            return patterns;
        return [new OptionalToken()
                .addPattern(...patterns),
        ];
    }
    __createSearchPatterns() {
        const patterns = [];
        const values = this.__createValuesPattern();
        if (values)
            patterns.push(values);
        const selfTriple = this.__createSelfPattern();
        if (selfTriple) {
            if (this.parent && !this.pathBuilderFn) {
                patterns.push(this.parent._getContextGraph()
                    .addPattern(selfTriple));
            }
            else {
                patterns.push(selfTriple);
            }
        }
        switch (this.propertyType) {
            case QueryPropertyType.EMPTY:
                patterns.push(this.__createTypesSearchPatterns());
                break;
            case QueryPropertyType.PARTIAL:
                patterns.push(...this.__createPartialSearchPatterns());
                break;
            case QueryPropertyType.ALL:
                patterns.push(this.__createSearchAllPattern());
                patterns.push(...this.__createSubPropertiesPatterns());
                break;
            case QueryPropertyType.FULL:
                patterns.push(this.__createSearchGraphPattern());
                patterns.push(...this.__createSubPropertiesPatterns());
                break;
            default:
                const selfTypeFilter = this.__createSelfTypeFilter();
                if (selfTypeFilter)
                    patterns.push(selfTypeFilter);
                break;
        }
        if (this._filters.length) {
            const filters = this._filters
                .map(constraint => new FilterToken(constraint));
            patterns.push(...filters);
        }
        return patterns;
    }
    __createValuesPattern() {
        if (this.values.length <= 1)
            return;
        const values = new ValuesToken()
            .addVariables(this.variable);
        this.values
            .forEach(value => values.addValues(value));
        return values;
    }
    __createSelfTypeFilter() {
        const identifier = this.identifier;
        if (this.definition.literal) {
            const literalToken = this.queryContainer
                .compactIRI(this.definition.literalType);
            if (identifier.token === "variable")
                return new FilterToken(`datatype( ${identifier} ) = ${literalToken}`);
        }
        if (this.definition.pointerType !== null && identifier.token === "variable")
            return new FilterToken(`! isLiteral( ${identifier} )`);
    }
    __createPartialSearchPatterns() {
        return [
            this.__createTypesSearchPatterns(),
            ...this.__createSubPropertiesPatterns(),
        ];
    }
    __createSubPropertiesPatterns() {
        const patterns = [];
        this.subProperties.forEach(subProperty => {
            patterns.push(...subProperty.getSearchPatterns());
        });
        return patterns;
    }
    __createTypesSearchPatterns() {
        const types = this.__createTypesPattern();
        const pattern = this.propertyType === QueryPropertyType.EMPTY
            ? types
            : this._getContextGraph()
                .addPattern(types);
        if (!this._types.length)
            return new OptionalToken()
                .addPattern(pattern);
        this.__addTypesTo(types);
        return pattern;
    }
    __addTypesTo(pattern) {
        const types = this
            .__createTypesTokens();
        let aProperty = pattern.properties
            .find(_ => _.verb === "a");
        if (!aProperty) {
            aProperty = new PropertyToken("a");
            pattern.addProperty(aProperty);
        }
        aProperty.objects
            .unshift(...types);
    }
    __createTypesTokens() {
        return this._types
            .map(type => this.queryContainer.compactIRI(type));
    }
    __createSearchAllPattern() {
        const pattern = this.__createAllPattern();
        if (this._types.length)
            this.__addTypesTo(pattern);
        return this
            ._getContextGraph()
            .addPattern(pattern);
    }
    __createSearchGraphPattern() {
        const graph = new GraphToken(this.__getSelfToken());
        if (this._types.length) {
            const pattern = new SubjectToken(this.__getSelfToken());
            this.__addTypesTo(pattern);
            graph.addPattern(pattern);
        }
        return graph
            .addPattern(this.__createGraphSubPattern());
    }
    __getValuedPatterns() {
        if (this.optional)
            return;
        const selfSubject = new SubjectToken(this.identifier);
        const patterns = [selfSubject];
        const valuesPattern = this.__createValuesPattern();
        if (valuesPattern)
            patterns.push(valuesPattern);
        if (this._types.length) {
            const typesTokens = this
                .__createTypesTokens();
            selfSubject
                .addProperty(new PropertyToken("a")
                .addObject(...typesTokens));
        }
        this.subProperties.forEach(subProperty => {
            const subPatterns = subProperty
                .__getValuedPatterns();
            if (subPatterns) {
                subProperty.__addPropertyTo(selfSubject);
                patterns.push(...subPatterns);
            }
        });
        if (!selfSubject.properties.length)
            return patterns.slice(1);
        return patterns;
    }
    getConstructPatterns() {
        const patterns = [];
        const selfPattern = this.__createSelfConstructPattern();
        if (selfPattern)
            patterns.push(selfPattern);
        this.subProperties.forEach(property => {
            const subPatterns = property
                .getConstructPatterns();
            patterns.push(...subPatterns);
        });
        return patterns;
    }
    __createSelfConstructPattern() {
        switch (this.propertyType) {
            case QueryPropertyType.EMPTY:
                return this.__createTypesPattern();
            case QueryPropertyType.PARTIAL:
                return this.__createPartialConstructPattern();
            case QueryPropertyType.ALL:
            case QueryPropertyType.FULL:
                return this.__createCompleteConstructPattern()
                    .addProperty(new PropertyToken(this.queryContainer.compactIRI(C.document))
                    .addObject(this._getContextVariable()));
            default:
                return;
        }
    }
    __createCompleteConstructPattern() {
        switch (this.propertyType) {
            case QueryPropertyType.ALL:
                return this.__createAllPattern();
            case QueryPropertyType.FULL:
                return this.__createGraphSubPattern();
            default:
                throw new IllegalActionError("Invalid property type");
        }
    }
    __createPartialConstructPattern() {
        const subject = this.__createTypesPattern()
            .addProperty(new PropertyToken(this.queryContainer.compactIRI(C.document))
            .addObject(this._getContextVariable()));
        this.subProperties.forEach(subProperty => {
            subject.addProperty(new PropertyToken(subProperty.__createIRIToken())
                .addObject(subProperty.identifier));
        });
        return subject;
    }
    __createTypesPattern() {
        return new SubjectToken(this.identifier)
            .addProperty(new PropertyToken("a")
            .addObject(this._getVariable("types")));
    }
    __createAllPattern() {
        return new SubjectToken(this.__getSelfToken())
            .addProperty(new PropertyToken(this._getVariable("_predicate"))
            .addObject(this._getVariable("_object")));
    }
    __createGraphSubPattern() {
        return new SubjectToken(this._getVariable("_subject"))
            .addProperty(new PropertyToken(this._getVariable("_predicate"))
            .addObject(this._getVariable("_object")));
    }
    __getSelfToken() {
        const identifier = this.identifier;
        if (identifier.token === "literal")
            throw new IllegalActionError(`Property is not a resource.`);
        return identifier;
    }
    getSchemaFor(object) {
        switch (this.propertyType) {
            case void 0:
                return new DigestedObjectSchema();
            case QueryPropertyType.EMPTY:
            case QueryPropertyType.PARTIAL:
                return this.__createSchema();
            default:
                return ObjectSchemaDigester._combineSchemas([
                    this.queryContainer.context.registry.getSchemaFor(object),
                    this.__createSchema(),
                ]);
        }
    }
    __createSchema() {
        const schema = new DigestedObjectSchema();
        this.subProperties.forEach(property => {
            schema.properties.set(property.name, property.definition);
        });
        return schema;
    }
    _getSearchSchema() {
        if (this._searchSchema)
            return this._searchSchema;
        return this._searchSchema = this.queryContainer.getGeneralSchema();
    }
}

//# sourceMappingURL=QueryProperty.js.map
