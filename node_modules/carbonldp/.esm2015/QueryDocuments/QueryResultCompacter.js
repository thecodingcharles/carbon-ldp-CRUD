import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { DigestedObjectSchemaProperty } from "../ObjectSchema/DigestedObjectSchemaProperty";
import { Pointer } from "../Pointer/Pointer";
import { RDFNode } from "../RDF/Node";
import { _isExistingValue } from "../Utils";
import { C } from "../Vocabularies/C";
import { XSD } from "../Vocabularies/XSD";
import { QueryableProperty } from "./QueryableProperty";
import { QueryableRootProperty } from "./QueryableRootProperty";
import { QueryPropertyType } from "./QueryPropertyType";
export class QueryResultCompacter {
    get jsonldConverter() {
        return this.queryContainer.context.jsonldConverter;
    }
    constructor(registry, queryContainer) {
        this.registry = registry;
        this.queryContainer = queryContainer;
    }
    compactDocuments(rdfDocuments, targetDocuments) {
        if (!targetDocuments)
            targetDocuments = rdfDocuments.map(x => x["@id"]);
        const compactionMap = new Map();
        rdfDocuments.forEach(rdfDocument => {
            const document = this.registry.getPointer(rdfDocument["@id"], true);
            if (!document.$_queryableMetadata) {
                document.$_queryableMetadata = new QueryableRootProperty({
                    uri: document.$id,
                    propertyType: QueryPropertyType.PARTIAL,
                });
            }
            const previousFragments = new Set();
            document
                .$getPointers(true)
                .forEach(pointer => previousFragments.add(pointer.$id));
            rdfDocument["@graph"].forEach(rdfNode => {
                const nodeID = rdfNode["@id"];
                const resource = nodeID !== rdfDocument["@id"]
                    ? document.$getPointer(nodeID, true)
                    : document;
                compactionMap.set(nodeID, {
                    node: rdfNode,
                    document: document,
                    resource: resource,
                });
                previousFragments.delete(nodeID);
            });
            previousFragments
                .forEach(pointer => document.$removePointer(pointer));
        });
        targetDocuments.forEach(documentID => {
            const compactionNode = compactionMap.get(documentID);
            if (!compactionNode)
                throw new IllegalArgumentError(`Invalid data provided.`);
            const queryProperty = this.queryContainer._queryProperty;
            const metadataProperty = compactionNode.resource.$_queryableMetadata;
            this.__processNode(compactionMap, compactionNode, queryProperty, metadataProperty);
        });
        compactionMap.forEach(({ node, resource, document, isCompacted }) => {
            if (!isCompacted) {
                const targetNode = Object.assign({}, node, { [C.document]: undefined, [C.checksum]: undefined });
                const targetSchema = this.queryContainer.context.registry.getSchemaFor(targetNode);
                this.jsonldConverter.update(resource, targetNode, targetSchema, document);
                resource.$_queryableMetadata = void 0;
            }
            this.registry.decorate(resource);
        });
        rdfDocuments
            .map(RDFNode.getID)
            .map(id => compactionMap.get(id))
            .filter(_isExistingValue)
            .forEach(({ resource, node }) => {
            resource.$_syncSnapshot();
            const rawValues = node[C.checksum];
            if (!rawValues || typeof rawValues === "string")
                return;
            const [eTag] = RDFNode.getPropertyLiterals(rawValues, XSD.string);
            if (!eTag)
                return;
            resource.$eTag = `"${eTag}"`;
            resource.$_resolved = true;
        });
        return targetDocuments.map(id => {
            return compactionMap
                .get(id)
                .resource;
        });
    }
    __processNode(compactionMap, compactionNode, queryProperty, metadataProperty) {
        const { node, document, resource } = compactionNode;
        compactionNode.isCompacted = true;
        const targetSchema = queryProperty.getSchemaFor(node);
        const pointerLibrary = __createPointerLibrary(compactionMap, document);
        const targetNode = Object.assign({}, node, { [C.document]: undefined, [C.checksum]: undefined });
        this.jsonldConverter
            .update(resource, targetNode, targetSchema, pointerLibrary, !queryProperty._isComplete());
        if (!queryProperty._isPartial()) {
            resource.$_queryableMetadata = void 0;
            return;
        }
        queryProperty.subProperties.forEach((subQueryProperty, propertyName) => {
            if (resource.hasOwnProperty(propertyName) && subQueryProperty.pathBuilderFn) {
                Object.defineProperty(resource, propertyName, {
                    enumerable: false,
                    configurable: true,
                    writable: true,
                });
            }
            const subMetadataProperty = metadataProperty
                .getProperty(propertyName, subQueryProperty);
            if (!resource.hasOwnProperty(propertyName))
                return;
            if (subQueryProperty.propertyType === void 0)
                return;
            const values = Array.isArray(resource[propertyName])
                ? resource[propertyName]
                : [resource[propertyName]];
            values.forEach(value => {
                if (!Pointer.is(value))
                    return;
                const subCompactionNode = compactionMap.get(value.$id);
                if (!subCompactionNode)
                    throw new IllegalArgumentError(`Invalid data provided.`);
                if (subCompactionNode.resource.$_queryableMetadata) {
                    subCompactionNode.resource.$_queryableMetadata
                        .mergeData(propertyName, subMetadataProperty);
                    if (subCompactionNode.document === document && !subCompactionNode.isCompacted) {
                        metadataProperty
                            .setProperty(propertyName, subCompactionNode.resource.$_queryableMetadata);
                    }
                    else {
                        subMetadataProperty.propertyType = void 0;
                    }
                }
                else {
                    if (subCompactionNode.document === document) {
                        subCompactionNode.resource.$_queryableMetadata = subMetadataProperty;
                    }
                    else {
                        subCompactionNode.resource.$_queryableMetadata = new QueryableProperty({
                            propertyType: subMetadataProperty.propertyType,
                            optional: subMetadataProperty.optional,
                            definition: Object.assign(new DigestedObjectSchemaProperty(), subMetadataProperty.definition, {
                                uri: null,
                            }),
                        });
                        subMetadataProperty.propertyType = void 0;
                    }
                }
                this.__processNode(compactionMap, subCompactionNode, subQueryProperty, subCompactionNode.resource.$_queryableMetadata);
            });
        });
    }
}
function __createPointerLibrary(compactionMap, document) {
    return {
        hasPointer(id) {
            if (compactionMap.has(id))
                return true;
            return document.$hasPointer(id);
        },
        getPointer(id) {
            if (compactionMap.has(id))
                return compactionMap
                    .get(id)
                    .resource;
            return document
                .$getPointer(id);
        },
    };
}

//# sourceMappingURL=QueryResultCompacter.js.map
