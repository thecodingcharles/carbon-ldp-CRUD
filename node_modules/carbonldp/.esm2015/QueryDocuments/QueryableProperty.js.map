{"version":3,"sources":["QueryDocuments/QueryableProperty.ts"],"names":[],"mappings":"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","file":"QueryableProperty.js","sourcesContent":["import { Path, PathBuilder } from \"sparqler/patterns\";\nimport { IRIToken, LiteralToken } from \"sparqler/tokens\";\n\nimport { IllegalArgumentError } from \"../Errors/IllegalArgumentError\";\n\nimport { DigestedObjectSchema } from \"../ObjectSchema/DigestedObjectSchema\";\nimport { DigestedObjectSchemaProperty } from \"../ObjectSchema/DigestedObjectSchemaProperty\";\n\nimport { QueryablePropertyData } from \"./QueryablePropertyData\";\nimport { QueryPropertyType } from \"./QueryPropertyType\";\nimport { _getBestType } from \"./Utils\";\n\n\n/**\n * Metadata of a resource that has been queried.\n *\n * It is used in {@link QueryablePointer.$_queryableMetadata}.\n */\nexport class QueryableProperty {\n\treadonly definition:DigestedObjectSchemaProperty;\n\treadonly pathBuilderFn?:( pathBuilder:PathBuilder ) => Path;\n\n\tpropertyType?:QueryPropertyType;\n\toptional:boolean;\n\n\treadonly subProperties:Map<string, QueryableProperty>;\n\n\treadonly values:(IRIToken | LiteralToken)[];\n\n\n\tconstructor( data:QueryablePropertyData ) {\n\t\tthis.definition = data.definition;\n\t\tthis.pathBuilderFn = data.pathBuilderFn;\n\n\t\tthis.propertyType = data.propertyType;\n\n\t\tthis.optional = data.optional;\n\n\t\tthis.subProperties = new Map();\n\n\t\tthis.values = data.values\n\t\t\t? data.values\n\t\t\t: [];\n\t}\n\n\n\t/**\n\t * Sets the type of content of the property.\n\t * @param type\n\t */\n\tsetType( type:QueryPropertyType ):void {\n\t\tthis.propertyType = _getBestType( this.propertyType!, type );\n\t}\n\n\n\t/**\n\t * Stores the property with the specified name.\n\t * @param propertyName Name of the property to store.\n\t * @param property The property to be stored.\n\t */\n\tsetProperty( propertyName:string, property:QueryableProperty ):void {\n\t\tthis.subProperties.set( propertyName, property );\n\t}\n\n\t/**\n\t * Gets an existing property identified by the specified name, optionally merging with a {@param data} provided.\n\t * If the property doesn't exists, one will be created using the suggested {@param data}.\n\t * @param propertyName Name of the property to get/create.\n\t * @param data The optional data of the property to create.\n\t */\n\tgetProperty( propertyName:string, data?:QueryablePropertyData ):QueryableProperty {\n\t\tif( ! this.subProperties.has( propertyName ) ) {\n\t\t\tif( ! data )\n\t\t\t\tthrow new Error( `Property \"${propertyName}\" doesn't exists.` );\n\n\t\t\tconst property:QueryableProperty = new QueryableProperty( data );\n\n\t\t\tthis.subProperties.set( propertyName, property );\n\t\t\treturn property;\n\n\t\t} else {\n\t\t\tconst property:QueryableProperty = this.subProperties.get( propertyName )!;\n\n\t\t\tif( data ) property\n\t\t\t\t.mergeData( propertyName, data );\n\n\t\t\treturn property;\n\t\t}\n\t}\n\n\n\t/**\n\t * Merge the provided {@param data} into the current property.\n\t * @param propertyName Name of the current property.\n\t * @param data Data to be merged.\n\t */\n\tmergeData( propertyName:string, data:QueryablePropertyData ):void {\n\t\tif( this === data ) return;\n\n\t\tthis.setType( data.propertyType! );\n\t\tthis.__mergeDefinition( propertyName, data.definition );\n\t}\n\n\t// TODO: Improve merging\n\tprotected __mergeDefinition( propertyName:string, newDefinition:DigestedObjectSchemaProperty ):void {\n\t\tfor( const key in newDefinition ) {\n\t\t\tconst oldValue:any = this.definition[ key ];\n\t\t\tconst newValue:any = newDefinition[ key ];\n\n\t\t\tif( oldValue === null )\n\t\t\t\tthis.definition[ key ] = newValue;\n\n\t\t\tif( newValue !== oldValue ) {\n\t\t\t\tthrow new IllegalArgumentError( `Property \"${propertyName}\" has different \"${key}\": \"${oldValue}\", \"${newValue}\".` );\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Returns the schema generated with the definitions of the stored properties.\n\t */\n\tgetSchema():DigestedObjectSchema {\n\t\tconst schema:DigestedObjectSchema = new DigestedObjectSchema();\n\n\t\tthis.subProperties.forEach( ( property, propertyName ) => {\n\t\t\tschema.properties.set( propertyName, property.definition );\n\t\t} );\n\n\t\treturn schema;\n\t}\n\n}\n"],"sourceRoot":"../../src"}