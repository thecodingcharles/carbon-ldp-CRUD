import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { DigestedObjectSchema } from "../ObjectSchema/DigestedObjectSchema";
import { _getBestType } from "./Utils";
export class QueryableProperty {
    constructor(data) {
        this.definition = data.definition;
        this.pathBuilderFn = data.pathBuilderFn;
        this.propertyType = data.propertyType;
        this.optional = data.optional;
        this.subProperties = new Map();
        this.values = data.values
            ? data.values
            : [];
    }
    setType(type) {
        this.propertyType = _getBestType(this.propertyType, type);
    }
    setProperty(propertyName, property) {
        this.subProperties.set(propertyName, property);
    }
    getProperty(propertyName, data) {
        if (!this.subProperties.has(propertyName)) {
            if (!data)
                throw new Error(`Property "${propertyName}" doesn't exists.`);
            const property = new QueryableProperty(data);
            this.subProperties.set(propertyName, property);
            return property;
        }
        else {
            const property = this.subProperties.get(propertyName);
            if (data)
                property
                    .mergeData(propertyName, data);
            return property;
        }
    }
    mergeData(propertyName, data) {
        if (this === data)
            return;
        this.setType(data.propertyType);
        this.__mergeDefinition(propertyName, data.definition);
    }
    __mergeDefinition(propertyName, newDefinition) {
        for (const key in newDefinition) {
            const oldValue = this.definition[key];
            const newValue = newDefinition[key];
            if (oldValue === null)
                this.definition[key] = newValue;
            if (newValue !== oldValue) {
                throw new IllegalArgumentError(`Property "${propertyName}" has different "${key}": "${oldValue}", "${newValue}".`);
            }
        }
    }
    getSchema() {
        const schema = new DigestedObjectSchema();
        this.subProperties.forEach((property, propertyName) => {
            schema.properties.set(propertyName, property.definition);
        });
        return schema;
    }
}

//# sourceMappingURL=QueryableProperty.js.map
