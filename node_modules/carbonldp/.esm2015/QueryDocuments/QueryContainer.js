import { IRIResolver } from "sparqler/data";
import { isPrefixed } from "sparqler/iri";
import { DeniableFluentPath, FluentPath, FluentPathContainer } from "sparqler/patterns";
import { IRIRefToken, PrefixToken } from "sparqler/tokens";
import { IllegalArgumentError } from "../Errors/IllegalArgumentError";
import { ObjectSchemaDigester } from "../ObjectSchema/ObjectSchemaDigester";
import { QueryContainerProperty } from "./QueryContainerProperty";
import { QueryRootProperty } from "./QueryRootProperty";
import { QueryVariable } from "./QueryVariable";
export class QueryContainer extends FluentPathContainer {
    constructor(context, propertyData) {
        const schema = context.getObjectSchema();
        super({
            iriResolver: __createIRIResolver(schema),
            targetToken: void 0,
            fluentPathFactory: FluentPath.createFrom,
            deniableFluentPathFactory: DeniableFluentPath.createFrom,
        });
        this.context = context;
        this._generalSchema = schema;
        this._prefixesTuples = Array.from(schema.prefixes);
        this._variablesCounter = 0;
        this._variablesMap = new Map();
        if ("uris" in propertyData) {
            const values = propertyData.uris.map(this.compactIRI, this);
            this._queryProperty = new QueryRootProperty({
                queryContainer: this,
                values: values,
            });
        }
        else {
            const iri = this.compactIRI(propertyData.uri);
            this._queryProperty = new QueryContainerProperty({
                queryContainer: this,
                containerIRI: iri,
                containerPropertyType: propertyData.containerPropertyType,
            });
        }
    }
    getVariable(name) {
        if (this._variablesMap.has(name))
            return this._variablesMap.get(name);
        const variable = new QueryVariable(name, this._variablesCounter++);
        this._variablesMap.set(name, variable);
        return variable;
    }
    compactIRI(iri) {
        const compactedIRI = this.__getCompactedIRI(iri);
        return this.iriResolver.resolve(compactedIRI);
    }
    __getCompactedIRI(iri) {
        if (isPrefixed(iri))
            return iri;
        const prefix = this._prefixesTuples
            .find(([, x]) => iri.startsWith(x));
        if (!prefix)
            return iri;
        const [namespace, prefixIRI] = prefix;
        return `${namespace}:${iri.substr(prefixIRI.length)}`;
    }
    getPrologues() {
        return this._prefixesTuples
            .filter(this.__isUsedPrefix, this)
            .map(__createPrefixToken);
    }
    __isUsedPrefix([namespace,]) {
        return !!this.iriResolver.prefixes.get(namespace);
    }
    digestProperty(name, definition) {
        return ObjectSchemaDigester
            .digestProperty(name, definition, this._generalSchema);
    }
    getGeneralSchema() {
        return ObjectSchemaDigester
            .combineDigestedObjectSchemas([this._generalSchema]);
    }
    serializeLiteral(type, value) {
        if (!this.context.jsonldConverter.literalSerializers.has(type))
            throw new IllegalArgumentError(`Type "${type}" hasn't a defined serializer.`);
        return this.context.jsonldConverter
            .literalSerializers
            .get(type)
            .serialize(value);
    }
}
function __createIRIResolver(schema) {
    const iriResolver = new IRIResolver(void 0, schema.vocab);
    Array.from(schema.prefixes.keys())
        .forEach(key => iriResolver.prefixes.set(key, false));
    return iriResolver;
}
function __createPrefixToken([namespace, iri]) {
    return new PrefixToken(namespace, new IRIRefToken(iri));
}

//# sourceMappingURL=QueryContainer.js.map
