import { DocumentsRegistry } from "../DocumentsRegistry/DocumentsRegistry";
import { DocumentsRepository } from "../DocumentsRepository/DocumentsRepository";
import { IllegalStateError } from "../Errors/IllegalStateError";
import { MessagingService } from "../Messaging/MessagingService";
import { URI } from "../RDF/URI";
import { isObject, isString, ObjectUtils } from "../Utils";
import { AbstractContext } from "./AbstractContext";
import { GlobalContext } from "./GlobalContext";
export class DocumentsContext extends AbstractContext {
    static __mergePaths(target, source) {
        if (!source)
            return target;
        if (!target)
            return ObjectUtils.clone(source, { objects: true });
        for (const key of Object.keys(source)) {
            const sourcePath = source[key];
            if (sourcePath === null) {
                delete target[key];
                continue;
            }
            const targetPath = target[key];
            if (!targetPath) {
                target[key] = isObject(sourcePath) ?
                    ObjectUtils.clone(sourcePath, { objects: true }) :
                    sourcePath;
                continue;
            }
            if (isString(sourcePath)) {
                if (isObject(targetPath)) {
                    targetPath.slug = sourcePath;
                }
                else {
                    target[key] = sourcePath;
                }
                continue;
            }
            if (sourcePath.slug === void 0 && sourcePath.paths === void 0)
                continue;
            const targetDocPaths = isString(targetPath) ?
                target[key] = { slug: targetPath } : targetPath;
            if (sourcePath.slug !== void 0)
                targetDocPaths.slug = sourcePath.slug;
            if (sourcePath.paths !== void 0)
                targetDocPaths.paths = DocumentsContext.__mergePaths(targetDocPaths.paths, sourcePath.paths);
        }
        return target;
    }
    constructor(url) {
        super(GlobalContext.instance);
        this._baseURI = url;
        this.registry = DocumentsRegistry.createFrom({ context: this });
        this.repository = DocumentsRepository.createFrom({ context: this });
        this.messaging = new MessagingService(this);
    }
    _resolvePath(path) {
        const leftSearchedPaths = path.split(".");
        const currentSearchedPaths = [];
        let url = "";
        let documentPaths = this._settings && this._settings.paths;
        while (leftSearchedPaths.length) {
            const containerKey = leftSearchedPaths.shift();
            currentSearchedPaths.push(containerKey);
            const containerPath = documentPaths ? documentPaths[containerKey] : null;
            if (!containerPath)
                throw new IllegalStateError(`The path "${currentSearchedPaths.join(".")}" hasn't been declared.`);
            const slug = isString(containerPath) ? containerPath : containerPath.slug;
            if (!slug)
                throw new IllegalStateError(`The path "${currentSearchedPaths.join(".")}" doesn't have a slug set.`);
            url = URI.resolve(url, slug);
            documentPaths = isObject(containerPath) ? containerPath.paths : undefined;
        }
        return this.resolve(url);
    }
    _extendPaths(paths) {
        this._settings.paths = DocumentsContext.__mergePaths(this._settings.paths, paths);
    }
    _extendsSettings(settings) {
        this._extendPaths(settings.paths);
        delete settings.paths;
        ObjectUtils.extend(this._settings, settings);
    }
}

//# sourceMappingURL=DocumentsContext.js.map
