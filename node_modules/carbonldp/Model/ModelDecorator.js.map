{"version":3,"sources":["Model/ModelDecorator.ts"],"names":[],"mappings":"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","file":"ModelDecorator.js","sourcesContent":["import { isFunction } from \"../Utils\";\n\n\n/**\n * Interface with the methods of a model decoration.\n */\nexport interface ModelDecorator<MODEL extends object, BASE extends object = object> {\n\t/**\n\t * Returns true if the object provided has the decorated properties and methods of a model.\n\t * @param object The object to check.\n\t */\n\tisDecorated( object:object ):object is MODEL;\n\n\t/**\n\t * Decorates an object with the correct prototypes to create a model.\n\t * @param object The object to decorate.\n\t */\n\tdecorate<W extends object>( object:W & BASE ):W & MODEL;\n}\n\n\n/**\n * Factory and utils for {@link ModelDecorator}.\n */\nexport interface ModelDecoratorFactory {\n\thasPropertiesFrom<P extends object, O extends object>( prototype:P, object:O ):boolean;\n\n\tdefinePropertiesFrom<P extends object, O extends object>( prototype:P, object:O ):O & P;\n\n\tdecorateMultiple<O extends B1, M1 extends object, B1 extends object>( object:O, model1:ModelDecorator<M1, B1> ):O & M1;\n\tdecorateMultiple<O extends B1 & Pick<B2, Exclude<keyof B2, keyof M1>>, M1 extends object, B1 extends object, M2 extends object, B2 extends object>( object:O, model1:ModelDecorator<M1, B1>, model2:ModelDecorator<M2, B2> ):O & M1 & M2;\n\tdecorateMultiple<O extends B1 & B2 & B3, M1 extends object, B1 extends object, M2 extends object, B2 extends object, M3 extends object, B3 extends object>( object:O, model1:ModelDecorator<M1, B1>, model2:ModelDecorator<M2, B2>, model3:ModelDecorator<M3, B3> ):O & M1 & M2 & M3;\n\tdecorateMultiple<O extends B1 & B2 & B3 & B4, M1 extends object, B1 extends object, M2 extends object, B2 extends object, M3 extends object, B3 extends object, M4 extends object, B4 extends object>( object:O, model1:ModelDecorator<M1, B1>, model2:ModelDecorator<M2, B2>, model3:ModelDecorator<M3, B3>, model4:ModelDecorator<M4, B4> ):O & M1 & M2 & M3 & M4;\n\tdecorateMultiple<O extends B1 & B2 & B3 & B4 & B5, M1 extends object, B1 extends object, M2 extends object, B2 extends object, M3 extends object, B3 extends object, M4 extends object, B4 extends object, M5 extends object, B5 extends object>( object:O, model1:ModelDecorator<M1, B1>, model2:ModelDecorator<M2, B2>, model3:ModelDecorator<M3, B3>, model4:ModelDecorator<M4, B4>, model5:ModelDecorator<M5, B5> ):O & M1 & M2 & M3 & M4 & M5;\n\tdecorateMultiple<O extends B1 & B2 & B3 & B4 & B5 & B6, M1 extends object, B1 extends object, M2 extends object, B2 extends object, M3 extends object, B3 extends object, M4 extends object, B4 extends object, M5 extends object, B5 extends object, M6 extends object, B6 extends object>( object:O, model1:ModelDecorator<M1, B1>, model2:ModelDecorator<M2, B2>, model3:ModelDecorator<M3, B3>, model4:ModelDecorator<M4, B4>, model5:ModelDecorator<M5, B5>, model6:ModelDecorator<M6, B6> ):O & M1 & M2 & M3 & M4 & M5 & M6;\n}\n\n/**\n * Constant that implements {@link ModelDecoratorFactory}.\n */\nexport const ModelDecorator:ModelDecoratorFactory = {\n\thasPropertiesFrom( prototype:object, object:object ):boolean {\n\t\tconst prototypeKeys:string[] = Object\n\t\t\t.keys( prototype );\n\n\t\tconst shouldAddDollar:boolean = \"$id\" in object\n\t\t\t&& ! prototypeKeys.some( key => key.startsWith( \"$\" ) );\n\n\t\treturn prototypeKeys\n\t\t\t.every( key => {\n\t\t\t\tconst targetKey:string = shouldAddDollar ?\n\t\t\t\t\t\"$\" + key : key;\n\n\n\t\t\t\tconst definition:PropertyDescriptor | undefined = Object\n\t\t\t\t\t.getOwnPropertyDescriptor( prototype, key );\n\n\t\t\t\tif( ! definition ) return false;\n\n\n\t\t\t\tconst targetDefinition:PropertyDescriptor | undefined = Object\n\t\t\t\t\t.getOwnPropertyDescriptor( object, targetKey );\n\n\t\t\t\tif( ! targetDefinition ) return false;\n\n\n\t\t\t\tif( isFunction( definition.value ) )\n\t\t\t\t\treturn isFunction( targetDefinition.value );\n\n\t\t\t\treturn ! targetDefinition.enumerable;\n\t\t\t} )\n\t\t\t;\n\t},\n\n\tdefinePropertiesFrom<P extends object, O extends object>( prototype:P, object:O ):O & P {\n\t\tconst prototypeKeys:string[] = Object\n\t\t\t.keys( prototype );\n\n\t\tconst shouldAddDollar:boolean = \"$id\" in object\n\t\t\t&& ! prototypeKeys.some( key => key.startsWith( \"$\" ) );\n\n\t\tprototypeKeys\n\t\t\t.forEach( key => {\n\t\t\t\tconst targetKey:string = shouldAddDollar ?\n\t\t\t\t\t\"$\" + key : key;\n\n\n\t\t\t\tconst definition:PropertyDescriptor = Object\n\t\t\t\t\t.getOwnPropertyDescriptor( prototype, key )!;\n\n\t\t\t\tconst descriptor:PropertyDescriptor = {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t};\n\n\t\t\t\tif( isFunction( definition.value ) ) {\n\t\t\t\t\tdescriptor.writable = false;\n\t\t\t\t\tdescriptor.value = definition.value;\n\n\t\t\t\t} else if( ! definition.set ) {\n\t\t\t\t\tdescriptor.writable = true;\n\t\t\t\t\tdescriptor.value = object.hasOwnProperty( targetKey ) ?\n\t\t\t\t\t\tobject[ targetKey ] : definition.get ?\n\t\t\t\t\t\t\tdefinition.get() : definition.value;\n\n\t\t\t\t} else {\n\t\t\t\t\tdescriptor.get = definition.get;\n\t\t\t\t\tdescriptor.set = definition.set;\n\t\t\t\t}\n\n\t\t\t\tObject.defineProperty( object, targetKey, descriptor );\n\t\t\t} )\n\t\t;\n\n\t\treturn object as P & O;\n\t},\n\n\tdecorateMultiple<O extends object, M extends object>( object:O, ...models:ModelDecorator<M>[] ):O & M {\n\t\tmodels.forEach( model => model.decorate( object ) );\n\t\treturn object as O & M;\n\t},\n};\n"],"sourceRoot":"../../src"}