"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var http_1 = tslib_1.__importDefault(require("http"));
var https_1 = tslib_1.__importDefault(require("https"));
var url_1 = tslib_1.__importDefault(require("url"));
var Utils_1 = require("../Utils");
var index_1 = require("./Errors/index");
var BadResponseError_1 = require("./Errors/ServerErrors/BadResponseError");
var UnknownError_1 = require("./Errors/UnknownError");
var Header_1 = require("./Header");
var HTTPMethod_1 = require("./HTTPMethod");
var Response_1 = require("./Response");
function __onResolve(resolve, reject, response) {
    if (response.status >= 200 && response.status <= 299) {
        resolve(response);
    }
    else {
        if (!index_1.statusCodeMap.has(response.status))
            return reject(new UnknownError_1.UnknownError(response.data, response));
        reject(new (index_1.statusCodeMap.get(response.status))(response.data, response));
    }
}
function __sendWithBrowser(method, url, body, options) {
    return new Promise(function (resolve, reject) {
        var request = options.request ? options.request : new XMLHttpRequest();
        request.open(method, url, true);
        if (options.headers)
            options.headers
                .forEach(function (header, name) { return request.setRequestHeader(name, header.toString()); });
        request.withCredentials = !!options.sendCredentialsOnCORS;
        if (options.timeout)
            request.timeout = options.timeout;
        request.onload = request.onerror = function () {
            var response = new Response_1.Response(request);
            __onResolve(resolve, reject, response);
        };
        if (body) {
            request.send(body);
        }
        else {
            request.send();
        }
    });
}
function __sendWithNode(method, url, body, options) {
    return new Promise(function (resolve, reject) {
        function returnResponse(request, res) {
            var rawData = [];
            res.on("data", function (chunk) {
                if (typeof chunk === "string")
                    chunk = Buffer.from(chunk, "utf-8");
                rawData.push(chunk);
            }).on("end", function () {
                var data = Buffer.concat(rawData).toString("utf8");
                var response = new Response_1.Response(request, data, res);
                __onResolve(resolve, reject, response);
            });
        }
        var numberOfRedirects = 0;
        function sendRequestWithRedirect(_url) {
            var parsedURL = url_1.default.parse(_url);
            var Adapter = parsedURL.protocol === "http:" ? http_1.default : https_1.default;
            var requestOptions = {
                protocol: parsedURL.protocol,
                hostname: parsedURL.hostname,
                port: parsedURL.port,
                path: parsedURL.path,
                method: method,
                headers: {},
            };
            if (options.headers)
                options.headers
                    .forEach(function (header, name) { return requestOptions.headers[name] = header.toString(); });
            var request = Adapter.request(requestOptions);
            if (options.timeout)
                request.setTimeout(options.timeout);
            request.on("response", function (res) {
                if (res.statusCode >= 300 && res.statusCode <= 399 && "location" in res.headers) {
                    if (++numberOfRedirects < 10)
                        return sendRequestWithRedirect(url_1.default.resolve(_url, res.headers.location));
                }
                returnResponse(request, res);
            });
            request.on("error", function (error) {
                var response = new Response_1.Response(request, error.message);
                __onResolve(resolve, reject, response);
            });
            if (body) {
                if (method === "DELETE")
                    request.useChunkedEncodingByDefault = true;
                request.write(body);
            }
            request.end();
        }
        sendRequestWithRedirect(url);
    });
}
function __sendRequest(method, url, body, options) {
    return typeof XMLHttpRequest !== "undefined" ?
        __sendWithBrowser(method, url, body, options) :
        __sendWithNode(method, url, body, options);
}
function __isBody(data) {
    return Utils_1.isString(data)
        || typeof Blob !== "undefined" && data instanceof Blob
        || typeof Buffer !== "undefined" && data instanceof Buffer;
}
var RequestService = (function () {
    function RequestService() {
    }
    RequestService.send = function (method, url, bodyOrOptions, optionsOrParser, parser) {
        var _this = this;
        var body = undefined;
        var options = Utils_1.hasProperty(optionsOrParser, "parse") ? bodyOrOptions : optionsOrParser;
        parser = Utils_1.hasProperty(optionsOrParser, "parse") ? optionsOrParser : parser;
        if (!bodyOrOptions || __isBody(bodyOrOptions)) {
            body = bodyOrOptions;
        }
        else {
            options = bodyOrOptions ? bodyOrOptions : options;
        }
        options = Object.assign({}, RequestService.defaultOptions, options);
        if (Utils_1.isNumber(method))
            method = HTTPMethod_1.HTTPMethod[method];
        var requestPromise = __sendRequest(method, url, body, options)
            .then(function (response) {
            if (method === "GET" && options.headers)
                return _this.__handleGETResponse(url, options, response);
            else
                return response;
        });
        if (!parser)
            return requestPromise;
        return requestPromise.then(function (response) {
            return parser.parse(response.data).then(function (parsedBody) {
                return [parsedBody, response];
            });
        });
    };
    RequestService.options = function (url, options) {
        if (options === void 0) { options = RequestService.defaultOptions; }
        return RequestService.send(HTTPMethod_1.HTTPMethod.OPTIONS, url, options);
    };
    RequestService.head = function (url, options) {
        if (options === void 0) { options = RequestService.defaultOptions; }
        return RequestService.send(HTTPMethod_1.HTTPMethod.HEAD, url, options);
    };
    RequestService.get = function (url, options, parser) {
        if (options === void 0) { options = RequestService.defaultOptions; }
        return RequestService.send(HTTPMethod_1.HTTPMethod.GET, url, undefined, options, parser);
    };
    RequestService.post = function (url, bodyOrOptions, options, parser) {
        if (bodyOrOptions === void 0) { bodyOrOptions = RequestService.defaultOptions; }
        if (options === void 0) { options = RequestService.defaultOptions; }
        return RequestService.send(HTTPMethod_1.HTTPMethod.POST, url, bodyOrOptions, options, parser);
    };
    RequestService.put = function (url, bodyOrOptions, options, parser) {
        if (bodyOrOptions === void 0) { bodyOrOptions = RequestService.defaultOptions; }
        if (options === void 0) { options = RequestService.defaultOptions; }
        return RequestService.send(HTTPMethod_1.HTTPMethod.PUT, url, bodyOrOptions, options, parser);
    };
    RequestService.patch = function (url, bodyOrOptions, options, parser) {
        if (bodyOrOptions === void 0) { bodyOrOptions = RequestService.defaultOptions; }
        if (options === void 0) { options = RequestService.defaultOptions; }
        return RequestService.send(HTTPMethod_1.HTTPMethod.PATCH, url, bodyOrOptions, options, parser);
    };
    RequestService.delete = function (url, bodyOrOptions, optionsOrParser, parser) {
        if (bodyOrOptions === void 0) { bodyOrOptions = RequestService.defaultOptions; }
        if (optionsOrParser === void 0) { optionsOrParser = RequestService.defaultOptions; }
        return RequestService.send(HTTPMethod_1.HTTPMethod.DELETE, url, bodyOrOptions, optionsOrParser, parser);
    };
    RequestService.__handleGETResponse = function (url, requestOptions, response) {
        var _this = this;
        return Promise.resolve()
            .then(function () {
            if (_this.__contentTypeIsAccepted(requestOptions, response))
                return response;
            _this.__setNoCacheHeaders(requestOptions);
            if (!_this.__isChromiumAgent())
                _this.__setFalseETag(requestOptions);
            return __sendRequest("GET", url, undefined, requestOptions)
                .then(function (noCachedResponse) {
                if (!_this.__contentTypeIsAccepted(requestOptions, response)) {
                    throw new BadResponseError_1.BadResponseError("The server responded with an unacceptable Content-Type", response);
                }
                return noCachedResponse;
            });
        });
    };
    RequestService.__contentTypeIsAccepted = function (requestOptions, response) {
        if (!requestOptions.headers)
            return true;
        var accepts = requestOptions.headers.has("accept") ?
            requestOptions.headers.get("accept").values :
            [];
        var contentType = response.headers.has("content-type") ?
            response.headers.get("content-type") :
            undefined;
        return !contentType || accepts.some(contentType.hasValue, contentType);
    };
    RequestService.__setNoCacheHeaders = function (requestOptions) {
        requestOptions.headers
            .set("pragma", new Header_1.Header("no-cache"))
            .set("cache-control", new Header_1.Header("no-cache, max-age=0"));
    };
    RequestService.__isChromiumAgent = function () {
        return typeof window !== "undefined" && !!window["chrome"];
    };
    RequestService.__setFalseETag = function (requestOptions) {
        requestOptions.headers.set("if-none-match", new Header_1.Header());
    };
    RequestService.defaultOptions = {
        sendCredentialsOnCORS: true,
    };
    return RequestService;
}());
exports.RequestService = RequestService;
var RequestUtils = (function () {
    function RequestUtils() {
    }
    RequestUtils.getHeader = function (headerName, requestOptions, initialize) {
        if (!requestOptions.headers) {
            if (!initialize)
                return undefined;
            requestOptions.headers = new Map();
        }
        headerName = headerName.toLowerCase();
        var header = requestOptions.headers.get(headerName);
        if (!header) {
            if (!initialize)
                return undefined;
            header = new Header_1.Header();
            requestOptions.headers.set(headerName, header);
        }
        return header;
    };
    RequestUtils.setAcceptHeader = function (accept, requestOptions) {
        RequestUtils.__addHeaderValue("accept", accept, requestOptions);
        return requestOptions;
    };
    RequestUtils.setContentTypeHeader = function (contentType, requestOptions) {
        RequestUtils.__addHeaderValue("content-type", contentType, requestOptions);
        return requestOptions;
    };
    RequestUtils.setIfMatchHeader = function (eTag, requestOptions) {
        if (!eTag)
            return requestOptions;
        RequestUtils.__addHeaderValue("if-match", eTag, requestOptions);
        return requestOptions;
    };
    RequestUtils.setIfNoneMatchHeader = function (eTag, requestOptions) {
        if (!eTag)
            return requestOptions;
        RequestUtils.__addHeaderValue("if-none-match", eTag, requestOptions);
        return requestOptions;
    };
    RequestUtils.setPreferredInteractionModel = function (interactionModelURI, requestOptions) {
        var headerValue = interactionModelURI + "; rel=interaction-model";
        RequestUtils.__addHeaderValue("prefer", headerValue, requestOptions);
        return requestOptions;
    };
    RequestUtils.setPreferredRetrieval = function (retrievalType, requestOptions) {
        var headerValue = "return=" + retrievalType;
        RequestUtils.__addHeaderValue("prefer", headerValue, requestOptions);
        return requestOptions;
    };
    RequestUtils.setRetrievalPreferences = function (preferences, requestOptions) {
        var prefer = RequestUtils.getHeader("prefer", requestOptions, true);
        var keys = ["include", "omit"];
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            if (!(key in preferences))
                continue;
            if (preferences[key].length <= 0)
                continue;
            var strPreferences = preferences[key].join(" ");
            prefer.values.push(key + "=\"" + strPreferences + "\"");
        }
        return requestOptions;
    };
    RequestUtils.setSlug = function (slug, requestOptions) {
        RequestUtils.__addHeaderValue("slug", slug, requestOptions);
        return requestOptions;
    };
    RequestUtils.isOptions = function (value) {
        return Utils_1.hasPropertyDefined(value, "headers")
            || Utils_1.hasPropertyDefined(value, "sendCredentialsOnCORS")
            || Utils_1.hasPropertyDefined(value, "timeout")
            || Utils_1.hasPropertyDefined(value, "request");
    };
    RequestUtils.cloneOptions = function (options) {
        var clone = tslib_1.__assign({}, options, { headers: new Map() });
        if (options.headers)
            options.headers
                .forEach(function (value, key) { return clone.headers.set(key, new Header_1.Header(value.values.slice())); });
        return clone;
    };
    RequestUtils.__addHeaderValue = function (headerName, headerValue, requestOptions) {
        var header = RequestUtils.getHeader(headerName, requestOptions, true);
        header.addValue(headerValue);
    };
    return RequestUtils;
}());
exports.RequestUtils = RequestUtils;

//# sourceMappingURL=Request.js.map
