{"version":3,"file":"sparqler.umd.js","sources":["../src/clauses/FinishClause.ts","../src/data/Factory.ts","../src/iri/utils.ts","../src/tokens/IRIRefToken.ts","../src/tokens/PrefixedNameToken.ts","../src/data/IRIResolver.ts","../src/data/utils.ts","../src/tokens/BaseToken.ts","../src/tokens/PrefixToken.ts","../src/data/Container.ts","../../node_modules/tslib/tslib.es6.js","../src/tokens/printing.ts","../src/tokens/GroupPatternToken.ts","../src/tokens/WhereToken.ts","../src/tokens/SharedQueryClauseToken.ts","../src/tokens/AskToken.ts","../src/tokens/FromToken.ts","../src/tokens/SharedSelectToken.ts","../src/tokens/SubSelectToken.ts","../src/tokens/VariableToken.ts","../src/tokens/GroupToken.ts","../src/tokens/HavingToken.ts","../src/tokens/OrderToken.ts","../src/tokens/LimitToken.ts","../src/clauses/SolutionModifierClause.ts","../src/clauses/LimitClause.ts","../src/tokens/OffsetToken.ts","../src/clauses/OffsetClause.ts","../src/tokens/IRIToken.ts","../src/tokens/LiteralToken.ts","../src/tokens/RDFLiteralToken.ts","../src/utils/XSD.ts","../src/patterns/utils.ts","../src/tokens/ValuesToken.ts","../src/clauses/ValuesClause.ts","../src/clauses/LimitOffsetClause.ts","../src/clauses/OrderClause.ts","../src/clauses/HavingClause.ts","../src/clauses/GroupClause.ts","../src/patterns/Pattern.ts","../src/patterns/clausePatterns/FinishPattern.ts","../src/patterns/clausePatterns/WherePattern.ts","../src/patterns/clausePatterns/SubSelectPattern.ts","../src/tokens/BindToken.ts","../src/tokens/FilterToken.ts","../src/tokens/GraphToken.ts","../src/tokens/MinusPatternToken.ts","../src/tokens/OptionalToken.ts","../src/tokens/ServicePatternToken.ts","../src/tokens/UnionPatternToken.ts","../src/patterns/notTriplePatterns/NotTriplePattern.ts","../src/patterns/notTriplePatterns/UnionPattern.ts","../src/patterns/notTriplePatterns/GroupPattern.ts","../src/patterns/notTriplePatterns/MultipleValuesPattern.ts","../src/patterns/notTriplePatterns/SingleValuesPattern.ts","../src/patterns/notTriplePatterns/NotTriplePatternsBuilder.ts","../src/tokens/PathAlternativeToken.ts","../src/patterns/paths/FluentPathContainer.ts","../src/patterns/paths/utils.ts","../src/tokens/SharedSubPathToken.ts","../src/patterns/paths/fns/utils.ts","../src/patterns/paths/fns/alternativeFn.ts","../src/tokens/PathInverseToken.ts","../src/patterns/paths/fns/inverseFn.ts","../src/tokens/PathModToken.ts","../src/patterns/paths/fns/modFn.ts","../src/tokens/PathSequenceToken.ts","../src/patterns/paths/fns/sequenceFn.ts","../src/patterns/paths/fns/subPathFn.ts","../src/patterns/paths/Path.ts","../src/patterns/paths/FluentPath.ts","../src/tokens/PathNegatedToken.ts","../src/patterns/paths/fns/negatedFn.ts","../src/patterns/paths/DeniableFluentPath.ts","../src/patterns/paths/PathBuilder.ts","../src/patterns/paths/PathsBuilder.ts","../src/tokens/BlankNodePropertyToken.ts","../src/tokens/BlankNodeToken.ts","../src/tokens/CollectionToken.ts","../src/tokens/SubjectToken.ts","../src/tokens/PropertyToken.ts","../src/patterns/triplePatterns/PropertyBuilder.ts","../src/patterns/triplePatterns/BlankNodeBuilder.ts","../src/tokens/LanguageToken.ts","../src/patterns/triplePatterns/TriplePattern.ts","../src/patterns/triplePatterns/TripleSubject.ts","../src/patterns/triplePatterns/RDFLiteral.ts","../src/patterns/triplePatterns/TriplePatternsBuilder.ts","../src/patterns/PatternBuilder.ts","../src/clauses/WhereClause.ts","../src/clauses/FromClause.ts","../src/clauses/AskClause.ts","../src/tokens/SelectToken.ts","../src/clauses/SelectClause.ts","../src/clauses/QueryClause.ts","../src/data/QueryUnitContainer.ts","../src/tokens/QueryToken.ts","../src/SPARQLER.ts","../src/tokens/ConstructToken.ts"],"sourcesContent":["import { Container } from \"../data/Container\";\n\nimport { TokenNode } from \"../tokens/TokenNode\";\n\n\n/**\n * Interface with methods to construct the final SPARQL query string.\n */\nexport interface FinishClause {\n\t/**\n\t * Constructs a compact SPARQL query string.\n\t *\n\t * Tries to minimize the optional elements and the blank spaces\n\t * between the elements of the query.\n\t *\n\t * @returns The compact string.\n\t */\n\ttoCompactString():string;\n\n\t/**\n\t * Constructs a pretty SPARQL query string.\n\t *\n\t * Prints the statements with indentation and also print all the\n\t * elements even if their are optional ones.\n\t *\n\t * @returns The pretty string.\n\t */\n\ttoPrettyString():string;\n\n\t/**\n\t * Return the same result as {@link FinishClause.toPrettyString}\n\t */\n\ttoString():string;\n\n\n\tdebug( debugFn:( query:this, container:Container<TokenNode> ) => any ):this;\n}\n\n\n/**\n * Constant with the utils for {@link FinishClause} objects.\n */\nexport const FinishClause = {\n\tcreateFrom<O extends object>( container:Container<TokenNode>, object:O ):O & FinishClause {\n\t\tconst toPrettyString:FinishClause[ \"toPrettyString\" ] = () =>\n\t\t\tcontainer.targetToken.toString( 0 );\n\n\t\tconst debug:FinishClause[ \"debug\" ] = debugFn => {\n\t\t\tdebugFn.call( void 0, object, container );\n\t\t\treturn object as O & FinishClause;\n\t\t};\n\n\t\treturn Object.assign<O, FinishClause>( object, {\n\t\t\ttoCompactString: () => container.targetToken.toString(),\n\t\t\ttoPrettyString: toPrettyString,\n\t\t\ttoString: toPrettyString,\n\t\t\tdebug,\n\t\t} );\n\t}\n};","import { TokenNode } from \"../tokens/TokenNode\";\n\nimport { Container } from \"./Container\";\n\n\n/**\n * Interface that describes the factory functions. A specific type\n * of function that are used to create the instances of the objects\n * related to external data stored in a {@link Container}.\n */\nexport interface Factory<CONTAINER extends Container<TokenNode>, TARGET extends object> extends Function {\n\t/**\n\t * The function signature of the factory.\n\t *\n\t * @param container The related container with the stored data for\n\t * the factory.\n\t * @param object The base object from where to create the target\n\t * object.\n\t *\n\t * @return The provided object with the elements of the target\n\t * object to be created.\n\t */<OBJECT extends object>( container:CONTAINER, object:OBJECT ):OBJECT & TARGET;\n}\n\n\n/**\n * Constant with the utils functions for {@link Factory} objects.\n */\nexport const Factory:{\n\t/**\n\t * Creates a new factory function that applies the factory function provided.\n\t *\n\t * @param factory The factory function to be applied.\n\t */\n\tcreateFrom<CONTAINER extends Container<any>, TARGET extends object>( factory:Factory<CONTAINER, TARGET> ):Factory<CONTAINER, TARGET>;\n\t/**\n\t * Creates a new factory function that applies the two factory\n\t * functions provided.\n\t *\n\t * @param factory1 The fist factory function to be applied.\n\t * @param factory2 The second factory function to be applied.\n\t */\n\tcreateFrom<CONTAINER extends Container<any>, TARGET1 extends object, TARGET2 extends object>( factory1:Factory<CONTAINER, TARGET1>, factory2:Factory<CONTAINER, TARGET2> ):Factory<CONTAINER, TARGET1 & TARGET2>;\n\t/**\n\t * Created a new factory function that applies the three factory\n\t * function provided.\n\t *\n\t * @param factory1 The first factory function to be applied.\n\t * @param factory2 The second factory function to be applied.\n\t * @param factory3 The third factory function to be applied.\n\t */\n\tcreateFrom<CONTAINER extends Container<any>, TARGET1 extends object, TARGET2 extends object, TARGET3 extends object>( factory1:Factory<CONTAINER, TARGET1>, factory2:Factory<CONTAINER, TARGET2>, factory3:Factory<CONTAINER, TARGET3> ):Factory<CONTAINER, TARGET1 & TARGET2 & TARGET3>;\n\t/**\n\t * Created a new factory function that applies the three factory\n\t * function provided.\n\t *\n\t * @param factory1 The first factory function to be applied.\n\t * @param factory2 The second factory function to be applied.\n\t * @param factory3 The third factory function to be applied.\n\t * @param factory4 The fourth factory function to be applied.\n\t */\n\tcreateFrom<CONTAINER extends Container<any>, TARGET1 extends object, TARGET2 extends object, TARGET3 extends object, TARGET4 extends object>( factory1:Factory<CONTAINER, TARGET1>, factory2:Factory<CONTAINER, TARGET2>, factory3:Factory<CONTAINER, TARGET3>, factory4:Factory<CONTAINER, TARGET4> ):Factory<CONTAINER, TARGET1 & TARGET2 & TARGET3 & TARGET4>;\n} = {\n\tcreateFrom( ...factories:Factory<any, any>[] ):Factory<any, any> {\n\t\treturn <W extends object>( container:Container<any>, object:W ):W & any => {\n\t\t\treturn factories\n\t\t\t\t.reduce( ( target, factoryFn ) => factoryFn( container, target ), object );\n\t\t};\n\t}\n};\n","export function isAbsolute( iri:string ):boolean {\n\treturn iri.indexOf( \":\" ) !== - 1;\n}\n\nexport function hasProtocol( iri:string ):boolean {\n\treturn iri.indexOf( \"://\" ) !== - 1;\n}\n\nexport function isRelative( iri:string ):boolean {\n\treturn ! isAbsolute( iri );\n}\n\nexport function isIRI( iri:string ):boolean {\n\treturn hasProtocol( iri ) || ! isAbsolute( iri );\n}\n\n\nexport function isBNodeLabel( label:string ):boolean {\n\treturn /^_:/.test( label );\n}\n\n\nexport function isPrefixed( iri:string ):boolean {\n\treturn /^(?!_:)[^]*?:/.test( iri ) && ! hasProtocol( iri );\n}\n","import { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the IRI term.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rIRIREF}\n */\nexport class IRIRefToken implements TokenNode {\n\treadonly token:\"iri\" = \"iri\";\n\treadonly value:string;\n\n\tconstructor( value:string ) {\n\t\tthis.value = value;\n\t}\n\n\ttoString( spaces?:number ):string {\n\t\treturn `<${ this.value }>`;\n\t}\n}\n","import { isPrefixed } from \"../iri/utils\";\n\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * Regex to validate a correct prefixed name.\n */\nconst NAMESPACE_REGEX:RegExp = /^([A-Za-z](([A-Za-z_\\-0-9]|\\.)*[A-Za-z_\\-0-9])?)?$/;\n\n\n/**\n * The token of the prefixed named term.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rPrefixedName}\n */\nexport class PrefixedNameToken implements TokenNode {\n\treadonly token:\"prefixedName\" = \"prefixedName\";\n\treadonly namespace:string;\n\treadonly localName:string;\n\n\tconstructor( prefixedName:string );\n\tconstructor( namespace:string, localName:string );\n\tconstructor( prefixedOrNamespace:string, localName?:string ) {\n\t\tlet namespace:string = prefixedOrNamespace;\n\t\tif( localName === void 0 ) {\n\t\t\tif( ! isPrefixed( prefixedOrNamespace ) ) throw new Error( \"Invalid prefixed name.\" );\n\t\t\t[ namespace, localName ] = prefixedOrNamespace.split( /:(.*)/ );\n\t\t}\n\n\t\tif( ! NAMESPACE_REGEX.test( namespace ) ) throw new Error( \"Invalid prefixed namespace.\" );\n\t\tthis.namespace = namespace;\n\n\t\tconst [ , ln1, ln2, ln3 ] = localName.split( /^(.)(?:(.*)?(.))?$/ );\n\n\t\tlet preSanitation:string = \"\";\n\t\tif( ln1 ) preSanitation += ln1.replace( /([\\-.])/g, \"\\\\$1\" );\n\t\tif( ln2 ) preSanitation += ln2;\n\t\tif( ln3 ) preSanitation += ln3.replace( /([.])/g, \"\\\\$1\" );\n\n\t\tthis.localName = preSanitation.replace( /([~!$&'|()*+,;=/?#@%])/g, \"\\\\$1\" );\n\t}\n\n\ttoString( spaces?:number ):string {\n\t\treturn `${ this.namespace }:${ this.localName }`;\n\t}\n}\n","import { isPrefixed, isRelative } from \"../iri/utils\";\n\nimport { IRIRefToken } from \"../tokens/IRIRefToken\";\nimport { IRIToken } from \"../tokens/IRIToken\";\nimport { PrefixedNameToken } from \"../tokens/PrefixedNameToken\";\n\n\n/**\n * Map type of the stored prefixes used by {@link IRIResolver}.\n */\nexport type PrefixMap = Map<string, boolean>;\n\n\n/**\n * Class to manage the resolution of IRIs in tokens\n */\nexport class IRIResolver {\n\n\t/**\n\t * Map to store prefixes and information of its usage\n\t */\n\treadonly prefixes:PrefixMap;\n\n\t/**\n\t * IRI to resolve relative RDF properties\n\t */\n\treadonly vocab?:string;\n\n\t/**\n\t * Creates a new empty instance of IRIResolver if no parameter is provided, but\n\t * if a base IRIResolver is specified, its information will be copied to the new instance.\n\t *\n\t * @param base IRIResolver to copy its data from.\n\t * @param vocab Absolute IRI to change the default vocab value.\n\t */\n\tconstructor( base?:IRIResolver, vocab?:string ) {\n\t\tthis.prefixes = base\n\t\t\t? new Map( base.prefixes.entries() )\n\t\t\t: new Map();\n\n\t\tthis.vocab = vocab\n\t\t\t? vocab\n\t\t\t: base && base.vocab;\n\n\t\tif( new.target === IRIResolver ) Object.freeze( this );\n\t}\n\n\t/**\n\t * Resolves (if necessary) and creates the respective tokens if the IRI provided.\n\t *\n\t * If vocab parameter is to `true`, the stored vocab IRI is used to resolve relative IRIs.\n\t *\n\t * @param relativeIRI The relative IRI to be resolved and tokenized.\n\t * @param vocab Optional parameter to specified if the relative IRIs will be resolved with the stored vocab IRI.\n\t * @returns An array of tokens representing the provided IRI to be used in the SPARQL query.\n\t */\n\tresolve( relativeIRI:string, vocab?:boolean ):IRIToken {\n\t\tif( isPrefixed( relativeIRI ) )\n\t\t\treturn this.resolvePrefixed( relativeIRI );\n\n\t\treturn this.resolveIRIRef( relativeIRI, vocab );\n\t}\n\n\tprivate resolveIRIRef( relativeIRI:string, vocab:boolean = false ):IRIRefToken {\n\t\tif( vocab && this.vocab && isRelative( relativeIRI ) )\n\t\t\trelativeIRI = this.vocab + relativeIRI;\n\n\t\treturn new IRIRefToken( relativeIRI );\n\t}\n\n\tprivate resolvePrefixed( prefixedName:string ):PrefixedNameToken {\n\t\tlet token:PrefixedNameToken = new PrefixedNameToken( prefixedName );\n\n\t\tconst used:boolean | undefined = this.prefixes.get( token.namespace );\n\t\tif( used === void 0 ) throw new Error( `The prefix \"${ token.namespace }\" has not been declared.` );\n\n\t\tif( ! used ) this.prefixes.set( token.namespace, true );\n\t\treturn token;\n\t}\n}\n","/**\n * Function used to create shallow clones of immutable objects, with\n * the option to replace with new values the respective element.\n *\n * @param element The immutable object to the cloned.\n * @param newValues Optional object with the new values to be replaced.\n *\n * @return The shallow clone with the replaces values, in read-only\n * using the {@link Object.freeze} method.\n */\nexport function cloneElement<T extends object, P extends Partial<T>>( element:T, newValues:P = {} as P ):Readonly<T & P> {\n\tconst base:T = Object.create( Object.getPrototypeOf( element ) );\n\n\tconst clone:T & P = Object\n\t\t.assign( base, element, newValues );\n\n\treturn Object.freeze( clone );\n}\n","import { IRIRefToken } from \"./IRIRefToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the `BASE` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rBaseDecl}\n */\nexport class BaseToken implements TokenNode {\n\treadonly token:\"base\" = \"base\";\n\treadonly iri:IRIRefToken;\n\n\tconstructor( iri:IRIRefToken ) {\n\t\tthis.iri = iri;\n\t}\n\n\ttoString():string {\n\t\treturn `BASE ${ this.iri }`;\n\t}\n}\n","import { IRIRefToken } from \"./IRIRefToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the `PREFIX` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rPrefixDecl}\n */\nexport class PrefixToken implements TokenNode {\n\treadonly token:\"prefix\" = \"prefix\";\n\treadonly namespace:string;\n\treadonly iri:IRIRefToken;\n\n\tconstructor( namespace:string, iri:IRIRefToken ) {\n\t\tthis.namespace = namespace;\n\t\tthis.iri = iri;\n\t}\n\n\ttoString( spaces?:number ):string {\n\t\treturn `PREFIX ${ this.namespace }: ${ this.iri }`;\n\t}\n}\n","import { TokenNode } from \"../tokens/TokenNode\";\n\nimport { IRIResolver } from \"./IRIResolver\";\n\n\n/**\n * Interface that describe the necessary data for the creation\n * of a {@link Container}.\n */\nexport interface ContainerData<TOKEN extends TokenNode | \"a\" | undefined> {\n\t/**\n\t * @see Container.iriResolver\n\t */\n\tiriResolver:IRIResolver;\n\t/**\n\t * @see Container.targetToken\n\t */\n\ttargetToken:TOKEN;\n}\n\n\n/**\n * Immutable class that contains the hidden data of the query statement.\n *\n * Every statement of the builder uses a different instance of the container\n * to make the query builder independent of the step and be able to\n * reuse it in a immutable-like pattern.\n */\nexport class Container<TOKEN extends TokenNode | \"a\" | undefined> implements ContainerData<TOKEN> {\n\t/**\n\t * The IRI resolver used to resolve and create IRIs and\n\t * Prefixed Names\n\t */\n\treadonly iriResolver:IRIResolver;\n\t/**\n\t * The target token where the state of the current query step is\n\t * actually stored.\n\t */\n\treadonly targetToken:TOKEN;\n\n\n\t/**\n\t * Constructor that receives an object with the base data of the\n\t * container.\n\t *\n\t * @param data The base data for the container creation.\n\t */\n\tconstructor( data:ContainerData<TOKEN> ) {\n\t\tthis.iriResolver = data.iriResolver;\n\t\tthis.targetToken = data.targetToken;\n\n\t\tif( new.target === Container ) Object.freeze( this );\n\t}\n\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The number of spaces to be used as indentation in the pretty print\n * mode of the tokens.\n */\nexport const INDENTATION_SPACES:4 = 4;\n\n\n/**\n * Returns the separator of tokens depending in the spaces provided.\n *\n * If no spaces provided this means the printing mode is in compact\n * and so a blank space will be returned, otherwise a new line will\n * be the one returned.\n *\n * @param spaces The spaces of the current indentation of the tokens.\n */\nexport function getSeparator( spaces?:number ):string {\n\tif( spaces === void 0 ) return \" \";\n\treturn \"\\n\";\n}\n\n/**\n * Get the full indentation for a token line printing.\n *\n * If no spaces is provided, this means the printing mode is in\n * compact and no indentation is needed and so a empty string will be\n * returned, even if extra spaces are also provided.\n *\n * Otherwise, a string with the sum of the spaces and the extra ones\n * as empty spaces will be returned..\n *\n * @param spaces The spaces of the current indentation of a line.\n * @param extra Extra spaces to be added in the indentation line.\n */\nexport function getIndentation( spaces?:number, extra?:number ):string {\n\tif( spaces === void 0 ) return \"\";\n\n\tif( extra ) spaces += extra;\n\treturn \" \".repeat( spaces );\n}\n\n/**\n * Returns the sum of the provided spaces with the extra ones.\n *\n * If spaces is undefined it means the current printing mode is\n * compact and so undefined will be returned.\n *\n * @param spaces The spaces of the current indentation of a line.\n * @param extra The extra spaces to be added in the indentation.\n */\nexport function addSpaces( spaces:number | undefined, extra:number ):number | undefined {\n\tif( spaces === void 0 ) return spaces;\n\treturn spaces + extra;\n}\n\n\n/**\n * Returns the printing of a group of tokens that are contained in a\n * specific block.\n *\n * @param spaces The spaces of the current indentation.\n * @param tags The close and open tag of the token container to print.\n * @param tokensSeparator The separator betaken the tokens.\n * @param tokens The actual tokens to be printed.\n */\nexport function getTokenContainerString( { spaces, tags, tokensSeparator, tokens }:{\n\tspaces:number | undefined,\n\ttags:{ open:string, close:string },\n\ttokensSeparator?:string;\n\ttokens:TokenNode[],\n} ):string {\n\tif( ! tokens.length ) return tags.open + tags.close;\n\n\tconst generalSeparator:string = getSeparator( spaces );\n\n\tconst tokensSpaces:number | undefined = addSpaces( spaces, INDENTATION_SPACES );\n\tconst strArrayTokens:string[] = tokens.map( ( token, index, array ) => {\n\t\tconst strToken:string = token.toString( tokensSpaces );\n\n\t\t// No separator or last one\n\t\tif( ! tokensSeparator || index === array.length - 1 ) return strToken;\n\n\t\t// Optional when not triple token\n\t\tif( tokensSeparator === \".\" && token.token !== \"subject\" ) return strToken;\n\n\t\treturn strToken + tokensSeparator;\n\t} );\n\n\n\tif( strArrayTokens.length === 1 && ! strArrayTokens[ 0 ].includes( \"\\n\" ) )\n\t\treturn tags.open + \" \" + strArrayTokens + \" \" + tags.close;\n\n\n\tconst tokensIndent:string = getIndentation( tokensSpaces );\n\tconst strTokens:string = strArrayTokens\n\t\t.map( x => tokensIndent + x )\n\t\t.join( generalSeparator );\n\n\tconst indent:string = getIndentation( spaces );\n\treturn tags.open +\n\t\tgeneralSeparator + strTokens + generalSeparator +\n\t\tindent + tags.close;\n}\n","import { PatternToken } from \"./PatternToken\";\nimport { getTokenContainerString } from \"./printing\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the for grouping pattern statements.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rGroupGraphPattern}\n */\nexport class GroupPatternToken implements TokenNode {\n\ttoken:\"groupPattern\" = \"groupPattern\";\n\n\treadonly patterns:PatternToken[];\n\n\tconstructor() {\n\t\tthis.patterns = [];\n\t}\n\n\n\taddPattern( ...patterns:PatternToken[] ):this {\n\t\tthis.patterns.push( ...patterns );\n\t\treturn this;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\treturn getTokenContainerString( {\n\t\t\tspaces,\n\t\t\ttags: { open: \"{\", close: \"}\" },\n\t\t\ttokensSeparator: \".\",\n\t\t\ttokens: this.patterns,\n\t\t} );\n\t}\n}\n","import { GroupPatternToken } from \"./GroupPatternToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token for `WHERE` statements.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rWhereClause}\n */\nexport class WhereToken implements TokenNode {\n\ttoken:\"where\" = \"where\";\n\n\treadonly groupPattern:GroupPatternToken;\n\n\tconstructor() {\n\t\tthis.groupPattern = new GroupPatternToken();\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\tconst identifier:string = spaces === void 0 ? \"\" : \"WHERE \";\n\t\treturn identifier + this.groupPattern.toString( spaces );\n\t}\n}\n","import { PatternToken } from \"./PatternToken\";\nimport { SolutionModifierToken } from \"./SolutionModifierToken\";\nimport { TokenNode } from \"./TokenNode\";\nimport { WhereToken } from \"./WhereToken\";\n\n\n/**\n * Abstract class with the shared data of a query clause token\n * (SELECT, CONSTRUCT, etc.).\n */\nexport abstract class SharedQueryClauseToken implements TokenNode {\n\tabstract readonly token:string;\n\n\treadonly where:WhereToken;\n\treadonly modifiers:SolutionModifierToken[];\n\n\tprotected constructor() {\n\t\tthis.where = new WhereToken();\n\t\tthis.modifiers = [];\n\t}\n\n\n\taddPattern( ...patterns:PatternToken[] ):this {\n\t\tthis.where.groupPattern.patterns.push( ...patterns );\n\t\treturn this;\n\t}\n\n\taddModifier( ...modifier:SolutionModifierToken[] ):this {\n\t\tthis.modifiers.push( ...modifier );\n\t\treturn this;\n\t}\n\n\n\tabstract toString( spaces?:number ):string;\n}\n","import { FromToken } from \"./FromToken\";\nimport { getSeparator } from \"./printing\";\nimport { SharedQueryClauseToken } from \"./SharedQueryClauseToken\";\n\n\n/**\n * The token of the `ASK` query statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rAskQuery}\n */\nexport class AskToken extends SharedQueryClauseToken {\n\treadonly token:\"ask\" = \"ask\";\n\n\treadonly datasets:FromToken[];\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis.datasets = [];\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\tlet query:string = \"ASK\";\n\t\tconst separator:string = getSeparator( spaces );\n\n\t\tif( this.datasets.length ) query += separator + this.datasets.join( separator );\n\n\t\tquery += separator + this.where.toString( spaces );\n\n\t\tif( this.modifiers.length ) query += separator + this.modifiers.join( separator );\n\n\t\treturn query;\n\t}\n}\n","import { IRIToken } from \"./IRIToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the `FROM` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rDatasetClause}\n */\nexport class FromToken implements TokenNode {\n\treadonly token:\"from\" = \"from\";\n\n\treadonly named:boolean;\n\treadonly source:IRIToken;\n\n\tconstructor( source:IRIToken, named:boolean = false ) {\n\t\tthis.source = source;\n\t\tthis.named = named;\n\t}\n\n\ttoString( spaces?:number ):string {\n\t\tlet str:string = `FROM `;\n\n\t\tif( this.named ) str += `NAMED `;\n\n\t\treturn str + this.source;\n\t}\n}\n","import { SharedQueryClauseToken } from \"./SharedQueryClauseToken\";\nimport { VariableToken } from \"./VariableToken\";\n\n\n/**\n * Abstract class of the shared data of SELECT and SUB-SELECT\n * statements.\n */\nexport abstract class SharedSelectToken extends SharedQueryClauseToken {\n\tabstract readonly token:string;\n\n\treadonly modifier?:\"DISTINCT\" | \"REDUCED\";\n\treadonly variables:VariableToken[];\n\n\tprotected constructor( modifier?:\"DISTINCT\" | \"REDUCED\" ) {\n\t\tsuper();\n\n\t\tthis.modifier = modifier;\n\t\tthis.variables = [];\n\t}\n\n\n\taddVariable( ...variables:VariableToken[] ):this {\n\t\tthis.variables.push( ...variables );\n\t\treturn this;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\tlet query:string = `SELECT`;\n\n\t\tif( this.modifier ) query += ` ${ this.modifier }`;\n\n\t\tquery += this.variables.length ?\n\t\t\t` ${ this.variables.join( \" \" ) }` :\n\t\t\t\" *\";\n\n\t\treturn query;\n\t}\n}\n","import { SharedSelectToken } from \"./SharedSelectToken\";\nimport { addSpaces, getIndentation, getSeparator, INDENTATION_SPACES } from \"./printing\";\nimport { ValuesToken } from \"./ValuesToken\";\n\n\nexport class SubSelectToken extends SharedSelectToken {\n\treadonly token:\"subSelect\" = \"subSelect\";\n\n\treadonly values?:ValuesToken;\n\n\tconstructor( modifier?:\"DISTINCT\" | \"REDUCED\", values?:ValuesToken ) {\n\t\tsuper( modifier );\n\n\t\tthis.values = values;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\tconst subSpaces:number | undefined = addSpaces( spaces, INDENTATION_SPACES );\n\t\tconst subIndent:string = getIndentation( subSpaces );\n\t\tconst separator:string = getSeparator( spaces );\n\n\t\tlet query:string = super.toString( spaces ) + separator +\n\t\t\tsubIndent + this.where.toString( subSpaces );\n\n\t\tif( this.modifiers.length ) query += separator + this.modifiers\n\t\t\t.map( x => subIndent + x )\n\t\t\t.join( separator );\n\n\t\tif( this.values ) query += separator + subIndent + this.values;\n\n\t\tconst indent:string = getIndentation( spaces );\n\t\treturn \"{\" + separator + subIndent +\n\t\t\tquery + separator +\n\t\t\tindent + \"}\";\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\n/**\n * Regex for validate a correct variable name.\n */\nconst NAME_REGEX:RegExp = /^((?:[0-9A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF]))((?:[0-9A-Z_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF]))*$/;\n\n\n/**\n * The token for variable statements.\n *\n * Currently only supports variables with `?` sign.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rVar}\n */\nexport class VariableToken implements TokenNode {\n\treadonly token:\"variable\" = \"variable\";\n\treadonly name:string;\n\n\tconstructor( name:string ) {\n\t\tif( ! NAME_REGEX.test( name ) ) throw new Error( \"Invalid variable name\" );\n\n\t\tthis.name = name;\n\t}\n\n\ttoString( spaces?:number ):string {\n\t\treturn `?${ this.name }`;\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the `GROUP BY` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rGroupClause}\n */\nexport class GroupToken implements TokenNode {\n\treadonly token:\"group\" = \"group\";\n\n\treadonly rawCondition:string;\n\n\tconstructor( rawCondition:string ) {\n\t\tthis.rawCondition = rawCondition;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\treturn `GROUP BY ${ this.rawCondition }`;\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the `HAVING` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rHavingClause}\n */\nexport class HavingToken implements TokenNode {\n\treadonly token:\"having\" = \"having\";\n\n\treadonly rawCondition:string;\n\n\tconstructor( rawCondition:string ) {\n\t\tthis.rawCondition = rawCondition;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\treturn `HAVING ${ this.rawCondition }`;\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\nimport { VariableToken } from \"./VariableToken\";\n\n\n/**\n * The token of the `GROUP BY` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rGroupClause}\n */\nexport class OrderToken implements TokenNode {\n\treadonly token:\"order\" = \"order\";\n\treadonly condition:VariableToken | string;\n\treadonly flow?:string;\n\n\tconstructor( condition:VariableToken | string, flow?:\"ASC\" | \"DESC\" ) {\n\t\tthis.condition = condition;\n\t\tif( flow ) this.flow = flow;\n\t}\n\n\ttoString( spaces?:number ):string {\n\t\treturn \"ORDER BY \" + (this.flow ?\n\t\t\t`${ this.flow }( ${ this.condition } )` :\n\t\t\t`${ this.condition }`);\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the `LIMIT` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rLimitClause}\n */\nexport class LimitToken implements TokenNode {\n\treadonly token:\"limit\" = \"limit\";\n\treadonly value:number;\n\n\tconstructor( value:number ) {\n\t\tthis.value = value;\n\t}\n\n\ttoString():string {\n\t\treturn `LIMIT ${ this.value }`;\n\t}\n}\n","import { Container } from \"../data/Container\";\nimport { cloneElement } from \"../data/utils\";\n\nimport { QueryClauseToken } from \"../tokens/QueryClauseToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SolutionModifierToken } from \"../tokens/SolutionModifierToken\";\nimport { SubSelectToken } from \"../tokens/SubSelectToken\";\n\n\nexport function cloneSolutionModifierContainer<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>>( container:C, token:SolutionModifierToken ):C {\n\tconst targetToken:QueryToken | SubSelectToken = container.targetToken.token === \"query\" ?\n\t\t_cloneFromQuery( container.targetToken, token ) :\n\t\t_cloneFromClause( container.targetToken, token );\n\n\treturn cloneElement( container, { targetToken } as Partial<C> );\n}\n\nfunction _cloneFromClause<T extends QueryClauseToken | SubSelectToken>( this:void, clauseToken:T, token:SolutionModifierToken ):T {\n\tconst modifiers:SolutionModifierToken[] = clauseToken.modifiers.concat( token );\n\treturn cloneElement( clauseToken, { modifiers } as Partial<T> );\n}\n\nfunction _cloneFromQuery( this:void, queryToken:QueryToken<QueryClauseToken>, token:SolutionModifierToken ):QueryToken<QueryClauseToken> {\n\tconst queryClause:QueryClauseToken = _cloneFromClause( queryToken.queryClause, token );\n\treturn cloneElement( queryToken, { queryClause } );\n}\n","import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\n\nimport { LimitToken } from \"../tokens/LimitToken\";\nimport { QueryClauseToken } from \"../tokens/QueryClauseToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SubSelectToken } from \"../tokens/SubSelectToken\";\n\nimport { cloneSolutionModifierContainer } from \"./SolutionModifierClause\";\n\n\n/**\n * Interface with the methods available to make a LIMIT statement.\n */\nexport interface LimitClause<T extends object> {\n\t/**\n\t * Set the limit of results the query should return.\n\t *\n\t * @param limit The number to be applied as limit.\n\t * @returns An OffsetClause or the FinishClause/SubFinishClause depending\n\t * if the offset method has been called before or not.\n\t */\n\tlimit( limit:number ):T;\n}\n\n\n/**\n * Function that creates the {@link LimitClause.limit} function.\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link LimitClause} receives.\n * @param container The container with the query data of the statement.\n *\n * @returns The {@link LimitClause.limit} function.\n *\n * @private\n */\nfunction getLimitFn<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends object>( genericFactory:Factory<C, T>, container:C ):LimitClause<T>[ \"limit\" ] {\n\treturn ( limit:number ) => {\n\t\tconst token:LimitToken = new LimitToken( limit );\n\n\t\tconst newContainer:C = cloneSolutionModifierContainer( container, token );\n\t\treturn genericFactory( newContainer, {} );\n\t};\n}\n\n\n/**\n * Constant with the utils for {@link LimitClause} objects.\n */\nexport const LimitClause:{\n\t/**\n\t * Factory function that allows to crete a {@link LimitClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link LimitClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link LimitClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link LimitClause} statement.\n\t *\n\t * @return The {@link LimitClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends object, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & LimitClause<T>;\n} = {\n\tcreateFrom( genericFactory, container, object ) {\n\t\treturn Object.assign( object, {\n\t\t\tlimit: getLimitFn( genericFactory, container ),\n\t\t} );\n\t},\n};\n","import { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the `OFFSET` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rOffsetClause}\n */\nexport class OffsetToken implements TokenNode {\n\treadonly token:\"offset\" = \"offset\";\n\treadonly value:number;\n\n\tconstructor( value:number ) {\n\t\tthis.value = value;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\treturn `OFFSET ${ this.value }`;\n\t}\n}\n","import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\n\nimport { OffsetToken } from \"../tokens/OffsetToken\";\nimport { QueryClauseToken } from \"../tokens/QueryClauseToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SubSelectToken } from \"../tokens/SubSelectToken\";\n\nimport { cloneSolutionModifierContainer } from \"./SolutionModifierClause\";\n\n\n/**\n * Interface with the methods available to make a OFFSET statement.\n */\nexport interface OffsetClause<T extends object> {\n\t/**\n\t * Set the offset of results the query should return from.\n\t *\n\t * @param offset The number to be applied as offset.\n\t * @returns A OffsetClause or the FinishClause/SubFinishClause depending\n\t * if the limit method has been called before or not.\n\t */\n\toffset( offset:number ):T;\n}\n\n/**\n * Function that creates the {@link OffsetClause.offset} function.\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link OffsetClause} receives.\n * @param container The container with the query data of the statement.\n *\n * @returns The {@link OffsetClause.offset} function.\n *\n * @private\n */\nfunction getOffsetFn<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends object>( genericFactory:Factory<C, T>, container:C ):OffsetClause<T>[ \"offset\" ] {\n\treturn ( offset:number ) => {\n\t\tconst token:OffsetToken = new OffsetToken( offset );\n\n\t\tconst newContainer:C = cloneSolutionModifierContainer( container, token );\n\t\treturn genericFactory( newContainer, {} );\n\t};\n}\n\n/**\n * Constant with the utils for {@link OffsetClause} objects.\n */\nexport const OffsetClause:{\n\t/**\n\t * Factory function that allows to crete a {@link OffsetClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link OffsetClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link OffsetClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link OffsetClause} statement.\n\t *\n\t * @return The {@link OffsetClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends object, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & OffsetClause<T>;\n} = {\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends object, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & OffsetClause<T> {\n\t\treturn Object.assign( object, {\n\t\t\toffset: getOffsetFn( genericFactory, container ),\n\t\t} );\n\t},\n};","import { isPrefixed } from \"../iri/utils\";\nimport { IRIRefToken } from \"./IRIRefToken\";\nimport { PrefixedNameToken } from \"./PrefixedNameToken\";\n\n\n/**\n * Alias for any IRI token.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#riri}\n */\nexport type IRIToken = IRIRefToken | PrefixedNameToken;\n\n\n/**\n * Returns the respective token from the IRI string.\n *\n * @param iri The IRI string to be converted into a token.\n */\nexport function getIRIToken( iri:string ):IRIToken {\n\tif( isPrefixed( iri ) ) return new PrefixedNameToken( iri );\n\treturn new IRIRefToken( iri );\n}\n","import { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the any literal term.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rRDFLiteral}\n * @see {@link https://www.w3.org/TR/sparql11-query/#rNumericLiteral}\n * @see {@link https://www.w3.org/TR/sparql11-query/#rBooleanLiteral}\n */\nexport class LiteralToken implements TokenNode {\n\treadonly token:\"literal\" = \"literal\";\n\n\treadonly value:boolean | number | string;\n\n\tconstructor( value:boolean | number | string ) {\n\t\tthis.value = value;\n\t}\n\n\ttoString( spaces?:number ):string {\n\t\treturn JSON.stringify( this.value );\n\t}\n}\n","import { IRIToken } from \"./IRIToken\";\nimport { LanguageToken } from \"./LanguageToken\";\nimport { LiteralToken } from \"./LiteralToken\";\n\n\n/**\n * The token of the RDF Literal term.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rRDFLiteral}\n */\nexport class RDFLiteralToken extends LiteralToken {\n\treadonly value!:string;\n\treadonly type?:IRIToken;\n\treadonly language?:LanguageToken;\n\n\tconstructor( value:string, type?:IRIToken );\n\tconstructor( value:string, language?:LanguageToken );\n\tconstructor( value:string, typeOrLanguage?:IRIToken | LanguageToken ) {\n\t\tsuper( value );\n\n\t\tif( ! typeOrLanguage ) return;\n\n\n\t\tif( typeOrLanguage.token === \"language\" ) {\n\t\t\tthis.language = typeOrLanguage;\n\t\t} else {\n\t\t\tthis.type = typeOrLanguage;\n\t\t}\n\t}\n\n\ttoString( spaces?:number ):string {\n\t\tconst value:string = super.toString();\n\n\t\tif( this.language ) return value + this.language;\n\t\tif( this.type ) return `${ value }^^${ this.type }`;\n\n\t\treturn value;\n\t}\n\n}\n","export const XSD:{\n\tnamespace:\"http://www.w3.org/2001/XMLSchema#\",\n\n\tboolean:\"http://www.w3.org/2001/XMLSchema#boolean\",\n\tbyte:\"http://www.w3.org/2001/XMLSchema#byte\",\n\tdate:\"http://www.w3.org/2001/XMLSchema#date\",\n\tdateTime:\"http://www.w3.org/2001/XMLSchema#dateTime\",\n\tdecimal:\"http://www.w3.org/2001/XMLSchema#decimal\",\n\tdouble:\"http://www.w3.org/2001/XMLSchema#double\",\n\tduration:\"http://www.w3.org/2001/XMLSchema#duration\",\n\tfloat:\"http://www.w3.org/2001/XMLSchema#float\",\n\tgDay:\"http://www.w3.org/2001/XMLSchema#gDay\",\n\tgMonth:\"http://www.w3.org/2001/XMLSchema#gMonth\",\n\tgMonthDay:\"http://www.w3.org/2001/XMLSchema#gMonthDay\",\n\tgYear:\"http://www.w3.org/2001/XMLSchema#gYear\",\n\tgYearMonth:\"http://www.w3.org/2001/XMLSchema#gYearMonth\",\n\tint:\"http://www.w3.org/2001/XMLSchema#int\",\n\tinteger:\"http://www.w3.org/2001/XMLSchema#integer\",\n\tlong:\"http://www.w3.org/2001/XMLSchema#long\",\n\tnegativeInteger:\"http://www.w3.org/2001/XMLSchema#negativeInteger\",\n\tnonNegativeInteger:\"http://www.w3.org/2001/XMLSchema#nonNegativeInteger\",\n\tnonPositiveInteger:\"http://www.w3.org/2001/XMLSchema#nonPositiveInteger\",\n\tobject:\"http://www.w3.org/2001/XMLSchema#object\",\n\tpositiveInteger:\"http://www.w3.org/2001/XMLSchema#positiveInteger\",\n\tshort:\"http://www.w3.org/2001/XMLSchema#short\",\n\tstring:\"http://www.w3.org/2001/XMLSchema#string\",\n\ttime:\"http://www.w3.org/2001/XMLSchema#time\",\n\tunsignedByte:\"http://www.w3.org/2001/XMLSchema#unsignedByte\",\n\tunsignedInt:\"http://www.w3.org/2001/XMLSchema#unsignedInt\",\n\tunsignedLong:\"http://www.w3.org/2001/XMLSchema#unsignedLong\",\n\tunsignedShort:\"http://www.w3.org/2001/XMLSchema#unsignedShort\",\n} = {\n\tnamespace: \"http://www.w3.org/2001/XMLSchema#\",\n\n\tboolean: \"http://www.w3.org/2001/XMLSchema#boolean\",\n\tbyte: \"http://www.w3.org/2001/XMLSchema#byte\",\n\tdate: \"http://www.w3.org/2001/XMLSchema#date\",\n\tdateTime: \"http://www.w3.org/2001/XMLSchema#dateTime\",\n\tdecimal: \"http://www.w3.org/2001/XMLSchema#decimal\",\n\tdouble: \"http://www.w3.org/2001/XMLSchema#double\",\n\tduration: \"http://www.w3.org/2001/XMLSchema#duration\",\n\tfloat: \"http://www.w3.org/2001/XMLSchema#float\",\n\tgDay: \"http://www.w3.org/2001/XMLSchema#gDay\",\n\tgMonth: \"http://www.w3.org/2001/XMLSchema#gMonth\",\n\tgMonthDay: \"http://www.w3.org/2001/XMLSchema#gMonthDay\",\n\tgYear: \"http://www.w3.org/2001/XMLSchema#gYear\",\n\tgYearMonth: \"http://www.w3.org/2001/XMLSchema#gYearMonth\",\n\tint: \"http://www.w3.org/2001/XMLSchema#int\",\n\tinteger: \"http://www.w3.org/2001/XMLSchema#integer\",\n\tlong: \"http://www.w3.org/2001/XMLSchema#long\",\n\tnegativeInteger: \"http://www.w3.org/2001/XMLSchema#negativeInteger\",\n\tnonNegativeInteger: \"http://www.w3.org/2001/XMLSchema#nonNegativeInteger\",\n\tnonPositiveInteger: \"http://www.w3.org/2001/XMLSchema#nonPositiveInteger\",\n\tobject: \"http://www.w3.org/2001/XMLSchema#object\",\n\tpositiveInteger: \"http://www.w3.org/2001/XMLSchema#positiveInteger\",\n\tshort: \"http://www.w3.org/2001/XMLSchema#short\",\n\tstring: \"http://www.w3.org/2001/XMLSchema#string\",\n\ttime: \"http://www.w3.org/2001/XMLSchema#time\",\n\tunsignedByte: \"http://www.w3.org/2001/XMLSchema#unsignedByte\",\n\tunsignedInt: \"http://www.w3.org/2001/XMLSchema#unsignedInt\",\n\tunsignedLong: \"http://www.w3.org/2001/XMLSchema#unsignedLong\",\n\tunsignedShort: \"http://www.w3.org/2001/XMLSchema#unsignedShort\",\n};","import { getIRIToken } from \"../tokens/IRIToken\";\nimport { LiteralToken } from \"../tokens/LiteralToken\";\nimport { ObjectToken } from \"../tokens/ObjectToken\";\nimport { RDFLiteralToken } from \"../tokens/RDFLiteralToken\";\nimport { TermToken } from \"../tokens/TermToken\";\nimport { VariableToken } from \"../tokens/VariableToken\";\n\nimport { XSD } from \"../utils/XSD\";\n\nimport { SupportedNativeTypes } from \"./SupportedNativeTypes\";\nimport { TripleSubject } from \"./triplePatterns/TripleSubject\";\n\n\nexport function convertValue( value:\"UNDEF\" ):\"UNDEF\";\nexport function convertValue<T extends TripleSubject<X>, X extends ObjectToken>( value:T ):X;\nexport function convertValue<T extends SupportedNativeTypes>( value:T ):LiteralToken;\nexport function convertValue( value:SupportedNativeTypes | TripleSubject<VariableToken | TermToken> ):ObjectToken | \"UNDEF\" {\n\tif( value instanceof Date )\n\t\treturn new RDFLiteralToken( value.toISOString(), getIRIToken( XSD.dateTime ) );\n\n\tif( typeof value === \"object\" )\n\t\treturn value.getSubject();\n\n\tif( typeof value === \"string\" ) {\n\t\tif( value === \"UNDEF\" ) return value;\n\t\treturn new LiteralToken( value );\n\t}\n\n\treturn new LiteralToken( value );\n}\n","import { IRIToken } from \"./IRIToken\";\nimport { LiteralToken } from \"./LiteralToken\";\nimport { getIndentation, getSeparator, INDENTATION_SPACES } from \"./printing\";\nimport { RDFLiteralToken } from \"./RDFLiteralToken\";\nimport { TokenNode } from \"./TokenNode\";\nimport { VariableToken } from \"./VariableToken\";\n\n\n/**\n * The token of the `VALUES` clause or pattern statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rValuesClause}\n * @see {@link https://www.w3.org/TR/sparql11-query/#rInlineData}\n */\nexport class ValuesToken implements TokenNode {\n\treadonly token:\"values\" = \"values\";\n\n\treadonly variables:VariableToken[];\n\treadonly values:(IRIToken | RDFLiteralToken | LiteralToken | \"UNDEF\")[][];\n\n\tconstructor() {\n\t\tthis.variables = [];\n\t\tthis.values = [];\n\t}\n\n\taddVariables( ...variables:VariableToken[] ):this {\n\t\tthis.variables.push( ...variables );\n\t\treturn this;\n\t}\n\n\taddValues( ...values:(IRIToken | LiteralToken | \"UNDEF\")[] ):this {\n\t\tthis.values.push( values );\n\t\treturn this;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\tconst variables:string = this._getVariablesStr();\n\n\t\tconst values:string = this._getValuesStr( spaces );\n\t\treturn `VALUES ${ variables } ${ values }`;\n\t}\n\n\tprivate _getVariablesStr():string {\n\t\tif( ! this.variables.length ) return \"()\";\n\n\t\tconst variables:string = this.variables.join( \" \" );\n\t\tif( this.variables.length === 1 ) return variables;\n\n\t\treturn `( ${ variables } )`;\n\t}\n\n\tprivate _getValuesStr( spaces?:number ):string {\n\t\tif( ! this.values.length ) return \"{}\";\n\n\t\tif( this.variables.length === 1 ) {\n\t\t\tconst values:string = this.values\n\t\t\t\t.filter( x => x.length )\n\t\t\t\t.map( x => x[ 0 ] )\n\t\t\t\t.join( \" \" );\n\n\t\t\tif( ! values ) return \"{}\";\n\t\t\treturn \"{ \" + values + \" }\";\n\t\t}\n\n\t\tconst subIndent:string = getIndentation( spaces, INDENTATION_SPACES );\n\t\tconst separator:string = getSeparator( spaces );\n\t\tconst indent:string = getIndentation( spaces );\n\t\treturn \"{\" + separator +\n\t\t\tthis.values\n\t\t\t\t.map( values => {\n\t\t\t\t\tconst valuesStr:string = values.length ?\n\t\t\t\t\t\t`( ${ values.join( \" \" ) } )` : \"()\";\n\t\t\t\t\treturn subIndent + valuesStr;\n\t\t\t\t} )\n\t\t\t\t.join( separator ) + separator +\n\t\t\tindent + \"}\";\n\t}\n}\n","import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\nimport { IRIResolver } from \"../data/IRIResolver\";\nimport { cloneElement } from \"../data/utils\";\n\nimport { PatternBuilder } from \"../patterns/PatternBuilder\";\nimport { SupportedNativeTypes } from \"../patterns/SupportedNativeTypes\";\nimport { Literal } from \"../patterns/triplePatterns/Literal\";\nimport { Resource } from \"../patterns/triplePatterns/Resource\";\nimport { Undefined } from \"../patterns/Undefined\";\nimport { convertValue } from \"../patterns/utils\";\n\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SubSelectToken } from \"../tokens/SubSelectToken\";\nimport { ValuesToken } from \"../tokens/ValuesToken\";\nimport { VariableToken } from \"../tokens/VariableToken\";\n\nimport { FinishClause } from \"./FinishClause\";\n\n\nexport interface ValuesClause<T extends FinishClause> {\n\t/**\n\t * Set the values of a variable to be combined into the results query.\n\t *\n\t * @param variable Variable to add values.\n\t * @param values The values to be combined.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variable:string, values:SupportedNativeTypes | SupportedNativeTypes[] ):T;\n\n\t/**\n\t * Set the values of a variable to be combined into the results query.\n\t *\n\t * The values are constructed with a function that receives a\n\t * pattern builder.\n\t *\n\t * @param variable Variable to add values.\n\t * @param valuesBuilder Functions that returns the values to be added.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variable:string, valuesBuilder:( builder:PatternBuilder ) => (SupportedNativeTypes | Resource | Literal | Undefined) | (SupportedNativeTypes | Resource | Literal | Undefined)[] ):T;\n\n\t/**\n\t * Set the values of multiple variables to be combined into the results\n\t * query.\n\t *\n\t * @param variables Variables to add values.\n\t * @param values The values to be combined.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variables:string[], values:SupportedNativeTypes[] | SupportedNativeTypes[][] ):T;\n\n\t/**\n\t * Set the values of multiple variables to be combined into the results\n\t * query.\n\t *\n\t * The values are constructed with a function that receives a\n\t * pattern builder.\n\t *\n\t * @param variables Variables to add values.\n\t * @param valuesBuilder Functions that returns the values to be added.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvalues( variables:string[], valuesBuilder:( builder:PatternBuilder ) => (SupportedNativeTypes | Resource | Literal | Undefined)[] | (SupportedNativeTypes | Resource | Literal | Undefined)[][] ):T;\n}\n\n\ntype Values = SupportedNativeTypes | Resource | Literal | \"UNDEF\";\n\ntype ValuesOrBuilder =\n\t| (SupportedNativeTypes | SupportedNativeTypes[])\n\t| (SupportedNativeTypes[] | SupportedNativeTypes[][])\n\t| (( builder:PatternBuilder ) => Values | Values[])\n\t| (( builder:PatternBuilder ) => Values[] | Values[][])\n\t;\n\nfunction _normalizeVariables( variableOrVariables:string | string [] ):VariableToken[] {\n\tconst variables:string[] = Array.isArray( variableOrVariables ) ? variableOrVariables : [ variableOrVariables ];\n\treturn variables.map( x => new VariableToken( x ) );\n}\n\nfunction _normalizeRawValues( valuesOrBuilder:ValuesOrBuilder, iriResolver:IRIResolver, isSingle:boolean ):Values[][] {\n\tlet rawValues:Values | (Values | Values[])[] = typeof valuesOrBuilder === \"function\" ?\n\t\tvaluesOrBuilder( PatternBuilder.create( iriResolver ) ) :\n\t\tvaluesOrBuilder;\n\n\t// When single variable\n\tif( ! Array.isArray( rawValues ) )\n\t\treturn [ [ rawValues ] ];\n\n\tif( isSingle )\n\t\trawValues.map( value => [ value ] );\n\n\n\t// When multiple variables\n\tif( rawValues.some( Array.isArray ) )\n\t\treturn rawValues as Values[][];\n\n\treturn [ rawValues as Values[] ];\n}\n\n/**\n * Function that creates the {@link ValuesClause.values} function.\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link ValuesClause} receives.\n * @param container The container with the query data of the statement.\n *\n * @returns The {@link ValuesClause.values} function.\n *\n * @private\n */\nfunction createValuesFn<C extends Container<QueryToken | SubSelectToken>, T extends FinishClause>( genericFactory:Factory<C, T>, container:C ):ValuesClause<T>[ \"values\" ] {\n\treturn ( variableOrVariables:string | string [], valuesOrBuilder:ValuesOrBuilder ) => {\n\t\tconst token:ValuesToken = new ValuesToken();\n\n\t\tconst variables:VariableToken[] = _normalizeVariables( variableOrVariables );\n\t\ttoken.addVariables( ...variables );\n\n\t\tconst isSingle:boolean = ! Array.isArray( variableOrVariables );\n\t\tconst iriResolver:IRIResolver = new IRIResolver( container.iriResolver );\n\t\tconst values:Values[][] = _normalizeRawValues( valuesOrBuilder, iriResolver, isSingle );\n\t\tvalues.forEach( ( valuesRow ) => token.addValues( ...valuesRow.map( convertValue ) ) );\n\n\t\tconst targetToken = cloneElement( container.targetToken, { values: token } );\n\t\tconst newContainer = cloneElement( container, { iriResolver, targetToken } as Partial<C> );\n\t\treturn genericFactory( newContainer, {} );\n\t}\n}\n\n\n/**\n * Constant with the utils for {@link ValuesClause} objects.\n */\nexport const ValuesClause:{\n\t/**\n\t * Factory function that allows to crete a {@link ValuesClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link ValuesClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link ValuesClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link ValuesClause} statement.\n\t *\n\t * @return The {@link ValuesClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken | SubSelectToken>, T extends FinishClause, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & ValuesClause<T>\n} = {\n\tcreateFrom<C extends Container<QueryToken | SubSelectToken>, T extends FinishClause, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & ValuesClause<T> {\n\t\treturn Object.assign( object, {\n\t\t\tvalues: createValuesFn( genericFactory, container ),\n\t\t} );\n\t},\n};\n","import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\n\nimport { QueryClauseToken } from \"../tokens/QueryClauseToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SubSelectToken } from \"../tokens/SubSelectToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { LimitClause } from \"./LimitClause\";\nimport { OffsetClause } from \"./OffsetClause\";\nimport { ValuesClause } from \"./ValuesClause\";\n\n\n/**\n * Interface that specify union of the LIMIT and OFFSET statements.\n * Its specified in a form one can use `limit` and `offset` in\n * this order or viceversa, but not be able to repeat the `limit`\n * or `offset` methods.\n *\n * Example:\n *  - Correct:\n *  ```typescript\n *      import { LimitOffsetClause } from \"sparqler/clauses\";\n *      let query:LimitOffsetClause;\n *\n *      query\n *          .limit( &#47;*...*&#47; )\n *          .offset( &#47;*...*&#47; )\n *      ;\n *\n *      query\n *          .offset( &#47;*...*&#47; )\n *          .limit( &#47;*...*&#47; )\n *      ;\n *\n *      query\n *          .limit( &#47;*...*&#47; )\n *      ;\n * ```\n *\n *  - Incorrect:\n *  ```typescript\n *      import { LimitOffsetClause } from \"sparqler/Clauses\";\n *      let query:LimitOffsetClause;\n *\n *      query\n *          .limit( &#47;*...*&#47; )\n *          .limit( &#47;*...*&#47; ) // Not possible\n *          .offset( &#47;*...*&#47; )\n *      ;\n *\n *      query\n *          .offset( &#47;*...*&#47; )\n *          .limit( &#47;*...*&#47; )\n *          .offset( &#47;*...*&#47; ) // Not possible\n *      ;\n * ```\n */\nexport interface LimitOffsetClause<T extends FinishClause> extends LimitClause<OffsetClause<ValuesClause<T> & T> & ValuesClause<T> & T>,\n                                                                   OffsetClause<LimitClause<ValuesClause<T> & T> & ValuesClause<T> & T>,\n                                                                   ValuesClause<T> {}\n\n\nfunction _getLimitFactory<CONTAINER extends Container<any>, T extends FinishClause>( valuesFactory:Factory<CONTAINER, ValuesClause<T> & T> ):Factory<CONTAINER, LimitClause<OffsetClause<ValuesClause<T> & T> & ValuesClause<T> & T>> {\n\tconst offsetValuesFactory:Factory<CONTAINER, OffsetClause<ValuesClause<T> & T>> = OffsetClause\n\t\t.createFrom.bind( null, valuesFactory );\n\n\treturn ( container1, object1 ) => LimitClause\n\t\t.createFrom( Factory.createFrom( offsetValuesFactory, valuesFactory ), container1, object1 );\n}\n\nfunction _getOffsetFactory<CONTAINER extends Container<any>, T extends FinishClause>( valuesFactory:Factory<CONTAINER, ValuesClause<T> & T> ):Factory<CONTAINER, OffsetClause<LimitClause<ValuesClause<T> & T> & ValuesClause<T> & T>> {\n\tconst limitValuesFactory:Factory<CONTAINER, LimitClause<ValuesClause<T> & T>> = LimitClause\n\t\t.createFrom.bind( null, valuesFactory );\n\n\treturn ( container1, object1 ) => OffsetClause\n\t\t.createFrom( Factory.createFrom( valuesFactory, limitValuesFactory ), container1, object1 );\n}\n\n\n/**\n * Constant with the utils for {@link LimitOffsetClause} objects.\n */\nexport const LimitOffsetClause:{\n\t/**\n\t * Factory function that allows to crete a {@link LimitOffsetClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link LimitOffsetClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link LimitOffsetClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link LimitOffsetClause} statement.\n\t *\n\t * @return The {@link LimitOffsetClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends FinishClause, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & LimitOffsetClause<T>;\n} = {\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends FinishClause, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & LimitOffsetClause<T> {\n\t\tconst valuesFactory:Factory<C, ValuesClause<T>> = ValuesClause\n\t\t\t.createFrom.bind( null, genericFactory );\n\n\t\tconst genericAndValuesFactory = Factory.createFrom( genericFactory, valuesFactory );\n\n\t\treturn Factory.createFrom(\n\t\t\t_getLimitFactory<C, T>( genericAndValuesFactory ),\n\t\t\t_getOffsetFactory<C, T>( genericAndValuesFactory ),\n\t\t\tvaluesFactory\n\t\t)( container, object );\n\t},\n};\n","import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\n\nimport { OrderToken } from \"../tokens/OrderToken\";\nimport { QueryClauseToken } from \"../tokens/QueryClauseToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SubSelectToken } from \"../tokens/SubSelectToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { LimitOffsetClause } from \"./LimitOffsetClause\";\nimport { cloneSolutionModifierContainer } from \"./SolutionModifierClause\";\n\n\n/**\n * Interface with the methods available to make a ORDER BY statement.\n */\nexport interface OrderClause<T extends FinishClause> extends LimitOffsetClause<T> {\n\t/**\n\t * Set a condition to be used as the order of the sequence of solutions the\n\t * query will retrieve.\n\t *\n\t * Notice: The current version of SPARQLER does not evaluate the condition\n\t * for possible errors.\n\t *\n\t * @param rawCondition Raw condition to be applied for the solutions order.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\t// TODO: create order condition expressions\n\torderBy( rawCondition:string ):LimitOffsetClause<T> & T;\n}\n\n/**\n * Function that creates the {@link OrderClause.orderBy} function.\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link OrderClause} receives.\n * @param container The container with the query data of the statement.\n *\n * @returns The {@link OrderClause.orderBy} function.\n *\n * @private\n */\nfunction getOrderByFn<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends FinishClause>( genericFactory:Factory<C, T>, container:C ):OrderClause<T>[ \"orderBy\" ] {\n\treturn ( rawCondition:string ) => {\n\t\tconst token:OrderToken = new OrderToken( rawCondition );\n\t\tconst newContainer = cloneSolutionModifierContainer( container, token );\n\n\t\tconst limitOffsetClause:LimitOffsetClause<T> = LimitOffsetClause.createFrom( genericFactory, newContainer, {} );\n\t\treturn genericFactory( newContainer, limitOffsetClause );\n\t};\n}\n\n\n/**\n * Constant with the utils for {@link OrderClause} objects.\n */\nexport const OrderClause:{\n\t/**\n\t * Factory function that allows to crete a {@link OrderClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link OrderClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link OrderClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link OrderClause} statement.\n\t *\n\t * @return The {@link OrderClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends FinishClause, O extends object>( genericFactory:Factory<typeof container, T>, container:C, object:O ):O & OrderClause<T>;\n} = {\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends FinishClause, O extends object>( genericFactory:Factory<typeof container, T>, container:C, object:O ):O & OrderClause<T> {\n\t\treturn LimitOffsetClause.createFrom( genericFactory, container, Object.assign( object, {\n\t\t\torderBy: getOrderByFn( genericFactory, container ),\n\t\t} ) );\n\t}\n};\n","import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\n\nimport { HavingToken } from \"../tokens/HavingToken\";\nimport { QueryClauseToken } from \"../tokens/QueryClauseToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SubSelectToken } from \"../tokens/SubSelectToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { OrderClause } from \"./OrderClause\";\nimport { cloneSolutionModifierContainer } from \"./SolutionModifierClause\";\n\n\n/**\n * Interface with the methods available to make a HAVING statement.\n */\nexport interface HavingClause<T extends FinishClause> extends OrderClause<T> {\n\t/**\n\t * Set a condition to filter the sequence of solutions the query will\n\t * retrieve.\n\t *\n\t * Notice: The current version of SPARQLER does not evaluate the condition\n\t * for possible errors\n\t *\n\t * @param rawCondition Raw condition to be applied for the solutions filtering.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\t// TODO: create having condition expressions\n\thaving( rawCondition:string ):OrderClause<T> & T;\n}\n\n\n/**\n * Function that creates the {@link HavingClause.having} function.\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link HavingClause} receives.\n * @param container The container with the query data of the statement.\n *\n * @returns The {@link HavingClause.having} function.\n *\n * @private\n */\nfunction getHavingFn<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends FinishClause>( genericFactory:Factory<C, T>, container:C ):HavingClause<T>[ \"having\" ] {\n\treturn ( rawCondition:string ) => {\n\t\tconst token:HavingToken = new HavingToken( rawCondition );\n\t\tconst newContainer = cloneSolutionModifierContainer( container, token );\n\n\t\tconst orderClause:OrderClause<T> = OrderClause.createFrom( genericFactory, newContainer, {} );\n\t\treturn genericFactory( newContainer, orderClause );\n\t}\n}\n\n\n/**\n * Constant with the utils for {@link HavingClause} objects.\n */\nexport const HavingClause:{\n\t/**\n\t * Factory function that allows to crete a {@link HavingClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link HavingClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link HavingClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link HavingClause} statement.\n\t *\n\t * @return The {@link HavingClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends FinishClause, O extends object>( genericFactory:Factory<typeof container, T>, container:C, object:O ):O & HavingClause<T>;\n} = {\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends FinishClause, O extends object>( genericFactory:Factory<typeof container, T>, container:C, object:O ):O & HavingClause<T> {\n\t\treturn OrderClause.createFrom( genericFactory, container, Object.assign( object, {\n\t\t\thaving: getHavingFn( genericFactory, container ),\n\t\t} ) );\n\t},\n};\n","import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\n\nimport { GroupToken } from \"../tokens/GroupToken\";\nimport { QueryClauseToken } from \"../tokens/QueryClauseToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SubSelectToken } from \"../tokens/SubSelectToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { HavingClause } from \"./HavingClause\";\nimport { cloneSolutionModifierContainer } from \"./SolutionModifierClause\";\n\n\n/**\n * Interface with the methods available to make a GROUP BY statement.\n */\nexport interface GroupClause<T extends FinishClause> extends HavingClause<T> {\n\t/**\n\t * Set a condition to be divide the solutions returned by the query\n\t * into one or more groups.\n\t *\n\t * @param rawCondition Raw condition to be applied to the solutions grouping.\n\t *\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\t// TODO: create group condition expressions\n\tgroupBy( rawCondition:string ):HavingClause<T> & T;\n}\n\n\n/**\n * Function that creates the {@link GroupClause.groupBy} function.\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link GroupClause} receives.\n * @param container The container with the query data of the statement.\n *\n * @returns The {@link GroupClause.groupBy} function.\n *\n * @private\n */\nfunction getGroupByFn<C extends Container<QueryToken<QueryClauseToken> | SubSelectToken>, T extends FinishClause>( genericFactory:Factory<C, T>, container:C ):GroupClause<T>[ \"groupBy\" ] {\n\treturn ( rawCondition:string ) => {\n\t\tconst token:GroupToken = new GroupToken( rawCondition );\n\t\tconst newContainer = cloneSolutionModifierContainer( container, token );\n\n\t\tconst havingClause:HavingClause<T> = HavingClause.createFrom( genericFactory, newContainer, {} );\n\t\treturn genericFactory( newContainer, havingClause );\n\t}\n}\n\n\n/**\n * Constant with the utils for {@link GroupClause} objects.\n */\nexport const GroupClause:{\n\t/**\n\t * Factory function that allows to crete a {@link GroupClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link GroupClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link GroupClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link GroupClause} statement.\n\t *\n\t * @return The {@link GroupClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<SubSelectToken | QueryToken<QueryClauseToken>>, T extends FinishClause, O extends object>( genericFactory:Factory<typeof container, T>, container:C, object:O ):O & GroupClause<T>;\n} = {\n\tcreateFrom<C extends Container<SubSelectToken | QueryToken<QueryClauseToken>>, T extends FinishClause, O extends object>( genericFactory:Factory<typeof container, T>, container:C, object:O ):O & GroupClause<T> {\n\t\treturn HavingClause.createFrom( genericFactory, container, Object.assign( object, {\n\t\t\tgroupBy: getGroupByFn( genericFactory, container ),\n\t\t} ) );\n\t},\n};\n","import { Container } from \"../data/Container\";\n\nimport { PatternToken } from \"../tokens/PatternToken\";\n\n\n/**\n * Object that contains any type of pattern.\n */\nexport interface Pattern<T extends PatternToken = PatternToken> {\n\tgetPattern():T;\n}\n\n\n/**\n * Constant with utils for {@link Pattern} objects.\n */\nexport const Pattern:{\n\t/**\n\t * Factory function that allows to crete a {@link Pattern}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link Pattern} statement.\n\t * @param object The base base from where to create the\n\t * {@link Pattern} statement.\n\t *\n\t * @return The {@link Pattern} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<T extends PatternToken, C extends Container<T>, O extends object>( container:C, object:O ):O & Pattern<T>;\n} = {\n\tcreateFrom<T extends PatternToken, C extends Container<T>, O extends object>( container:C, object:O ):O & Pattern<T> {\n\t\treturn Object.assign( object, {\n\t\t\tgetPattern: () => container.targetToken,\n\t\t} );\n\t},\n};\n","import { FinishClause } from \"../../clauses/FinishClause\";\n\nimport { Container } from \"../../data/Container\";\nimport { Factory } from \"../../data/Factory\";\n\nimport { SubSelectToken } from \"../../tokens/SubSelectToken\";\n\nimport { Pattern } from \"../Pattern\";\n\n\n/**\n * Interface with the methods available to finish a sub-query.\n *\n * Extends {@link FinishClause} to be compatible with the clauses\n * system, and {@link Pattern} with the {@link Pattern.getPattern}\n * method that is the one used to retrieve the sub-query pattern.\n */\nexport interface FinishPattern extends Pattern<SubSelectToken>, FinishClause {\n}\n\n\n/**\n * Constant with the utils for {@link FinishPattern} objects.\n */\nexport const FinishPattern:{\n\t/**\n\t * Factory function that allows to crete a {@link FinishPattern}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link FinishPattern} statement.\n\t * @param object The base base from where to create the\n\t * {@link FinishPattern} statement.\n\t *\n\t * @return The {@link FinishPattern} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<SubSelectToken>, O extends object>( container:C, object:O ):O & FinishPattern;\n} = {\n\tcreateFrom<C extends Container<SubSelectToken>, O extends object>( container:C, object:O ):O & FinishPattern {\n\t\treturn Factory.createFrom<C, Pattern<SubSelectToken>, FinishClause>(\n\t\t\tPattern.createFrom,\n\t\t\tFinishClause.createFrom,\n\t\t)( container, object );\n\t},\n};\n","import { GroupClause } from \"../../clauses/GroupClause\";\nimport { Container } from \"../../data/Container\";\nimport { cloneElement } from \"../../data/utils\";\n\nimport { SubSelectToken } from \"../../tokens/SubSelectToken\";\nimport { WhereToken } from \"../../tokens/WhereToken\";\n\nimport { Pattern } from \"../Pattern\";\nimport { FinishPattern } from \"./FinishPattern\";\n\n\n/**\n * Interface with the methods available to make a WHERE statement of\n * a sub-query.\n */\nexport interface WherePattern {\n\t/**\n\t * Sets the graph patterns the sub-query should match to retrieve the\n\t * sub-solutions data.\n\t *\n\t * @param patterns Patterns the sub-query should match.\n\t *\n\t * @returns Object with the methods to keep constructing the\n\t * sub-query.\n\t */\n\twhere( patterns:Pattern | Pattern[] ):GroupClause<FinishPattern> & FinishPattern;\n}\n\n\n/**\n * Function that creates the {@link WherePattern.where} function.\n *\n * @param container The container with the query data of the statement.\n *\n * @returns The {@link WherePattern.where} function.\n *\n * @private\n */\nfunction getWhereFn( container:Container<SubSelectToken> ):WherePattern[ \"where\" ] {\n\treturn ( patterns:Pattern | Pattern[] ) => {\n\t\tconst where:WhereToken = new WhereToken();\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\t\twhere.groupPattern.patterns.push( ...patterns.map( x => x.getPattern() ) );\n\n\t\tconst targetToken:SubSelectToken = cloneElement( container.targetToken, { where } );\n\t\tconst newContainer = cloneElement( container, { targetToken } );\n\n\t\tconst groupClause:GroupClause<FinishPattern> = GroupClause.createFrom( FinishPattern.createFrom, newContainer, {} );\n\t\treturn FinishPattern.createFrom( newContainer, groupClause );\n\t};\n}\n\n\n/**\n * Constant with the utils for {@link WherePattern} objects.\n */\nexport const WherePattern:{\n\n\t/**\n\t * Factory function that allows to crete a {@link WherePattern}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link WherePattern} statement.\n\t * @param object The base base from where to create the\n\t * {@link WherePattern} statement.\n\t *\n\t * @return The {@link WherePattern} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<SubSelectToken>, O extends object>( container:C, object:O ):O & WherePattern;\n} = {\n\tcreateFrom<C extends Container<SubSelectToken>, O extends object>( container:C, object:O ):O & WherePattern {\n\t\treturn Object.assign( object, {\n\t\t\twhere: getWhereFn( container ),\n\t\t} );\n\t},\n};","import { Container } from \"../../data/Container\";\n\nimport { SubSelectToken } from \"../../tokens/SubSelectToken\";\nimport { VariableToken } from \"../../tokens/VariableToken\";\n\nimport { WherePattern } from \"./WherePattern\";\n\n\n/**\n * Interface with the methods available to make a sub-SELECT query.\n */\nexport interface SubSelectPattern {\n\t/**\n\t * Set a list of variables to be retrieved by the sub-query.\n\t *\n\t * @param variables The list of variables.\n\t * IF no variable is provided, the behaviour will be the same\n\t * as {@link SubSelectPattern.selectAll}\n\t *\n\t * @returns Object with the methods to keep constructing the\n\t * sub-query.\n\t */\n\tselect( ...variables:string[] ):WherePattern;\n\n\t/**\n\t * Set a list of variables to be retrieved by the sub-query\n\t * ensuring no repetitions in the set of solutions.\n\t *\n\t * @param variables The list of variables.\n\t * IF no variable is provided, the behaviour will be the same\n\t * as {@link SubSelectPattern.selectAllDistinct}\n\t *\n\t * @returns Object with the methods to keep constructing the\n\t * sub-query.\n\t */\n\tselectDistinct( ...variables:string[] ):WherePattern;\n\n\t/**\n\t * Set a list of variables to be retrieved by the sub-query\n\t * permitting eliminations of non-distinct solutions, but not\n\t * ensuring a set of unique ones.\n\t *\n\t * @param variables The list of variables.\n\t * IF no variable is provided, the behaviour will be the same\n\t * as {@link SubSelectPattern.selectAllReduced}\n\t *\n\t * @returns Object with the methods to keep constructing the\n\t * sub-query.\n\t */\n\tselectReduced( ...variables:string[] ):WherePattern;\n\n\t/**\n\t * Set that the sub-query must return all the solutions for the\n\t * variables used in the where pattern matching.\n\t *\n\t * @returns Object with the methods to keep constructing the\n\t * sub-query.\n\t */\n\tselectAll():WherePattern;\n\n\t/**\n\t * Set that the sub-query must return all the solutions for the\n\t * variables used in the where pattern matching, ensuring there\n\t * is not duplicated solutions.\n\t *\n\t * @returns Object with the methods to keep constructing the\n\t * sub-query.\n\t */\n\tselectAllDistinct():WherePattern;\n\n\t/**\n\t * Set that the sub-query must return all the solutions for the\n\t * variables used in the where pattern matching, permitting\n\t * eliminations of non-distinct solutions, but not ensuring a set\n\t * of unique ones.\n\t *\n\t * @returns Object with the methods to keep constructing the\n\t * sub-query.\n\t */\n\tselectAllReduced():WherePattern;\n}\n\n\n/**\n * Function that creates a generic {@link SubSelectPattern.select} function.\n * This function is used to create all the methods for the {@link SubSelectPattern}\n *\n * @param container The container with the query data for the statement.\n * @param modifier The optional modifier of the SELECT queries.\n *\n * @returns A generic \"select\" function that shares the\n * {@link SubSelectPattern.select} signature. It behaviour depends of\n * the {@param modifier} set.\n *\n * @private\n */\nfunction getSelectFn( container:Container<undefined>, modifier?:\"DISTINCT\" | \"REDUCED\" ):SubSelectPattern[ \"select\" ] {\n\treturn ( ...variables:string[] ) => {\n\t\tconst targetToken:SubSelectToken = new SubSelectToken( modifier );\n\t\tif( variables.length ) targetToken.addVariable( ...variables.map( x => new VariableToken( x ) ) );\n\n\t\tconst newContainer:Container<SubSelectToken> = new Container( {\n\t\t\tiriResolver: container.iriResolver,\n\t\t\ttargetToken\n\t\t} );\n\t\treturn WherePattern.createFrom( newContainer, {} );\n\t};\n}\n\n\n/**\n * Constant with the utils for {@link SubSelectPattern} objects.\n */\nexport const SubSelectPattern:{\n\t/**\n\t * Factory function that allows to crete a {@link SubSelectPattern}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link SubSelectPattern} statement.\n\t * @param object The base base from where to create the\n\t * {@link SubSelectPattern} statement.\n\t *\n\t * @return The {@link SubSelectPattern} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<O extends object>( container:Container<undefined>, object:O ):O & SubSelectPattern;\n} = {\n\tcreateFrom<O extends object>( container:Container<undefined>, object:O ):O & SubSelectPattern {\n\t\treturn Object.assign( object, {\n\t\t\tselect: getSelectFn( container ),\n\t\t\tselectDistinct: getSelectFn( container, \"DISTINCT\" ),\n\t\t\tselectReduced: getSelectFn( container, \"REDUCED\" ),\n\t\t\tselectAll: () => getSelectFn( container )(),\n\t\t\tselectAllDistinct: () => getSelectFn( container, \"DISTINCT\" )(),\n\t\t\tselectAllReduced: () => getSelectFn( container, \"REDUCED\" )(),\n\t\t} );\n\t},\n};\n","import { TokenNode } from \"./TokenNode\";\nimport { VariableToken } from \"./VariableToken\";\n\n\n/**\n * The token of the `BIND` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rBind}\n */\nexport class BindToken implements TokenNode {\n\treadonly token:\"bind\" = \"bind\";\n\n\treadonly expression:string;\n\treadonly variable:VariableToken;\n\n\tconstructor( expression:string, variable:VariableToken ) {\n\t\tthis.expression = expression;\n\t\tthis.variable = variable;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\treturn `BIND(${ this.expression } AS ${ this.variable })`;\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the `FILTER` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rFilter}\n */\nexport class FilterToken implements TokenNode {\n\treadonly token:\"filter\" = \"filter\";\n\treadonly constraint:string;\n\n\tconstructor( constraint:string ) {\n\t\tthis.constraint = constraint;\n\t}\n\n\ttoString( spaces?:number ):string {\n\t\treturn `FILTER( ${ this.constraint } )`;\n\t}\n}\n","import { VariableOrIRIToken } from \"./VariableOrIRIToken\";\nimport { GroupPatternToken } from \"./GroupPatternToken\";\nimport { PatternToken } from \"./PatternToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the `GRAPH` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rGraphGraphPattern}\n */\nexport class GraphToken implements TokenNode {\n\treadonly token:\"graph\" = \"graph\";\n\n\treadonly graph:VariableOrIRIToken;\n\treadonly groupPattern:GroupPatternToken;\n\n\tconstructor( graph:VariableOrIRIToken ) {\n\t\tthis.graph = graph;\n\t\tthis.groupPattern = new GroupPatternToken();\n\t}\n\n\n\taddPattern( ...pattern:PatternToken[] ):this {\n\t\tthis.groupPattern.patterns.push( ...pattern );\n\t\treturn this;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\treturn `GRAPH ${ this.graph } ${ this.groupPattern.toString( spaces ) }`;\n\t}\n}\n","import { GroupPatternToken } from \"./GroupPatternToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the `MINUS` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rMinusGraphPattern}\n */\nexport class MinusPatternToken implements TokenNode {\n\treadonly token:\"minusPattern\" = \"minusPattern\";\n\n\treadonly groupPattern:GroupPatternToken;\n\n\tconstructor() {\n\t\tthis.groupPattern = new GroupPatternToken();\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\treturn `MINUS ${ this.groupPattern.toString( spaces ) }`;\n\t}\n}","import { GroupPatternToken } from \"./GroupPatternToken\";\nimport { PatternToken } from \"./PatternToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the `OPTIONAL` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rMinusGraphPattern}\n */\nexport class OptionalToken implements TokenNode {\n\treadonly token:\"optional\" = \"optional\";\n\n\treadonly groupPattern:GroupPatternToken;\n\n\tconstructor() {\n\t\tthis.groupPattern = new GroupPatternToken();\n\t}\n\n\n\taddPattern( ...pattern:PatternToken[] ):this {\n\t\tthis.groupPattern.patterns.push( ...pattern );\n\t\treturn this;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\treturn `OPTIONAL ${ this.groupPattern.toString( spaces ) }`;\n\t}\n}\n","import { GroupPatternToken } from \"./GroupPatternToken\";\nimport { TokenNode } from \"./TokenNode\";\nimport { VariableOrIRIToken } from \"./VariableOrIRIToken\";\n\n\n/**\n * The token of the `SERVICE` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rServiceGraphPattern}\n */\nexport class ServicePatternToken implements TokenNode {\n\treadonly token:\"servicePattern\" = \"servicePattern\";\n\n\treadonly modifier?:\"SILENT\";\n\treadonly resource:VariableOrIRIToken;\n\treadonly groupPattern:GroupPatternToken;\n\n\tconstructor( resource:VariableOrIRIToken, modifier?:\"SILENT\" ) {\n\t\tthis.modifier = modifier;\n\t\tthis.resource = resource;\n\t\tthis.groupPattern = new GroupPatternToken();\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\tlet query:string = `SERVICE `;\n\n\t\tif( this.modifier ) query += `SILENT `;\n\n\t\tquery += `${ this.resource } ${ this.groupPattern.toString( spaces ) }`;\n\n\t\treturn query;\n\t}\n}\n","import { GroupPatternToken } from \"./GroupPatternToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of the `UNION` statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rGroupOrUnionGraphPattern}\n */\nexport class UnionPatternToken implements TokenNode {\n\treadonly token:\"unionPattern\" = \"unionPattern\";\n\n\treadonly groupPatterns:GroupPatternToken[];\n\n\tconstructor() {\n\t\tthis.groupPatterns = [];\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\treturn this\n\t\t\t.groupPatterns\n\t\t\t.map( x => x.toString( spaces ) )\n\t\t\t.join( ` UNION ` )\n\t\t\t;\n\t}\n}\n","import { Container } from \"../../data/Container\";\n\nimport { NotTripleToken } from \"../../tokens/NotTripleToken\";\n\nimport { Pattern } from \"../Pattern\";\n\n\n/**\n * Object that contains a pattern made from a non triple statement.\n */\nexport interface NotTriplePattern<T extends NotTripleToken = NotTripleToken> extends Pattern<T> {\n}\n\n\n/**\n * Constant with utils for {@link NotTriplePattern} objects.\n */\nexport const NotTriplePattern:{\n\t/**\n\t * Factory function that allows to crete a {@link NotTriplePattern}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link NotTriplePattern} statement.\n\t * @param object The base base from where to create the\n\t * {@link NotTriplePattern} statement.\n\t *\n\t * @return The {@link NotTriplePattern} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<T extends NotTripleToken, C extends Container<T>, O extends object>( container:C, object:O ):O & NotTriplePattern<T>;\n} = {\n\tcreateFrom: Pattern.createFrom,\n};\n","import { Container } from \"../../data/Container\";\nimport { cloneElement } from \"../../data/utils\";\n\nimport { GroupPatternToken } from \"../../tokens/GroupPatternToken\";\nimport { UnionPatternToken } from \"../../tokens/UnionPatternToken\";\n\nimport { Pattern } from \"../Pattern\";\nimport { NotTriplePattern } from \"./NotTriplePattern\";\n\n\n/**\n * Wrapper for easier usage of SPARQL UNION patterns.\n */\nexport interface UnionPattern extends NotTriplePattern<UnionPatternToken> {\n\tand( patterns:Pattern | Pattern[] ):UnionPattern;\n}\n\n/**\n * Function that creates a generic {@link UnionPattern.and} function.\n *\n * @param container The container with the query data for the statement.\n *\n * @private\n */\nfunction getAndFn( container:Container<UnionPatternToken> ):UnionPattern[ \"and\" ] {\n\treturn patterns => {\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\t\tconst newGroupToken:GroupPatternToken = new GroupPatternToken();\n\t\tnewGroupToken.patterns.push( ...patterns.map( x => x.getPattern() ) );\n\n\t\tconst groupPatterns = container.targetToken.groupPatterns.concat( newGroupToken );\n\t\tconst unionToken:UnionPatternToken = cloneElement( container.targetToken, { groupPatterns } );\n\n\t\tconst newContainer = new Container( {\n\t\t\tiriResolver: container.iriResolver,\n\t\t\ttargetToken: unionToken,\n\t\t} );\n\t\treturn UnionPattern.createFrom( newContainer, {} );\n\t}\n}\n\n\n/**\n * Constant with utils for {@link UnionPattern} objects.\n */\nexport const UnionPattern:{\n\t/**\n\t * Factory function that allows to crete a {@link UnionPattern}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link UnionPattern} statement.\n\t * @param object The base base from where to create the\n\t * {@link UnionPattern} statement.\n\t *\n\t * @return The {@link UnionPattern} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<UnionPatternToken>, O extends object>( container:C, object:O ):UnionPattern;\n} = {\n\tcreateFrom<C extends Container<UnionPatternToken>, O extends object>( container:C, object:O ):UnionPattern {\n\t\treturn NotTriplePattern.createFrom( container, Object.assign( object, {\n\t\t\tand: getAndFn( container ),\n\t\t} ) );\n\t},\n};","import { Container } from \"../../data/Container\";\n\nimport { GroupPatternToken } from \"../../tokens/GroupPatternToken\";\nimport { UnionPatternToken } from \"../../tokens/UnionPatternToken\";\n\nimport { Pattern } from \"../Pattern\";\n\nimport { NotTriplePattern } from \"./NotTriplePattern\";\nimport { UnionPattern } from \"./UnionPattern\";\n\n\n/**\n * Wrapper for easier usage of SPARQL group patterns.\n */\nexport interface GroupPattern extends NotTriplePattern<GroupPatternToken> {\n\tunion( patterns:Pattern | Pattern[] ):UnionPattern;\n}\n\n\n/**\n * Function that creates a generic {@link GroupPattern.union} function.\n *\n * @param container The container with the query data for the statement.\n *\n * @private\n */\nfunction getUnionFn( container:Container<GroupPatternToken> ):GroupPattern[ \"union\" ] {\n\treturn patterns => {\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\t\tconst newGroupToken:GroupPatternToken = new GroupPatternToken();\n\t\tnewGroupToken.patterns.push( ...patterns.map( x => x.getPattern() ) );\n\n\t\tconst unionToken:UnionPatternToken = new UnionPatternToken();\n\t\tunionToken.groupPatterns.push( container.targetToken, newGroupToken );\n\n\t\tconst newContainer = new Container( {\n\t\t\tiriResolver: container.iriResolver,\n\t\t\ttargetToken: unionToken,\n\t\t} );\n\t\treturn UnionPattern.createFrom( newContainer, {} );\n\t}\n}\n\n\n/**\n * Constant with utils for {@link GroupPattern} objects.\n */\nexport const GroupPattern:{\n\t/**\n\t * Factory function that allows to crete a {@link GroupPattern}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link GroupPattern} statement.\n\t * @param object The base base from where to create the\n\t * {@link GroupPattern} statement.\n\t *\n\t * @return The {@link GroupPattern} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<GroupPatternToken>, O extends object>( container:C, object:O ):GroupPattern;\n} = {\n\tcreateFrom<C extends Container<GroupPatternToken>, O extends object>( container:C, object:O ):GroupPattern {\n\t\treturn NotTriplePattern.createFrom( container, Object.assign( object, {\n\t\t\tunion: getUnionFn( container ),\n\t\t} ) );\n\t}\n};","import { Container } from \"../../data/Container\";\nimport { cloneElement } from \"../../data/utils\";\n\nimport { ValuesToken } from \"../../tokens/ValuesToken\";\n\nimport { SupportedNativeTypes } from \"../SupportedNativeTypes\";\n\nimport { Literal } from \"../triplePatterns/Literal\";\nimport { Resource } from \"../triplePatterns/Resource\";\n\nimport { Undefined } from \"../Undefined\";\nimport { convertValue } from \"../utils\";\n\nimport { NotTriplePattern } from \"./NotTriplePattern\";\n\n\n/**\n * Wrapper for easier usage of SPARQL VALUES patterns that have\n * multiple variables.\n */\nexport interface MultipleValuesPattern extends NotTriplePattern<ValuesToken> {\n\thas( ...values:(SupportedNativeTypes | Resource | Literal | Undefined)[] ):MultipleValuesPatternMore;\n}\n\n/**\n * Wrapper for add more values to a {@link MultipleValuesPattern}.\n */\nexport interface MultipleValuesPatternMore extends NotTriplePattern<ValuesToken> {\n\tand( ...values:(SupportedNativeTypes | Resource | Literal | Undefined)[] ):MultipleValuesPatternMore;\n}\n\n\n/**\n * Function that creates a generic {@link MultipleValuesPattern.has} function.\n * This function is used also for declaring {@link MultipleValuesPatternMore.and}\n *\n * @param container The container with the query data for the statement.\n *\n * @private\n */\nfunction getHasFn<C extends Container<ValuesToken>>( container:C ):MultipleValuesPattern[ \"has\" ] {\n\treturn ( ...values:(SupportedNativeTypes | Resource | Literal | Undefined)[] ) => {\n\t\tconst parsedValues = container.targetToken.values.slice();\n\t\tparsedValues.push( values.map( convertValue ) );\n\n\t\tconst targetToken = cloneElement( container.targetToken, { values: parsedValues } );\n\t\tconst newContainer = cloneElement( container, { targetToken } as Partial<C> );\n\n\t\treturn MultipleValuesPatternMore.createFrom( newContainer, {} );\n\t};\n}\n\n\n/**\n * Constant with utils for {@link MultipleValuesPattern} objects.\n */\nexport const MultipleValuesPattern:{\n\t/**\n\t * Factory function that allows to crete a {@link MultipleValuesPattern}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link MultipleValuesPattern} statement.\n\t * @param object The base base from where to create the\n\t * {@link MultipleValuesPattern} statement.\n\t *\n\t * @return The {@link MultipleValuesPattern} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<ValuesToken>, O extends object>( container:C, object:O ):MultipleValuesPattern;\n} = {\n\tcreateFrom<C extends Container<ValuesToken>, O extends object>( container:C, object:O ):MultipleValuesPattern {\n\t\treturn NotTriplePattern.createFrom( container, Object.assign( object, {\n\t\t\thas: getHasFn( container ),\n\t\t} ) );\n\t},\n};\n\n/**\n * Constant with utils for {@link MultipleValuesPatternMore} objects.\n */\nexport const MultipleValuesPatternMore:{\n\t/**\n\t * Factory function that allows to crete a {@link MultipleValuesPatternMore}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link MultipleValuesPatternMore} statement.\n\t * @param object The base base from where to create the\n\t * {@link MultipleValuesPatternMore} statement.\n\t *\n\t * @return The {@link MultipleValuesPatternMore} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<ValuesToken>, O extends object>( container:C, object:O ):MultipleValuesPatternMore;\n} = {\n\tcreateFrom<C extends Container<ValuesToken>, O extends object>( container:C, object:O ):MultipleValuesPatternMore {\n\t\treturn NotTriplePattern.createFrom( container, Object.assign( object, {\n\t\t\tand: getHasFn( container ),\n\t\t} ) );\n\t},\n};\n","import { Container } from \"../../data/Container\";\nimport { cloneElement } from \"../../data/utils\";\n\nimport { ValuesToken } from \"../../tokens/ValuesToken\";\n\nimport { SupportedNativeTypes } from \"../SupportedNativeTypes\";\n\nimport { Literal } from \"../triplePatterns/Literal\";\nimport { Resource } from \"../triplePatterns/Resource\";\n\nimport { Undefined } from \"../Undefined\";\nimport { convertValue } from \"../utils\";\n\nimport { NotTriplePattern } from \"./NotTriplePattern\";\n\n\n/**\n * Wrapper for easier usage of SPARQL VALUES patterns that have\n * a single variable.\n */\nexport interface SingleValuesPattern extends NotTriplePattern<ValuesToken> {\n\thas( value:SupportedNativeTypes | Resource | Literal | Undefined ):SingleValuesPatternMore;\n}\n\n/**\n * Wrapper for add more values to a {@link SingleValuesPattern}.\n */\nexport interface SingleValuesPatternMore extends NotTriplePattern<ValuesToken> {\n\tand( value:SupportedNativeTypes | Resource | Literal | Undefined ):SingleValuesPatternMore;\n}\n\n\n/**\n * Function that creates a generic {@link SingleValuesPattern.has} function.\n * This function is used also for declaring {@link SingleValuesPatternMore.and}\n *\n * @param container The container with the query data for the statement.\n *\n * @private\n */\nfunction getHasFn<C extends Container<ValuesToken>>( container:C ):SingleValuesPattern[ \"has\" ] {\n\treturn value => {\n\t\tconst values = container.targetToken.values.slice();\n\t\tif( ! values.length ) values.push( [] );\n\t\tvalues[ 0 ] = values[ 0 ].concat( convertValue( value as SupportedNativeTypes ) );\n\n\t\tconst targetToken = cloneElement( container.targetToken, { values } );\n\t\tconst newContainer = cloneElement( container, { targetToken } as Partial<C> );\n\n\t\treturn SingleValuesPatternMore.createFrom( newContainer, {} );\n\t};\n}\n\n\n/**\n * Constant with utils for {@link SingleValuesPattern} objects.\n */\nexport const SingleValuesPattern:{\n\t/**\n\t * Factory function that allows to crete a {@link SingleValuesPattern}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link SingleValuesPattern} statement.\n\t * @param object The base base from where to create the\n\t * {@link SingleValuesPattern} statement.\n\t *\n\t * @return The {@link SingleValuesPattern} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<ValuesToken>, O extends object>( container:C, object:O ):SingleValuesPattern;\n} = {\n\tcreateFrom<C extends Container<ValuesToken>, O extends object>( container:C, object:O ):SingleValuesPattern {\n\t\treturn NotTriplePattern.createFrom( container, Object.assign( object, {\n\t\t\thas: getHasFn( container ),\n\t\t} ) );\n\t},\n};\n\n/**\n * Constant with utils for {@link SingleValuesPatternMore} objects.\n */\nexport const SingleValuesPatternMore:{\n\t/**\n\t * Factory function that allows to crete a {@link SingleValuesPatternMore}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link SingleValuesPatternMore} statement.\n\t * @param object The base base from where to create the\n\t * {@link SingleValuesPatternMore} statement.\n\t *\n\t * @return The {@link SingleValuesPatternMore} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<ValuesToken>, O extends object>( container:C, object:O ):SingleValuesPatternMore;\n} = {\n\tcreateFrom<C extends Container<ValuesToken>, O extends object>( container:C, object:O ):SingleValuesPatternMore {\n\t\treturn NotTriplePattern.createFrom( container, Object.assign( object, {\n\t\t\tand: getHasFn( container ),\n\t\t} ) );\n\t},\n};\n","import { Container } from \"../../data/Container\";\n\nimport { BindToken } from \"../../tokens/BindToken\";\nimport { FilterToken } from \"../../tokens/FilterToken\";\nimport { GraphToken } from \"../../tokens/GraphToken\";\nimport { GroupPatternToken } from \"../../tokens/GroupPatternToken\";\nimport { MinusPatternToken } from \"../../tokens/MinusPatternToken\";\nimport { NotTripleToken } from \"../../tokens/NotTripleToken\";\nimport { OptionalToken } from \"../../tokens/OptionalToken\";\nimport { ServicePatternToken } from \"../../tokens/ServicePatternToken\";\nimport { UnionPatternToken } from \"../../tokens/UnionPatternToken\";\nimport { ValuesToken } from \"../../tokens/ValuesToken\";\nimport { VariableToken } from \"../../tokens/VariableToken\";\n\nimport { Pattern } from \"../Pattern\";\nimport { Resource } from \"../triplePatterns/Resource\";\nimport { Variable } from \"../triplePatterns/Variable\";\nimport { Undefined } from \"../Undefined\";\n\nimport { BindPattern } from \"./BindPattern\";\nimport { FilterPattern } from \"./FilterPattern\";\nimport { GraphPattern } from \"./GraphPattern\";\nimport { GroupPattern } from \"./GroupPattern\";\nimport { MinusPattern } from \"./MinusPattern\";\nimport { MultipleValuesPattern } from \"./MultipleValuesPattern\";\nimport { NotTriplePattern } from \"./NotTriplePattern\";\nimport { OptionalPattern } from \"./OptionalPattern\";\nimport { ServicePattern } from \"./ServicePattern\";\nimport { SingleValuesPattern } from \"./SingleValuesPattern\";\nimport { UnionPattern } from \"./UnionPattern\";\n\n\n/**\n * Builder for non triple based patterns.\n */\nexport interface NotTriplePatternsBuilder {\n\t/**\n\t * Property por a quickly access to the `\"UNDEF\"` keyword.\n\t */\n\tundefined:Undefined;\n\n\t/**\n\t * Creates a {@link GraphPattern} for the target named graph\n\t * specified by {@param iri}, having the patterns specified.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#accessByLabel}\n\t * for more information.\n\t *\n\t * @param iri The target graph to have the patterns.\n\t * @param patterns The patterns to match for the target graph.\n\t */\n\tgraph( iri:string | Resource | Variable, patterns:Pattern | Pattern[] ):GraphPattern;\n\n\t/**\n\t * Creates a {@link GroupPattern} for the patterns specified,\n\t * where will group the patterns in a new pattern.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#GroupPatterns}\n\t * for more information.\n\t *\n\t * @param patterns The patterns to be enclosed in a group.\n\t */\n\tgroup( patterns:Pattern | Pattern[] ):GroupPattern;\n\n\t/**\n\t * Creates a {@link UnionPattern} for the patterns specified,\n\t * where will group the pattern to be used as an alternative\n\t * matching for another group declared by the subsequents\n\t * {@link UnionPattern.and} methods.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#alternatives}\n\t * for more information.\n\t *\n\t * @param patterns The patterns to be enclosed in a group.\n\t */\n\tunion( patterns:Pattern | Pattern[] ):UnionPattern;\n\n\t/**\n\t * Creates an {@link OptionalPattern} for the patterns specified,\n\t * which will be considered as optional to match and retrieve.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#optionals}\n\t * for more information.\n\t *\n\t * @param patterns The patterns to be enclosed in a optional\n\t * group.\n\t */\n\toptional( patterns:Pattern | Pattern[] ):OptionalPattern;\n\n\t/**\n\t * Creates a {@link MinusPattern} for the patterns specified\n\t * which will be excluded from the query.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#neg-minus}\n\t * for more information.\n\t *\n\t * @param patterns The patterns to be enclosed in a minus\n\t * group.\n\t */\n\tminus( patterns:Pattern | Pattern[] ):MinusPattern;\n\n\t/**\n\t * Creates a {@link ServicePattern} for the target resource\n\t * service and the patterns specified.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-federated-query/}\n\t * for more information.\n\t *\n\t * @param resource The service where to execute the federated\n\t * query.\n\t * @param patterns The patterns of the target service.\n\t */\n\tservice( resource:string | Resource | Variable, patterns:Pattern | Pattern[] ):ServicePattern;\n\t/**\n\t * Creates a silent {@link ServicePattern} for the target resource\n\t * service and the patterns specified.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-federated-query/}\n\t * for more information.\n\t *\n\t * @param resource The service where to execute the federated\n\t * query.\n\t * @param patterns The patterns of the target service.\n\t */\n\tserviceSilent( resource:string | Resource | Variable, patterns:Pattern | Pattern[] ):ServicePattern;\n\n\n\t/**\n\t * Create a {@link FilterPattern} for the raw constraint.\n\t *\n\t * This is used to exclude values or entire patterns.\n\t * See {@link https://www.w3.org/TR/sparql11-query/#termConstraint\n     * and {@link https://www.w3.org/TR/sparql11-query/#negation} to\n\t * know more.\n\t *\n\t * @param rawConstraint The RAW constraint to filter.\n\t */\n\tfilter( rawConstraint:string ):FilterPattern;\n\n\t/**\n\t * Created a {@link BindPattern} for the raw expression\n\t * into the variable specified.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#bind}\n\t * for more information.\n\t *\n\t * @param rawExpression The RAW expression to assign.\n\t * @param variable The variable to be assigned.\n\t */\n\t// TODO: Add expression support for this patterns\n\tbind( rawExpression:string, variable:string | Variable ):BindPattern;\n\n\t/**\n\t * Create a {@link SingleValuesPattern} for the variable\n\t * specified.\n\t *\n\t * This is used to assign data to an specific variable.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#inline-data}\n\t * for more information.\n\t *\n\t * @param variable The variable to assign data.\n\t */\n\tvalues( variable:Variable ):SingleValuesPattern;\n\t/**\n\t * Create a {@link MultipleValuesPattern} for the variables\n\t * specified.\n\t *\n\t * This is used to assign data to multiple variables.\n\t *\n\t * See {@link https://www.w3.org/TR/sparql11-query/#inline-data}\n\t * for more information.\n\t *\n\t * @param variables The variables to assign data.\n\t */\n\tvalues( ...variables:Variable[] ):MultipleValuesPattern;\n}\n\n\nfunction _getPatternContainer<T extends NotTripleToken>( container:Container<undefined>, targetToken:T ):Container<T> {\n\treturn new Container( {\n\t\tiriResolver: container.iriResolver,\n\t\ttargetToken,\n\t} )\n}\n\nfunction _getPattern<T extends NotTripleToken>( container:Container<undefined>, token:T ):NotTriplePattern<T> {\n\tconst patternContainer = _getPatternContainer( container, token );\n\treturn NotTriplePattern.createFrom( patternContainer, {} );\n}\n\n\nfunction getGraphFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"graph\" ] {\n\treturn ( iriOrVariable:string | Resource | Variable, patterns:Pattern | Pattern[] ) => {\n\t\tconst varOrIRI = typeof iriOrVariable === \"string\" ?\n\t\t\tcontainer.iriResolver.resolve( iriOrVariable ) :\n\t\t\tiriOrVariable.getSubject();\n\n\t\tconst token:GraphToken = new GraphToken( varOrIRI );\n\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\t\ttoken.addPattern( ...patterns.map( x => x.getPattern() ) );\n\n\t\treturn _getPattern( container, token );\n\t}\n}\n\nfunction getGroupFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"group\" ] {\n\treturn ( patterns:Pattern | Pattern[] ) => {\n\t\tconst token:GroupPatternToken = new GroupPatternToken();\n\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\t\ttoken.patterns.push( ...patterns.map( x => x.getPattern() ) );\n\n\t\tconst patternContainer = _getPatternContainer( container, token );\n\t\treturn GroupPattern.createFrom( patternContainer, {} );\n\t}\n}\n\nfunction getUnionFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"union\" ] {\n\treturn ( patterns:Pattern | Pattern[] ) => {\n\t\tconst token:UnionPatternToken = new UnionPatternToken();\n\n\t\tconst patternContainer = _getPatternContainer( container, token );\n\t\tconst unionPattern:UnionPattern = UnionPattern\n\t\t\t.createFrom( patternContainer, {} );\n\n\t\treturn unionPattern.and( patterns );\n\t}\n}\n\nfunction getOptionalFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"optional\" ] {\n\treturn ( patterns:Pattern | Pattern[] ) => {\n\t\tconst token:OptionalToken = new OptionalToken();\n\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\t\ttoken.addPattern( ...patterns.map( x => x.getPattern() ) );\n\n\t\treturn _getPattern( container, token );\n\t}\n}\n\nfunction getMinusFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"minus\" ] {\n\treturn ( patterns:Pattern | Pattern[] ) => {\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\n\t\tconst token:MinusPatternToken = new MinusPatternToken();\n\t\ttoken.groupPattern.patterns\n\t\t\t.push( ...patterns.map( x => x.getPattern() ) );\n\n\t\treturn _getPattern( container, token );\n\t}\n}\n\nfunction getServiceFn( container:Container<undefined>, modifier?:\"SILENT\" ):NotTriplePatternsBuilder[ \"service\" ] {\n\treturn ( resource:string | Resource | Variable, patterns:Pattern | Pattern[] ) => {\n\t\tconst varOrIRI = typeof resource === \"string\" ?\n\t\t\tcontainer.iriResolver.resolve( resource ) :\n\t\t\tresource.getSubject();\n\n\t\tconst token:ServicePatternToken = new ServicePatternToken( varOrIRI, modifier );\n\n\t\tpatterns = Array.isArray( patterns ) ? patterns : [ patterns ];\n\t\ttoken.groupPattern.patterns\n\t\t\t.push( ...patterns.map( x => x.getPattern() ) );\n\n\t\treturn _getPattern( container, token );\n\t}\n}\n\n\nfunction getFilterFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"filter\" ] {\n\treturn ( rawConstraint:string ) => {\n\t\tconst token:FilterToken = new FilterToken( rawConstraint );\n\n\t\treturn _getPattern( container, token );\n\t}\n}\n\nfunction getBindFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"bind\" ] {\n\treturn ( rawExpression:string, variable:string | Variable ) => {\n\t\tconst parsedVar = typeof variable === \"string\" ?\n\t\t\tnew VariableToken( variable ) :\n\t\t\tvariable.getSubject();\n\n\t\tconst token:BindToken = new BindToken( rawExpression, parsedVar );\n\n\t\treturn _getPattern( container, token );\n\t}\n}\n\nfunction getValuesFn( container:Container<undefined> ):NotTriplePatternsBuilder[ \"values\" ] {\n\treturn ( ...variables:Variable[] ) => {\n\t\tconst token:ValuesToken = new ValuesToken();\n\t\ttoken.variables.push( ...variables.map( x => x.getSubject() ) );\n\n\t\tconst patternContainer = _getPatternContainer( container, token );\n\n\t\tif( variables.length === 1 )\n\t\t\treturn SingleValuesPattern\n\t\t\t\t.createFrom( patternContainer, {} );\n\n\t\treturn MultipleValuesPattern\n\t\t\t.createFrom( patternContainer, {} );\n\t}\n}\n\n\n/**\n * Constant with the utils for {@link NotTriplePatternsBuilder} objects.\n */\nexport const NotTriplePatternsBuilder:{\n\t/**\n\t * Factory function that allows to crete a {@link NotTriplePatternsBuilder}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link NotTriplePatternsBuilder} statement.\n\t * @param object The base base from where to create the\n\t * {@link NotTriplePatternsBuilder} statement.\n\t *\n\t * @return The {@link NotTriplePatternsBuilder} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<O extends object>( container:Container<undefined>, object:O ):O & NotTriplePatternsBuilder;\n} = {\n\tcreateFrom<O extends object>( container:Container<undefined>, object:O ):O & NotTriplePatternsBuilder {\n\t\treturn Object.assign( object, {\n\t\t\tundefined: \"UNDEF\" as \"UNDEF\",\n\n\t\t\tgraph: getGraphFn( container ),\n\t\t\tgroup: getGroupFn( container ),\n\t\t\tunion: getUnionFn( container ),\n\t\t\toptional: getOptionalFn( container ),\n\t\t\tminus: getMinusFn( container ),\n\t\t\tservice: getServiceFn( container ),\n\t\t\tserviceSilent: getServiceFn( container, \"SILENT\" ),\n\n\t\t\tfilter: getFilterFn( container ),\n\t\t\tbind: getBindFn( container ),\n\t\t\tvalues: getValuesFn( container ),\n\t\t} )\n\t},\n};","import { PathInAlternativeToken } from \"./PathInAlternativeToken\";\n\n\n/**\n * Token for the alternative paths statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rPathAlternative}\n */\nexport class PathAlternativeToken<T extends PathInAlternativeToken = PathInAlternativeToken> {\n\treadonly token:\"pathAlternative\" = \"pathAlternative\";\n\treadonly paths:T[];\n\n\tconstructor() {\n\t\tthis.paths = [];\n\t}\n\n\n\taddPath( path:T ):this {\n\t\tthis.paths.push( path );\n\n\t\treturn this;\n\t}\n\n\n\ttoString():string {\n\t\treturn this.paths\n\t\t\t.join( \"|\" );\n\t}\n}\n","import { Container, ContainerData } from \"../../data/Container\";\n\nimport { PathAlternativeToken } from \"../../tokens/PathAlternativeToken\";\nimport { PathInNegatedToken } from \"../../tokens/PathInNegatedToken\";\nimport { PathToken } from \"../../tokens/PathToken\";\nimport { SubPathInNegatedToken } from \"../../tokens/SubPathInNegatedToken\";\n\nimport { DeniableFluentPath } from \"./DeniableFluentPath\";\nimport { FluentPath } from \"./FluentPath\";\n\n\n/**\n * Interface that describe the necessary data for the creation\n * of a {@link FluentPathContainer}.\n */\nexport interface FluentPathContainerData<T extends PathToken | undefined> extends ContainerData<T> {\n\t/**\n\t * @see FluentPathContainer.fluentPathFactory\n\t */\n\tfluentPathFactory:<W extends PathToken, O extends object>( container:FluentPathContainer<W>, object:O ) => O & FluentPath<W>;\n\n\t/**\n\t * @see FluentPathContainer.deniableFluentPathFactory\n\t */\n\tdeniableFluentPathFactory:<W extends PathInNegatedToken | SubPathInNegatedToken | PathAlternativeToken<PathInNegatedToken>, O extends object>( container:FluentPathContainer<W>, object:O ) => O & DeniableFluentPath<W>;\n}\n\n\n/**\n * Extension of the {@link Container} class that adds the factory\n * for construct FluentPath.\n *\n * The factory is provided from the container to avoid circular\n * dependency when imported directly in the fluent functions of the\n * paths builder and objects.\n */\nexport class FluentPathContainer<T extends PathToken | undefined> extends Container<T> implements FluentPathContainerData<T> {\n\n\treadonly fluentPathFactory:<W extends PathToken, O extends object>( container:FluentPathContainer<W>, object:O ) => O & FluentPath<W>;\n\treadonly deniableFluentPathFactory:<W extends PathInNegatedToken | SubPathInNegatedToken | PathAlternativeToken<PathInNegatedToken>, O extends object>( container:FluentPathContainer<W>, object:O ) => O & DeniableFluentPath<W>;\n\n\tconstructor( data:FluentPathContainerData<T> ) {\n\t\tsuper( data );\n\n\t\tthis.fluentPathFactory = data.fluentPathFactory;\n\t\tthis.deniableFluentPathFactory = data.deniableFluentPathFactory;\n\n\t\tif( new.target === FluentPathContainer ) Object.freeze( this );\n\t}\n}\n","import { Container } from \"../../data/Container\";\n\nimport { IRIToken } from \"../../tokens/IRIToken\";\nimport { PathToken } from \"../../tokens/PathToken\";\nimport { VariableToken } from \"../../tokens/VariableToken\";\n\nimport { Resource } from \"../triplePatterns/Resource\";\nimport { Variable } from \"../triplePatterns/Variable\";\n\nimport { Path } from \"./Path\";\n\n\n/**\n * Obtain the token representation from the property provided.\n *\n * @param container The general container with the {@link IRIResolver}\n * that will be used to resolve a string property.\n * @param property The property to obtain its token.\n */\nexport function getPropertyToken<T extends PathToken>( container:Container<any>, property:Resource | \"a\" | string | Path<T> | PathToken ):IRIToken | \"a\" | T;\nexport function getPropertyToken<T extends PathToken>( container:Container<any>, property:Variable | Resource | \"a\" | string | Path<T> ):VariableToken | IRIToken | \"a\" | T;\nexport function getPropertyToken<T extends PathToken>( container:Container<any>, property:Variable | Resource | \"a\" | string | Path<T> | PathToken ):VariableToken | IRIToken | \"a\" | T {\n\tif( property === \"a\" )\n\t\treturn property;\n\n\tif( typeof property === \"string\" )\n\t\treturn container.iriResolver.resolve( property, true );\n\n\tif( \"token\" in property )\n\t\treturn property as T;\n\n\tif( \"getSubject\" in property )\n\t\treturn property.getSubject();\n\n\treturn property.getPath();\n}","import { PathToken } from \"./PathToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * Class with the implementation of a sub-path token.\n *\n * Used to separate logic and types of {@link SubPathToken} and\n * {@link SubPathInNegatedToken}.\n */\nexport class SharedSubPathToken<T extends PathToken | undefined> implements TokenNode {\n\treadonly token:\"subPath\" = \"subPath\";\n\treadonly path:T;\n\n\tconstructor( path:T ) {\n\t\tthis.path = path;\n\t}\n\n\ttoString():string {\n\t\tif( ! this.path ) return \"()\";\n\t\treturn `(${ this.path })`;\n\t}\n}\n","import { IRIToken } from \"../../../tokens/IRIToken\";\nimport { PathInNegatedToken } from \"../../../tokens/PathInNegatedToken\";\nimport { PathToken } from \"../../../tokens/PathToken\";\nimport { SharedSubPathToken } from \"../../../tokens/SharedSubPathToken\";\n\n\n/**\n * Create a function that will wrap into a sub-path any token\n * matched by the symbols provided.\n *\n * The match is calculated comparing a symbol provided with the\n * {@link TokenNode.token} property.\n *\n * @param symbols The name of the tokens to be wrapped.\n *\n * @private\n */\nexport function _getTokenWrapper<T extends PathToken>( ...symbols:string[] ):( token:PathToken ) => T {\n\treturn ( token:PathToken ):any => {\n\t\tif( token === \"a\" ) return token;\n\n\t\tif( symbols.indexOf( token.token ) !== - 1 )\n\t\t\treturn new SharedSubPathToken( token );\n\n\t\treturn token;\n\t}\n}\n\n\n/**\n * Verify the token provided is a base token primitive.\n * i.e. if the token is `\"a\"` or a {@link IRIToken}.\n *\n * @param token the token to be verified.\n * @private\n */\nexport function _isBasePrimitive( token:PathToken ):token is IRIToken | \"a\" {\n\treturn token === \"a\"\n\t\t|| token.token === \"iri\"\n\t\t|| token.token === \"prefixedName\"\n\t\t;\n}\n\n/**\n * Verify is the token provided is a {@link PathInNegatedToken}.\n *\n * @param token The token to be verified.\n * @private\n */\nexport function _isPathInNegatedToken( token:PathToken ):token is PathInNegatedToken {\n\treturn _isBasePrimitive( token )\n\t\t|| (\n\t\t\ttoken.token === \"pathInverse\"\n\t\t\t&& _isBasePrimitive( token.path )\n\t\t);\n}\n","import { PathAlternativeToken } from \"../../../tokens/PathAlternativeToken\";\nimport { PathInAlternativeToken } from \"../../../tokens/PathInAlternativeToken\";\nimport { PathInNegatedToken } from \"../../../tokens/PathInNegatedToken\";\nimport { PathToken } from \"../../../tokens/PathToken\";\n\nimport { Resource } from \"../../triplePatterns/Resource\";\n\nimport { DeniableFluentPath } from \"../DeniableFluentPath\";\nimport { FluentPath } from \"../FluentPath\";\nimport { FluentPathContainer } from \"../FluentPathContainer\";\nimport { Path } from \"../Path\";\nimport { getPropertyToken } from \"../utils\";\n\nimport { _getTokenWrapper, _isPathInNegatedToken } from \"./utils\";\n\n\ntype TargetToken = PathAlternativeToken & PathAlternativeToken<PathInNegatedToken>;\n\ntype TargetParams = Resource | \"a\" | string | Path<PathToken>;\n\nconst _getInAlternativeToken = _getTokenWrapper<PathInAlternativeToken>( \"pathAlternative\" );\n\n\nexport type AlternativeFn<T extends PathToken> = ( ...paths:((Resource | \"a\" | string | Path<PathToken>) | (Resource | \"a\" | string | Path<PathToken>)[])[] )\n\t=> (T extends PathInNegatedToken ? DeniableFluentPath<PathAlternativeToken<PathInNegatedToken>> : FluentPath<PathAlternativeToken>) & DeniableFluentPath<PathAlternativeToken<PathInNegatedToken>>;\n\nexport function getAlternativeFn<T extends PathToken>( container:FluentPathContainer<undefined | PathToken> ):AlternativeFn<T> {\n\treturn ( ...paths:(TargetParams | TargetParams[])[] ) => {\n\t\tconst tokensParams:PathToken[] = paths\n\t\t\t.reduce<TargetParams[]>( ( array, paths ) => array.concat( paths ), [] )\n\t\t\t.map( path => getPropertyToken( container, path ) );\n\n\t\t// [In FluentPath] Add to process when not alternative\n\t\tif( container.targetToken && ! (container.targetToken instanceof PathAlternativeToken) )\n\t\t\ttokensParams.unshift( container.targetToken );\n\n\t\tconst processedTokens:PathInAlternativeToken[] = tokensParams\n\t\t\t.map( _getInAlternativeToken );\n\n\t\t// [In FluentPath] Extends if path alternative, not process needed\n\t\tif( container.targetToken instanceof PathAlternativeToken )\n\t\t\tprocessedTokens.unshift( ...container.targetToken.paths );\n\n\n\t\tconst targetToken:TargetToken = new PathAlternativeToken();\n\t\ttargetToken.paths.push( ...processedTokens );\n\n\t\tconst newContainer:FluentPathContainer<TargetToken> = new FluentPathContainer( {\n\t\t\t...container,\n\t\t\ttargetToken,\n\t\t} );\n\n\n\t\tif( processedTokens.every( _isPathInNegatedToken ) )\n\t\t\treturn container.deniableFluentPathFactory( newContainer, {} );\n\n\t\treturn container.fluentPathFactory( newContainer, {} ) as any;\n\t}\n}","import { PathEltToken } from \"./PathEltToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * Token for inverting a path statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rPathEltOrInverse}\n */\nexport class PathInverseToken<T extends PathEltToken = PathEltToken> implements TokenNode {\n\treadonly token:\"pathInverse\" = \"pathInverse\";\n\treadonly path:T;\n\n\tconstructor( path:T ) {\n\t\tthis.path = path;\n\t}\n\n\ttoString():string {\n\t\treturn `^${ this.path }`;\n\t}\n}\n","import { IRIToken } from \"../../../tokens/IRIToken\";\nimport { PathEltToken } from \"../../../tokens/PathEltToken\";\nimport { PathInNegatedToken } from \"../../../tokens/PathInNegatedToken\";\nimport { PathInverseToken } from \"../../../tokens/PathInverseToken\";\nimport { PathToken } from \"../../../tokens/PathToken\";\n\nimport { Resource } from \"../../triplePatterns/Resource\";\n\nimport { DeniableFluentPath } from \"../DeniableFluentPath\";\nimport { FluentPath } from \"../FluentPath\";\nimport { FluentPathContainer } from \"../FluentPathContainer\";\nimport { Path } from \"../Path\";\nimport { getPropertyToken } from \"../utils\";\n\nimport { _getTokenWrapper, _isBasePrimitive } from \"./utils\";\n\n\ntype TargetToken = PathInverseToken<IRIToken | \"a\"> & PathInverseToken;\n\ntype TargetParams = Resource | \"a\" | string | Path<PathToken>;\n\nconst _getInInverseToken = _getTokenWrapper<PathEltToken>( \"pathAlternative\", \"pathSequence\", \"pathInverse\" );\n\n\nexport type InverseFn<T extends PathToken> = ( path?:Resource | \"a\" | string | Path<PathToken> )\n\t=> DeniableFluentPath<PathInverseToken<IRIToken | \"a\">> & (T extends PathInNegatedToken ? DeniableFluentPath<PathInverseToken<IRIToken | \"a\">> : FluentPath<PathInverseToken>);\n\nexport function getInverseFn<T extends PathToken>( container:FluentPathContainer<undefined | PathToken> ):InverseFn<T> {\n\treturn ( path?:TargetParams ) => {\n\t\tconst token:PathToken = container.targetToken\n\t\t\t// In FluentPath\n\t\t\t? container.targetToken\n\t\t\t// In PathBuilder\n\t\t\t: getPropertyToken( container, path! );\n\n\t\tconst inInverseToken:PathEltToken = _getInInverseToken( token );\n\t\tconst targetToken:TargetToken = new PathInverseToken( inInverseToken ) as TargetToken;\n\n\t\tconst newContainer:FluentPathContainer<TargetToken> = new FluentPathContainer( {\n\t\t\t...container,\n\t\t\ttargetToken,\n\t\t} );\n\n\n\t\tif( _isBasePrimitive( token ) )\n\t\t\treturn container.deniableFluentPathFactory( newContainer, {} );\n\n\t\treturn container.fluentPathFactory( newContainer, {} ) as any;\n\t}\n}","import { PathPrimaryToken } from \"./PathPrimaryToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * Token for the primary path with an specific mod.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rPathMod}\n */\nexport class PathModToken implements TokenNode {\n\treadonly token:\"pathMod\" = \"pathMod\";\n\treadonly path:PathPrimaryToken;\n\treadonly mod:\"?\" | \"*\" | \"+\";\n\n\tconstructor( path:PathPrimaryToken, mod:\"?\" | \"*\" | \"+\" ) {\n\t\tthis.path = path;\n\t\tthis.mod = mod;\n\t}\n\n\ttoString():string {\n\t\treturn `${ this.path }${ this.mod }`;\n\t}\n}\n","import { PathModToken } from \"../../../tokens/PathModToken\";\nimport { PathPrimaryToken } from \"../../../tokens/PathPrimaryToken\";\nimport { PathToken } from \"../../../tokens/PathToken\";\nimport { Resource } from \"../../triplePatterns/Resource\";\nimport { FluentPath } from \"../FluentPath\";\nimport { FluentPathContainer } from \"../FluentPathContainer\";\nimport { Path } from \"../Path\";\nimport { getPropertyToken } from \"../utils\";\nimport { _getTokenWrapper } from \"./utils\";\n\n\ntype TargetParams = Path<PathToken> | Resource | \"a\" | string;\n\nconst _getInModToken = _getTokenWrapper<PathPrimaryToken>( \"pathAlternative\", \"pathSequence\", \"pathInverse\", \"pathMod\" );\n\n\nexport type ModFn = ( path?:Resource | \"a\" | string | Path<PathToken> ) =>\n\tFluentPath<PathModToken>;\n\nexport function getModFn( container:FluentPathContainer<undefined | PathToken>, mod:\"?\" | \"*\" | \"+\" ):ModFn {\n\treturn ( path?:TargetParams ) => {\n\t\tconst token:PathToken = container.targetToken\n\t\t\t? container.targetToken\n\t\t\t: getPropertyToken( container, path! );\n\n\t\tconst inModToken:PathPrimaryToken = _getInModToken( token );\n\t\tconst targetToken:PathModToken = new PathModToken( inModToken, mod );\n\n\t\tconst newContainer:FluentPathContainer<PathModToken> = new FluentPathContainer( {\n\t\t\t...container,\n\t\t\ttargetToken,\n\t\t} );\n\n\t\treturn container.fluentPathFactory( newContainer, {} );\n\t};\n}","import { PathInSequenceToken } from \"./PathInSequenceToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * Token for the sequence paths statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rPathSequence}\n */\nexport class PathSequenceToken implements TokenNode {\n\treadonly token:\"pathSequence\" = \"pathSequence\";\n\treadonly paths:PathInSequenceToken[];\n\n\tconstructor() {\n\t\tthis.paths = [];\n\t}\n\n\n\taddPath( path:PathInSequenceToken ):this {\n\t\tthis.paths.push( path );\n\n\t\treturn this;\n\t}\n\n\n\ttoString():string {\n\t\treturn this.paths\n\t\t\t.join( \"/\" );\n\t}\n}\n","import { PathInSequenceToken } from \"../../../tokens/PathInSequenceToken\";\nimport { PathSequenceToken } from \"../../../tokens/PathSequenceToken\";\nimport { PathToken } from \"../../../tokens/PathToken\";\n\nimport { Resource } from \"../../triplePatterns/Resource\";\n\nimport { FluentPath } from \"../FluentPath\";\nimport { FluentPathContainer } from \"../FluentPathContainer\";\nimport { Path } from \"../Path\";\nimport { getPropertyToken } from \"../utils\";\n\nimport { _getTokenWrapper } from \"./utils\";\n\n\ntype TargetParams = Resource | \"a\" | string | Path<PathToken>;\n\nconst _getInSequenceToken = _getTokenWrapper<PathInSequenceToken>( \"pathAlternative\", \"pathSequence\" );\n\n\nexport type SequenceFn = ( ...paths:((Resource | \"a\" | string | Path<PathToken>) | (Resource | \"a\" | string | Path<PathToken>)[])[] )\n\t=> FluentPath<PathSequenceToken>;\n\nexport function getSequenceFn( container:FluentPathContainer<undefined | PathToken> ):SequenceFn {\n\treturn ( ...paths:(TargetParams | TargetParams[])[] ):any => {\n\t\tconst tokensParams:PathToken[] = paths\n\t\t\t.reduce<TargetParams[]>( ( array, paths ) => array.concat( paths ), [] )\n\t\t\t.map( path => getPropertyToken( container, path ) );\n\n\t\t// [In FluentPath] Add to process when not sequence\n\t\tif( container.targetToken && ! (container.targetToken instanceof PathSequenceToken) )\n\t\t\ttokensParams.unshift( container.targetToken );\n\n\t\tconst processedTokens:PathInSequenceToken[] = tokensParams\n\t\t\t.map( _getInSequenceToken );\n\n\t\t// [In FluentPath] Extends if path alternative, not process needed\n\t\tif( container.targetToken instanceof PathSequenceToken )\n\t\t\tprocessedTokens.unshift( ...container.targetToken.paths );\n\n\n\t\tconst targetToken:PathSequenceToken = new PathSequenceToken();\n\t\ttargetToken.paths.push( ...processedTokens );\n\n\t\tconst newContainer:FluentPathContainer<PathSequenceToken> = new FluentPathContainer( {\n\t\t\t...container,\n\t\t\ttargetToken,\n\t\t} );\n\n\t\treturn container.fluentPathFactory( newContainer, {} );\n\t}\n}","import { PathInNegatedToken } from \"../../../tokens/PathInNegatedToken\";\nimport { PathToken } from \"../../../tokens/PathToken\";\nimport { SharedSubPathToken } from \"../../../tokens/SharedSubPathToken\";\nimport { SubPathInNegatedToken } from \"../../../tokens/SubPathInNegatedToken\";\nimport { SubPathToken } from \"../../../tokens/SubPathToken\";\n\nimport { Resource } from \"../../triplePatterns/Resource\";\nimport { DeniableFluentPath } from \"../DeniableFluentPath\";\n\nimport { FluentPath } from \"../FluentPath\";\nimport { FluentPathContainer } from \"../FluentPathContainer\";\n\nimport { Path } from \"../Path\";\nimport { getPropertyToken } from \"../utils\";\nimport { _isPathInNegatedToken } from \"./utils\";\n\n\ntype TargetToken<T extends PathToken = PathToken> = SubPathToken<T> & SubPathInNegatedToken;\n\nfunction _canBeNegated( token:PathToken | undefined ):boolean {\n\treturn ! token\n\t\t|| _isPathInNegatedToken( token )\n\t\t|| (token.token === \"pathAlternative\" && token.paths.every( _isPathInNegatedToken ))\n\t\t;\n}\n\n\nexport type SubPathFn<T extends PathToken = PathToken> = ( path?:Resource | \"a\" | string | Path<PathToken> ) =>\n\t(T extends PathInNegatedToken ? DeniableFluentPath<SubPathToken<T>> : FluentPath<SubPathToken<T>>) & DeniableFluentPath<SubPathInNegatedToken>;\n\nexport function getSubPathFn<T extends PathToken>( container:FluentPathContainer<undefined | PathToken> ):SubPathFn<T> {\n\treturn ( path?:Resource | \"a\" | string | Path<PathToken> ) => {\n\t\tconst token:PathToken | undefined = container.targetToken\n\t\t\t// Is in FluentPath\n\t\t\t? container.targetToken\n\t\t\t// Is in PathBuilder\n\t\t\t: path === void 0 ? path\n\t\t\t\t: getPropertyToken( container, path );\n\n\n\t\tconst targetToken:TargetToken<T> = new SharedSubPathToken( token ) as TargetToken<T>;\n\n\t\tconst newContainer:FluentPathContainer<TargetToken<T>> = new FluentPathContainer( {\n\t\t\t...container,\n\t\t\ttargetToken,\n\t\t} );\n\n\n\t\tif( _canBeNegated( token ) )\n\t\t\treturn container.deniableFluentPathFactory( newContainer, {} );\n\n\t\treturn container.fluentPathFactory( newContainer, {} ) as any;\n\t};\n}\n","import { Container } from \"../../data/Container\";\n\nimport { PathToken } from \"../../tokens/PathToken\";\n\n\n/**\n * Object that contains the a property path.\n */\nexport interface Path<T extends PathToken = PathToken> {\n\tgetPath():T;\n}\n\n\n/**\n * Constant with the utils for {@link Path} objects.\n */\nexport const Path:{\n\t/**\n\t * Factory function that allows to crete a {@link Path}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link Path} statement.\n\t * @param object The base base from where to create the\n\t * {@link Path} statement.\n\t *\n\t * @return The {@link Path} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<T extends PathToken, O extends object>( container:Container<T>, object:O ):O & Path<T>;\n} = {\n\tcreateFrom<T extends PathToken, O extends object>( container:Container<T>, object:O ):O & Path<T> {\n\t\treturn Object.assign( object, {\n\t\t\tgetPath: () => container.targetToken,\n\t\t} );\n\t}\n};","import { IRIToken } from \"../../tokens/IRIToken\";\nimport { PathAlternativeToken } from \"../../tokens/PathAlternativeToken\";\nimport { PathInNegatedToken } from \"../../tokens/PathInNegatedToken\";\nimport { PathInverseToken } from \"../../tokens/PathInverseToken\";\nimport { PathModToken } from \"../../tokens/PathModToken\";\nimport { PathSequenceToken } from \"../../tokens/PathSequenceToken\";\nimport { PathToken } from \"../../tokens/PathToken\";\nimport { SubPathToken } from \"../../tokens/SubPathToken\";\n\nimport { Resource } from \"../triplePatterns/Resource\";\nimport { DeniableFluentPath } from \"./DeniableFluentPath\";\n\nimport { FluentPathContainer } from \"./FluentPathContainer\";\nimport { getAlternativeFn } from \"./fns/alternativeFn\";\nimport { getInverseFn } from \"./fns/inverseFn\";\nimport { getModFn } from \"./fns/modFn\";\nimport { getSequenceFn } from \"./fns/sequenceFn\";\nimport { getSubPathFn } from \"./fns/subPathFn\";\n\nimport { Path } from \"./Path\";\n\n\n/**\n * The interface with the methods for constructing a path with in\n * a fluent mode.\n *\n * Example:\n * ```typescript\n * _.inverse( \"ex:path1\" ) // ^ex:path1\n *     .then( \"ex:path2\" ) // ^ex:path1 / ex:path2\n *     .onceOrMore()       // (^ex:path1 / ex:path2)+\n * ```\n */\nexport interface FluentPath<T extends PathToken = PathToken> extends Path<T> {\n\t/**\n\t * Wrap the current path as a sub-path.\n\t */\n\tsubPath():T extends PathInNegatedToken ? DeniableFluentPath<SubPathToken<T>> : FluentPath<SubPathToken<T>>;\n\n\n\t/**\n\t * Add alternative paths from the current one.\n\t * @param paths The to be added as alternatives.\n\t */\n\tor( ...paths:((Resource | \"a\" | string | Path<PathInNegatedToken>) | (Resource | \"a\" | string | Path<PathInNegatedToken>)[])[] ):T extends PathInNegatedToken ? DeniableFluentPath<PathAlternativeToken<PathInNegatedToken>> : FluentPath<PathAlternativeToken>;\n\tor( ...paths:((Resource | \"a\" | string | Path<PathToken>) | (Resource | \"a\" | string | Path<PathToken>)[])[] ):FluentPath<PathAlternativeToken>;\n\n\t/**\n\t * Add sequence paths from the current one.\n\t * @param paths The paths to be added as a sequence.\n\t */\n\tthen( ...paths:((Resource | \"a\" | string | Path<PathToken>) | (Resource | \"a\" | string | Path<PathToken>)[])[] ):FluentPath<PathSequenceToken>;\n\n\n\t/**\n\t * Change the current path to be an inverse path.\n\t */\n\tinverse():T extends PathInNegatedToken ? DeniableFluentPath<PathInverseToken<IRIToken | \"a\">> : FluentPath<PathInverseToken>;\n\n\n\t/**\n\t * Add the one or none mod (?) into the current path.\n\t */\n\toneOrNone():FluentPath<PathModToken>;\n\n\t/**\n\t * Add the zero or more mod (*) into the current path.\n\t */\n\tzeroOrMore():FluentPath<PathModToken>;\n\n\t/**\n\t * Add the once or more mod (+) into the current path.\n\t */\n\tonceOrMore():FluentPath<PathModToken>;\n}\n\n/**\n * Constant with the utils for {@link FluentPath} objects.\n */\nexport const FluentPath:{\n\t/**\n\t * Factory function that allows to crete a {@link FluentPath}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link FluentPath} statement.\n\t * @param object The base base from where to create the\n\t * {@link FluentPath} statement.\n\t *\n\t * @return The {@link FluentPath} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<T extends PathToken, O extends object>( container:FluentPathContainer<T>, object:O ):O & FluentPath<T>;\n} = {\n\tcreateFrom<T extends PathToken, O extends object>( container:FluentPathContainer<T>, object:O ):O & FluentPath<T> {\n\t\treturn Path.createFrom( container, Object.assign( object, {\n\t\t\tsubPath: getSubPathFn<T>( container ),\n\n\t\t\tor: getAlternativeFn<T>( container ),\n\t\t\tthen: getSequenceFn( container ),\n\n\t\t\tinverse: getInverseFn<T>( container ),\n\n\t\t\toneOrNone: getModFn( container, \"?\" ),\n\t\t\tzeroOrMore: getModFn( container, \"*\" ),\n\t\t\tonceOrMore: getModFn( container, \"+\" ),\n\t\t} ) );\n\t},\n};\n","import { SubPathInNegatedToken } from \"./SubPathInNegatedToken\";\nimport { PathInNegatedToken } from \"./PathInNegatedToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * Token for the negation of a path statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rPathPrimary}\n */\nexport class PathNegatedToken implements TokenNode {\n\treadonly token:\"pathNegated\" = \"pathNegated\";\n\treadonly path:PathInNegatedToken | SubPathInNegatedToken;\n\n\tconstructor( path:PathInNegatedToken | SubPathInNegatedToken ) {\n\t\tthis.path = path;\n\t}\n\n\ttoString():string {\n\t\treturn `!${ this.path }`;\n\t}\n}","import { PathAlternativeToken } from \"../../../tokens/PathAlternativeToken\";\nimport { PathInNegatedToken } from \"../../../tokens/PathInNegatedToken\";\nimport { PathNegatedToken } from \"../../../tokens/PathNegatedToken\";\nimport { SubPathInNegatedToken } from \"../../../tokens/SubPathInNegatedToken\";\n\nimport { Resource } from \"../../triplePatterns/Resource\";\n\nimport { FluentPath } from \"../FluentPath\";\nimport { FluentPathContainer } from \"../FluentPathContainer\";\nimport { Path } from \"../Path\";\nimport { getPropertyToken } from \"../utils\";\n\nimport { _getTokenWrapper } from \"./utils\";\n\n\ntype ExpectedToken = PathInNegatedToken | SubPathInNegatedToken | PathAlternativeToken<PathInNegatedToken>;\n\ntype TargetParams =\n\t| Resource\n\t| \"a\"\n\t| string\n\t| Path<ExpectedToken>\n\t;\n\nconst _getInNegatedToken = _getTokenWrapper<PathInNegatedToken | SubPathInNegatedToken>( \"pathAlternative\" );\n\n\nexport type NegatedFn = ( path?:Resource | \"a\" | string | Path<PathInNegatedToken | SubPathInNegatedToken | PathAlternativeToken<PathInNegatedToken>> ) =>\n\tFluentPath<PathNegatedToken>;\n\nexport function getNegatedFn( container:FluentPathContainer<undefined | PathInNegatedToken | SubPathInNegatedToken | PathAlternativeToken<PathInNegatedToken>> ):NegatedFn {\n\treturn ( path?:TargetParams ) => {\n\t\tconst token:ExpectedToken = container.targetToken\n\t\t\t// In FluentPath\n\t\t\t? container.targetToken\n\t\t\t// In FluentPath\n\t\t\t: getPropertyToken( container, path! );\n\n\t\tconst inNegatedToken:PathInNegatedToken | SubPathInNegatedToken = _getInNegatedToken( token );\n\t\tconst targetToken:PathNegatedToken = new PathNegatedToken( inNegatedToken );\n\n\t\tconst newContainer:FluentPathContainer<PathNegatedToken> = new FluentPathContainer( {\n\t\t\t...container,\n\t\t\ttargetToken,\n\t\t} );\n\n\t\treturn container.fluentPathFactory( newContainer, {} );\n\t}\n}\n","import { PathAlternativeToken } from \"../../tokens/PathAlternativeToken\";\nimport { PathInNegatedToken } from \"../../tokens/PathInNegatedToken\";\nimport { PathNegatedToken } from \"../../tokens/PathNegatedToken\";\nimport { SubPathInNegatedToken } from \"../../tokens/SubPathInNegatedToken\";\n\nimport { FluentPath } from \"./FluentPath\";\nimport { FluentPathContainer } from \"./FluentPathContainer\";\n\nimport { getNegatedFn } from \"./fns/negatedFn\";\n\n\n/**\n * The interface that add a function to negate the current path.\n *\n * This is a different interface, since the only special paths can\n * be negated.\n */\nexport interface DeniableFluentPath<T extends PathInNegatedToken | SubPathInNegatedToken | PathAlternativeToken<PathInNegatedToken>> extends FluentPath<T> {\n\tnegated():FluentPath<PathNegatedToken>\n}\n\n\n/**\n * Constant with the utils for {@link DeniableFluentPath} objects.\n */\nexport const DeniableFluentPath:{\n\t/**\n\t * Factory function that allows to crete a {@link DeniableFluentPath}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link DeniableFluentPath} statement.\n\t * @param object The base base from where to create the\n\t * {@link DeniableFluentPath} statement.\n\t *\n\t * @return The {@link DeniableFluentPath} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<T extends PathInNegatedToken | SubPathInNegatedToken | PathAlternativeToken<PathInNegatedToken>, O extends object>( container:FluentPathContainer<T>, object:O ):O & DeniableFluentPath<T>;\n} = {\n\tcreateFrom<T extends PathInNegatedToken | SubPathInNegatedToken | PathAlternativeToken<PathInNegatedToken>, O extends object>( container:FluentPathContainer<T>, object:O ):O & DeniableFluentPath<T> {\n\t\treturn FluentPath.createFrom( container, Object.assign( object, {\n\t\t\tnegated: getNegatedFn( container ),\n\t\t} ) );\n\t},\n};","import { IRIToken } from \"../../tokens/IRIToken\";\nimport { PathAlternativeToken } from \"../../tokens/PathAlternativeToken\";\nimport { PathInNegatedToken } from \"../../tokens/PathInNegatedToken\";\nimport { PathInverseToken } from \"../../tokens/PathInverseToken\";\nimport { PathModToken } from \"../../tokens/PathModToken\";\nimport { PathNegatedToken } from \"../../tokens/PathNegatedToken\";\nimport { PathSequenceToken } from \"../../tokens/PathSequenceToken\";\nimport { PathToken } from \"../../tokens/PathToken\";\nimport { SubPathInNegatedToken } from \"../../tokens/SubPathInNegatedToken\";\nimport { SubPathToken } from \"../../tokens/SubPathToken\";\n\nimport { Resource } from \"../triplePatterns/Resource\";\n\nimport { DeniableFluentPath } from \"./DeniableFluentPath\";\nimport { FluentPath } from \"./FluentPath\";\n\nimport { FluentPathContainer } from \"./FluentPathContainer\";\nimport { getAlternativeFn } from \"./fns/alternativeFn\";\nimport { getInverseFn } from \"./fns/inverseFn\";\nimport { getModFn } from \"./fns/modFn\";\nimport { getNegatedFn } from \"./fns/negatedFn\";\nimport { getSequenceFn } from \"./fns/sequenceFn\";\nimport { getSubPathFn } from \"./fns/subPathFn\";\n\nimport { Path } from \"./Path\";\n\n\n/**\n * Builder with the methods that helps you to construct any path.\n *\n * See {@link https://www.w3.org/TR/sparql11-query/#propertypaths} for\n * more information.\n */\nexport interface PathBuilder {\n\t/**\n\t * Create a sub-path from a property or path.\n\t * @param path the path to be added as in the sub-path.\n\t */\n\tsubPath( path?:Resource | \"a\" | string | Path<PathInNegatedToken | PathAlternativeToken<PathInNegatedToken>> ):DeniableFluentPath<SubPathInNegatedToken>;\n\tsubPath( path:Path ):FluentPath<SubPathToken<PathToken>>;\n\n\n\t/**\n\t * Create a alternative path from the paths.\n\t * @param paths The paths to be added as alternate options.\n\t */\n\talternatives( ...paths:((Resource | \"a\" | string | Path<PathInNegatedToken>) | (Resource | \"a\" | string | Path<PathInNegatedToken>)[])[] ):DeniableFluentPath<PathAlternativeToken<PathInNegatedToken>>;\n\talternatives( ...paths:((Resource | \"a\" | string | Path<PathToken>) | (Resource | \"a\" | string | Path<PathToken>)[])[] ):FluentPath<PathAlternativeToken>;\n\n\t/**\n\t * Create a sequence path from the paths.\n\t * @param paths The paths to be added as path sequence.\n\t */\n\tsequences( ...paths:((Resource | \"a\" | string | Path<PathToken>) | (Resource | \"a\" | string | Path<PathToken>)[])[] ):FluentPath<PathSequenceToken>;\n\n\n\t/**\n\t * Create an inverse path from another one.\n\t * @param path The path to be inverted.\n\t */\n\tinverse( path:Resource | \"a\" | string | Path<IRIToken | \"a\"> ):DeniableFluentPath<PathInverseToken<IRIToken | \"a\">>;\n\tinverse( path:Resource | \"a\" | string | Path<PathToken> ):FluentPath<PathInverseToken>;\n\n\t/**\n\t * Create an negated path from the another one.\n\t * @param path The path to be negated.\n\t */\n\tnegated( path:Resource | \"a\" | string | Path<PathInNegatedToken | SubPathInNegatedToken | PathAlternativeToken<PathInNegatedToken>> ):FluentPath<PathNegatedToken>;\n\n\n\t/**\n\t * Set the path to be matched one or zero times.\n\t * i.e. the `?` mod.\n\t *\n\t * @param path The path to add the mod.\n\t */\n\toneOrNone( path:Resource | \"a\" | string | Path<PathToken> ):FluentPath<PathModToken>;\n\n\t/**\n\t * Set the path to be matched zero or more times.\n\t * i.e. the `*` mod.\n\t *\n\t * @param path The path to add the mod.\n\t */\n\tzeroOrMore( path:Resource | \"a\" | string | Path<PathToken> ):FluentPath<PathModToken>;\n\n\t/**\n\t * Set the path to be matched one or more times.\n\t * i.e. the `+` mod.\n\t *\n\t * @param path The path to add the mod.\n\t */\n\tonceOrMore( path:Resource | \"a\" | string | Path<PathToken> ):FluentPath<PathModToken>;\n}\n\n\n/**\n * Constant with the utils for {@link PathBuilder} objects.\n */\nexport const PathBuilder:{\n\t/**\n\t * Factory function that allows to crete a {@link PathBuilder}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link PathBuilder} statement.\n\t * @param object The base base from where to create the\n\t * {@link PathBuilder} statement.\n\t *\n\t * @return The {@link PathBuilder} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<O extends object>( container:FluentPathContainer<undefined>, object:O ):O & PathBuilder;\n} = {\n\tcreateFrom<O extends object>( container:FluentPathContainer<undefined>, object:O ):O & PathBuilder {\n\t\treturn Object.assign( object, {\n\t\t\tsubPath: getSubPathFn( container ),\n\n\t\t\talternatives: getAlternativeFn( container ),\n\t\t\tsequences: getSequenceFn( container ),\n\n\t\t\tinverse: getInverseFn( container ),\n\t\t\tnegated: getNegatedFn( container ),\n\n\t\t\toneOrNone: getModFn( container, \"?\" ),\n\t\t\tzeroOrMore: getModFn( container, \"*\" ),\n\t\t\tonceOrMore: getModFn( container, \"+\" ),\n\t\t} );\n\t}\n};\n","import { Container } from \"../../data/Container\";\n\nimport { IRIToken } from \"../../tokens/IRIToken\";\nimport { PathToken } from \"../../tokens/PathToken\";\n\nimport { Resource } from \"../triplePatterns/Resource\";\n\nimport { DeniableFluentPath } from \"./DeniableFluentPath\";\nimport { FluentPath } from \"./FluentPath\";\nimport { FluentPathContainer } from \"./FluentPathContainer\";\nimport { Path } from \"./Path\";\nimport { PathBuilder } from \"./PathBuilder\";\nimport { getPropertyToken } from \"./utils\";\n\n\n/**\n * Object with the methods to build a property path.\n */\nexport interface PathsBuilder {\n\tpath( property:Resource | \"a\" | string ):DeniableFluentPath<IRIToken | \"a\">;\n\tpath<T extends FluentPath<PathToken>>( builderFn:( pathBuilder:PathBuilder ) => T ):T;\n}\n\n\nfunction _getContainer<T extends PathToken | undefined>( container:Container<undefined>, targetToken?:T ):FluentPathContainer<T> {\n\treturn new FluentPathContainer<T>( {\n\t\t...container,\n\t\ttargetToken: targetToken!,\n\t\tfluentPathFactory: FluentPath.createFrom,\n\t\tdeniableFluentPathFactory: DeniableFluentPath.createFrom,\n\t} );\n}\n\n/**\n * Create a {@link Path} from the property provided.\n *\n * @param container The general container with the {@link IRIResolver}\n * that will be used to resolve a string property.\n * @param property The property to be converted into a Path.\n */\nfunction _parseProperty( container:Container<undefined>, property:Resource | \"a\" | string ):DeniableFluentPath<IRIToken | \"a\"> {\n\tconst targetToken:IRIToken | \"a\" = getPropertyToken( container, property );\n\n\tconst newContainer:FluentPathContainer<IRIToken | \"a\"> = _getContainer( container, targetToken );\n\treturn DeniableFluentPath.createFrom( newContainer, {} );\n}\n\nfunction getPathFn( container:Container<undefined> ):PathsBuilder[ \"path\" ] {\n\treturn ( propertyOrBuilderFn:Resource | \"a\" | string | (( pathBuilder:PathBuilder ) => Path<PathToken>) ):any => {\n\t\tif( typeof propertyOrBuilderFn !== \"function\" )\n\t\t\treturn _parseProperty( container, propertyOrBuilderFn );\n\n\t\tconst newContainer:FluentPathContainer<undefined> = _getContainer( container );\n\n\t\tconst pathBuilder:PathBuilder = PathBuilder.createFrom( newContainer, {} );\n\t\treturn propertyOrBuilderFn( pathBuilder );\n\t};\n}\n\n\n/**\n * Constant with the utils for {@link PathsBuilder} objects.\n */\nexport const PathsBuilder:{\n\t/**\n\t * Factory function that allows to crete a {@link PathsBuilder}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link PathsBuilder} statement.\n\t * @param object The base base from where to create the\n\t * {@link PathsBuilder} statement.\n\t *\n\t * @return The {@link PathsBuilder} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<O extends object>( container:Container<undefined>, object:O ):O & PathsBuilder;\n} = {\n\tcreateFrom<O extends object>( container:Container<undefined>, object:O ):O & PathsBuilder {\n\t\treturn Object.assign( object, {\n\t\t\tpath: getPathFn( container ),\n\t\t} )\n\t}\n};\n","import { getTokenContainerString } from \"./printing\";\nimport { PropertyToken } from \"./PropertyToken\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The generic token of a blank node property list.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rBlankNodePropertyList}\n * @see {@link https://www.w3.org/TR/sparql11-query/#rBlankNodePropertyListPath}\n */\nexport class BlankNodePropertyToken implements TokenNode {\n\treadonly token:\"blankNodeProperty\" = \"blankNodeProperty\";\n\n\treadonly properties:PropertyToken[];\n\n\tconstructor() {\n\t\tthis.properties = [];\n\t}\n\n\n\taddProperty( property:PropertyToken ):this {\n\t\tthis.properties.push( property );\n\t\treturn this;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\treturn getTokenContainerString( {\n\t\t\tspaces,\n\t\t\ttags: { open: \"[\", close: \"]\" },\n\t\t\ttokensSeparator: \";\",\n\t\t\ttokens: this.properties,\n\t\t} );\n\t}\n}\n","import { TokenNode } from \"./TokenNode\";\n\n/**\n * Regex to evaluate a correct blank node label.\n */\nconst LABEL_REGEX:RegExp = /^_:[A-Za-z0-9_]([A-Za-z0-9_\\-.]*[A-Za-z0-9_\\-])?$/;\n\n\n/**\n * The token of a blank node resource.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rBlankNode}\n */\nexport class BlankNodeToken implements TokenNode {\n\treadonly token:\"blankNode\" = \"blankNode\";\n\treadonly label?:string;\n\n\tconstructor( label?:string ) {\n\t\tif( ! label ) return;\n\t\tif( ! LABEL_REGEX.test( label ) ) throw new Error( \"Invalid blank node label.\" );\n\t\tthis.label = label;\n\t}\n\n\ttoString( spaces?:number ):string {\n\t\tif( this.label ) return this.label;\n\t\treturn `[]`;\n\t}\n}\n","import { ObjectToken } from \"./ObjectToken\";\nimport { getTokenContainerString } from \"./printing\";\nimport { TokenNode } from \"./TokenNode\";\n\n\n/**\n * The token of a collection triples node.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rCollection}\n * @see {@link https://www.w3.org/TR/sparql11-query/#rCollectionPath}\n */\nexport class CollectionToken implements TokenNode {\n\treadonly token:\"collection\" = \"collection\";\n\n\treadonly objects:ObjectToken[];\n\n\tconstructor() {\n\t\tthis.objects = [];\n\t}\n\n\n\taddObject( ...object:ObjectToken[] ):this {\n\t\tthis.objects.push( ...object );\n\t\treturn this;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\treturn getTokenContainerString( {\n\t\t\tspaces,\n\t\t\ttags: { open: \"(\", close: \")\" },\n\t\t\ttokens: this.objects,\n\t\t} );\n\t}\n}\n","import { addSpaces, getIndentation, getSeparator, INDENTATION_SPACES } from \"./printing\";\nimport { PropertyToken } from \"./PropertyToken\";\nimport { TokenNode } from \"./TokenNode\";\nimport { TripleNodeToken } from \"./TripleNodeToken\";\nimport { VariableOrTermToken } from \"./VariableOrTermToken\";\n\n\n/**\n * The token for defining a triple subject statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rTriplesSameSubject}\n * @see {@link https://www.w3.org/TR/sparql11-query/#rTriplesSameSubjectPath}\n */\nexport class SubjectToken<T extends VariableOrTermToken | TripleNodeToken = VariableOrTermToken | TripleNodeToken> implements TokenNode {\n\treadonly token:\"subject\" = \"subject\";\n\n\treadonly subject:T;\n\treadonly properties:PropertyToken[];\n\n\tconstructor( subject:T ) {\n\t\tthis.subject = subject;\n\t\tthis.properties = [];\n\t}\n\n\n\taddProperty( property:PropertyToken ):this {\n\t\tthis.properties.push( property );\n\t\treturn this;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\tlet query:string = this.subject.toString( spaces );\n\n\t\tlet separator:string = ! this.properties.length ? \"\"\n\t\t\t: (this.subject.token === \"collection\" || this.subject.token === \"blankNodeProperty\")\n\t\t\t&& query.includes( \"\\n\" ) ? \"\\n\"\n\t\t\t\t: \" \";\n\n\t\tconst subSpaces:number | undefined = separator === \" \" ?\n\t\t\taddSpaces( spaces, query.length + 1 ) :\n\t\t\taddSpaces( spaces, INDENTATION_SPACES );\n\n\t\tconst subIndent:string = getIndentation( subSpaces );\n\t\tconst properties:string = this.properties\n\t\t\t.map( property => property.toString( subSpaces ) )\n\t\t\t.join( \";\" + getSeparator( spaces ) + subIndent );\n\n\t\tif( separator === \"\\n\" ) separator += subIndent;\n\t\treturn query + separator + properties;\n\t}\n}\n","import { ObjectToken } from \"./ObjectToken\";\nimport { PathToken } from \"./PathToken\";\nimport { addSpaces, getIndentation, getSeparator } from \"./printing\";\nimport { TokenNode } from \"./TokenNode\";\nimport { VariableToken } from \"./VariableToken\";\n\n\n/**\n * The token for defining a property statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rPropertyListNotEmpty}\n * @see {@link https://www.w3.org/TR/sparql11-query/#rPropertyListPathNotEmpty}\n */\nexport class PropertyToken implements TokenNode {\n\treadonly token:\"property\" = \"property\";\n\n\treadonly verb:VariableToken | PathToken;\n\treadonly objects:ObjectToken[];\n\n\tconstructor( verb:VariableToken | PathToken ) {\n\t\tthis.verb = verb;\n\t\tthis.objects = [];\n\t}\n\n\n\taddObject( ...object:ObjectToken[] ):this {\n\t\tthis.objects.push( ...object );\n\t\treturn this;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\tconst separator:string = getSeparator( spaces );\n\n\t\tconst verb:string = `${ this.verb }`;\n\n\t\t// Extra spaces until object\n\t\tconst objectSpaces:number | undefined = addSpaces( spaces, verb.length + 1 );\n\t\tconst objectIndent:string = getIndentation( objectSpaces );\n\t\tconst objects:string = this.objects\n\t\t\t.map( object => {\n\t\t\t\tif( object.token === \"collection\" || object.token === \"blankNodeProperty\" )\n\t\t\t\t\treturn object.toString( spaces );\n\n\t\t\t\treturn object.toString( objectSpaces )\n\t\t\t} )\n\t\t\t.join( \",\" + separator + objectIndent );\n\n\t\treturn verb + \" \" + objects;\n\t}\n}\n","import { Container } from \"../../data/Container\";\nimport { Factory } from \"../../data/Factory\";\nimport { cloneElement } from \"../../data/utils\";\n\nimport { BlankNodePropertyToken } from \"../../tokens/BlankNodePropertyToken\";\nimport { PathToken } from \"../../tokens/PathToken\";\nimport { PropertyToken } from \"../../tokens/PropertyToken\";\nimport { TripleToken } from \"../../tokens/TripleToken\";\nimport { VariableToken } from \"../../tokens/VariableToken\";\n\nimport { Path } from \"../paths/Path\";\nimport { getPropertyToken } from \"../paths/utils\";\n\nimport { SupportedNativeTypes } from \"../SupportedNativeTypes\";\nimport { convertValue } from \"../utils\";\n\nimport { BlankNodeProperty } from \"./BlankNodeProperty\";\nimport { Collection } from \"./Collection\";\nimport { Literal } from \"./Literal\";\nimport { Resource } from \"./Resource\";\nimport { Variable } from \"./Variable\";\n\n\n/**\n * Object that allows to add a property to the triple related.\n */\nexport interface PropertyBuilder<T extends object> {\n\t/**\n\t * Assign a property and values to the triple statement.\n\t *\n\t * @param property The property to be added in the triple.\n\t * @param objects The value(s) the property added have.\n\t *\n\t * @return Object that allows to add more data to the triple.\n\t */\n\thas( property:Path | Variable | Resource | \"a\" | string, objects:(SupportedNativeTypes | Resource | Variable | Literal | Collection | BlankNodeProperty) | (SupportedNativeTypes | Resource | Variable | Literal | Collection | BlankNodeProperty)[] ):PropertyBuilderMore<T> & T;\n}\n\n/**\n * Object that allows to add more properties to the triple related.\n */\nexport interface PropertyBuilderMore<T extends object> {\n\t/**\n\t * Added another property and values to the triple.\n\t *\n\t * @param property The property to be added in the triple.\n\t * @param objects The value(s) the property added have.\n\t *\n\t * @return Object that allows to add more data to the triple.\n\t */\n\tand( property:Path | Variable | Resource | \"a\" | string, objects:(SupportedNativeTypes | Resource | Variable | Literal | Collection | BlankNodeProperty) | (SupportedNativeTypes | Resource | Variable | Literal | Collection | BlankNodeProperty)[] ):PropertyBuilderMore<T> & T;\n}\n\n\ntype Objects = SupportedNativeTypes | Resource | Variable | Literal | Collection | BlankNodeProperty;\n\nfunction _cloneContainer<C extends Container<TripleToken | BlankNodePropertyToken>>( container:C, propertyToken:PropertyToken ):C {\n\tconst properties = container.targetToken.properties.concat( propertyToken );\n\tconst targetToken = cloneElement( container.targetToken, { properties } );\n\treturn cloneElement( container, { targetToken } as Partial<C> );\n}\n\nfunction _updateContainer<C extends Container<TripleToken | BlankNodePropertyToken>>( container:C, propertyToken:PropertyToken ):C {\n\tcontainer.targetToken.properties.push( propertyToken );\n\treturn container;\n}\n\n/**\n * Function that creates a generic {@link PropertyBuilder.has} function.\n * This function is used for create {@link PropertyBuilder} and {@link PropertyBuilderMore}\n *\n * @param genericFactory The factory of the generic expected to be returned.\n * @param container The container that is bound to the PropertyBuilder methods.\n *\n * @private\n */\nfunction getHasFn<T extends object, C extends Container<TripleToken | BlankNodePropertyToken>>( genericFactory:Factory<C, T>, container:C ):PropertyBuilder<T>[ \"has\" ] {\n\treturn ( property:string | Variable | Resource | Path, objects:Objects | Objects[] ) => {\n\t\tconst verbToken:VariableToken | PathToken = getPropertyToken( container, property );\n\t\tconst propertyToken:PropertyToken = new PropertyToken( verbToken );\n\n\t\tobjects = Array.isArray( objects ) ? objects : [ objects ];\n\t\tpropertyToken.addObject( ...objects.map( convertValue ) );\n\n\t\tconst newContainer = container.targetToken.token === \"subject\" ?\n\t\t\t_cloneContainer( container, propertyToken ) :\n\t\t\t_updateContainer( container, propertyToken );\n\n\t\tconst genericObject:T = genericFactory( newContainer, {} );\n\t\treturn PropertyBuilderMore.createFrom( genericFactory, newContainer, genericObject );\n\t};\n}\n\n\n/**\n * Constant with the utils for {@link PropertyBuilder} objects.\n */\nexport const PropertyBuilder:{\n\t/**\n\t * Factory function that allows to crete a {@link PropertyBuilder}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory of the generic expected to\n\t * be returned by the {@link PropertyBuilder.has} method.\n\t * @param container The related container with the data for the\n\t * {@link PropertyBuilder} statement.\n\t * @param object The base base from where to create the\n\t * {@link PropertyBuilder} statement.\n\t *\n\t * @return The {@link PropertyBuilder} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<T extends object, C extends Container<TripleToken | BlankNodePropertyToken>, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & PropertyBuilder<T>;\n} = {\n\tcreateFrom<T extends object, C extends Container<TripleToken | BlankNodePropertyToken>, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & PropertyBuilder<T> {\n\t\treturn Object.assign( object, {\n\t\t\thas: getHasFn( genericFactory, container ),\n\t\t} );\n\t}\n};\n\n/**\n * Constant with the utils for {@link PropertyBuilderMore} objects.\n */\nexport const PropertyBuilderMore:{\n\t/**\n\t * Factory function that allows to crete a {@link PropertyBuilderMore}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory of the generic expected to\n\t * be returned by the {@link PropertyBuilderMore.and} method.\n\t * @param container The related container with the data for the\n\t * {@link PropertyBuilderMore} statement.\n\t * @param object The base base from where to create the\n\t * {@link PropertyBuilderMore} statement.\n\t *\n\t * @return The {@link PropertyBuilderMore} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<T extends object, C extends Container<TripleToken | BlankNodePropertyToken>, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & PropertyBuilderMore<T>;\n} = {\n\tcreateFrom<T extends object, C extends Container<TripleToken | BlankNodePropertyToken>, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & PropertyBuilderMore<T> {\n\t\treturn Object.assign( object, {\n\t\t\tand: getHasFn( genericFactory, container ),\n\t\t} );\n\t}\n};","import { Container } from \"../../data/Container\";\nimport { Factory } from \"../../data/Factory\";\n\nimport { BlankNodePropertyToken } from \"../../tokens/BlankNodePropertyToken\";\n\nimport { PropertyBuilder } from \"./PropertyBuilder\";\n\n\n/**\n * Builder for construct a inline blank node property list.\n */\nexport interface BlankNodeBuilder extends PropertyBuilder<{}> {}\n\n\n/**\n * Factory that only returns the same object provided.\n */\nconst emptyGenericFactory:Factory<any, {}> = ( container, object ) => object;\n\n\n/**\n * Constant with utils for {@link BlankNodeBuilder}\n */\nexport const BlankNodeBuilder:{\n\t/**\n\t * Factory function that allows to crete a {@link BlankNodeBuilder}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link BlankNodeBuilder} statement.\n\t * @param object The base base from where to create the\n\t * {@link BlankNodeBuilder} statement.\n\t *\n\t * @return The {@link BlankNodeBuilder} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<BlankNodePropertyToken>, O extends object>( container:C, object:O ):O & BlankNodeBuilder;\n} = {\n\tcreateFrom<C extends Container<BlankNodePropertyToken>, O extends object>( container:C, object:O ):O & BlankNodeBuilder {\n\t\treturn PropertyBuilder.createFrom( emptyGenericFactory, container, object );\n\t}\n};\n","import { TokenNode } from \"./TokenNode\";\n\n\n/**\n * Regex of a valid language tag\n */\nconst LANGUAGE_REGEX:RegExp = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/;\n\n\n/**\n * The token of the language tag term.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rLANGTAG}\n */\nexport class LanguageToken implements TokenNode {\n\treadonly token:\"language\" = \"language\";\n\treadonly tag:string;\n\n\tconstructor( tag:string ) {\n\t\tif( ! LANGUAGE_REGEX.test( tag ) ) throw new Error( `\"${ tag }\" is an invalid language tag.` );\n\t\tthis.tag = tag;\n\t}\n\n\ttoString( spaces?:number ):string {\n\t\treturn `@${ this.tag }`;\n\t}\n}\n","import { Container } from \"../../data/Container\";\n\nimport { ObjectToken } from \"../../tokens/ObjectToken\";\nimport { TripleToken } from \"../../tokens/TripleToken\";\n\nimport { Pattern } from \"../Pattern\";\n\n\n/**\n * Object that contains a pattern made from a triple subject.\n */\nexport interface TriplePattern<T extends ObjectToken = ObjectToken> extends Pattern<TripleToken<T>> {}\n\n\n/**\n * Constant with utils for {@link TriplePattern} objects.\n */\nexport const TriplePattern:{\n\t/**\n\t * Factory function that allows to crete a {@link TriplePattern}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link TriplePattern} statement.\n\t * @param object The base base from where to create the\n\t * {@link TriplePattern} statement.\n\t *\n\t * @return The {@link TriplePattern} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<T extends ObjectToken, C extends Container<TripleToken<T>>, O extends object>( container:C, object:O ):O & TriplePattern<T>;\n} = {\n\tcreateFrom: Pattern.createFrom,\n};\n","import { Container } from \"../../data/Container\";\nimport { Factory } from \"../../data/Factory\";\n\nimport { ObjectToken } from \"../../tokens/ObjectToken\";\nimport { TripleToken } from \"../../tokens/TripleToken\";\n\nimport { PropertyBuilder } from \"./PropertyBuilder\";\nimport { TriplePattern } from \"./TriplePattern\";\n\n\n/**\n * Object that contains a specific triple subject and allows to\n * create patterns for it.\n */\nexport interface TripleSubject<T extends ObjectToken> extends PropertyBuilder<TriplePattern<T>> {\n\t/**\n\t * Return the subject token of the triple.\n\t */\n\tgetSubject():T;\n}\n\n\n/**\n * Constant with the utils for {@link TripleSubject} objects.\n */\nexport const TripleSubject:{\n\t/**\n\t * Factory function that allows to crete a {@link TripleSubject}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link TripleSubject} statement.\n\t * @param object The base base from where to create the\n\t * {@link TripleSubject} statement.\n\t *\n\t * @return The {@link TripleSubject} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<T extends ObjectToken, C extends Container<TripleToken<T>>, O extends object>( container:C, object:O ):O & TripleSubject<T>;\n} = {\n\tcreateFrom<T extends ObjectToken, C extends Container<TripleToken<T>>, O extends object>( container:C, object:O ):O & TripleSubject<T> {\n\t\tconst triplePatternFactory:Factory<C, TriplePattern<T>> = TriplePattern.createFrom;\n\t\treturn PropertyBuilder.createFrom( triplePatternFactory, container, Object.assign( object, {\n\t\t\tgetSubject: () => container.targetToken.subject,\n\t\t} ) );\n\t}\n};\n","import { Container } from \"../../data/Container\";\nimport { cloneElement } from \"../../data/utils\";\n\nimport { LanguageToken } from \"../../tokens/LanguageToken\";\nimport { RDFLiteralToken } from \"../../tokens/RDFLiteralToken\";\nimport { SubjectToken } from \"../../tokens/SubjectToken\";\n\nimport { XSD } from \"../../utils/XSD\";\n\nimport { Literal } from \"./Literal\";\nimport { TripleSubject } from \"./TripleSubject\";\n\n\n/**\n * Wrapper for easier usage of SPARQL RDLiterals as objects and for\n * declaring triple patterns as its subject.\n */\nexport interface RDFLiteral extends Literal {\n\t/**\n\t * Add an specific type to the RDFLiteral.\n\t *\n\t * Relative types of the XMLSchema ({@link https://www.w3.org/2001/XMLSchema-datatypes})\n\t * can be provided and resolved internally.\n\t *\n\t * @param type The IRI type to be added.\n\t */\n\twithType( type:string ):Literal;\n\n\t/**\n\t * Add an specific language tag to the RDFLiteral.\n\t *\n\t * @param language The language tag to be added.\n\t */\n\twithLanguage( language:string ):Literal;\n}\n\n\nfunction getWithTypeFn<C extends Container<SubjectToken<RDFLiteralToken>>>( container:C ):RDFLiteral[ \"withType\" ] {\n\treturn type => {\n\t\tif( type in XSD ) type = XSD[ type as keyof typeof XSD ];\n\n\t\tconst iriType = container.iriResolver.resolve( type, true );\n\t\tconst subject = cloneElement( container.targetToken.subject, { type: iriType } );\n\n\t\tconst targetToken = cloneElement( container.targetToken, { subject } );\n\t\tconst newContainer:C = cloneElement( container, { targetToken } as Partial<C> );\n\n\t\treturn TripleSubject.createFrom( newContainer, {} );\n\t}\n}\n\nfunction getWithLanguageFn<C extends Container<SubjectToken<RDFLiteralToken>>>( container:C ):RDFLiteral[ \"withLanguage\" ] {\n\treturn language => {\n\t\tconst langToken = new LanguageToken( language );\n\t\tconst subject = cloneElement( container.targetToken.subject, { language: langToken } );\n\n\t\tconst targetToken = cloneElement( container.targetToken, { subject } );\n\t\tconst newContainer:C = cloneElement( container, { targetToken } as Partial<C> );\n\n\t\treturn TripleSubject.createFrom( newContainer, {} );\n\t}\n}\n\n\n/**\n * Constant with utils for {@link RDFLiteral} objects.\n */\nexport const RDFLiteral:{\n\t/**\n\t * Factory function that allows to crete a {@link TripleSubject}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link TripleSubject} statement.\n\t * @param object The base base from where to create the\n\t * {@link TripleSubject} statement.\n\t *\n\t * @return The {@link TripleSubject} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<SubjectToken<RDFLiteralToken>>, O extends object>( container:C, object:O ):O & RDFLiteral;\n} = {\n\tcreateFrom<C extends Container<SubjectToken<RDFLiteralToken>>, O extends object>( container:C, object:O ):O & RDFLiteral {\n\t\treturn TripleSubject.createFrom( container, Object.assign( object, {\n\t\t\twithType: getWithTypeFn( container ),\n\t\t\twithLanguage: getWithLanguageFn( container ),\n\t\t} ) );\n\t},\n};\n","import { Container } from \"../../data/Container\";\nimport { Factory } from \"../../data/Factory\";\n\nimport { BlankNodePropertyToken } from \"../../tokens/BlankNodePropertyToken\";\nimport { BlankNodeToken } from \"../../tokens/BlankNodeToken\";\nimport { CollectionToken } from \"../../tokens/CollectionToken\";\nimport { IRIToken } from \"../../tokens/IRIToken\";\nimport { LiteralToken } from \"../../tokens/LiteralToken\";\nimport { ObjectToken } from \"../../tokens/ObjectToken\";\nimport { RDFLiteralToken } from \"../../tokens/RDFLiteralToken\";\nimport { SubjectToken } from \"../../tokens/SubjectToken\";\nimport { TripleToken } from \"../../tokens/TripleToken\";\nimport { VariableToken } from \"../../tokens/VariableToken\";\n\nimport { Pattern } from \"../Pattern\";\nimport { SupportedNativeTypes } from \"../SupportedNativeTypes\";\nimport { convertValue } from \"../utils\";\nimport { BlankNode } from \"./BlankNode\";\nimport { BlankNodeBuilder } from \"./BlankNodeBuilder\";\nimport { BlankNodeProperty } from \"./BlankNodeProperty\";\nimport { Collection } from \"./Collection\";\nimport { Literal } from \"./Literal\";\nimport { RDFLiteral } from \"./RDFLiteral\";\nimport { Resource } from \"./Resource\";\nimport { TripleSubject } from \"./TripleSubject\";\nimport { Variable } from \"./Variable\";\n\n\n/**\n * Builder for triples based elements.\n */\nexport interface TriplePatternsBuilder {\n\t/**\n\t * Create a {@link Resource} from the IRI or prefixed name\n\t * specified.\n\t * @param iri The IRI or prefixed name to create the\n\t * {@link Resource} from.\n\t */\n\tresource( iri:string ):Resource;\n\n\t/**\n\t * Crete a {@link Variable} from the name specified.\n\t * @param name The name of the {@link Variable} to be created.\n\t */\n\tvar( name:string ):Variable;\n\n\t/**\n\t * Create a {@link RDFLiteral} from the string specified.\n\t * @param value The string value of the {@link RDFLiteral}.\n\t */\n\tliteral( value:string ):RDFLiteral;\n\t/**\n\t * Create a {@link Literal} from the value specified.\n\t * @param value The value of the {@link Literal}.\n\t */\n\tliteral( value:string | number | boolean ):Literal;\n\n\t/**\n\t * Create a {@link Collection} from all the values provided.\n\t * @param values The values to be added to the collection.\n\t */\n\tcollection( ...values:(SupportedNativeTypes | Resource | BlankNode | Variable | Literal | Collection | BlankNodeProperty)[] ):Collection;\n\n\t/**\n\t * Create a {@link BlankNode} reference from the label specified.\n\t * @param label The optional label of the {@link BlankNode} to be\n\t * created.\n\t */\n\tblankNode( label?:string ):BlankNode;\n\t/**\n\t * Create a {@link BlankNodeProperty} from the properties\n\t * added in the `selfBuilder` of the {@param builderFn} specified.\n\t * @param builderFn The function that will receive a `selfBuilder`\n\t * parameter to add the properties of the blank node to match.\n\t * This builder as s similar API of a triple pattern, i.e. the\n\t * `has` and `and` methods.\n\t */\n\tblankNode( builderFn:( selfBuilder:BlankNodeBuilder ) => any ):BlankNodeProperty;\n}\n\n\nfunction _getPatternContainer<T extends ObjectToken>( container:Container<undefined>, token:T ):Container<TripleToken<T>> {\n\treturn new Container( {\n\t\tiriResolver: container.iriResolver,\n\t\ttargetToken: new SubjectToken( token ),\n\t} );\n}\n\nfunction _getTripleSubject<T extends ObjectToken>( container:Container<undefined>, token:T ):TripleSubject<T> {\n\tconst patternContainer = _getPatternContainer( container, token );\n\treturn TripleSubject.createFrom( patternContainer, {} );\n}\n\nfunction _getNodeSubject<T extends ObjectToken>( container:Container<undefined>, token:T ):TripleSubject<T> & Pattern<TripleToken<T>> {\n\tconst patternContainer = _getPatternContainer( container, token );\n\treturn Factory.createFrom<typeof patternContainer, TripleSubject<T>, Pattern<TripleToken<T>>>(\n\t\tTripleSubject.createFrom,\n\t\tPattern.createFrom,\n\t)( patternContainer, {} );\n}\n\n\nfunction getResourceFn( container:Container<undefined> ):TriplePatternsBuilder[ \"resource\" ] {\n\treturn iri => {\n\t\tconst token:IRIToken = container.iriResolver.resolve( iri );\n\t\treturn _getTripleSubject( container, token );\n\t}\n}\n\nfunction getVarFn( container:Container<undefined> ):TriplePatternsBuilder[ \"var\" ] {\n\treturn name => {\n\t\tconst token:VariableToken = new VariableToken( name );\n\t\treturn _getTripleSubject( container, token );\n\t}\n}\n\nfunction getLiteralFn( container:Container<undefined> ):TriplePatternsBuilder[ \"literal\" ] {\n\treturn ( value:string | number | boolean ):any => {\n\n\t\tif( typeof value !== \"string\" ) {\n\t\t\tconst token:LiteralToken = new LiteralToken( value );\n\t\t\treturn _getTripleSubject( container, token );\n\t\t}\n\n\t\tconst token:RDFLiteralToken = new RDFLiteralToken( value );\n\t\tconst patternContainer = _getPatternContainer( container, token );\n\t\treturn RDFLiteral.createFrom( patternContainer, {} );\n\t}\n}\n\n\ntype Values = SupportedNativeTypes | Resource | BlankNode | Variable | Literal | Collection | BlankNodeProperty;\n\nfunction getCollectionFn( container:Container<undefined> ):TriplePatternsBuilder[ \"collection\" ] {\n\treturn ( ...values:Values[] ) => {\n\t\tconst token:CollectionToken = new CollectionToken()\n\t\t\t.addObject( ...values.map( convertValue ) );\n\t\treturn _getNodeSubject( container, token );\n\t}\n}\n\nfunction _getBlankNode( container:Container<undefined>, label?:string ):BlankNode {\n\tif( label && ! label.startsWith( \"_:\" ) )\n\t\tlabel = \"_:\" + label;\n\n\tconst token:BlankNodeToken = new BlankNodeToken( label );\n\treturn _getTripleSubject( container, token );\n}\n\nfunction _getBlankNodeProperty( container:Container<undefined>, builderFn:( selfBuilder:BlankNodeBuilder ) => any ):BlankNodeProperty {\n\tconst token:BlankNodePropertyToken = new BlankNodePropertyToken();\n\n\tconst builderContainer:Container<BlankNodePropertyToken> = new Container( {\n\t\tiriResolver: container.iriResolver,\n\t\ttargetToken: token,\n\t} );\n\n\tconst builder:BlankNodeBuilder = BlankNodeBuilder.createFrom( builderContainer, {} );\n\tbuilderFn( builder );\n\n\tif( token.properties.length < 1 )\n\t\tthrow new Error( \"At least one property must be specified by the self builder.\" );\n\n\treturn _getNodeSubject( container, token );\n}\n\nfunction getBlankNodeFn( container:Container<undefined> ):TriplePatternsBuilder[ \"blankNode\" ] {\n\treturn ( labelOrBuilderFn?:string | (( selfBuilder:BlankNodeBuilder ) => any) ):any => {\n\t\tif( typeof labelOrBuilderFn === \"function\" )\n\t\t\treturn _getBlankNodeProperty( container, labelOrBuilderFn );\n\n\t\treturn _getBlankNode( container, labelOrBuilderFn );\n\t};\n}\n\n\n/**\n * Constant with the utils for {@link TriplePatternsBuilder} objects.\n */\nexport const TriplePatternsBuilder:{\n\t/**\n\t * Factory function that allows to crete a {@link TriplePatternsBuilder}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link TriplePatternsBuilder} statement.\n\t * @param object The base base from where to create the\n\t * {@link TriplePatternsBuilder} statement.\n\t *\n\t * @return The {@link TriplePatternsBuilder} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<O extends object>( container:Container<undefined>, object:O ):O & TriplePatternsBuilder;\n} = {\n\tcreateFrom<O extends object>( container:Container<undefined>, object:O ):O & TriplePatternsBuilder {\n\t\treturn Object.assign( object, {\n\t\t\tresource: getResourceFn( container ),\n\t\t\tvar: getVarFn( container ),\n\t\t\tliteral: getLiteralFn( container ),\n\t\t\tcollection: getCollectionFn( container ),\n\t\t\tblankNode: getBlankNodeFn( container ),\n\t\t} );\n\t},\n};\n","import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\nimport { IRIResolver } from \"../data/IRIResolver\";\n\nimport { SubSelectPattern } from \"./clausePatterns/SubSelectPattern\";\nimport { NotTriplePatternsBuilder } from \"./notTriplePatterns/NotTriplePatternsBuilder\";\nimport { PathsBuilder } from \"./paths/PathsBuilder\";\nimport { TriplePatternsBuilder } from \"./triplePatterns/TriplePatternsBuilder\";\n\n\n/**\n * Helper builder for generate patters.\n */\nexport interface PatternBuilder extends TriplePatternsBuilder, NotTriplePatternsBuilder, SubSelectPattern, PathsBuilder {\n}\n\n\n/**\n * Constant with the utils for {@link PatternBuilder} objects.\n */\nexport const PatternBuilder:{\n\t/**\n\t * Function that crete a {@link PatternBuilder}.\n\t *\n\t * @param iriResolver The iri resolver that will use the\n\t * pattern builder.\n\t *\n\t * @return The {@link PatternBuilder} created.\n\t */\n\tcreate( iriResolver:IRIResolver ):PatternBuilder;\n\t/**\n\t * Factory function that allows to crete a {@link PatternBuilder}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link PatternBuilder} statement.\n\t * @param object The base base from where to create the\n\t * {@link PatternBuilder} statement.\n\t *\n\t * @return The {@link PatternBuilder} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<undefined>, O extends object>( container:C, object:O ):O & PatternBuilder;\n} = {\n\tcreate( iriResolver:IRIResolver ):PatternBuilder {\n\t\tconst container:Container<undefined> = new Container( {\n\t\t\tiriResolver,\n\t\t\ttargetToken: void 0,\n\t\t} );\n\n\t\treturn PatternBuilder\n\t\t\t.createFrom( container, {} );\n\t},\n\n\tcreateFrom<C extends Container<undefined>, O extends object>( container:C, object:O ):O & PatternBuilder {\n\t\treturn Factory.createFrom(\n\t\t\tTriplePatternsBuilder.createFrom,\n\t\t\tNotTriplePatternsBuilder.createFrom,\n\t\t\tSubSelectPattern.createFrom,\n\t\t\tPathsBuilder.createFrom,\n\t\t)( container, object );\n\t},\n};","import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\nimport { IRIResolver } from \"../data/IRIResolver\";\nimport { cloneElement } from \"../data/utils\";\n\nimport { Pattern } from \"../patterns/Pattern\";\nimport { PatternBuilder } from \"../patterns/PatternBuilder\";\n\nimport { PatternToken } from \"../tokens/PatternToken\";\nimport { QueryClauseToken } from \"../tokens/QueryClauseToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { WhereToken } from \"../tokens/WhereToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { GroupClause } from \"./GroupClause\";\n\n\n/**\n * Interface with the methods available to make a WHERE statement.\n */\nexport interface WhereClause<T extends FinishClause> {\n\t/**\n\t * Specifies the graph patterns the query should match to retrieve\n\t * the solutions results.\n\t *\n\t * This pattern are created by a pattern constructor function that\n\t * receives a {@link PatternBuilder} which is a class that exposes\n\t * the possible elements and configurations the patterns chan have.\n\t *\n\t * @param patternFunction Function that retrieves a pattern or an\n\t * array of patterns to match.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\twhere( patternFunction:( builder:PatternBuilder ) => Pattern | Pattern[] ):GroupClause<T> & T;\n}\n\n\nfunction _getPatterns( iriResolver:IRIResolver, patternFunction:( builder:PatternBuilder ) => Pattern | Pattern[] ):PatternToken[] {\n\tconst patternOrPatterns:Pattern | Pattern[] = patternFunction( PatternBuilder.create( iriResolver ) );\n\tconst patterns:Pattern[] = Array.isArray( patternOrPatterns ) ? patternOrPatterns : [ patternOrPatterns ];\n\n\treturn patterns.map( x => x.getPattern() );\n}\n\n/**\n * Function that creates the {@link WhereClause.where} function.\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link WhereClause} receives.\n * @param container The container with the query data of the statement.\n *\n * @returns The {@link WhereClause.where} function.\n *\n * @private\n */\nfunction getWhereFn<C extends Container<QueryToken<QueryClauseToken>>, T extends FinishClause>( genericFactory:Factory<C, T>, container:C ):WhereClause<T>[ \"where\" ] {\n\treturn ( patternFunction:( builder:PatternBuilder ) => Pattern | Pattern[] ) => {\n\t\tconst iriResolver:IRIResolver = new IRIResolver( container.iriResolver );\n\t\tconst patterns:PatternToken[] = _getPatterns( iriResolver, patternFunction );\n\n\t\tconst query = cloneElement( container.targetToken.queryClause, { where: new WhereToken() } )\n\t\t\t.addPattern( ...patterns );\n\n\t\tconst queryToken:QueryToken = cloneElement( container.targetToken, { queryClause: query } );\n\t\tconst newContainer = cloneElement( container, { iriResolver, targetToken: queryToken } as Partial<C> );\n\n\t\tconst groupClause:GroupClause<T> = GroupClause.createFrom( genericFactory, newContainer, {} );\n\t\treturn genericFactory( newContainer, groupClause );\n\t};\n}\n\n\n/**\n * Constant with the utils for {@link WhereClause} objects.\n */\nexport const WhereClause:{\n\t/**\n\t * Factory function that allows to crete a {@link WhereClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link WhereClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link WhereClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link WhereClause} statement.\n\t *\n\t * @return The {@link WhereClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken>>, T extends FinishClause, O extends object>( genericFactory:Factory<typeof container, T>, container:C, object:O ):O & WhereClause<T>\n} = {\n\tcreateFrom<C extends Container<QueryToken<QueryClauseToken>>, T extends FinishClause, O extends object>( genericFactory:Factory<typeof container, T>, container:C, object:O ):O & WhereClause<T> {\n\t\treturn Object.assign( object, {\n\t\t\twhere: getWhereFn( genericFactory, container ),\n\t\t} );\n\t},\n};\n","import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\nimport { IRIResolver } from \"../data/IRIResolver\";\nimport { cloneElement } from \"../data/utils\";\nimport { AskToken } from \"../tokens/AskToken\";\n\nimport { FromToken } from \"../tokens/FromToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SelectToken } from \"../tokens/SelectToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { WhereClause } from \"./WhereClause\";\n\n\n/**\n * Interface with the methods available to make a FROM statement.\n */\nexport interface FromClause<T extends FinishClause> extends WhereClause<T> {\n\t/**\n\t * Set a default graph to be included as the RDF Dataset where to\n\t * look for the query solutions.\n\t *\n\t * @param iri IRI of the default graph to be included.\n\t * @returns Object with the methods to keep constructing to query.\n\t */\n\tfrom( iri:string ):FromClause<T>;\n\n\t/**\n\t * Set a named graph to be included as the RDF Dataset where to look for\n\t * the query solutions.\n\t *\n\t * @param iri IRI of the named graph to be included.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tfromNamed( iri:string ):FromClause<T>;\n}\n\n\n/**\n * Function that creates a generic {@link FromClause.from} function.\n * This function is used to create all the methods for the {@link FromClause}\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link FromClause} receives.\n * @param container The container that is bound to the FromClause methods.\n * @param named Optional boolean that indicates if the dataset graph is named or not.\n *\n * @returns The generic \"from\" function that shares the {@link FromClause.from} signature.\n * It behaviour depends if the {@param named} was set or not.\n *\n * @private\n */\nfunction getFromFn<C extends Container<QueryToken<SelectToken | AskToken>>, T extends FinishClause>( genericFactory:Factory<C, T>, container:C, named?:boolean ):FromClause<T>[ \"from\" ] {\n\treturn ( iri:string ) => {\n\t\tconst iriResolver:IRIResolver = new IRIResolver( container.iriResolver );\n\n\t\tconst datasets:FromToken[] = container.targetToken.queryClause.datasets\n\t\t\t.concat( new FromToken( iriResolver.resolve( iri ), named ) );\n\t\tconst queryClause = cloneElement( container.targetToken.queryClause, { datasets } );\n\n\t\tconst queryToken:QueryToken = cloneElement( container.targetToken, { queryClause } );\n\t\tconst newContainer = cloneElement( container, {\n\t\t\tiriResolver,\n\t\t\ttargetToken: queryToken,\n\t\t} as Partial<C> );\n\n\t\treturn FromClause.createFrom( genericFactory, newContainer, {} );\n\t}\n}\n\n\n/**\n * Constant with the utils for {@link FromClause} objects.\n */\nexport const FromClause:{\n\t/**\n\t * Factory function that allows to crete a {@link FromClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link FromClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link FromClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link FromClause} statement.\n\t *\n\t * @return The {@link FromClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken<SelectToken | AskToken>>, T extends FinishClause, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & FromClause<T>;\n} = {\n\tcreateFrom<C extends Container<QueryToken<SelectToken | AskToken>>, T extends FinishClause, O extends object>( genericFactory:Factory<C, T>, container:C, object:O ):O & FromClause<T> {\n\t\treturn WhereClause.createFrom( genericFactory, container, Object.assign( object, {\n\t\t\tfrom: getFromFn( genericFactory, container ),\n\t\t\tfromNamed: getFromFn( genericFactory, container, true ),\n\t\t} ) );\n\t},\n};","import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\nimport { cloneElement } from \"../data/utils\";\nimport { AskToken } from \"../tokens/AskToken\";\n\nimport { QueryToken } from \"../tokens/QueryToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { FromClause } from \"./FromClause\";\n\n\n/**\n * Interface with the methods available to make a ASK query.\n */\nexport interface AskClause<T extends FinishClause> {\n\t/**\n\t * Set that the query will ask for a pattern matching.\n\t */\n\task():FromClause<T>;\n}\n\n\n/**\n * Function that creates a {@link AskClause.ask} function.\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link AskClause} receives.\n * @param container The container with the query data for the statement.\n *\n * @private\n */\nfunction getSelectFn<C extends Container<QueryToken>, T extends FinishClause>( genericFactory:Factory<Container<QueryToken<AskToken>>, T>, container:C ):AskClause<T>[ \"ask\" ] {\n\treturn () => {\n\t\tconst queryClause:AskToken = new AskToken();\n\n\t\tconst queryToken:QueryToken<AskToken> = cloneElement( container.targetToken, { queryClause } );\n\t\tconst newContainer:Container<QueryToken<AskToken>> = new Container( {\n\t\t\tiriResolver: container.iriResolver,\n\t\t\ttargetToken: queryToken,\n\t\t} );\n\n\t\treturn FromClause.createFrom( genericFactory, newContainer, {} );\n\t};\n}\n\n\n/**\n * Constant with the utils for {@link AskClause} objects.\n */\nexport const AskClause:{\n\t/**\n\t * Factory function that allows to crete a {@link AskClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link AskClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link AskClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link AskClause} statement.\n\t *\n\t * @return The {@link AskClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken>, T extends FinishClause, O extends object>( genericFactory:Factory<Container<QueryToken<AskToken>>, T>, container:C, object:O ):O & AskClause<T>;\n} = {\n\tcreateFrom<C extends Container<QueryToken>, T extends FinishClause, O extends object>( genericFactory:Factory<Container<QueryToken<AskToken>>, T>, container:C, object:O ):O & AskClause<T> {\n\t\treturn Object.assign( object, {\n\t\t\task: getSelectFn( genericFactory, container ),\n\t\t} );\n\t},\n};","import { FromToken } from \"./FromToken\";\nimport { getSeparator } from \"./printing\";\nimport { SharedSelectToken } from \"./SharedSelectToken\";\n\n\n/**\n * The token of the `SELECT` query statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rSelectQuery}\n */\nexport class SelectToken extends SharedSelectToken {\n\treadonly token:\"select\" = \"select\";\n\n\treadonly datasets:FromToken[];\n\n\tconstructor( modifier?:\"DISTINCT\" | \"REDUCED\" ) {\n\t\tsuper( modifier );\n\n\t\tthis.datasets = [];\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\tlet query:string = super.toString( spaces );\n\t\tconst separator:string = getSeparator( spaces );\n\n\t\tif( this.datasets.length ) query += separator + this.datasets.join( separator );\n\n\t\tquery += separator + this.where.toString( spaces );\n\n\t\tif( this.modifiers.length ) query += separator + this.modifiers.join( separator );\n\n\t\treturn query;\n\t}\n}\n","import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\nimport { cloneElement } from \"../data/utils\";\n\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SelectToken } from \"../tokens/SelectToken\";\nimport { VariableToken } from \"../tokens/VariableToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { FromClause } from \"./FromClause\";\n\n\n/**\n * Interface with the methods available to make a SELECT query.\n */\nexport interface SelectClause<T extends FinishClause> {\n\t/**\n\t * Set a list of variables to be retrieved by the query.\n\t *\n\t * @param variables The list of variables.\n\t * IF no variable is provided, the behaviour will be the same\n\t * as {@link SelectClause.selectAll}\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tselect( ...variables:string[] ):FromClause<T>;\n\n\t/**\n\t * Set a list of variables to be retrieved by the query ensuring no\n\t * repetitions in the set of solutions.\n\t *\n\t * @param variables The list of variables.\n\t * IF no variable is provided, the behaviour will be the same\n\t * as {@link SelectClause.selectAllDistinct}\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tselectDistinct( ...variables:string[] ):FromClause<T>;\n\n\t/**\n\t * Set a list of variables to be retrieved by the query permitting\n\t * eliminations of non-distinct solutions, but not ensuring a set of\n\t * unique ones.\n\t *\n\t * @param variables The list of variables.\n\t * IF no variable is provided, the behaviour will be the same\n\t * as {@link SelectClause.selectAllReduced}\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tselectReduced( ...variables:string[] ):FromClause<T>;\n\n\t/**\n\t * Set that the query must return all the solutions for the variables\n\t * used in the where pattern matching.\n\t *\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tselectAll():FromClause<T>;\n\n\t/**\n\t * Set that the query must return all the solutions for the variables\n\t * used in the where pattern matching, ensuring there is not\n\t * duplicated solutions.\n\t *\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tselectAllDistinct():FromClause<T>;\n\n\t/**\n\t * Set that the query must return all the solutions for the variables\n\t * used in the where pattern matching, permitting eliminations of\n\t * non-distinct solutions, but not ensuring a set of unique ones.\n\t *\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tselectAllReduced():FromClause<T>;\n}\n\n\n/**\n * Function that creates a generic {@link SelectClause.select} function.\n * This function is used to create all the methods for the {@link SelectClause}\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link SelectClause} receives.\n * @param container The container with the query data for the statement.\n * @param modifier The optional modifier of the SELECT queries.\n *\n * @returns A generic \"select\" function that shares the {@link SelectClause.select} signature.\n * It behaviour depends of the {@param modifier} set.\n *\n * @private\n */\nfunction getSelectFn<C extends Container<QueryToken>, T extends FinishClause>( genericFactory:Factory<Container<QueryToken<SelectToken>>, T>, container:C, modifier?:\"DISTINCT\" | \"REDUCED\" ):SelectClause<T>[ \"select\" ] {\n\treturn ( ...variables:string[] ) => {\n\t\tconst queryClause:SelectToken = new SelectToken( modifier );\n\t\tif( variables.length ) queryClause.addVariable( ...variables.map( x => new VariableToken( x ) ) );\n\n\t\tconst queryToken:QueryToken<SelectToken> = cloneElement( container.targetToken, { queryClause } );\n\t\tconst newContainer:Container<QueryToken<SelectToken>> = new Container( {\n\t\t\tiriResolver: container.iriResolver,\n\t\t\ttargetToken: queryToken,\n\t\t} );\n\n\t\treturn FromClause.createFrom( genericFactory, newContainer, {} );\n\t};\n}\n\n\n/**\n * Constant with the utils for {@link SelectClause} objects.\n */\nexport const SelectClause:{\n\t/**\n\t * Factory function that allows to crete a {@link SelectClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link SelectClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link SelectClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link SelectClause} statement.\n\t *\n\t * @return The {@link SelectClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken>, T extends FinishClause, O extends object>( genericFactory:Factory<Container<QueryToken<SelectToken>>, T>, container:C, object:O ):O & SelectClause<T>;\n} = {\n\tcreateFrom<C extends Container<QueryToken>, T extends FinishClause, O extends object>( genericFactory:Factory<Container<QueryToken<SelectToken>>, T>, container:C, object:O ):O & SelectClause<T> {\n\t\treturn Object.assign( object, {\n\t\t\tselect: getSelectFn( genericFactory, container ),\n\t\t\tselectDistinct: getSelectFn( genericFactory, container, \"DISTINCT\" ),\n\t\t\tselectReduced: getSelectFn( genericFactory, container, \"REDUCED\" ),\n\t\t\tselectAll: () => getSelectFn( genericFactory, container )(),\n\t\t\tselectAllDistinct: () => getSelectFn( genericFactory, container, \"DISTINCT\" )(),\n\t\t\tselectAllReduced: () => getSelectFn( genericFactory, container, \"REDUCED\" )(),\n\t\t} );\n\t},\n};","import { Factory } from \"../data/Factory\";\nimport { IRIResolver } from \"../data/IRIResolver\";\nimport { QueryUnitContainer } from \"../data/QueryUnitContainer\";\nimport { cloneElement } from \"../data/utils\";\n\nimport { BaseToken } from \"../tokens/BaseToken\";\nimport { IRIRefToken } from \"../tokens/IRIRefToken\";\nimport { PrefixToken } from \"../tokens/PrefixToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\n\nimport { AskClause } from \"./AskClause\";\nimport { FinishClause } from \"./FinishClause\";\nimport { SelectClause } from \"./SelectClause\";\n\n\n/**\n * Interface that describes the base entry of any query statement.\n *\n * It allows to add the prologues `BASE` and `PREFIX`.\n * And also add support for specify a `vocab` used to resolve\n * relative properties/predicates.\n *\n * The current query types supported are:\n * - `SELECT`, specified by the extension of {@link SelectClause}\n * - `ASK`, specified by the extension of {@link AskClause}\n */\nexport interface QueryClause<SELECT extends FinishClause, ASK extends FinishClause> extends SelectClause<SELECT>, AskClause<ASK> {\n\t/**\n\t * Add a base IRI the query uses to resolve any relative IRIs.\n\t *\n\t * If a default vocabulary is set with the {@link QueryClause.vocab}\n\t * method, the base is ignored for relative predicates.\n\t *\n\t * @param iri IRI to be used as the query BASE.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tbase( iri:string ):QueryClause<SELECT, ASK>;\n\n\t/**\n\t * Add a default vocabulary to be used to resolve relative IRIs when\n\t * used as a predicate in a triple pattern.\n\t *\n\t * @param iri IRI to append to prepend to any relative predicate.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvocab( iri:string ):QueryClause<SELECT, ASK>;\n\n\t/**\n\t * Add a prefix to the query.\n\t *\n\t * If the prefix is not used in any part of the query it is not added\n\t * in the compact query string.\n\t *\n\t * @param name Name the prefix will be identified for.\n\t * @param iri The IRI of the current PREFIX.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tprefix( name:string, iri:string ):QueryClause<SELECT, ASK>;\n}\n\n\n/**\n * @see {@link QueryClause.base}\n */\nfunction base<SELECT extends FinishClause, ASK extends FinishClause>( this:QueryUnitContainer<SELECT, ASK>, iri:string ):QueryClause<SELECT, ASK> {\n\tconst token:BaseToken = new BaseToken( new IRIRefToken( iri ) );\n\n\tconst prologues:QueryToken[ \"prologues\" ] = this.targetToken\n\t\t.prologues.concat( token );\n\n\tconst queryToken:QueryToken = cloneElement( this.targetToken, { prologues } );\n\tconst container:QueryUnitContainer<SELECT, ASK> = cloneElement( this, { targetToken: queryToken } );\n\n\treturn QueryClause.createFrom( container, {} );\n}\n\n/**\n * @see {@link QueryClause.vocab}\n */\nfunction vocab<SELECT extends FinishClause, ASK extends FinishClause>( this:QueryUnitContainer<SELECT, ASK>, iri:string ):QueryClause<SELECT, ASK> {\n\tconst iriResolver:IRIResolver = new IRIResolver( this.iriResolver, iri );\n\tconst container:QueryUnitContainer<SELECT, ASK> = cloneElement( this, { iriResolver } );\n\n\treturn QueryClause.createFrom( container, {} );\n}\n\n/**\n * @see {@link QueryClause.prefix}\n */\nfunction prefix<SELECT extends FinishClause, ASK extends FinishClause>( this:QueryUnitContainer<SELECT, ASK>, name:string, iri:string ):QueryClause<SELECT, ASK> {\n\tconst iriResolver:IRIResolver = new IRIResolver( this.iriResolver );\n\n\n\tconst prologues = this.targetToken.prologues.slice();\n\n\tif( iriResolver.prefixes.has( name ) ) {\n\t\tconst index:number = prologues\n\t\t\t.findIndex( token => token.token === \"prefix\" && token.namespace === name );\n\n\t\tif( index !== - 1 )\n\t\t\tprologues.splice( index, 1 );\n\t}\n\n\tprologues.push( new PrefixToken( name, new IRIRefToken( iri ) ) );\n\tiriResolver.prefixes.set( name, false );\n\n\n\tconst queryToken:QueryToken = cloneElement( this.targetToken, { prologues } );\n\tconst container:QueryUnitContainer<SELECT, ASK> = cloneElement( this, {\n\t\tiriResolver,\n\t\ttargetToken: queryToken,\n\t} );\n\n\treturn QueryClause.createFrom( container, {} );\n}\n\n\n/**\n * Constant with the utils functions for {@link QueryClause} objects.\n */\nexport const QueryClause:{\n\t/**\n\t * Factory function that allows to crete a {@link QueryClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link QueryClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link QueryClause} statement.\n\t *\n\t * @return The {@link QueryClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends QueryUnitContainer<SELECT, ASK>, SELECT extends FinishClause, ASK extends FinishClause, T extends object>( container:C, object:T ):T & QueryClause<SELECT, ASK>;\n} = {\n\tcreateFrom<C extends QueryUnitContainer<SELECT, ASK>, SELECT extends FinishClause, ASK extends FinishClause, T extends object>( container:C, object:T ):T & QueryClause<SELECT, ASK> {\n\t\tconst selectFactory:Factory<C, SelectClause<SELECT>> = SelectClause\n\t\t\t.createFrom.bind( null, container.selectFinishClauseFactory );\n\t\tconst askFactory:Factory<C, AskClause<ASK>> = AskClause\n\t\t\t.createFrom.bind( null, container.askFinishClauseFactory );\n\n\t\treturn Factory.createFrom(\n\t\t\tselectFactory,\n\t\t\taskFactory,\n\t\t)( container, Object.assign( object, {\n\t\t\tbase: base.bind( container ),\n\t\t\tvocab: vocab.bind( container ),\n\t\t\tprefix: prefix.bind( container ),\n\t\t} ) );\n\t},\n};","import { FinishClause } from \"../clauses/FinishClause\";\nimport { AskToken } from \"../tokens/AskToken\";\n\nimport { QueryToken } from \"../tokens/QueryToken\";\nimport { SelectToken } from \"../tokens/SelectToken\";\n\nimport { Container, ContainerData } from \"./Container\";\nimport { Factory } from \"./Factory\";\n\n\n/**\n * Interface that describe the necessary data for the creation\n * of a {@link QueryUnitContainer}.\n */\nexport interface QueryUnitContainerData<SELECT extends FinishClause, ASK extends FinishClause> extends ContainerData<QueryToken> {\n\t/**\n\t * @see QueryUnitContainer.selectFinishClauseFactory\n\t */\n\tselectFinishClauseFactory:Factory<Container<any>, SELECT>;\n\n\t/**\n\t * @see QueryUnitContainer.askFinishClauseFactory\n\t */\n\taskFinishClauseFactory:Factory<Container<any>, ASK>;\n}\n\n\n/**\n * Immutable class that contains the hidden data of the main query\n * statement.\n *\n * Extension of the {@link Container} that add the finish factories\n * for every type of type of query supported.\n */\nexport class QueryUnitContainer<SELECT extends FinishClause, ASK extends FinishClause>\n\textends Container<QueryToken>\n\timplements QueryUnitContainerData<SELECT, ASK> {\n\n\t/**\n\t * The factory used for create the finish statement of a SELECT\n\t * query.\n\t */\n\treadonly selectFinishClauseFactory:Factory<Container<QueryToken<SelectToken>>, SELECT>;\n\n\t/**\n\t * The factory used for create the finish statement of a SELECT\n\t * query.\n\t */\n\treadonly askFinishClauseFactory:Factory<Container<QueryToken<AskToken>>, ASK>;\n\n\t/**\n\t * Constructor that receives and object with the base data of the\n\t * container.\n\t *\n\t * @param data The base data for the container creation.\n\t */\n\tconstructor( data:QueryUnitContainerData<SELECT, ASK> ) {\n\t\tsuper( data );\n\t\tthis.selectFinishClauseFactory = data.selectFinishClauseFactory;\n\t\tthis.askFinishClauseFactory = data.askFinishClauseFactory;\n\n\t\tif( new.target === QueryUnitContainer ) Object.freeze( this );\n\t}\n}\n","import { BaseToken } from \"./BaseToken\";\nimport { PrefixToken } from \"./PrefixToken\";\nimport { getSeparator } from \"./printing\";\nimport { QueryClauseToken } from \"./QueryClauseToken\";\nimport { TokenNode } from \"./TokenNode\";\nimport { ValuesToken } from \"./ValuesToken\";\n\n\n/**\n * Token of a complete query statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rQuery}\n */\nexport class QueryToken<T extends QueryClauseToken | undefined = QueryClauseToken | undefined> implements TokenNode {\n\treadonly token:\"query\" = \"query\";\n\n\treadonly prologues:(BaseToken | PrefixToken)[];\n\treadonly queryClause:T;\n\treadonly values?:ValuesToken;\n\n\tconstructor( query:T, values?:ValuesToken ) {\n\t\tthis.prologues = [];\n\t\tthis.queryClause = query;\n\t\tthis.values = values;\n\t}\n\n\n\taddPrologues( ...prologues:(BaseToken | PrefixToken)[] ):this {\n\t\tthis.prologues.push( ...prologues );\n\t\treturn this;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\tconst separator:string = getSeparator( spaces );\n\n\t\tlet query:string = this.prologues\n\t\t\t.map( prologue => {\n\t\t\t\t// TODO: Remove new line separator when resolved https://community.stardog.com/t/error-with-inline-sparql-base/1200\n\t\t\t\tif( prologue.token === \"base\" )\n\t\t\t\t\treturn prologue + \"\\n\";\n\t\t\t\treturn prologue + separator;\n\t\t\t} )\n\t\t\t.join( \"\" );\n\n\t\tif( this.queryClause ) query += this.queryClause.toString( spaces );\n\n\t\tif( this.values ) query += separator + this.values.toString( spaces );\n\n\t\treturn query;\n\t}\n}\n","import { FinishClause } from \"./clauses/FinishClause\";\nimport { QueryClause } from \"./clauses/QueryClause\";\n\nimport { IRIResolver } from \"./data/IRIResolver\";\nimport { QueryUnitContainer } from \"./data/QueryUnitContainer\";\n\nimport { FinishFactory } from \"./FinishFactory\";\n\nimport { QueryToken } from \"./tokens/QueryToken\";\n\n\n/**\n * Interface with the same name fo the SPARQLER class, that helps\n * in the definition of the methods decorated by {@link QueryClause.createFrom}\n */\nexport interface SPARQLER<SELECT extends FinishClause = FinishClause, ASK extends FinishClause = FinishClause> extends QueryClause<SELECT, ASK> {\n}\n\n/**\n * Class that allows to create the SPARQL query builder.\n *\n * See {@link QueryClause} for know the methods available for\n * construct the queries.\n */\nexport class SPARQLER<SELECT extends FinishClause = FinishClause, ASK extends FinishClause = FinishClause> implements SPARQLER<SELECT, ASK> {\n\n\t/**\n\t * Constructor that allows to create query builder with custom finish\n\t * methods specified by the factories provided if specified.\n\t *\n\t * If no custom factory specified {@link FinishClause.createFrom}\n\t * will be used instead.\n\t *\n\t * @param finishSelectFactory Factory for finishing a SELECT query.\n\t * @param finishAskFactory Factory for finishing an ASK query.\n\t */\n\tconstructor(\n\t\tfinishSelectFactory:FinishFactory<SELECT> = FinishClause.createFrom as FinishFactory<SELECT>,\n\t\tfinishAskFactory:FinishFactory<ASK> = FinishClause.createFrom as FinishFactory<ASK>,\n\t) {\n\n\t\tconst container:QueryUnitContainer<SELECT, ASK> = new QueryUnitContainer( {\n\t\t\tiriResolver: new IRIResolver(),\n\t\t\ttargetToken: new QueryToken( void 0 ),\n\t\t\tselectFinishClauseFactory: finishSelectFactory,\n\t\t\taskFinishClauseFactory: finishAskFactory,\n\t\t} );\n\n\t\treturn QueryClause.createFrom( container, this );\n\t}\n\n}","import { SharedQueryClauseToken } from \"./SharedQueryClauseToken\";\nimport { getSeparator, getTokenContainerString } from \"./printing\";\nimport { TripleToken } from \"./TripleToken\";\n\n\n/**\n * The token of the `CONSTRUCT` query statement.\n *\n * @see {@link https://www.w3.org/TR/sparql11-query/#rConstructQuery}\n */\nexport class ConstructToken extends SharedQueryClauseToken {\n\treadonly token:\"construct\" = \"construct\";\n\n\treadonly triples:TripleToken[];\n\n\tconstructor() {\n\t\tsuper();\n\n\t\tthis.triples = [];\n\t}\n\n\n\taddTriple( ...triple:TripleToken[] ):this {\n\t\tthis.triples.push( ...triple );\n\t\treturn this;\n\t}\n\n\n\ttoString( spaces?:number ):string {\n\t\tconst triples:string = getTokenContainerString( {\n\t\t\tspaces,\n\t\t\ttags: { open: \"{\", close: \"}\" },\n\t\t\ttokensSeparator: \".\",\n\t\t\ttokens: this.triples,\n\t\t} );\n\n\t\tconst separator:string = getSeparator( spaces );\n\t\tlet query:string = `CONSTRUCT ` +\n\t\t\ttriples + separator +\n\t\t\tthis.where.toString( spaces );\n\n\t\tif( this.modifiers.length ) query += separator + this.modifiers.join( separator );\n\n\t\treturn query;\n\t}\n}\n"],"names":["tslib_1.__extends","getHasFn","getUnionFn","_getPatternContainer","getWhereFn","getSelectFn"],"mappings":";;;;;;IA0CO,IAAM,YAAY,GAAG;QAC3B,UAAU,EAAV,UAA8B,SAA8B,EAAE,MAAQ;YACrE,IAAM,cAAc,GAAoC;gBACvD,OAAA,SAAS,CAAC,WAAW,CAAC,QAAQ,CAAE,CAAC,CAAE;aAAA,CAAC;YAErC,IAAM,KAAK,GAA2B,UAAA,OAAO;gBAC5C,OAAO,CAAC,IAAI,CAAE,KAAK,CAAC,EAAE,MAAM,EAAE,SAAS,CAAE,CAAC;gBAC1C,OAAO,MAA0B,CAAC;aAClC,CAAC;YAEF,OAAO,MAAM,CAAC,MAAM,CAAmB,MAAM,EAAE;gBAC9C,eAAe,EAAE,cAAM,OAAA,SAAS,CAAC,WAAW,CAAC,QAAQ,EAAE,GAAA;gBACvD,cAAc,EAAE,cAAc;gBAC9B,QAAQ,EAAE,cAAc;gBACxB,KAAK,OAAA;aACL,CAAE,CAAC;SACJ;KACD,CAAC;;IC/BK,IAAM,OAAO,GAkChB;QACH,UAAU,EAAV;YAAY,mBAAgC;iBAAhC,UAAgC,EAAhC,qBAAgC,EAAhC,IAAgC;gBAAhC,8BAAgC;;YAC3C,OAAO,UAAoB,SAAwB,EAAE,MAAQ;gBAC5D,OAAO,SAAS;qBACd,MAAM,CAAE,UAAE,MAAM,EAAE,SAAS,IAAM,OAAA,SAAS,CAAE,SAAS,EAAE,MAAM,CAAE,GAAA,EAAE,MAAM,CAAE,CAAC;aAC5E,CAAC;SACF;KACD,CAAC;;aCrEc,UAAU,CAAE,GAAU;QACrC,OAAO,GAAG,CAAC,OAAO,CAAE,GAAG,CAAE,KAAK,CAAE,CAAC,CAAC;IACnC,CAAC;AAED,aAAgB,WAAW,CAAE,GAAU;QACtC,OAAO,GAAG,CAAC,OAAO,CAAE,KAAK,CAAE,KAAK,CAAE,CAAC,CAAC;IACrC,CAAC;AAED,aAAgB,UAAU,CAAE,GAAU;QACrC,OAAO,CAAE,UAAU,CAAE,GAAG,CAAE,CAAC;IAC5B,CAAC;AAED,aAAgB,KAAK,CAAE,GAAU;QAChC,OAAO,WAAW,CAAE,GAAG,CAAE,IAAI,CAAE,UAAU,CAAE,GAAG,CAAE,CAAC;IAClD,CAAC;AAGD,aAAgB,YAAY,CAAE,KAAY;QACzC,OAAO,KAAK,CAAC,IAAI,CAAE,KAAK,CAAE,CAAC;IAC5B,CAAC;AAGD,aAAgB,UAAU,CAAE,GAAU;QACrC,OAAO,eAAe,CAAC,IAAI,CAAE,GAAG,CAAE,IAAI,CAAE,WAAW,CAAE,GAAG,CAAE,CAAC;IAC5D,CAAC;;IChBD;QAIC,qBAAa,KAAY;YAHhB,UAAK,GAAS,KAAK,CAAC;YAI5B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;SACnB;QAED,8BAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,MAAK,IAAI,CAAC,KAAK,MAAI,CAAC;SAC3B;QACF,kBAAC;IAAD,CAXA,IAWC;;ICXD,IAAM,eAAe,GAAU,oDAAoD,CAAC;IAQpF;QAOC,2BAAa,mBAA0B,EAAE,SAAiB;;YANjD,UAAK,GAAkB,cAAc,CAAC;YAO9C,IAAI,SAAS,GAAU,mBAAmB,CAAC;YAC3C,IAAI,SAAS,KAAK,KAAK,CAAC,EAAG;gBAC1B,IAAI,CAAE,UAAU,CAAE,mBAAmB,CAAE;oBAAG,MAAM,IAAI,KAAK,CAAE,wBAAwB,CAAE,CAAC;gBACtF,uCAA+D,EAA7D,iBAAS,EAAE,iBAAS,CAA0C;aAChE;YAED,IAAI,CAAE,eAAe,CAAC,IAAI,CAAE,SAAS,CAAE;gBAAG,MAAM,IAAI,KAAK,CAAE,6BAA6B,CAAE,CAAC;YAC3F,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;YAErB,IAAA,0CAA6D,EAAzD,WAAG,EAAE,WAAG,EAAE,WAAG,CAA6C;YAEpE,IAAI,aAAa,GAAU,EAAE,CAAC;YAC9B,IAAI,GAAG;gBAAG,aAAa,IAAI,GAAG,CAAC,OAAO,CAAE,UAAU,EAAE,MAAM,CAAE,CAAC;YAC7D,IAAI,GAAG;gBAAG,aAAa,IAAI,GAAG,CAAC;YAC/B,IAAI,GAAG;gBAAG,aAAa,IAAI,GAAG,CAAC,OAAO,CAAE,QAAQ,EAAE,MAAM,CAAE,CAAC;YAE3D,IAAI,CAAC,SAAS,GAAG,aAAa,CAAC,OAAO,CAAE,yBAAyB,EAAE,MAAM,CAAE,CAAC;SAC5E;QAED,oCAAQ,GAAR,UAAU,MAAc;YACvB,OAAW,IAAI,CAAC,SAAS,SAAM,IAAI,CAAC,SAAY,CAAC;SACjD;QACF,wBAAC;IAAD,CA9BA,IA8BC;;IC9BD;QAmBC,qBAAa,IAAiB,EAAE,KAAa;;YAC5C,IAAI,CAAC,QAAQ,GAAG,IAAI;kBACjB,IAAI,GAAG,CAAE,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAE;kBAClC,IAAI,GAAG,EAAE,CAAC;YAEb,IAAI,CAAC,KAAK,GAAG,KAAK;kBACf,KAAK;kBACL,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC;YAEtB,IAAI,eAAe,WAAW;gBAAG,MAAM,CAAC,MAAM,CAAE,IAAI,CAAE,CAAC;SACvD;QAWD,6BAAO,GAAP,UAAS,WAAkB,EAAE,KAAc;YAC1C,IAAI,UAAU,CAAE,WAAW,CAAE;gBAC5B,OAAO,IAAI,CAAC,eAAe,CAAE,WAAW,CAAE,CAAC;YAE5C,OAAO,IAAI,CAAC,aAAa,CAAE,WAAW,EAAE,KAAK,CAAE,CAAC;SAChD;QAEO,mCAAa,GAArB,UAAuB,WAAkB,EAAE,KAAqB;YAArB,sBAAA,EAAA,aAAqB;YAC/D,IAAI,KAAK,IAAI,IAAI,CAAC,KAAK,IAAI,UAAU,CAAE,WAAW,CAAE;gBACnD,WAAW,GAAG,IAAI,CAAC,KAAK,GAAG,WAAW,CAAC;YAExC,OAAO,IAAI,WAAW,CAAE,WAAW,CAAE,CAAC;SACtC;QAEO,qCAAe,GAAvB,UAAyB,YAAmB;YAC3C,IAAI,KAAK,GAAqB,IAAI,iBAAiB,CAAE,YAAY,CAAE,CAAC;YAEpE,IAAM,IAAI,GAAuB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAE,KAAK,CAAC,SAAS,CAAE,CAAC;YACtE,IAAI,IAAI,KAAK,KAAK,CAAC;gBAAG,MAAM,IAAI,KAAK,CAAE,kBAAgB,KAAK,CAAC,SAAS,8BAA2B,CAAE,CAAC;YAEpG,IAAI,CAAE,IAAI;gBAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAE,KAAK,CAAC,SAAS,EAAE,IAAI,CAAE,CAAC;YACxD,OAAO,KAAK,CAAC;SACb;QACF,kBAAC;IAAD,CA/DA,IA+DC;;aCrEe,YAAY,CAA0C,OAAS,EAAE,SAAqB;QAArB,0BAAA,EAAA,YAAc,EAAO;QACrG,IAAM,IAAI,GAAK,MAAM,CAAC,MAAM,CAAE,MAAM,CAAC,cAAc,CAAE,OAAO,CAAE,CAAE,CAAC;QAEjE,IAAM,KAAK,GAAS,MAAM;aACxB,MAAM,CAAE,IAAI,EAAE,OAAO,EAAE,SAAS,CAAE,CAAC;QAErC,OAAO,MAAM,CAAC,MAAM,CAAE,KAAK,CAAE,CAAC;IAC/B,CAAC;;ICRD;QAIC,mBAAa,GAAe;YAHnB,UAAK,GAAU,MAAM,CAAC;YAI9B,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;SACf;QAED,4BAAQ,GAAR;YACC,OAAO,UAAS,IAAI,CAAC,GAAM,CAAC;SAC5B;QACF,gBAAC;IAAD,CAXA,IAWC;;ICXD;QAKC,qBAAa,SAAgB,EAAE,GAAe;YAJrC,UAAK,GAAY,QAAQ,CAAC;YAKlC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;YAC3B,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;SACf;QAED,8BAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,YAAW,IAAI,CAAC,SAAS,UAAO,IAAI,CAAC,GAAM,CAAC;SACnD;QACF,kBAAC;IAAD,CAbA,IAaC;;ICMD;QAmBC,mBAAa,IAAyB;;YACrC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;YACpC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;YAEpC,IAAI,eAAe,SAAS;gBAAG,MAAM,CAAC,MAAM,CAAE,IAAI,CAAE,CAAC;SACrD;QAEF,gBAAC;IAAD,CA1BA,IA0BC;;ICtDD;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;;IAEA,IAAI,aAAa,GAAG,SAAS,CAAC,EAAE,CAAC,EAAE;IACnC,IAAI,aAAa,GAAG,MAAM,CAAC,cAAc;IACzC,SAAS,EAAE,SAAS,EAAE,EAAE,EAAE,YAAY,KAAK,IAAI,UAAU,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,EAAE,CAAC;IACpF,QAAQ,UAAU,CAAC,EAAE,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IACnF,IAAI,OAAO,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC/B,CAAC,CAAC;;AAEF,IAAO,SAAS,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE;IAChC,IAAI,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACxB,IAAI,SAAS,EAAE,GAAG,EAAE,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC,EAAE;IAC3C,IAAI,CAAC,CAAC,SAAS,GAAG,CAAC,KAAK,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,SAAS,GAAG,CAAC,CAAC,SAAS,EAAE,IAAI,EAAE,EAAE,CAAC,CAAC;IACzF,CAAC;;AAED,IAAO,IAAI,QAAQ,GAAG,WAAW;IACjC,IAAI,QAAQ,GAAG,MAAM,CAAC,MAAM,IAAI,SAAS,QAAQ,CAAC,CAAC,EAAE;IACrD,QAAQ,KAAK,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;IAC7D,YAAY,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;IAC7B,YAAY,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IACzF,SAAS;IACT,QAAQ,OAAO,CAAC,CAAC;IACjB,MAAK;IACL,IAAI,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IAC3C,CAAC;;IC/BM,IAAM,kBAAkB,GAAK,CAAC,CAAC;AAYtC,aAAgB,YAAY,CAAE,MAAc;QAC3C,IAAI,MAAM,KAAK,KAAK,CAAC;YAAG,OAAO,GAAG,CAAC;QACnC,OAAO,IAAI,CAAC;IACb,CAAC;AAeD,aAAgB,cAAc,CAAE,MAAc,EAAE,KAAa;QAC5D,IAAI,MAAM,KAAK,KAAK,CAAC;YAAG,OAAO,EAAE,CAAC;QAElC,IAAI,KAAK;YAAG,MAAM,IAAI,KAAK,CAAC;QAC5B,OAAO,GAAG,CAAC,MAAM,CAAE,MAAM,CAAE,CAAC;IAC7B,CAAC;AAWD,aAAgB,SAAS,CAAE,MAAyB,EAAE,KAAY;QACjE,IAAI,MAAM,KAAK,KAAK,CAAC;YAAG,OAAO,MAAM,CAAC;QACtC,OAAO,MAAM,GAAG,KAAK,CAAC;IACvB,CAAC;AAYD,aAAgB,uBAAuB,CAAE,EAKxC;YAL0C,kBAAM,EAAE,cAAI,EAAE,oCAAe,EAAE,kBAAM;QAM/E,IAAI,CAAE,MAAM,CAAC,MAAM;YAAG,OAAO,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC;QAEpD,IAAM,gBAAgB,GAAU,YAAY,CAAE,MAAM,CAAE,CAAC;QAEvD,IAAM,YAAY,GAAsB,SAAS,CAAE,MAAM,EAAE,kBAAkB,CAAE,CAAC;QAChF,IAAM,cAAc,GAAY,MAAM,CAAC,GAAG,CAAE,UAAE,KAAK,EAAE,KAAK,EAAE,KAAK;YAChE,IAAM,QAAQ,GAAU,KAAK,CAAC,QAAQ,CAAE,YAAY,CAAE,CAAC;YAGvD,IAAI,CAAE,eAAe,IAAI,KAAK,KAAK,KAAK,CAAC,MAAM,GAAG,CAAC;gBAAG,OAAO,QAAQ,CAAC;YAGtE,IAAI,eAAe,KAAK,GAAG,IAAI,KAAK,CAAC,KAAK,KAAK,SAAS;gBAAG,OAAO,QAAQ,CAAC;YAE3E,OAAO,QAAQ,GAAG,eAAe,CAAC;SAClC,CAAE,CAAC;QAGJ,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,IAAI,CAAE,cAAc,CAAE,CAAC,CAAE,CAAC,QAAQ,CAAE,IAAI,CAAE;YACxE,OAAO,IAAI,CAAC,IAAI,GAAG,GAAG,GAAG,cAAc,GAAG,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC;QAG5D,IAAM,YAAY,GAAU,cAAc,CAAE,YAAY,CAAE,CAAC;QAC3D,IAAM,SAAS,GAAU,cAAc;aACrC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,YAAY,GAAG,CAAC,GAAA,CAAE;aAC5B,IAAI,CAAE,gBAAgB,CAAE,CAAC;QAE3B,IAAM,MAAM,GAAU,cAAc,CAAE,MAAM,CAAE,CAAC;QAC/C,OAAO,IAAI,CAAC,IAAI;YACf,gBAAgB,GAAG,SAAS,GAAG,gBAAgB;YAC/C,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;;IC/FD;QAKC;YAJA,UAAK,GAAkB,cAAc,CAAC;YAKrC,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;SACnB;QAGD,sCAAU,GAAV;YAAY,kBAA0B;iBAA1B,UAA0B,EAA1B,qBAA0B,EAA1B,IAA0B;gBAA1B,6BAA0B;;;YACrC,CAAA,KAAA,IAAI,CAAC,QAAQ,EAAC,IAAI,WAAK,QAAQ,EAAG;YAClC,OAAO,IAAI,CAAC;SACZ;QAGD,oCAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,uBAAuB,CAAE;gBAC/B,MAAM,QAAA;gBACN,IAAI,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE;gBAC/B,eAAe,EAAE,GAAG;gBACpB,MAAM,EAAE,IAAI,CAAC,QAAQ;aACrB,CAAE,CAAC;SACJ;QACF,wBAAC;IAAD,CAxBA,IAwBC;;ICzBD;QAKC;YAJA,UAAK,GAAW,OAAO,CAAC;YAKvB,IAAI,CAAC,YAAY,GAAG,IAAI,iBAAiB,EAAE,CAAC;SAC5C;QAGD,6BAAQ,GAAR,UAAU,MAAc;YACvB,IAAM,UAAU,GAAU,MAAM,KAAK,KAAK,CAAC,GAAG,EAAE,GAAG,QAAQ,CAAC;YAC5D,OAAO,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAE,MAAM,CAAE,CAAC;SACzD;QACF,iBAAC;IAAD,CAdA,IAcC;;ICbD;QAMC;YACC,IAAI,CAAC,KAAK,GAAG,IAAI,UAAU,EAAE,CAAC;YAC9B,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;SACpB;QAGD,2CAAU,GAAV;YAAY,kBAA0B;iBAA1B,UAA0B,EAA1B,qBAA0B,EAA1B,IAA0B;gBAA1B,6BAA0B;;;YACrC,CAAA,KAAA,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,QAAQ,EAAC,IAAI,WAAK,QAAQ,EAAG;YACrD,OAAO,IAAI,CAAC;SACZ;QAED,4CAAW,GAAX;YAAa,kBAAmC;iBAAnC,UAAmC,EAAnC,qBAAmC,EAAnC,IAAmC;gBAAnC,6BAAmC;;;YAC/C,CAAA,KAAA,IAAI,CAAC,SAAS,EAAC,IAAI,WAAK,QAAQ,EAAG;YACnC,OAAO,IAAI,CAAC;SACZ;QAIF,6BAAC;IAAD,CAxBA,IAwBC;;ICxBD;QAA8BA,4BAAsB;QAKnD;YAAA,YACC,iBAAO,SAGP;YARQ,WAAK,GAAS,KAAK,CAAC;YAO5B,KAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;;SACnB;QAGD,2BAAQ,GAAR,UAAU,MAAc;YACvB,IAAI,KAAK,GAAU,KAAK,CAAC;YACzB,IAAM,SAAS,GAAU,YAAY,CAAE,MAAM,CAAE,CAAC;YAEhD,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM;gBAAG,KAAK,IAAI,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,SAAS,CAAE,CAAC;YAEhF,KAAK,IAAI,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE,MAAM,CAAE,CAAC;YAEnD,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM;gBAAG,KAAK,IAAI,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAE,SAAS,CAAE,CAAC;YAElF,OAAO,KAAK,CAAC;SACb;QACF,eAAC;IAAD,CAAC,CAxB6B,sBAAsB,GAwBnD;;ICzBD;QAMC,mBAAa,MAAe,EAAE,KAAqB;YAArB,sBAAA,EAAA,aAAqB;YAL1C,UAAK,GAAU,MAAM,CAAC;YAM9B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;YACrB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;SACnB;QAED,4BAAQ,GAAR,UAAU,MAAc;YACvB,IAAI,GAAG,GAAU,OAAO,CAAC;YAEzB,IAAI,IAAI,CAAC,KAAK;gBAAG,GAAG,IAAI,QAAQ,CAAC;YAEjC,OAAO,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;SACzB;QACF,gBAAC;IAAD,CAlBA,IAkBC;;ICnBD;QAAgDA,qCAAsB;QAMrE,2BAAuB,QAAgC;YAAvD,YACC,iBAAO,SAIP;YAFA,KAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;YACzB,KAAI,CAAC,SAAS,GAAG,EAAE,CAAC;;SACpB;QAGD,uCAAW,GAAX;YAAa,mBAA4B;iBAA5B,UAA4B,EAA5B,qBAA4B,EAA5B,IAA4B;gBAA5B,8BAA4B;;;YACxC,CAAA,KAAA,IAAI,CAAC,SAAS,EAAC,IAAI,WAAK,SAAS,EAAG;YACpC,OAAO,IAAI,CAAC;SACZ;QAGD,oCAAQ,GAAR,UAAU,MAAc;YACvB,IAAI,KAAK,GAAU,QAAQ,CAAC;YAE5B,IAAI,IAAI,CAAC,QAAQ;gBAAG,KAAK,IAAI,MAAK,IAAI,CAAC,QAAW,CAAC;YAEnD,KAAK,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM;gBAC7B,MAAK,IAAI,CAAC,SAAS,CAAC,IAAI,CAAE,GAAG,CAAK;gBAClC,IAAI,CAAC;YAEN,OAAO,KAAK,CAAC;SACb;QACF,wBAAC;IAAD,CAAC,CA/B+C,sBAAsB,GA+BrE;;IClCD;QAAoCA,kCAAiB;QAKpD,wBAAa,QAAgC,EAAE,MAAmB;YAAlE,YACC,kBAAO,QAAQ,CAAE,SAGjB;YARQ,WAAK,GAAe,WAAW,CAAC;YAOxC,KAAI,CAAC,MAAM,GAAG,MAAM,CAAC;;SACrB;QAGD,iCAAQ,GAAR,UAAU,MAAc;YACvB,IAAM,SAAS,GAAsB,SAAS,CAAE,MAAM,EAAE,kBAAkB,CAAE,CAAC;YAC7E,IAAM,SAAS,GAAU,cAAc,CAAE,SAAS,CAAE,CAAC;YACrD,IAAM,SAAS,GAAU,YAAY,CAAE,MAAM,CAAE,CAAC;YAEhD,IAAI,KAAK,GAAU,iBAAM,QAAQ,YAAE,MAAM,CAAE,GAAG,SAAS;gBACtD,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE,SAAS,CAAE,CAAC;YAE9C,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM;gBAAG,KAAK,IAAI,SAAS,GAAG,IAAI,CAAC,SAAS;qBAC7D,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,SAAS,GAAG,CAAC,GAAA,CAAE;qBACzB,IAAI,CAAE,SAAS,CAAE,CAAC;YAEpB,IAAI,IAAI,CAAC,MAAM;gBAAG,KAAK,IAAI,SAAS,GAAG,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC;YAE/D,IAAM,MAAM,GAAU,cAAc,CAAE,MAAM,CAAE,CAAC;YAC/C,OAAO,GAAG,GAAG,SAAS,GAAG,SAAS;gBACjC,KAAK,GAAG,SAAS;gBACjB,MAAM,GAAG,GAAG,CAAC;SACd;QACF,qBAAC;IAAD,CAAC,CA/BmC,iBAAiB,GA+BpD;;IC/BD,IAAM,UAAU,GAAU,kXAAkX,CAAC;IAU7Y;QAIC,uBAAa,IAAW;YAHf,UAAK,GAAc,UAAU,CAAC;YAItC,IAAI,CAAE,UAAU,CAAC,IAAI,CAAE,IAAI,CAAE;gBAAG,MAAM,IAAI,KAAK,CAAE,uBAAuB,CAAE,CAAC;YAE3E,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;SACjB;QAED,gCAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,MAAK,IAAI,CAAC,IAAO,CAAC;SACzB;QACF,oBAAC;IAAD,CAbA,IAaC;;ICpBD;QAKC,oBAAa,YAAmB;YAJvB,UAAK,GAAW,OAAO,CAAC;YAKhC,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;SACjC;QAGD,6BAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,cAAa,IAAI,CAAC,YAAe,CAAC;SACzC;QACF,iBAAC;IAAD,CAbA,IAaC;;ICbD;QAKC,qBAAa,YAAmB;YAJvB,UAAK,GAAY,QAAQ,CAAC;YAKlC,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;SACjC;QAGD,8BAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,YAAW,IAAI,CAAC,YAAe,CAAC;SACvC;QACF,kBAAC;IAAD,CAbA,IAaC;;ICZD;QAKC,oBAAa,SAAgC,EAAE,IAAoB;YAJ1D,UAAK,GAAW,OAAO,CAAC;YAKhC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;YAC3B,IAAI,IAAI;gBAAG,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;SAC5B;QAED,6BAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,WAAW,IAAI,IAAI,CAAC,IAAI;gBAC1B,IAAI,CAAC,IAAI,UAAO,IAAI,CAAC,SAAS,OAAK;gBACvC,KAAI,IAAI,CAAC,SAAY,CAAC,CAAC;SACxB;QACF,iBAAC;IAAD,CAfA,IAeC;;IChBD;QAIC,oBAAa,KAAY;YAHhB,UAAK,GAAW,OAAO,CAAC;YAIhC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;SACnB;QAED,6BAAQ,GAAR;YACC,OAAO,WAAU,IAAI,CAAC,KAAQ,CAAC;SAC/B;QACF,iBAAC;IAAD,CAXA,IAWC;;aCVe,8BAA8B,CAAsE,SAAW,EAAE,KAA2B;QAC3J,IAAM,WAAW,GAA+B,SAAS,CAAC,WAAW,CAAC,KAAK,KAAK,OAAO;YACtF,eAAe,CAAE,SAAS,CAAC,WAAW,EAAE,KAAK,CAAE;YAC/C,gBAAgB,CAAE,SAAS,CAAC,WAAW,EAAE,KAAK,CAAE,CAAC;QAElD,OAAO,YAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAgB,CAAE,CAAC;IACjE,CAAC;IAED,SAAS,gBAAgB,CAA0D,WAAa,EAAE,KAA2B;QAC5H,IAAM,SAAS,GAA2B,WAAW,CAAC,SAAS,CAAC,MAAM,CAAE,KAAK,CAAE,CAAC;QAChF,OAAO,YAAY,CAAE,WAAW,EAAE,EAAE,SAAS,WAAA,EAAgB,CAAE,CAAC;IACjE,CAAC;IAED,SAAS,eAAe,CAAa,UAAuC,EAAE,KAA2B;QACxG,IAAM,WAAW,GAAoB,gBAAgB,CAAE,UAAU,CAAC,WAAW,EAAE,KAAK,CAAE,CAAC;QACvF,OAAO,YAAY,CAAE,UAAU,EAAE,EAAE,WAAW,aAAA,EAAE,CAAE,CAAC;IACpD,CAAC;;ICYD,SAAS,UAAU,CAAwF,cAA4B,EAAE,SAAW;QACnJ,OAAO,UAAE,KAAY;YACpB,IAAM,KAAK,GAAc,IAAI,UAAU,CAAE,KAAK,CAAE,CAAC;YAEjD,IAAM,YAAY,GAAK,8BAA8B,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;YAC1E,OAAO,cAAc,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SAC1C,CAAC;IACH,CAAC;AAMD,IAAO,IAAM,WAAW,GAgBpB;QACH,UAAU,YAAE,cAAc,EAAE,SAAS,EAAE,MAAM;YAC5C,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,KAAK,EAAE,UAAU,CAAE,cAAc,EAAE,SAAS,CAAE;aAC9C,CAAE,CAAC;SACJ;KACD,CAAC;;IChEF;QAIC,qBAAa,KAAY;YAHhB,UAAK,GAAY,QAAQ,CAAC;YAIlC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;SACnB;QAGD,8BAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,YAAW,IAAI,CAAC,KAAQ,CAAC;SAChC;QACF,kBAAC;IAAD,CAZA,IAYC;;ICgBD,SAAS,WAAW,CAAwF,cAA4B,EAAE,SAAW;QACpJ,OAAO,UAAE,MAAa;YACrB,IAAM,KAAK,GAAe,IAAI,WAAW,CAAE,MAAM,CAAE,CAAC;YAEpD,IAAM,YAAY,GAAK,8BAA8B,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;YAC1E,OAAO,cAAc,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SAC1C,CAAC;IACH,CAAC;AAKD,IAAO,IAAM,YAAY,GAgBrB;QACH,UAAU,EAAV,UAAoH,cAA4B,EAAE,SAAW,EAAE,MAAQ;YACtK,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,MAAM,EAAE,WAAW,CAAE,cAAc,EAAE,SAAS,CAAE;aAChD,CAAE,CAAC;SACJ;KACD,CAAC;;aCpDc,WAAW,CAAE,GAAU;QACtC,IAAI,UAAU,CAAE,GAAG,CAAE;YAAG,OAAO,IAAI,iBAAiB,CAAE,GAAG,CAAE,CAAC;QAC5D,OAAO,IAAI,WAAW,CAAE,GAAG,CAAE,CAAC;IAC/B,CAAC;;ICXD;QAKC,sBAAa,KAA+B;YAJnC,UAAK,GAAa,SAAS,CAAC;YAKpC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;SACnB;QAED,+BAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,IAAI,CAAC,SAAS,CAAE,IAAI,CAAC,KAAK,CAAE,CAAC;SACpC;QACF,mBAAC;IAAD,CAZA,IAYC;;ICZD;QAAqCA,mCAAY;QAOhD,yBAAa,KAAY,EAAE,cAAwC;YAAnE,YACC,kBAAO,KAAK,CAAE,SAUd;YARA,IAAI,CAAE,cAAc;6BAAU;YAG9B,IAAI,cAAc,CAAC,KAAK,KAAK,UAAU,EAAG;gBACzC,KAAI,CAAC,QAAQ,GAAG,cAAc,CAAC;aAC/B;iBAAM;gBACN,KAAI,CAAC,IAAI,GAAG,cAAc,CAAC;aAC3B;;SACD;QAED,kCAAQ,GAAR,UAAU,MAAc;YACvB,IAAM,KAAK,GAAU,iBAAM,QAAQ,WAAE,CAAC;YAEtC,IAAI,IAAI,CAAC,QAAQ;gBAAG,OAAO,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC;YACjD,IAAI,IAAI,CAAC,IAAI;gBAAG,OAAW,KAAK,UAAO,IAAI,CAAC,IAAO,CAAC;YAEpD,OAAO,KAAK,CAAC;SACb;QAEF,sBAAC;IAAD,CAAC,CA7BoC,YAAY,GA6BhD;;ICvCM,IAAM,GAAG,GA+BZ;QACH,SAAS,EAAE,mCAAmC;QAE9C,OAAO,EAAE,0CAA0C;QACnD,IAAI,EAAE,uCAAuC;QAC7C,IAAI,EAAE,uCAAuC;QAC7C,QAAQ,EAAE,2CAA2C;QACrD,OAAO,EAAE,0CAA0C;QACnD,MAAM,EAAE,yCAAyC;QACjD,QAAQ,EAAE,2CAA2C;QACrD,KAAK,EAAE,wCAAwC;QAC/C,IAAI,EAAE,uCAAuC;QAC7C,MAAM,EAAE,yCAAyC;QACjD,SAAS,EAAE,4CAA4C;QACvD,KAAK,EAAE,wCAAwC;QAC/C,UAAU,EAAE,6CAA6C;QACzD,GAAG,EAAE,sCAAsC;QAC3C,OAAO,EAAE,0CAA0C;QACnD,IAAI,EAAE,uCAAuC;QAC7C,eAAe,EAAE,kDAAkD;QACnE,kBAAkB,EAAE,qDAAqD;QACzE,kBAAkB,EAAE,qDAAqD;QACzE,MAAM,EAAE,yCAAyC;QACjD,eAAe,EAAE,kDAAkD;QACnE,KAAK,EAAE,wCAAwC;QAC/C,MAAM,EAAE,yCAAyC;QACjD,IAAI,EAAE,uCAAuC;QAC7C,YAAY,EAAE,+CAA+C;QAC7D,WAAW,EAAE,8CAA8C;QAC3D,YAAY,EAAE,+CAA+C;QAC7D,aAAa,EAAE,gDAAgD;KAC/D,CAAC;;aC9Cc,YAAY,CAAE,KAAqE;QAClG,IAAI,KAAK,YAAY,IAAI;YACxB,OAAO,IAAI,eAAe,CAAE,KAAK,CAAC,WAAW,EAAE,EAAE,WAAW,CAAE,GAAG,CAAC,QAAQ,CAAE,CAAE,CAAC;QAEhF,IAAI,OAAO,KAAK,KAAK,QAAQ;YAC5B,OAAO,KAAK,CAAC,UAAU,EAAE,CAAC;QAE3B,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAG;YAC/B,IAAI,KAAK,KAAK,OAAO;gBAAG,OAAO,KAAK,CAAC;YACrC,OAAO,IAAI,YAAY,CAAE,KAAK,CAAE,CAAC;SACjC;QAED,OAAO,IAAI,YAAY,CAAE,KAAK,CAAE,CAAC;IAClC,CAAC;;ICfD;QAMC;YALS,UAAK,GAAY,QAAQ,CAAC;YAMlC,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;YACpB,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;SACjB;QAED,kCAAY,GAAZ;YAAc,mBAA4B;iBAA5B,UAA4B,EAA5B,qBAA4B,EAA5B,IAA4B;gBAA5B,8BAA4B;;;YACzC,CAAA,KAAA,IAAI,CAAC,SAAS,EAAC,IAAI,WAAK,SAAS,EAAG;YACpC,OAAO,IAAI,CAAC;SACZ;QAED,+BAAS,GAAT;YAAW,gBAA+C;iBAA/C,UAA+C,EAA/C,qBAA+C,EAA/C,IAA+C;gBAA/C,2BAA+C;;YACzD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,MAAM,CAAE,CAAC;YAC3B,OAAO,IAAI,CAAC;SACZ;QAGD,8BAAQ,GAAR,UAAU,MAAc;YACvB,IAAM,SAAS,GAAU,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAEjD,IAAM,MAAM,GAAU,IAAI,CAAC,aAAa,CAAE,MAAM,CAAE,CAAC;YACnD,OAAO,YAAW,SAAS,SAAM,MAAS,CAAC;SAC3C;QAEO,sCAAgB,GAAxB;YACC,IAAI,CAAE,IAAI,CAAC,SAAS,CAAC,MAAM;gBAAG,OAAO,IAAI,CAAC;YAE1C,IAAM,SAAS,GAAU,IAAI,CAAC,SAAS,CAAC,IAAI,CAAE,GAAG,CAAE,CAAC;YACpD,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC;gBAAG,OAAO,SAAS,CAAC;YAEnD,OAAO,OAAM,SAAS,OAAK,CAAC;SAC5B;QAEO,mCAAa,GAArB,UAAuB,MAAc;YACpC,IAAI,CAAE,IAAI,CAAC,MAAM,CAAC,MAAM;gBAAG,OAAO,IAAI,CAAC;YAEvC,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,KAAK,CAAC,EAAG;gBACjC,IAAM,MAAM,GAAU,IAAI,CAAC,MAAM;qBAC/B,MAAM,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,MAAM,GAAA,CAAE;qBACvB,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAE,CAAC,CAAE,GAAA,CAAE;qBAClB,IAAI,CAAE,GAAG,CAAE,CAAC;gBAEd,IAAI,CAAE,MAAM;oBAAG,OAAO,IAAI,CAAC;gBAC3B,OAAO,IAAI,GAAG,MAAM,GAAG,IAAI,CAAC;aAC5B;YAED,IAAM,SAAS,GAAU,cAAc,CAAE,MAAM,EAAE,kBAAkB,CAAE,CAAC;YACtE,IAAM,SAAS,GAAU,YAAY,CAAE,MAAM,CAAE,CAAC;YAChD,IAAM,MAAM,GAAU,cAAc,CAAE,MAAM,CAAE,CAAC;YAC/C,OAAO,GAAG,GAAG,SAAS;gBACrB,IAAI,CAAC,MAAM;qBACT,GAAG,CAAE,UAAA,MAAM;oBACX,IAAM,SAAS,GAAU,MAAM,CAAC,MAAM;wBACrC,OAAM,MAAM,CAAC,IAAI,CAAE,GAAG,CAAE,OAAK,GAAG,IAAI,CAAC;oBACtC,OAAO,SAAS,GAAG,SAAS,CAAC;iBAC7B,CAAE;qBACF,IAAI,CAAE,SAAS,CAAE,GAAG,SAAS;gBAC/B,MAAM,GAAG,GAAG,CAAC;SACd;QACF,kBAAC;IAAD,CAhEA,IAgEC;;ICFD,SAAS,mBAAmB,CAAE,mBAAsC;QACnE,IAAM,SAAS,GAAY,KAAK,CAAC,OAAO,CAAE,mBAAmB,CAAE,GAAG,mBAAmB,GAAG,CAAE,mBAAmB,CAAE,CAAC;QAChH,OAAO,SAAS,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,IAAI,aAAa,CAAE,CAAC,CAAE,GAAA,CAAE,CAAC;IACrD,CAAC;IAED,SAAS,mBAAmB,CAAE,eAA+B,EAAE,WAAuB,EAAE,QAAgB;QACvG,IAAI,SAAS,GAAkC,OAAO,eAAe,KAAK,UAAU;YACnF,eAAe,CAAE,cAAc,CAAC,MAAM,CAAE,WAAW,CAAE,CAAE;YACvD,eAAe,CAAC;QAGjB,IAAI,CAAE,KAAK,CAAC,OAAO,CAAE,SAAS,CAAE;YAC/B,OAAO,CAAE,CAAE,SAAS,CAAE,CAAE,CAAC;QAE1B,IAAI,QAAQ;YACX,SAAS,CAAC,GAAG,CAAE,UAAA,KAAK,IAAI,OAAA,CAAE,KAAK,CAAE,GAAA,CAAE,CAAC;QAIrC,IAAI,SAAS,CAAC,IAAI,CAAE,KAAK,CAAC,OAAO,CAAE;YAClC,OAAO,SAAuB,CAAC;QAEhC,OAAO,CAAE,SAAqB,CAAE,CAAC;IAClC,CAAC;IAaD,SAAS,cAAc,CAA4E,cAA4B,EAAE,SAAW;QAC3I,OAAO,UAAE,mBAAsC,EAAE,eAA+B;YAC/E,IAAM,KAAK,GAAe,IAAI,WAAW,EAAE,CAAC;YAE5C,IAAM,SAAS,GAAmB,mBAAmB,CAAE,mBAAmB,CAAE,CAAC;YAC7E,KAAK,CAAC,YAAY,OAAlB,KAAK,EAAkB,SAAS,EAAG;YAEnC,IAAM,QAAQ,GAAW,CAAE,KAAK,CAAC,OAAO,CAAE,mBAAmB,CAAE,CAAC;YAChE,IAAM,WAAW,GAAe,IAAI,WAAW,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;YACzE,IAAM,MAAM,GAAc,mBAAmB,CAAE,eAAe,EAAE,WAAW,EAAE,QAAQ,CAAE,CAAC;YACxF,MAAM,CAAC,OAAO,CAAE,UAAE,SAAS,IAAM,OAAA,KAAK,CAAC,SAAS,OAAf,KAAK,EAAe,SAAS,CAAC,GAAG,CAAE,YAAY,CAAE,IAAE,CAAE,CAAC;YAEvF,IAAM,WAAW,GAAG,YAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAE,CAAC;YAC7E,IAAM,YAAY,GAAG,YAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAE,WAAW,aAAA,EAAgB,CAAE,CAAC;YAC3F,OAAO,cAAc,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SAC1C,CAAA;IACF,CAAC;AAMD,IAAO,IAAM,YAAY,GAgBrB;QACH,UAAU,EAAV,UAAwG,cAA4B,EAAE,SAAW,EAAE,MAAQ;YAC1J,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,MAAM,EAAE,cAAc,CAAE,cAAc,EAAE,SAAS,CAAE;aACnD,CAAE,CAAC;SACJ;KACD,CAAC;;IC7FF,SAAS,gBAAgB,CAA4D,aAAqD;QACzI,IAAM,mBAAmB,GAAyD,YAAY;aAC5F,UAAU,CAAC,IAAI,CAAE,IAAI,EAAE,aAAa,CAAE,CAAC;QAEzC,OAAO,UAAE,UAAU,EAAE,OAAO,IAAM,OAAA,WAAW;aAC3C,UAAU,CAAE,OAAO,CAAC,UAAU,CAAE,mBAAmB,EAAE,aAAa,CAAE,EAAE,UAAU,EAAE,OAAO,CAAE,GAAA,CAAC;IAC/F,CAAC;IAED,SAAS,iBAAiB,CAA4D,aAAqD;QAC1I,IAAM,kBAAkB,GAAwD,WAAW;aACzF,UAAU,CAAC,IAAI,CAAE,IAAI,EAAE,aAAa,CAAE,CAAC;QAEzC,OAAO,UAAE,UAAU,EAAE,OAAO,IAAM,OAAA,YAAY;aAC5C,UAAU,CAAE,OAAO,CAAC,UAAU,CAAE,aAAa,EAAE,kBAAkB,CAAE,EAAE,UAAU,EAAE,OAAO,CAAE,GAAA,CAAC;IAC9F,CAAC;AAMD,IAAO,IAAM,iBAAiB,GAgB1B;QACH,UAAU,EAAV,UAA0H,cAA4B,EAAE,SAAW,EAAE,MAAQ;YAC5K,IAAM,aAAa,GAA+B,YAAY;iBAC5D,UAAU,CAAC,IAAI,CAAE,IAAI,EAAE,cAAc,CAAE,CAAC;YAE1C,IAAM,uBAAuB,GAAG,OAAO,CAAC,UAAU,CAAE,cAAc,EAAE,aAAa,CAAE,CAAC;YAEpF,OAAO,OAAO,CAAC,UAAU,CACxB,gBAAgB,CAAQ,uBAAuB,CAAE,EACjD,iBAAiB,CAAQ,uBAAuB,CAAE,EAClD,aAAa,CACb,CAAE,SAAS,EAAE,MAAM,CAAE,CAAC;SACvB;KACD,CAAC;;ICtEF,SAAS,YAAY,CAA8F,cAA4B,EAAE,SAAW;QAC3J,OAAO,UAAE,YAAmB;YAC3B,IAAM,KAAK,GAAc,IAAI,UAAU,CAAE,YAAY,CAAE,CAAC;YACxD,IAAM,YAAY,GAAG,8BAA8B,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;YAExE,IAAM,iBAAiB,GAAwB,iBAAiB,CAAC,UAAU,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;YAChH,OAAO,cAAc,CAAE,YAAY,EAAE,iBAAiB,CAAE,CAAC;SACzD,CAAC;IACH,CAAC;AAMD,IAAO,IAAM,WAAW,GAgBpB;QACH,UAAU,EAAV,UAA0H,cAA2C,EAAE,SAAW,EAAE,MAAQ;YAC3L,OAAO,iBAAiB,CAAC,UAAU,CAAE,cAAc,EAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBACtF,OAAO,EAAE,YAAY,CAAE,cAAc,EAAE,SAAS,CAAE;aAClD,CAAE,CAAE,CAAC;SACN;KACD,CAAC;;ICnCF,SAAS,WAAW,CAA8F,cAA4B,EAAE,SAAW;QAC1J,OAAO,UAAE,YAAmB;YAC3B,IAAM,KAAK,GAAe,IAAI,WAAW,CAAE,YAAY,CAAE,CAAC;YAC1D,IAAM,YAAY,GAAG,8BAA8B,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;YAExE,IAAM,WAAW,GAAkB,WAAW,CAAC,UAAU,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;YAC9F,OAAO,cAAc,CAAE,YAAY,EAAE,WAAW,CAAE,CAAC;SACnD,CAAA;IACF,CAAC;AAMD,IAAO,IAAM,YAAY,GAgBrB;QACH,UAAU,EAAV,UAA0H,cAA2C,EAAE,SAAW,EAAE,MAAQ;YAC3L,OAAO,WAAW,CAAC,UAAU,CAAE,cAAc,EAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAChF,MAAM,EAAE,WAAW,CAAE,cAAc,EAAE,SAAS,CAAE;aAChD,CAAE,CAAE,CAAC;SACN;KACD,CAAC;;ICtCF,SAAS,YAAY,CAA8F,cAA4B,EAAE,SAAW;QAC3J,OAAO,UAAE,YAAmB;YAC3B,IAAM,KAAK,GAAc,IAAI,UAAU,CAAE,YAAY,CAAE,CAAC;YACxD,IAAM,YAAY,GAAG,8BAA8B,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;YAExE,IAAM,YAAY,GAAmB,YAAY,CAAC,UAAU,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;YACjG,OAAO,cAAc,CAAE,YAAY,EAAE,YAAY,CAAE,CAAC;SACpD,CAAA;IACF,CAAC;AAMD,IAAO,IAAM,WAAW,GAgBpB;QACH,UAAU,EAAV,UAA0H,cAA2C,EAAE,SAAW,EAAE,MAAQ;YAC3L,OAAO,YAAY,CAAC,UAAU,CAAE,cAAc,EAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBACjF,OAAO,EAAE,YAAY,CAAE,cAAc,EAAE,SAAS,CAAE;aAClD,CAAE,CAAE,CAAC;SACN;KACD,CAAC;;IC7DK,IAAM,OAAO,GAchB;QACH,UAAU,EAAV,UAA8E,SAAW,EAAE,MAAQ;YAClG,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,UAAU,EAAE,cAAM,OAAA,SAAS,CAAC,WAAW,GAAA;aACvC,CAAE,CAAC;SACJ;KACD,CAAC;;ICZK,IAAM,aAAa,GActB;QACH,UAAU,EAAV,UAAmE,SAAW,EAAE,MAAQ;YACvF,OAAO,OAAO,CAAC,UAAU,CACxB,OAAO,CAAC,UAAU,EAClB,YAAY,CAAC,UAAU,CACvB,CAAE,SAAS,EAAE,MAAM,CAAE,CAAC;SACvB;KACD,CAAC;;ICPF,SAAS,UAAU,CAAE,SAAmC;QACvD,OAAO,UAAE,QAA4B;;YACpC,IAAM,KAAK,GAAc,IAAI,UAAU,EAAE,CAAC;YAC1C,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAE,QAAQ,CAAE,GAAG,QAAQ,GAAG,CAAE,QAAQ,CAAE,CAAC;YAC/D,CAAA,KAAA,KAAK,CAAC,YAAY,CAAC,QAAQ,EAAC,IAAI,WAAK,QAAQ,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,UAAU,EAAE,GAAA,CAAE,EAAG;YAE3E,IAAM,WAAW,GAAkB,YAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,KAAK,OAAA,EAAE,CAAE,CAAC;YACpF,IAAM,YAAY,GAAG,YAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAE,CAAE,CAAC;YAEhE,IAAM,WAAW,GAA8B,WAAW,CAAC,UAAU,CAAE,aAAa,CAAC,UAAU,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;YACpH,OAAO,aAAa,CAAC,UAAU,CAAE,YAAY,EAAE,WAAW,CAAE,CAAC;SAC7D,CAAC;IACH,CAAC;AAMD,IAAO,IAAM,YAAY,GAerB;QACH,UAAU,EAAV,UAAmE,SAAW,EAAE,MAAQ;YACvF,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,KAAK,EAAE,UAAU,CAAE,SAAS,CAAE;aAC9B,CAAE,CAAC;SACJ;KACD,CAAC;;ICmBF,SAAS,WAAW,CAAE,SAA8B,EAAE,QAAgC;QACrF,OAAO;YAAE,mBAAqB;iBAArB,UAAqB,EAArB,qBAAqB,EAArB,IAAqB;gBAArB,8BAAqB;;YAC7B,IAAM,WAAW,GAAkB,IAAI,cAAc,CAAE,QAAQ,CAAE,CAAC;YAClE,IAAI,SAAS,CAAC,MAAM;gBAAG,WAAW,CAAC,WAAW,OAAvB,WAAW,EAAiB,SAAS,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,IAAI,aAAa,CAAE,CAAC,CAAE,GAAA,CAAE,EAAG;YAElG,IAAM,YAAY,GAA6B,IAAI,SAAS,CAAE;gBAC7D,WAAW,EAAE,SAAS,CAAC,WAAW;gBAClC,WAAW,aAAA;aACX,CAAE,CAAC;YACJ,OAAO,YAAY,CAAC,UAAU,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SACnD,CAAC;IACH,CAAC;AAMD,IAAO,IAAM,gBAAgB,GAczB;QACH,UAAU,EAAV,UAA8B,SAA8B,EAAE,MAAQ;YACrE,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,MAAM,EAAE,WAAW,CAAE,SAAS,CAAE;gBAChC,cAAc,EAAE,WAAW,CAAE,SAAS,EAAE,UAAU,CAAE;gBACpD,aAAa,EAAE,WAAW,CAAE,SAAS,EAAE,SAAS,CAAE;gBAClD,SAAS,EAAE,cAAM,OAAA,WAAW,CAAE,SAAS,CAAE,EAAE,GAAA;gBAC3C,iBAAiB,EAAE,cAAM,OAAA,WAAW,CAAE,SAAS,EAAE,UAAU,CAAE,EAAE,GAAA;gBAC/D,gBAAgB,EAAE,cAAM,OAAA,WAAW,CAAE,SAAS,EAAE,SAAS,CAAE,EAAE,GAAA;aAC7D,CAAE,CAAC;SACJ;KACD,CAAC;;ICjIF;QAMC,mBAAa,UAAiB,EAAE,QAAsB;YAL7C,UAAK,GAAU,MAAM,CAAC;YAM9B,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;YAC7B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;SACzB;QAGD,4BAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,UAAS,IAAI,CAAC,UAAU,YAAS,IAAI,CAAC,QAAQ,MAAI,CAAC;SAC1D;QACF,gBAAC;IAAD,CAfA,IAeC;;IChBD;QAIC,qBAAa,UAAiB;YAHrB,UAAK,GAAY,QAAQ,CAAC;YAIlC,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;SAC7B;QAED,8BAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,aAAY,IAAI,CAAC,UAAU,OAAK,CAAC;SACxC;QACF,kBAAC;IAAD,CAXA,IAWC;;ICRD;QAMC,oBAAa,KAAwB;YAL5B,UAAK,GAAW,OAAO,CAAC;YAMhC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;YACnB,IAAI,CAAC,YAAY,GAAG,IAAI,iBAAiB,EAAE,CAAC;SAC5C;QAGD,+BAAU,GAAV;YAAY,iBAAyB;iBAAzB,UAAyB,EAAzB,qBAAyB,EAAzB,IAAyB;gBAAzB,4BAAyB;;;YACpC,CAAA,KAAA,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAC,IAAI,WAAK,OAAO,EAAG;YAC9C,OAAO,IAAI,CAAC;SACZ;QAGD,6BAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,WAAU,IAAI,CAAC,KAAK,SAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAE,MAAM,CAAK,CAAC;SACzE;QACF,iBAAC;IAAD,CArBA,IAqBC;;ICvBD;QAKC;YAJS,UAAK,GAAkB,cAAc,CAAC;YAK9C,IAAI,CAAC,YAAY,GAAG,IAAI,iBAAiB,EAAE,CAAC;SAC5C;QAGD,oCAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,WAAU,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAE,MAAM,CAAK,CAAC;SACzD;QACF,wBAAC;IAAD,CAbA,IAaC;;ICZD;QAKC;YAJS,UAAK,GAAc,UAAU,CAAC;YAKtC,IAAI,CAAC,YAAY,GAAG,IAAI,iBAAiB,EAAE,CAAC;SAC5C;QAGD,kCAAU,GAAV;YAAY,iBAAyB;iBAAzB,UAAyB,EAAzB,qBAAyB,EAAzB,IAAyB;gBAAzB,4BAAyB;;;YACpC,CAAA,KAAA,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAC,IAAI,WAAK,OAAO,EAAG;YAC9C,OAAO,IAAI,CAAC;SACZ;QAGD,gCAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,cAAa,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAE,MAAM,CAAK,CAAC;SAC5D;QACF,oBAAC;IAAD,CAnBA,IAmBC;;ICnBD;QAOC,6BAAa,QAA2B,EAAE,QAAkB;YANnD,UAAK,GAAoB,gBAAgB,CAAC;YAOlD,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;YACzB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;YACzB,IAAI,CAAC,YAAY,GAAG,IAAI,iBAAiB,EAAE,CAAC;SAC5C;QAGD,sCAAQ,GAAR,UAAU,MAAc;YACvB,IAAI,KAAK,GAAU,UAAU,CAAC;YAE9B,IAAI,IAAI,CAAC,QAAQ;gBAAG,KAAK,IAAI,SAAS,CAAC;YAEvC,KAAK,IAAQ,IAAI,CAAC,QAAQ,SAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAE,MAAM,CAAK,CAAC;YAExE,OAAO,KAAK,CAAC;SACb;QACF,0BAAC;IAAD,CAvBA,IAuBC;;ICxBD;QAKC;YAJS,UAAK,GAAkB,cAAc,CAAC;YAK9C,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;SACxB;QAGD,oCAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,IAAI;iBACT,aAAa;iBACb,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,QAAQ,CAAE,MAAM,CAAE,GAAA,CAAE;iBAChC,IAAI,CAAE,SAAS,CAAE,CACjB;SACF;QACF,wBAAC;IAAD,CAjBA,IAiBC;;ICTM,IAAM,gBAAgB,GAczB;QACH,UAAU,EAAE,OAAO,CAAC,UAAU;KAC9B,CAAC;;ICTF,SAAS,QAAQ,CAAE,SAAsC;QACxD,OAAO,UAAA,QAAQ;;YACd,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAE,QAAQ,CAAE,GAAG,QAAQ,GAAG,CAAE,QAAQ,CAAE,CAAC;YAC/D,IAAM,aAAa,GAAqB,IAAI,iBAAiB,EAAE,CAAC;YAChE,CAAA,KAAA,aAAa,CAAC,QAAQ,EAAC,IAAI,WAAK,QAAQ,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,UAAU,EAAE,GAAA,CAAE,EAAG;YAEtE,IAAM,aAAa,GAAG,SAAS,CAAC,WAAW,CAAC,aAAa,CAAC,MAAM,CAAE,aAAa,CAAE,CAAC;YAClF,IAAM,UAAU,GAAqB,YAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,aAAa,eAAA,EAAE,CAAE,CAAC;YAE9F,IAAM,YAAY,GAAG,IAAI,SAAS,CAAE;gBACnC,WAAW,EAAE,SAAS,CAAC,WAAW;gBAClC,WAAW,EAAE,UAAU;aACvB,CAAE,CAAC;YACJ,OAAO,YAAY,CAAC,UAAU,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SACnD,CAAA;IACF,CAAC;AAMD,IAAO,IAAM,YAAY,GAcrB;QACH,UAAU,EAAV,UAAsE,SAAW,EAAE,MAAQ;YAC1F,OAAO,gBAAgB,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBACrE,GAAG,EAAE,QAAQ,CAAE,SAAS,CAAE;aAC1B,CAAE,CAAE,CAAC;SACN;KACD,CAAC;;ICvCF,SAAS,UAAU,CAAE,SAAsC;QAC1D,OAAO,UAAA,QAAQ;;YACd,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAE,QAAQ,CAAE,GAAG,QAAQ,GAAG,CAAE,QAAQ,CAAE,CAAC;YAC/D,IAAM,aAAa,GAAqB,IAAI,iBAAiB,EAAE,CAAC;YAChE,CAAA,KAAA,aAAa,CAAC,QAAQ,EAAC,IAAI,WAAK,QAAQ,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,UAAU,EAAE,GAAA,CAAE,EAAG;YAEtE,IAAM,UAAU,GAAqB,IAAI,iBAAiB,EAAE,CAAC;YAC7D,UAAU,CAAC,aAAa,CAAC,IAAI,CAAE,SAAS,CAAC,WAAW,EAAE,aAAa,CAAE,CAAC;YAEtE,IAAM,YAAY,GAAG,IAAI,SAAS,CAAE;gBACnC,WAAW,EAAE,SAAS,CAAC,WAAW;gBAClC,WAAW,EAAE,UAAU;aACvB,CAAE,CAAC;YACJ,OAAO,YAAY,CAAC,UAAU,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SACnD,CAAA;IACF,CAAC;AAMD,IAAO,IAAM,YAAY,GAcrB;QACH,UAAU,EAAV,UAAsE,SAAW,EAAE,MAAQ;YAC1F,OAAO,gBAAgB,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBACrE,KAAK,EAAE,UAAU,CAAE,SAAS,CAAE;aAC9B,CAAE,CAAE,CAAC;SACN;KACD,CAAC;;IC3BF,SAAS,QAAQ,CAAoC,SAAW;QAC/D,OAAO;YAAE,gBAAmE;iBAAnE,UAAmE,EAAnE,qBAAmE,EAAnE,IAAmE;gBAAnE,2BAAmE;;YAC3E,IAAM,YAAY,GAAG,SAAS,CAAC,WAAW,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;YAC1D,YAAY,CAAC,IAAI,CAAE,MAAM,CAAC,GAAG,CAAE,YAAY,CAAE,CAAE,CAAC;YAEhD,IAAM,WAAW,GAAG,YAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,MAAM,EAAE,YAAY,EAAE,CAAE,CAAC;YACpF,IAAM,YAAY,GAAG,YAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAgB,CAAE,CAAC;YAE9E,OAAO,yBAAyB,CAAC,UAAU,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SAChE,CAAC;IACH,CAAC;AAMD,IAAO,IAAM,qBAAqB,GAc9B;QACH,UAAU,EAAV,UAAgE,SAAW,EAAE,MAAQ;YACpF,OAAO,gBAAgB,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBACrE,GAAG,EAAE,QAAQ,CAAE,SAAS,CAAE;aAC1B,CAAE,CAAE,CAAC;SACN;KACD,CAAC;AAKF,IAAO,IAAM,yBAAyB,GAclC;QACH,UAAU,EAAV,UAAgE,SAAW,EAAE,MAAQ;YACpF,OAAO,gBAAgB,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBACrE,GAAG,EAAE,QAAQ,CAAE,SAAS,CAAE;aAC1B,CAAE,CAAE,CAAC;SACN;KACD,CAAC;;IC7DF,SAASC,UAAQ,CAAoC,SAAW;QAC/D,OAAO,UAAA,KAAK;YACX,IAAM,MAAM,GAAG,SAAS,CAAC,WAAW,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;YACpD,IAAI,CAAE,MAAM,CAAC,MAAM;gBAAG,MAAM,CAAC,IAAI,CAAE,EAAE,CAAE,CAAC;YACxC,MAAM,CAAE,CAAC,CAAE,GAAG,MAAM,CAAE,CAAC,CAAE,CAAC,MAAM,CAAE,YAAY,CAAE,KAA6B,CAAE,CAAE,CAAC;YAElF,IAAM,WAAW,GAAG,YAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,MAAM,QAAA,EAAE,CAAE,CAAC;YACtE,IAAM,YAAY,GAAG,YAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAgB,CAAE,CAAC;YAE9E,OAAO,uBAAuB,CAAC,UAAU,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SAC9D,CAAC;IACH,CAAC;AAMD,IAAO,IAAM,mBAAmB,GAc5B;QACH,UAAU,EAAV,UAAgE,SAAW,EAAE,MAAQ;YACpF,OAAO,gBAAgB,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBACrE,GAAG,EAAEA,UAAQ,CAAE,SAAS,CAAE;aAC1B,CAAE,CAAE,CAAC;SACN;KACD,CAAC;AAKF,IAAO,IAAM,uBAAuB,GAchC;QACH,UAAU,EAAV,UAAgE,SAAW,EAAE,MAAQ;YACpF,OAAO,gBAAgB,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBACrE,GAAG,EAAEA,UAAQ,CAAE,SAAS,CAAE;aAC1B,CAAE,CAAE,CAAC;SACN;KACD,CAAC;;IC6EF,SAAS,oBAAoB,CAA4B,SAA8B,EAAE,WAAa;QACrG,OAAO,IAAI,SAAS,CAAE;YACrB,WAAW,EAAE,SAAS,CAAC,WAAW;YAClC,WAAW,aAAA;SACX,CAAE,CAAA;IACJ,CAAC;IAED,SAAS,WAAW,CAA4B,SAA8B,EAAE,KAAO;QACtF,IAAM,gBAAgB,GAAG,oBAAoB,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;QAClE,OAAO,gBAAgB,CAAC,UAAU,CAAE,gBAAgB,EAAE,EAAE,CAAE,CAAC;IAC5D,CAAC;IAGD,SAAS,UAAU,CAAE,SAA8B;QAClD,OAAO,UAAE,aAA0C,EAAE,QAA4B;YAChF,IAAM,QAAQ,GAAG,OAAO,aAAa,KAAK,QAAQ;gBACjD,SAAS,CAAC,WAAW,CAAC,OAAO,CAAE,aAAa,CAAE;gBAC9C,aAAa,CAAC,UAAU,EAAE,CAAC;YAE5B,IAAM,KAAK,GAAc,IAAI,UAAU,CAAE,QAAQ,CAAE,CAAC;YAEpD,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAE,QAAQ,CAAE,GAAG,QAAQ,GAAG,CAAE,QAAQ,CAAE,CAAC;YAC/D,KAAK,CAAC,UAAU,OAAhB,KAAK,EAAgB,QAAQ,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,UAAU,EAAE,GAAA,CAAE,EAAG;YAE3D,OAAO,WAAW,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;SACvC,CAAA;IACF,CAAC;IAED,SAAS,UAAU,CAAE,SAA8B;QAClD,OAAO,UAAE,QAA4B;;YACpC,IAAM,KAAK,GAAqB,IAAI,iBAAiB,EAAE,CAAC;YAExD,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAE,QAAQ,CAAE,GAAG,QAAQ,GAAG,CAAE,QAAQ,CAAE,CAAC;YAC/D,CAAA,KAAA,KAAK,CAAC,QAAQ,EAAC,IAAI,WAAK,QAAQ,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,UAAU,EAAE,GAAA,CAAE,EAAG;YAE9D,IAAM,gBAAgB,GAAG,oBAAoB,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;YAClE,OAAO,YAAY,CAAC,UAAU,CAAE,gBAAgB,EAAE,EAAE,CAAE,CAAC;SACvD,CAAA;IACF,CAAC;IAED,SAASC,YAAU,CAAE,SAA8B;QAClD,OAAO,UAAE,QAA4B;YACpC,IAAM,KAAK,GAAqB,IAAI,iBAAiB,EAAE,CAAC;YAExD,IAAM,gBAAgB,GAAG,oBAAoB,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;YAClE,IAAM,YAAY,GAAgB,YAAY;iBAC5C,UAAU,CAAE,gBAAgB,EAAE,EAAE,CAAE,CAAC;YAErC,OAAO,YAAY,CAAC,GAAG,CAAE,QAAQ,CAAE,CAAC;SACpC,CAAA;IACF,CAAC;IAED,SAAS,aAAa,CAAE,SAA8B;QACrD,OAAO,UAAE,QAA4B;YACpC,IAAM,KAAK,GAAiB,IAAI,aAAa,EAAE,CAAC;YAEhD,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAE,QAAQ,CAAE,GAAG,QAAQ,GAAG,CAAE,QAAQ,CAAE,CAAC;YAC/D,KAAK,CAAC,UAAU,OAAhB,KAAK,EAAgB,QAAQ,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,UAAU,EAAE,GAAA,CAAE,EAAG;YAE3D,OAAO,WAAW,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;SACvC,CAAA;IACF,CAAC;IAED,SAAS,UAAU,CAAE,SAA8B;QAClD,OAAO,UAAE,QAA4B;;YACpC,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAE,QAAQ,CAAE,GAAG,QAAQ,GAAG,CAAE,QAAQ,CAAE,CAAC;YAE/D,IAAM,KAAK,GAAqB,IAAI,iBAAiB,EAAE,CAAC;YACxD,CAAA,KAAA,KAAK,CAAC,YAAY,CAAC,QAAQ,EACzB,IAAI,WAAK,QAAQ,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,UAAU,EAAE,GAAA,CAAE,EAAG;YAEjD,OAAO,WAAW,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;SACvC,CAAA;IACF,CAAC;IAED,SAAS,YAAY,CAAE,SAA8B,EAAE,QAAkB;QACxE,OAAO,UAAE,QAAqC,EAAE,QAA4B;;YAC3E,IAAM,QAAQ,GAAG,OAAO,QAAQ,KAAK,QAAQ;gBAC5C,SAAS,CAAC,WAAW,CAAC,OAAO,CAAE,QAAQ,CAAE;gBACzC,QAAQ,CAAC,UAAU,EAAE,CAAC;YAEvB,IAAM,KAAK,GAAuB,IAAI,mBAAmB,CAAE,QAAQ,EAAE,QAAQ,CAAE,CAAC;YAEhF,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAE,QAAQ,CAAE,GAAG,QAAQ,GAAG,CAAE,QAAQ,CAAE,CAAC;YAC/D,CAAA,KAAA,KAAK,CAAC,YAAY,CAAC,QAAQ,EACzB,IAAI,WAAK,QAAQ,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,UAAU,EAAE,GAAA,CAAE,EAAG;YAEjD,OAAO,WAAW,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;SACvC,CAAA;IACF,CAAC;IAGD,SAAS,WAAW,CAAE,SAA8B;QACnD,OAAO,UAAE,aAAoB;YAC5B,IAAM,KAAK,GAAe,IAAI,WAAW,CAAE,aAAa,CAAE,CAAC;YAE3D,OAAO,WAAW,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;SACvC,CAAA;IACF,CAAC;IAED,SAAS,SAAS,CAAE,SAA8B;QACjD,OAAO,UAAE,aAAoB,EAAE,QAA0B;YACxD,IAAM,SAAS,GAAG,OAAO,QAAQ,KAAK,QAAQ;gBAC7C,IAAI,aAAa,CAAE,QAAQ,CAAE;gBAC7B,QAAQ,CAAC,UAAU,EAAE,CAAC;YAEvB,IAAM,KAAK,GAAa,IAAI,SAAS,CAAE,aAAa,EAAE,SAAS,CAAE,CAAC;YAElE,OAAO,WAAW,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;SACvC,CAAA;IACF,CAAC;IAED,SAAS,WAAW,CAAE,SAA8B;QACnD,OAAO;YAAE,mBAAuB;iBAAvB,UAAuB,EAAvB,qBAAuB,EAAvB,IAAuB;gBAAvB,8BAAuB;;;YAC/B,IAAM,KAAK,GAAe,IAAI,WAAW,EAAE,CAAC;YAC5C,CAAA,KAAA,KAAK,CAAC,SAAS,EAAC,IAAI,WAAK,SAAS,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,UAAU,EAAE,GAAA,CAAE,EAAG;YAEhE,IAAM,gBAAgB,GAAG,oBAAoB,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;YAElE,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC;gBACzB,OAAO,mBAAmB;qBACxB,UAAU,CAAE,gBAAgB,EAAE,EAAE,CAAE,CAAC;YAEtC,OAAO,qBAAqB;iBAC1B,UAAU,CAAE,gBAAgB,EAAE,EAAE,CAAE,CAAC;SACrC,CAAA;IACF,CAAC;AAMD,IAAO,IAAM,wBAAwB,GAcjC;QACH,UAAU,EAAV,UAA8B,SAA8B,EAAE,MAAQ;YACrE,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,SAAS,EAAE,OAAkB;gBAE7B,KAAK,EAAE,UAAU,CAAE,SAAS,CAAE;gBAC9B,KAAK,EAAE,UAAU,CAAE,SAAS,CAAE;gBAC9B,KAAK,EAAEA,YAAU,CAAE,SAAS,CAAE;gBAC9B,QAAQ,EAAE,aAAa,CAAE,SAAS,CAAE;gBACpC,KAAK,EAAE,UAAU,CAAE,SAAS,CAAE;gBAC9B,OAAO,EAAE,YAAY,CAAE,SAAS,CAAE;gBAClC,aAAa,EAAE,YAAY,CAAE,SAAS,EAAE,QAAQ,CAAE;gBAElD,MAAM,EAAE,WAAW,CAAE,SAAS,CAAE;gBAChC,IAAI,EAAE,SAAS,CAAE,SAAS,CAAE;gBAC5B,MAAM,EAAE,WAAW,CAAE,SAAS,CAAE;aAChC,CAAE,CAAA;SACH;KACD,CAAC;;IC/UF;QAIC;YAHS,UAAK,GAAqB,iBAAiB,CAAC;YAIpD,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;SAChB;QAGD,sCAAO,GAAP,UAAS,IAAM;YACd,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,CAAC;YAExB,OAAO,IAAI,CAAC;SACZ;QAGD,uCAAQ,GAAR;YACC,OAAO,IAAI,CAAC,KAAK;iBACf,IAAI,CAAE,GAAG,CAAE,CAAC;SACd;QACF,2BAAC;IAAD,CApBA,IAoBC;;ICQD;QAA0EF,uCAAY;QAKrF,6BAAa,IAA+B;;YAA5C,YACC,kBAAO,IAAI,CAAE,SAMb;YAJA,KAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,CAAC;YAChD,KAAI,CAAC,yBAAyB,GAAG,IAAI,CAAC,yBAAyB,CAAC;YAEhE,IAAI,eAAe,mBAAmB;gBAAG,MAAM,CAAC,MAAM,CAAE,KAAI,CAAE,CAAC;;SAC/D;QACF,0BAAC;IAAD,CAAC,CAbyE,SAAS,GAalF;;aC5Be,gBAAgB,CAAuB,SAAwB,EAAE,QAAiE;QACjJ,IAAI,QAAQ,KAAK,GAAG;YACnB,OAAO,QAAQ,CAAC;QAEjB,IAAI,OAAO,QAAQ,KAAK,QAAQ;YAC/B,OAAO,SAAS,CAAC,WAAW,CAAC,OAAO,CAAE,QAAQ,EAAE,IAAI,CAAE,CAAC;QAExD,IAAI,OAAO,IAAI,QAAQ;YACtB,OAAO,QAAa,CAAC;QAEtB,IAAI,YAAY,IAAI,QAAQ;YAC3B,OAAO,QAAQ,CAAC,UAAU,EAAE,CAAC;QAE9B,OAAO,QAAQ,CAAC,OAAO,EAAE,CAAC;IAC3B,CAAC;;ICzBD;QAIC,4BAAa,IAAM;YAHV,UAAK,GAAa,SAAS,CAAC;YAIpC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;SACjB;QAED,qCAAQ,GAAR;YACC,IAAI,CAAE,IAAI,CAAC,IAAI;gBAAG,OAAO,IAAI,CAAC;YAC9B,OAAO,MAAK,IAAI,CAAC,IAAI,MAAI,CAAC;SAC1B;QACF,yBAAC;IAAD,CAZA,IAYC;;aCLe,gBAAgB;QAAuB,iBAAmB;aAAnB,UAAmB,EAAnB,qBAAmB,EAAnB,IAAmB;YAAnB,4BAAmB;;QACzE,OAAO,UAAE,KAAe;YACvB,IAAI,KAAK,KAAK,GAAG;gBAAG,OAAO,KAAK,CAAC;YAEjC,IAAI,OAAO,CAAC,OAAO,CAAE,KAAK,CAAC,KAAK,CAAE,KAAK,CAAE,CAAC;gBACzC,OAAO,IAAI,kBAAkB,CAAE,KAAK,CAAE,CAAC;YAExC,OAAO,KAAK,CAAC;SACb,CAAA;IACF,CAAC;AAUD,aAAgB,gBAAgB,CAAE,KAAe;QAChD,OAAO,KAAK,KAAK,GAAG;eAChB,KAAK,CAAC,KAAK,KAAK,KAAK;eACrB,KAAK,CAAC,KAAK,KAAK,cAAc,CAChC;IACH,CAAC;AAQD,aAAgB,qBAAqB,CAAE,KAAe;QACrD,OAAO,gBAAgB,CAAE,KAAK,CAAE;gBAE9B,KAAK,CAAC,KAAK,KAAK,aAAa;mBAC1B,gBAAgB,CAAE,KAAK,CAAC,IAAI,CAAE,CACjC,CAAC;IACJ,CAAC;;ICnCD,IAAM,sBAAsB,GAAG,gBAAgB,CAA0B,iBAAiB,CAAE,CAAC;AAM7F,aAAgB,gBAAgB,CAAuB,SAAoD;QAC1G,OAAO;YAAE,eAA0C;iBAA1C,UAA0C,EAA1C,qBAA0C,EAA1C,IAA0C;gBAA1C,0BAA0C;;;YAClD,IAAM,YAAY,GAAe,KAAK;iBACpC,MAAM,CAAkB,UAAE,KAAK,EAAE,KAAK,IAAM,OAAA,KAAK,CAAC,MAAM,CAAE,KAAK,CAAE,GAAA,EAAE,EAAE,CAAE;iBACvE,GAAG,CAAE,UAAA,IAAI,IAAI,OAAA,gBAAgB,CAAE,SAAS,EAAE,IAAI,CAAE,GAAA,CAAE,CAAC;YAGrD,IAAI,SAAS,CAAC,WAAW,IAAI,EAAG,SAAS,CAAC,WAAW,YAAY,oBAAoB,CAAC;gBACrF,YAAY,CAAC,OAAO,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;YAE/C,IAAM,eAAe,GAA4B,YAAY;iBAC3D,GAAG,CAAE,sBAAsB,CAAE,CAAC;YAGhC,IAAI,SAAS,CAAC,WAAW,YAAY,oBAAoB;gBACxD,eAAe,CAAC,OAAO,OAAvB,eAAe,EAAa,SAAS,CAAC,WAAW,CAAC,KAAK,EAAG;YAG3D,IAAM,WAAW,GAAe,IAAI,oBAAoB,EAAE,CAAC;YAC3D,CAAA,KAAA,WAAW,CAAC,KAAK,EAAC,IAAI,WAAK,eAAe,EAAG;YAE7C,IAAM,YAAY,GAAoC,IAAI,mBAAmB,cACzE,SAAS,IACZ,WAAW,aAAA,IACT,CAAC;YAGJ,IAAI,eAAe,CAAC,KAAK,CAAE,qBAAqB,CAAE;gBACjD,OAAO,SAAS,CAAC,yBAAyB,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;YAEhE,OAAO,SAAS,CAAC,iBAAiB,CAAE,YAAY,EAAE,EAAE,CAAS,CAAC;SAC9D,CAAA;IACF,CAAC;;ICjDD;QAIC,0BAAa,IAAM;YAHV,UAAK,GAAiB,aAAa,CAAC;YAI5C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;SACjB;QAED,mCAAQ,GAAR;YACC,OAAO,MAAK,IAAI,CAAC,IAAO,CAAC;SACzB;QACF,uBAAC;IAAD,CAXA,IAWC;;ICCD,IAAM,kBAAkB,GAAG,gBAAgB,CAAgB,iBAAiB,EAAE,cAAc,EAAE,aAAa,CAAE,CAAC;AAM9G,aAAgB,YAAY,CAAuB,SAAoD;QACtG,OAAO,UAAE,IAAkB;YAC1B,IAAM,KAAK,GAAa,SAAS,CAAC,WAAW;kBAE1C,SAAS,CAAC,WAAW;kBAErB,gBAAgB,CAAE,SAAS,EAAE,IAAK,CAAE,CAAC;YAExC,IAAM,cAAc,GAAgB,kBAAkB,CAAE,KAAK,CAAE,CAAC;YAChE,IAAM,WAAW,GAAe,IAAI,gBAAgB,CAAE,cAAc,CAAiB,CAAC;YAEtF,IAAM,YAAY,GAAoC,IAAI,mBAAmB,cACzE,SAAS,IACZ,WAAW,aAAA,IACT,CAAC;YAGJ,IAAI,gBAAgB,CAAE,KAAK,CAAE;gBAC5B,OAAO,SAAS,CAAC,yBAAyB,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;YAEhE,OAAO,SAAS,CAAC,iBAAiB,CAAE,YAAY,EAAE,EAAE,CAAS,CAAC;SAC9D,CAAA;IACF,CAAC;;ICxCD;QAKC,sBAAa,IAAqB,EAAE,GAAmB;YAJ9C,UAAK,GAAa,SAAS,CAAC;YAKpC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;YACjB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;SACf;QAED,+BAAQ,GAAR;YACC,OAAO,KAAI,IAAI,CAAC,IAAI,GAAK,IAAI,CAAC,GAAM,CAAC;SACrC;QACF,mBAAC;IAAD,CAbA,IAaC;;ICTD,IAAM,cAAc,GAAG,gBAAgB,CAAoB,iBAAiB,EAAE,cAAc,EAAE,aAAa,EAAE,SAAS,CAAE,CAAC;AAMzH,aAAgB,QAAQ,CAAE,SAAoD,EAAE,GAAmB;QAClG,OAAO,UAAE,IAAkB;YAC1B,IAAM,KAAK,GAAa,SAAS,CAAC,WAAW;kBAC1C,SAAS,CAAC,WAAW;kBACrB,gBAAgB,CAAE,SAAS,EAAE,IAAK,CAAE,CAAC;YAExC,IAAM,UAAU,GAAoB,cAAc,CAAE,KAAK,CAAE,CAAC;YAC5D,IAAM,WAAW,GAAgB,IAAI,YAAY,CAAE,UAAU,EAAE,GAAG,CAAE,CAAC;YAErE,IAAM,YAAY,GAAqC,IAAI,mBAAmB,cAC1E,SAAS,IACZ,WAAW,aAAA,IACT,CAAC;YAEJ,OAAO,SAAS,CAAC,iBAAiB,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SACvD,CAAC;IACH,CAAC;;IC1BD;QAIC;YAHS,UAAK,GAAkB,cAAc,CAAC;YAI9C,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;SAChB;QAGD,mCAAO,GAAP,UAAS,IAAwB;YAChC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAAI,CAAE,CAAC;YAExB,OAAO,IAAI,CAAC;SACZ;QAGD,oCAAQ,GAAR;YACC,OAAO,IAAI,CAAC,KAAK;iBACf,IAAI,CAAE,GAAG,CAAE,CAAC;SACd;QACF,wBAAC;IAAD,CApBA,IAoBC;;ICbD,IAAM,mBAAmB,GAAG,gBAAgB,CAAuB,iBAAiB,EAAE,cAAc,CAAE,CAAC;AAMvG,aAAgB,aAAa,CAAE,SAAoD;QAClF,OAAO;YAAE,eAA0C;iBAA1C,UAA0C,EAA1C,qBAA0C,EAA1C,IAA0C;gBAA1C,0BAA0C;;;YAClD,IAAM,YAAY,GAAe,KAAK;iBACpC,MAAM,CAAkB,UAAE,KAAK,EAAE,KAAK,IAAM,OAAA,KAAK,CAAC,MAAM,CAAE,KAAK,CAAE,GAAA,EAAE,EAAE,CAAE;iBACvE,GAAG,CAAE,UAAA,IAAI,IAAI,OAAA,gBAAgB,CAAE,SAAS,EAAE,IAAI,CAAE,GAAA,CAAE,CAAC;YAGrD,IAAI,SAAS,CAAC,WAAW,IAAI,EAAG,SAAS,CAAC,WAAW,YAAY,iBAAiB,CAAC;gBAClF,YAAY,CAAC,OAAO,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;YAE/C,IAAM,eAAe,GAAyB,YAAY;iBACxD,GAAG,CAAE,mBAAmB,CAAE,CAAC;YAG7B,IAAI,SAAS,CAAC,WAAW,YAAY,iBAAiB;gBACrD,eAAe,CAAC,OAAO,OAAvB,eAAe,EAAa,SAAS,CAAC,WAAW,CAAC,KAAK,EAAG;YAG3D,IAAM,WAAW,GAAqB,IAAI,iBAAiB,EAAE,CAAC;YAC9D,CAAA,KAAA,WAAW,CAAC,KAAK,EAAC,IAAI,WAAK,eAAe,EAAG;YAE7C,IAAM,YAAY,GAA0C,IAAI,mBAAmB,cAC/E,SAAS,IACZ,WAAW,aAAA,IACT,CAAC;YAEJ,OAAO,SAAS,CAAC,iBAAiB,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SACvD,CAAA;IACF,CAAC;;IC/BD,SAAS,aAAa,CAAE,KAA2B;QAClD,OAAO,CAAE,KAAK;eACV,qBAAqB,CAAE,KAAK,CAAE;gBAC7B,KAAK,CAAC,KAAK,KAAK,iBAAiB,IAAI,KAAK,CAAC,KAAK,CAAC,KAAK,CAAE,qBAAqB,CAAE,CAAC,CACnF;IACH,CAAC;AAMD,aAAgB,YAAY,CAAuB,SAAoD;QACtG,OAAO,UAAE,IAA+C;YACvD,IAAM,KAAK,GAAyB,SAAS,CAAC,WAAW;kBAEtD,SAAS,CAAC,WAAW;kBAErB,IAAI,KAAK,KAAK,CAAC,GAAG,IAAI;sBACrB,gBAAgB,CAAE,SAAS,EAAE,IAAI,CAAE,CAAC;YAGxC,IAAM,WAAW,GAAkB,IAAI,kBAAkB,CAAE,KAAK,CAAoB,CAAC;YAErF,IAAM,YAAY,GAAuC,IAAI,mBAAmB,cAC5E,SAAS,IACZ,WAAW,aAAA,IACT,CAAC;YAGJ,IAAI,aAAa,CAAE,KAAK,CAAE;gBACzB,OAAO,SAAS,CAAC,yBAAyB,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;YAEhE,OAAO,SAAS,CAAC,iBAAiB,CAAE,YAAY,EAAE,EAAE,CAAS,CAAC;SAC9D,CAAC;IACH,CAAC;;ICrCM,IAAM,IAAI,GAcb;QACH,UAAU,EAAV,UAAmD,SAAsB,EAAE,MAAQ;YAClF,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,OAAO,EAAE,cAAM,OAAA,SAAS,CAAC,WAAW,GAAA;aACpC,CAAE,CAAC;SACJ;KACD,CAAC;;IC2CK,IAAM,UAAU,GAcnB;QACH,UAAU,EAAV,UAAmD,SAAgC,EAAE,MAAQ;YAC5F,OAAO,IAAI,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBACzD,OAAO,EAAE,YAAY,CAAK,SAAS,CAAE;gBAErC,EAAE,EAAE,gBAAgB,CAAK,SAAS,CAAE;gBACpC,IAAI,EAAE,aAAa,CAAE,SAAS,CAAE;gBAEhC,OAAO,EAAE,YAAY,CAAK,SAAS,CAAE;gBAErC,SAAS,EAAE,QAAQ,CAAE,SAAS,EAAE,GAAG,CAAE;gBACrC,UAAU,EAAE,QAAQ,CAAE,SAAS,EAAE,GAAG,CAAE;gBACtC,UAAU,EAAE,QAAQ,CAAE,SAAS,EAAE,GAAG,CAAE;aACtC,CAAE,CAAE,CAAC;SACN;KACD,CAAC;;IClGF;QAIC,0BAAa,IAA+C;YAHnD,UAAK,GAAiB,aAAa,CAAC;YAI5C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;SACjB;QAED,mCAAQ,GAAR;YACC,OAAO,MAAK,IAAI,CAAC,IAAO,CAAC;SACzB;QACF,uBAAC;IAAD,CAXA,IAWC;;ICGD,IAAM,kBAAkB,GAAG,gBAAgB,CAA8C,iBAAiB,CAAE,CAAC;AAM7G,aAAgB,YAAY,CAAE,SAAgI;QAC7J,OAAO,UAAE,IAAkB;YAC1B,IAAM,KAAK,GAAiB,SAAS,CAAC,WAAW;kBAE9C,SAAS,CAAC,WAAW;kBAErB,gBAAgB,CAAE,SAAS,EAAE,IAAK,CAAE,CAAC;YAExC,IAAM,cAAc,GAA8C,kBAAkB,CAAE,KAAK,CAAE,CAAC;YAC9F,IAAM,WAAW,GAAoB,IAAI,gBAAgB,CAAE,cAAc,CAAE,CAAC;YAE5E,IAAM,YAAY,GAAyC,IAAI,mBAAmB,cAC9E,SAAS,IACZ,WAAW,aAAA,IACT,CAAC;YAEJ,OAAO,SAAS,CAAC,iBAAiB,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SACvD,CAAA;IACF,CAAC;;ICvBM,IAAM,kBAAkB,GAc3B;QACH,UAAU,EAAV,UAA+H,SAAgC,EAAE,MAAQ;YACxK,OAAO,UAAU,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC/D,OAAO,EAAE,YAAY,CAAE,SAAS,CAAE;aAClC,CAAE,CAAE,CAAC;SACN;KACD,CAAC;;ICsDK,IAAM,WAAW,GAcpB;QACH,UAAU,EAAV,UAA8B,SAAwC,EAAE,MAAQ;YAC/E,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,OAAO,EAAE,YAAY,CAAE,SAAS,CAAE;gBAElC,YAAY,EAAE,gBAAgB,CAAE,SAAS,CAAE;gBAC3C,SAAS,EAAE,aAAa,CAAE,SAAS,CAAE;gBAErC,OAAO,EAAE,YAAY,CAAE,SAAS,CAAE;gBAClC,OAAO,EAAE,YAAY,CAAE,SAAS,CAAE;gBAElC,SAAS,EAAE,QAAQ,CAAE,SAAS,EAAE,GAAG,CAAE;gBACrC,UAAU,EAAE,QAAQ,CAAE,SAAS,EAAE,GAAG,CAAE;gBACtC,UAAU,EAAE,QAAQ,CAAE,SAAS,EAAE,GAAG,CAAE;aACtC,CAAE,CAAC;SACJ;KACD,CAAC;;ICzGF,SAAS,aAAa,CAAmC,SAA8B,EAAE,WAAc;QACtG,OAAO,IAAI,mBAAmB,cAC1B,SAAS,IACZ,WAAW,EAAE,WAAY,EACzB,iBAAiB,EAAE,UAAU,CAAC,UAAU,EACxC,yBAAyB,EAAE,kBAAkB,CAAC,UAAU,IACtD,CAAC;IACL,CAAC;IASD,SAAS,cAAc,CAAE,SAA8B,EAAE,QAAgC;QACxF,IAAM,WAAW,GAAkB,gBAAgB,CAAE,SAAS,EAAE,QAAQ,CAAE,CAAC;QAE3E,IAAM,YAAY,GAAuC,aAAa,CAAE,SAAS,EAAE,WAAW,CAAE,CAAC;QACjG,OAAO,kBAAkB,CAAC,UAAU,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IAC1D,CAAC;IAED,SAAS,SAAS,CAAE,SAA8B;QACjD,OAAO,UAAE,mBAA8F;YACtG,IAAI,OAAO,mBAAmB,KAAK,UAAU;gBAC5C,OAAO,cAAc,CAAE,SAAS,EAAE,mBAAmB,CAAE,CAAC;YAEzD,IAAM,YAAY,GAAkC,aAAa,CAAE,SAAS,CAAE,CAAC;YAE/E,IAAM,WAAW,GAAe,WAAW,CAAC,UAAU,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;YAC3E,OAAO,mBAAmB,CAAE,WAAW,CAAE,CAAC;SAC1C,CAAC;IACH,CAAC;AAMD,IAAO,IAAM,YAAY,GAcrB;QACH,UAAU,EAAV,UAA8B,SAA8B,EAAE,MAAQ;YACrE,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,IAAI,EAAE,SAAS,CAAE,SAAS,CAAE;aAC5B,CAAE,CAAA;SACH;KACD,CAAC;;ICxEF;QAKC;YAJS,UAAK,GAAuB,mBAAmB,CAAC;YAKxD,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;SACrB;QAGD,4CAAW,GAAX,UAAa,QAAsB;YAClC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAE,QAAQ,CAAE,CAAC;YACjC,OAAO,IAAI,CAAC;SACZ;QAGD,yCAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,uBAAuB,CAAE;gBAC/B,MAAM,QAAA;gBACN,IAAI,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE;gBAC/B,eAAe,EAAE,GAAG;gBACpB,MAAM,EAAE,IAAI,CAAC,UAAU;aACvB,CAAE,CAAC;SACJ;QACF,6BAAC;IAAD,CAxBA,IAwBC;;IC9BD,IAAM,WAAW,GAAU,mDAAmD,CAAC;IAQ/E;QAIC,wBAAa,KAAa;YAHjB,UAAK,GAAe,WAAW,CAAC;YAIxC,IAAI,CAAE,KAAK;gBAAG,OAAO;YACrB,IAAI,CAAE,WAAW,CAAC,IAAI,CAAE,KAAK,CAAE;gBAAG,MAAM,IAAI,KAAK,CAAE,2BAA2B,CAAE,CAAC;YACjF,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;SACnB;QAED,iCAAQ,GAAR,UAAU,MAAc;YACvB,IAAI,IAAI,CAAC,KAAK;gBAAG,OAAO,IAAI,CAAC,KAAK,CAAC;YACnC,OAAO,IAAI,CAAC;SACZ;QACF,qBAAC;IAAD,CAdA,IAcC;;IChBD;QAKC;YAJS,UAAK,GAAgB,YAAY,CAAC;YAK1C,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;SAClB;QAGD,mCAAS,GAAT;YAAW,gBAAuB;iBAAvB,UAAuB,EAAvB,qBAAuB,EAAvB,IAAuB;gBAAvB,2BAAuB;;;YACjC,CAAA,KAAA,IAAI,CAAC,OAAO,EAAC,IAAI,WAAK,MAAM,EAAG;YAC/B,OAAO,IAAI,CAAC;SACZ;QAGD,kCAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,uBAAuB,CAAE;gBAC/B,MAAM,QAAA;gBACN,IAAI,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE;gBAC/B,MAAM,EAAE,IAAI,CAAC,OAAO;aACpB,CAAE,CAAC;SACJ;QACF,sBAAC;IAAD,CAvBA,IAuBC;;ICrBD;QAMC,sBAAa,OAAS;YALb,UAAK,GAAa,SAAS,CAAC;YAMpC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;YACvB,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;SACrB;QAGD,kCAAW,GAAX,UAAa,QAAsB;YAClC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAE,QAAQ,CAAE,CAAC;YACjC,OAAO,IAAI,CAAC;SACZ;QAGD,+BAAQ,GAAR,UAAU,MAAc;YACvB,IAAI,KAAK,GAAU,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAE,MAAM,CAAE,CAAC;YAEnD,IAAI,SAAS,GAAU,CAAE,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,EAAE;kBACjD,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,KAAK,YAAY,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,KAAK,mBAAmB;uBACjF,KAAK,CAAC,QAAQ,CAAE,IAAI,CAAE,GAAG,IAAI;sBAC7B,GAAG,CAAC;YAER,IAAM,SAAS,GAAsB,SAAS,KAAK,GAAG;gBACrD,SAAS,CAAE,MAAM,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAE;gBACrC,SAAS,CAAE,MAAM,EAAE,kBAAkB,CAAE,CAAC;YAEzC,IAAM,SAAS,GAAU,cAAc,CAAE,SAAS,CAAE,CAAC;YACrD,IAAM,UAAU,GAAU,IAAI,CAAC,UAAU;iBACvC,GAAG,CAAE,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,QAAQ,CAAE,SAAS,CAAE,GAAA,CAAE;iBACjD,IAAI,CAAE,GAAG,GAAG,YAAY,CAAE,MAAM,CAAE,GAAG,SAAS,CAAE,CAAC;YAEnD,IAAI,SAAS,KAAK,IAAI;gBAAG,SAAS,IAAI,SAAS,CAAC;YAChD,OAAO,KAAK,GAAG,SAAS,GAAG,UAAU,CAAC;SACtC;QACF,mBAAC;IAAD,CAtCA,IAsCC;;ICtCD;QAMC,uBAAa,IAA8B;YALlC,UAAK,GAAc,UAAU,CAAC;YAMtC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;YACjB,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;SAClB;QAGD,iCAAS,GAAT;YAAW,gBAAuB;iBAAvB,UAAuB,EAAvB,qBAAuB,EAAvB,IAAuB;gBAAvB,2BAAuB;;;YACjC,CAAA,KAAA,IAAI,CAAC,OAAO,EAAC,IAAI,WAAK,MAAM,EAAG;YAC/B,OAAO,IAAI,CAAC;SACZ;QAGD,gCAAQ,GAAR,UAAU,MAAc;YACvB,IAAM,SAAS,GAAU,YAAY,CAAE,MAAM,CAAE,CAAC;YAEhD,IAAM,IAAI,GAAU,KAAI,IAAI,CAAC,IAAO,CAAC;YAGrC,IAAM,YAAY,GAAsB,SAAS,CAAE,MAAM,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAE,CAAC;YAC7E,IAAM,YAAY,GAAU,cAAc,CAAE,YAAY,CAAE,CAAC;YAC3D,IAAM,OAAO,GAAU,IAAI,CAAC,OAAO;iBACjC,GAAG,CAAE,UAAA,MAAM;gBACX,IAAI,MAAM,CAAC,KAAK,KAAK,YAAY,IAAI,MAAM,CAAC,KAAK,KAAK,mBAAmB;oBACxE,OAAO,MAAM,CAAC,QAAQ,CAAE,MAAM,CAAE,CAAC;gBAElC,OAAO,MAAM,CAAC,QAAQ,CAAE,YAAY,CAAE,CAAA;aACtC,CAAE;iBACF,IAAI,CAAE,GAAG,GAAG,SAAS,GAAG,YAAY,CAAE,CAAC;YAEzC,OAAO,IAAI,GAAG,GAAG,GAAG,OAAO,CAAC;SAC5B;QACF,oBAAC;IAAD,CArCA,IAqCC;;ICMD,SAAS,eAAe,CAA6D,SAAW,EAAE,aAA2B;QAC5H,IAAM,UAAU,GAAG,SAAS,CAAC,WAAW,CAAC,UAAU,CAAC,MAAM,CAAE,aAAa,CAAE,CAAC;QAC5E,IAAM,WAAW,GAAG,YAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,UAAU,YAAA,EAAE,CAAE,CAAC;QAC1E,OAAO,YAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAgB,CAAE,CAAC;IACjE,CAAC;IAED,SAAS,gBAAgB,CAA6D,SAAW,EAAE,aAA2B;QAC7H,SAAS,CAAC,WAAW,CAAC,UAAU,CAAC,IAAI,CAAE,aAAa,CAAE,CAAC;QACvD,OAAO,SAAS,CAAC;IAClB,CAAC;IAWD,SAASC,UAAQ,CAA+E,cAA4B,EAAE,SAAW;QACxI,OAAO,UAAE,QAA4C,EAAE,OAA2B;YACjF,IAAM,SAAS,GAA6B,gBAAgB,CAAE,SAAS,EAAE,QAAQ,CAAE,CAAC;YACpF,IAAM,aAAa,GAAiB,IAAI,aAAa,CAAE,SAAS,CAAE,CAAC;YAEnE,OAAO,GAAG,KAAK,CAAC,OAAO,CAAE,OAAO,CAAE,GAAG,OAAO,GAAG,CAAE,OAAO,CAAE,CAAC;YAC3D,aAAa,CAAC,SAAS,OAAvB,aAAa,EAAe,OAAO,CAAC,GAAG,CAAE,YAAY,CAAE,EAAG;YAE1D,IAAM,YAAY,GAAG,SAAS,CAAC,WAAW,CAAC,KAAK,KAAK,SAAS;gBAC7D,eAAe,CAAE,SAAS,EAAE,aAAa,CAAE;gBAC3C,gBAAgB,CAAE,SAAS,EAAE,aAAa,CAAE,CAAC;YAE9C,IAAM,aAAa,GAAK,cAAc,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;YAC3D,OAAO,mBAAmB,CAAC,UAAU,CAAE,cAAc,EAAE,YAAY,EAAE,aAAa,CAAE,CAAC;SACrF,CAAC;IACH,CAAC;AAMD,IAAO,IAAM,eAAe,GAgBxB;QACH,UAAU,EAAV,UAA2G,cAA4B,EAAE,SAAW,EAAE,MAAQ;YAC7J,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,GAAG,EAAEA,UAAQ,CAAE,cAAc,EAAE,SAAS,CAAE;aAC1C,CAAE,CAAC;SACJ;KACD,CAAC;AAKF,IAAO,IAAM,mBAAmB,GAgB5B;QACH,UAAU,EAAV,UAA2G,cAA4B,EAAE,SAAW,EAAE,MAAQ;YAC7J,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,GAAG,EAAEA,UAAQ,CAAE,cAAc,EAAE,SAAS,CAAE;aAC1C,CAAE,CAAC;SACJ;KACD,CAAC;;ICjIF,IAAM,mBAAmB,GAAoB,UAAE,SAAS,EAAE,MAAM,IAAM,OAAA,MAAM,GAAA,CAAC;AAM7E,IAAO,IAAM,gBAAgB,GAczB;QACH,UAAU,EAAV,UAA2E,SAAW,EAAE,MAAQ;YAC/F,OAAO,eAAe,CAAC,UAAU,CAAE,mBAAmB,EAAE,SAAS,EAAE,MAAM,CAAE,CAAC;SAC5E;KACD,CAAC;;ICnCF,IAAM,cAAc,GAAU,6BAA6B,CAAC;IAQ5D;QAIC,uBAAa,GAAU;YAHd,UAAK,GAAc,UAAU,CAAC;YAItC,IAAI,CAAE,cAAc,CAAC,IAAI,CAAE,GAAG,CAAE;gBAAG,MAAM,IAAI,KAAK,CAAE,OAAK,GAAG,mCAAgC,CAAE,CAAC;YAC/F,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;SACf;QAED,gCAAQ,GAAR,UAAU,MAAc;YACvB,OAAO,MAAK,IAAI,CAAC,GAAM,CAAC;SACxB;QACF,oBAAC;IAAD,CAZA,IAYC;;ICTM,IAAM,aAAa,GActB;QACH,UAAU,EAAE,OAAO,CAAC,UAAU;KAC9B,CAAC;;ICRK,IAAM,aAAa,GActB;QACH,UAAU,EAAV,UAA0F,SAAW,EAAE,MAAQ;YAC9G,IAAM,oBAAoB,GAAgC,aAAa,CAAC,UAAU,CAAC;YACnF,OAAO,eAAe,CAAC,UAAU,CAAE,oBAAoB,EAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC1F,UAAU,EAAE,cAAM,OAAA,SAAS,CAAC,WAAW,CAAC,OAAO,GAAA;aAC/C,CAAE,CAAE,CAAC;SACN;KACD,CAAC;;ICTF,SAAS,aAAa,CAAsD,SAAW;QACtF,OAAO,UAAA,IAAI;YACV,IAAI,IAAI,IAAI,GAAG;gBAAG,IAAI,GAAG,GAAG,CAAE,IAAwB,CAAE,CAAC;YAEzD,IAAM,OAAO,GAAG,SAAS,CAAC,WAAW,CAAC,OAAO,CAAE,IAAI,EAAE,IAAI,CAAE,CAAC;YAC5D,IAAM,OAAO,GAAG,YAAY,CAAE,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE,CAAE,CAAC;YAEjF,IAAM,WAAW,GAAG,YAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,OAAO,SAAA,EAAE,CAAE,CAAC;YACvE,IAAM,YAAY,GAAK,YAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAgB,CAAE,CAAC;YAEhF,OAAO,aAAa,CAAC,UAAU,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SACpD,CAAA;IACF,CAAC;IAED,SAAS,iBAAiB,CAAsD,SAAW;QAC1F,OAAO,UAAA,QAAQ;YACd,IAAM,SAAS,GAAG,IAAI,aAAa,CAAE,QAAQ,CAAE,CAAC;YAChD,IAAM,OAAO,GAAG,YAAY,CAAE,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAE,CAAC;YAEvF,IAAM,WAAW,GAAG,YAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,OAAO,SAAA,EAAE,CAAE,CAAC;YACvE,IAAM,YAAY,GAAK,YAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAgB,CAAE,CAAC;YAEhF,OAAO,aAAa,CAAC,UAAU,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SACpD,CAAA;IACF,CAAC;AAMD,IAAO,IAAM,UAAU,GAcnB;QACH,UAAU,EAAV,UAAkF,SAAW,EAAE,MAAQ;YACtG,OAAO,aAAa,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAClE,QAAQ,EAAE,aAAa,CAAE,SAAS,CAAE;gBACpC,YAAY,EAAE,iBAAiB,CAAE,SAAS,CAAE;aAC5C,CAAE,CAAE,CAAC;SACN;KACD,CAAC;;ICPF,SAASE,sBAAoB,CAAyB,SAA8B,EAAE,KAAO;QAC5F,OAAO,IAAI,SAAS,CAAE;YACrB,WAAW,EAAE,SAAS,CAAC,WAAW;YAClC,WAAW,EAAE,IAAI,YAAY,CAAE,KAAK,CAAE;SACtC,CAAE,CAAC;IACL,CAAC;IAED,SAAS,iBAAiB,CAAyB,SAA8B,EAAE,KAAO;QACzF,IAAM,gBAAgB,GAAGA,sBAAoB,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;QAClE,OAAO,aAAa,CAAC,UAAU,CAAE,gBAAgB,EAAE,EAAE,CAAE,CAAC;IACzD,CAAC;IAED,SAAS,eAAe,CAAyB,SAA8B,EAAE,KAAO;QACvF,IAAM,gBAAgB,GAAGA,sBAAoB,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;QAClE,OAAO,OAAO,CAAC,UAAU,CACxB,aAAa,CAAC,UAAU,EACxB,OAAO,CAAC,UAAU,CAClB,CAAE,gBAAgB,EAAE,EAAE,CAAE,CAAC;IAC3B,CAAC;IAGD,SAAS,aAAa,CAAE,SAA8B;QACrD,OAAO,UAAA,GAAG;YACT,IAAM,KAAK,GAAY,SAAS,CAAC,WAAW,CAAC,OAAO,CAAE,GAAG,CAAE,CAAC;YAC5D,OAAO,iBAAiB,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;SAC7C,CAAA;IACF,CAAC;IAED,SAAS,QAAQ,CAAE,SAA8B;QAChD,OAAO,UAAA,IAAI;YACV,IAAM,KAAK,GAAiB,IAAI,aAAa,CAAE,IAAI,CAAE,CAAC;YACtD,OAAO,iBAAiB,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;SAC7C,CAAA;IACF,CAAC;IAED,SAAS,YAAY,CAAE,SAA8B;QACpD,OAAO,UAAE,KAA+B;YAEvC,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAG;gBAC/B,IAAM,OAAK,GAAgB,IAAI,YAAY,CAAE,KAAK,CAAE,CAAC;gBACrD,OAAO,iBAAiB,CAAE,SAAS,EAAE,OAAK,CAAE,CAAC;aAC7C;YAED,IAAM,KAAK,GAAmB,IAAI,eAAe,CAAE,KAAK,CAAE,CAAC;YAC3D,IAAM,gBAAgB,GAAGA,sBAAoB,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;YAClE,OAAO,UAAU,CAAC,UAAU,CAAE,gBAAgB,EAAE,EAAE,CAAE,CAAC;SACrD,CAAA;IACF,CAAC;IAKD,SAAS,eAAe,CAAE,SAA8B;QACvD,OAAO;YAAE,gBAAkB;iBAAlB,UAAkB,EAAlB,qBAAkB,EAAlB,IAAkB;gBAAlB,2BAAkB;;;YAC1B,IAAM,KAAK,GAAmB,CAAA,KAAA,IAAI,eAAe,EAAE,EACjD,SAAS,WAAK,MAAM,CAAC,GAAG,CAAE,YAAY,CAAE,CAAE,CAAC;YAC7C,OAAO,eAAe,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;SAC3C,CAAA;IACF,CAAC;IAED,SAAS,aAAa,CAAE,SAA8B,EAAE,KAAa;QACpE,IAAI,KAAK,IAAI,CAAE,KAAK,CAAC,UAAU,CAAE,IAAI,CAAE;YACtC,KAAK,GAAG,IAAI,GAAG,KAAK,CAAC;QAEtB,IAAM,KAAK,GAAkB,IAAI,cAAc,CAAE,KAAK,CAAE,CAAC;QACzD,OAAO,iBAAiB,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;IAC9C,CAAC;IAED,SAAS,qBAAqB,CAAE,SAA8B,EAAE,SAAiD;QAChH,IAAM,KAAK,GAA0B,IAAI,sBAAsB,EAAE,CAAC;QAElE,IAAM,gBAAgB,GAAqC,IAAI,SAAS,CAAE;YACzE,WAAW,EAAE,SAAS,CAAC,WAAW;YAClC,WAAW,EAAE,KAAK;SAClB,CAAE,CAAC;QAEJ,IAAM,OAAO,GAAoB,gBAAgB,CAAC,UAAU,CAAE,gBAAgB,EAAE,EAAE,CAAE,CAAC;QACrF,SAAS,CAAE,OAAO,CAAE,CAAC;QAErB,IAAI,KAAK,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC;YAC9B,MAAM,IAAI,KAAK,CAAE,8DAA8D,CAAE,CAAC;QAEnF,OAAO,eAAe,CAAE,SAAS,EAAE,KAAK,CAAE,CAAC;IAC5C,CAAC;IAED,SAAS,cAAc,CAAE,SAA8B;QACtD,OAAO,UAAE,gBAAoE;YAC5E,IAAI,OAAO,gBAAgB,KAAK,UAAU;gBACzC,OAAO,qBAAqB,CAAE,SAAS,EAAE,gBAAgB,CAAE,CAAC;YAE7D,OAAO,aAAa,CAAE,SAAS,EAAE,gBAAgB,CAAE,CAAC;SACpD,CAAC;IACH,CAAC;AAMD,IAAO,IAAM,qBAAqB,GAc9B;QACH,UAAU,EAAV,UAA8B,SAA8B,EAAE,MAAQ;YACrE,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,QAAQ,EAAE,aAAa,CAAE,SAAS,CAAE;gBACpC,GAAG,EAAE,QAAQ,CAAE,SAAS,CAAE;gBAC1B,OAAO,EAAE,YAAY,CAAE,SAAS,CAAE;gBAClC,UAAU,EAAE,eAAe,CAAE,SAAS,CAAE;gBACxC,SAAS,EAAE,cAAc,CAAE,SAAS,CAAE;aACtC,CAAE,CAAC;SACJ;KACD,CAAC;;ICvLK,IAAM,cAAc,GAuBvB;QACH,MAAM,EAAN,UAAQ,WAAuB;YAC9B,IAAM,SAAS,GAAwB,IAAI,SAAS,CAAE;gBACrD,WAAW,aAAA;gBACX,WAAW,EAAE,KAAK,CAAC;aACnB,CAAE,CAAC;YAEJ,OAAO,cAAc;iBACnB,UAAU,CAAE,SAAS,EAAE,EAAE,CAAE,CAAC;SAC9B;QAED,UAAU,EAAV,UAA8D,SAAW,EAAE,MAAQ;YAClF,OAAO,OAAO,CAAC,UAAU,CACxB,qBAAqB,CAAC,UAAU,EAChC,wBAAwB,CAAC,UAAU,EACnC,gBAAgB,CAAC,UAAU,EAC3B,YAAY,CAAC,UAAU,CACvB,CAAE,SAAS,EAAE,MAAM,CAAE,CAAC;SACvB;KACD,CAAC;;ICzBF,SAAS,YAAY,CAAE,WAAuB,EAAE,eAAiE;QAChH,IAAM,iBAAiB,GAAuB,eAAe,CAAE,cAAc,CAAC,MAAM,CAAE,WAAW,CAAE,CAAE,CAAC;QACtG,IAAM,QAAQ,GAAa,KAAK,CAAC,OAAO,CAAE,iBAAiB,CAAE,GAAG,iBAAiB,GAAG,CAAE,iBAAiB,CAAE,CAAC;QAE1G,OAAO,QAAQ,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,UAAU,EAAE,GAAA,CAAE,CAAC;IAC5C,CAAC;IAaD,SAASC,YAAU,CAA6E,cAA4B,EAAE,SAAW;QACxI,OAAO,UAAE,eAAiE;;YACzE,IAAM,WAAW,GAAe,IAAI,WAAW,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;YACzE,IAAM,QAAQ,GAAkB,YAAY,CAAE,WAAW,EAAE,eAAe,CAAE,CAAC;YAE7E,IAAM,KAAK,GAAG,CAAA,KAAA,YAAY,CAAE,SAAS,CAAC,WAAW,CAAC,WAAW,EAAE,EAAE,KAAK,EAAE,IAAI,UAAU,EAAE,EAAE,CAAE,EAC1F,UAAU,WAAK,QAAQ,CAAE,CAAC;YAE5B,IAAM,UAAU,GAAc,YAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,WAAW,EAAE,KAAK,EAAE,CAAE,CAAC;YAC5F,IAAM,YAAY,GAAG,YAAY,CAAE,SAAS,EAAE,EAAE,WAAW,aAAA,EAAE,WAAW,EAAE,UAAU,EAAgB,CAAE,CAAC;YAEvG,IAAM,WAAW,GAAkB,WAAW,CAAC,UAAU,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;YAC9F,OAAO,cAAc,CAAE,YAAY,EAAE,WAAW,CAAE,CAAC;SACnD,CAAC;IACH,CAAC;AAMD,IAAO,IAAM,WAAW,GAgBpB;QACH,UAAU,EAAV,UAAyG,cAA2C,EAAE,SAAW,EAAE,MAAQ;YAC1K,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,KAAK,EAAEA,YAAU,CAAE,cAAc,EAAE,SAAS,CAAE;aAC9C,CAAE,CAAC;SACJ;KACD,CAAC;;IC7CF,SAAS,SAAS,CAAmF,cAA4B,EAAE,SAAW,EAAE,KAAc;QAC7J,OAAO,UAAE,GAAU;YAClB,IAAM,WAAW,GAAe,IAAI,WAAW,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;YAEzE,IAAM,QAAQ,GAAe,SAAS,CAAC,WAAW,CAAC,WAAW,CAAC,QAAQ;iBACrE,MAAM,CAAE,IAAI,SAAS,CAAE,WAAW,CAAC,OAAO,CAAE,GAAG,CAAE,EAAE,KAAK,CAAE,CAAE,CAAC;YAC/D,IAAM,WAAW,GAAG,YAAY,CAAE,SAAS,CAAC,WAAW,CAAC,WAAW,EAAE,EAAE,QAAQ,UAAA,EAAE,CAAE,CAAC;YAEpF,IAAM,UAAU,GAAc,YAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,WAAW,aAAA,EAAE,CAAE,CAAC;YACrF,IAAM,YAAY,GAAG,YAAY,CAAE,SAAS,EAAE;gBAC7C,WAAW,aAAA;gBACX,WAAW,EAAE,UAAU;aACT,CAAE,CAAC;YAElB,OAAO,UAAU,CAAC,UAAU,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SACjE,CAAA;IACF,CAAC;AAMD,IAAO,IAAM,UAAU,GAgBnB;QACH,UAAU,EAAV,UAA+G,cAA4B,EAAE,SAAW,EAAE,MAAQ;YACjK,OAAO,WAAW,CAAC,UAAU,CAAE,cAAc,EAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAChF,IAAI,EAAE,SAAS,CAAE,cAAc,EAAE,SAAS,CAAE;gBAC5C,SAAS,EAAE,SAAS,CAAE,cAAc,EAAE,SAAS,EAAE,IAAI,CAAE;aACvD,CAAE,CAAE,CAAC;SACN;KACD,CAAC;;IClEF,SAASC,aAAW,CAA2D,cAA0D,EAAE,SAAW;QACrJ,OAAO;YACN,IAAM,WAAW,GAAY,IAAI,QAAQ,EAAE,CAAC;YAE5C,IAAM,UAAU,GAAwB,YAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,WAAW,aAAA,EAAE,CAAE,CAAC;YAC/F,IAAM,YAAY,GAAmC,IAAI,SAAS,CAAE;gBACnE,WAAW,EAAE,SAAS,CAAC,WAAW;gBAClC,WAAW,EAAE,UAAU;aACvB,CAAE,CAAC;YAEJ,OAAO,UAAU,CAAC,UAAU,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SACjE,CAAC;IACH,CAAC;AAMD,IAAO,IAAM,SAAS,GAgBlB;QACH,UAAU,EAAV,UAAuF,cAA0D,EAAE,SAAW,EAAE,MAAQ;YACvK,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,GAAG,EAAEA,aAAW,CAAE,cAAc,EAAE,SAAS,CAAE;aAC7C,CAAE,CAAC;SACJ;KACD,CAAC;;IC7DF;QAAiCL,+BAAiB;QAKjD,qBAAa,QAAgC;YAA7C,YACC,kBAAO,QAAQ,CAAE,SAGjB;YARQ,WAAK,GAAY,QAAQ,CAAC;YAOlC,KAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;;SACnB;QAGD,8BAAQ,GAAR,UAAU,MAAc;YACvB,IAAI,KAAK,GAAU,iBAAM,QAAQ,YAAE,MAAM,CAAE,CAAC;YAC5C,IAAM,SAAS,GAAU,YAAY,CAAE,MAAM,CAAE,CAAC;YAEhD,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM;gBAAG,KAAK,IAAI,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAE,SAAS,CAAE,CAAC;YAEhF,KAAK,IAAI,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE,MAAM,CAAE,CAAC;YAEnD,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM;gBAAG,KAAK,IAAI,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAE,SAAS,CAAE,CAAC;YAElF,OAAO,KAAK,CAAC;SACb;QACF,kBAAC;IAAD,CAAC,CAxBgC,iBAAiB,GAwBjD;;ICyDD,SAASK,aAAW,CAA2D,cAA6D,EAAE,SAAW,EAAE,QAAgC;QAC1L,OAAO;YAAE,mBAAqB;iBAArB,UAAqB,EAArB,qBAAqB,EAArB,IAAqB;gBAArB,8BAAqB;;YAC7B,IAAM,WAAW,GAAe,IAAI,WAAW,CAAE,QAAQ,CAAE,CAAC;YAC5D,IAAI,SAAS,CAAC,MAAM;gBAAG,WAAW,CAAC,WAAW,OAAvB,WAAW,EAAiB,SAAS,CAAC,GAAG,CAAE,UAAA,CAAC,IAAI,OAAA,IAAI,aAAa,CAAE,CAAC,CAAE,GAAA,CAAE,EAAG;YAElG,IAAM,UAAU,GAA2B,YAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,WAAW,aAAA,EAAE,CAAE,CAAC;YAClG,IAAM,YAAY,GAAsC,IAAI,SAAS,CAAE;gBACtE,WAAW,EAAE,SAAS,CAAC,WAAW;gBAClC,WAAW,EAAE,UAAU;aACvB,CAAE,CAAC;YAEJ,OAAO,UAAU,CAAC,UAAU,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;SACjE,CAAC;IACH,CAAC;AAMD,IAAO,IAAM,YAAY,GAgBrB;QACH,UAAU,EAAV,UAAuF,cAA6D,EAAE,SAAW,EAAE,MAAQ;YAC1K,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBAC7B,MAAM,EAAEA,aAAW,CAAE,cAAc,EAAE,SAAS,CAAE;gBAChD,cAAc,EAAEA,aAAW,CAAE,cAAc,EAAE,SAAS,EAAE,UAAU,CAAE;gBACpE,aAAa,EAAEA,aAAW,CAAE,cAAc,EAAE,SAAS,EAAE,SAAS,CAAE;gBAClE,SAAS,EAAE,cAAM,OAAAA,aAAW,CAAE,cAAc,EAAE,SAAS,CAAE,EAAE,GAAA;gBAC3D,iBAAiB,EAAE,cAAM,OAAAA,aAAW,CAAE,cAAc,EAAE,SAAS,EAAE,UAAU,CAAE,EAAE,GAAA;gBAC/E,gBAAgB,EAAE,cAAM,OAAAA,aAAW,CAAE,cAAc,EAAE,SAAS,EAAE,SAAS,CAAE,EAAE,GAAA;aAC7E,CAAE,CAAC;SACJ;KACD,CAAC;;ICzEF,SAAS,IAAI,CAA+F,GAAU;QACrH,IAAM,KAAK,GAAa,IAAI,SAAS,CAAE,IAAI,WAAW,CAAE,GAAG,CAAE,CAAE,CAAC;QAEhE,IAAM,SAAS,GAA6B,IAAI,CAAC,WAAW;aAC1D,SAAS,CAAC,MAAM,CAAE,KAAK,CAAE,CAAC;QAE5B,IAAM,UAAU,GAAc,YAAY,CAAE,IAAI,CAAC,WAAW,EAAE,EAAE,SAAS,WAAA,EAAE,CAAE,CAAC;QAC9E,IAAM,SAAS,GAAmC,YAAY,CAAE,IAAI,EAAE,EAAE,WAAW,EAAE,UAAU,EAAE,CAAE,CAAC;QAEpG,OAAO,WAAW,CAAC,UAAU,CAAE,SAAS,EAAE,EAAE,CAAE,CAAC;IAChD,CAAC;IAKD,SAAS,KAAK,CAA+F,GAAU;QACtH,IAAM,WAAW,GAAe,IAAI,WAAW,CAAE,IAAI,CAAC,WAAW,EAAE,GAAG,CAAE,CAAC;QACzE,IAAM,SAAS,GAAmC,YAAY,CAAE,IAAI,EAAE,EAAE,WAAW,aAAA,EAAE,CAAE,CAAC;QAExF,OAAO,WAAW,CAAC,UAAU,CAAE,SAAS,EAAE,EAAE,CAAE,CAAC;IAChD,CAAC;IAKD,SAAS,MAAM,CAA+F,IAAW,EAAE,GAAU;QACpI,IAAM,WAAW,GAAe,IAAI,WAAW,CAAE,IAAI,CAAC,WAAW,CAAE,CAAC;QAGpE,IAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;QAErD,IAAI,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAE,IAAI,CAAE,EAAG;YACtC,IAAM,KAAK,GAAU,SAAS;iBAC5B,SAAS,CAAE,UAAA,KAAK,IAAI,OAAA,KAAK,CAAC,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,SAAS,KAAK,IAAI,GAAA,CAAE,CAAC;YAE7E,IAAI,KAAK,KAAK,CAAE,CAAC;gBAChB,SAAS,CAAC,MAAM,CAAE,KAAK,EAAE,CAAC,CAAE,CAAC;SAC9B;QAED,SAAS,CAAC,IAAI,CAAE,IAAI,WAAW,CAAE,IAAI,EAAE,IAAI,WAAW,CAAE,GAAG,CAAE,CAAE,CAAE,CAAC;QAClE,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAE,IAAI,EAAE,KAAK,CAAE,CAAC;QAGxC,IAAM,UAAU,GAAc,YAAY,CAAE,IAAI,CAAC,WAAW,EAAE,EAAE,SAAS,WAAA,EAAE,CAAE,CAAC;QAC9E,IAAM,SAAS,GAAmC,YAAY,CAAE,IAAI,EAAE;YACrE,WAAW,aAAA;YACX,WAAW,EAAE,UAAU;SACvB,CAAE,CAAC;QAEJ,OAAO,WAAW,CAAC,UAAU,CAAE,SAAS,EAAE,EAAE,CAAE,CAAC;IAChD,CAAC;AAMD,IAAO,IAAM,WAAW,GAcpB;QACH,UAAU,EAAV,UAAgI,SAAW,EAAE,MAAQ;YACpJ,IAAM,aAAa,GAAoC,YAAY;iBACjE,UAAU,CAAC,IAAI,CAAE,IAAI,EAAE,SAAS,CAAC,yBAAyB,CAAE,CAAC;YAC/D,IAAM,UAAU,GAA8B,SAAS;iBACrD,UAAU,CAAC,IAAI,CAAE,IAAI,EAAE,SAAS,CAAC,sBAAsB,CAAE,CAAC;YAE5D,OAAO,OAAO,CAAC,UAAU,CACxB,aAAa,EACb,UAAU,CACV,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;gBACpC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAE,SAAS,CAAE;gBAC5B,KAAK,EAAE,KAAK,CAAC,IAAI,CAAE,SAAS,CAAE;gBAC9B,MAAM,EAAE,MAAM,CAAC,IAAI,CAAE,SAAS,CAAE;aAChC,CAAE,CAAE,CAAC;SACN;KACD,CAAC;;ICpHF;QACSL,sCAAqB;QAqB7B,4BAAa,IAAwC;;YAArD,YACC,kBAAO,IAAI,CAAE,SAKb;YAJA,KAAI,CAAC,yBAAyB,GAAG,IAAI,CAAC,yBAAyB,CAAC;YAChE,KAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC,sBAAsB,CAAC;YAE1D,IAAI,eAAe,kBAAkB;gBAAG,MAAM,CAAC,MAAM,CAAE,KAAI,CAAE,CAAC;;SAC9D;QACF,yBAAC;IAAD,CAAC,CA5BQ,SAAS,GA4BjB;;IClDD;QAOC,oBAAa,KAAO,EAAE,MAAmB;YANhC,UAAK,GAAW,OAAO,CAAC;YAOhC,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;YACpB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;YACzB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;SACrB;QAGD,iCAAY,GAAZ;YAAc,mBAAwC;iBAAxC,UAAwC,EAAxC,qBAAwC,EAAxC,IAAwC;gBAAxC,8BAAwC;;;YACrD,CAAA,KAAA,IAAI,CAAC,SAAS,EAAC,IAAI,WAAK,SAAS,EAAG;YACpC,OAAO,IAAI,CAAC;SACZ;QAGD,6BAAQ,GAAR,UAAU,MAAc;YACvB,IAAM,SAAS,GAAU,YAAY,CAAE,MAAM,CAAE,CAAC;YAEhD,IAAI,KAAK,GAAU,IAAI,CAAC,SAAS;iBAC/B,GAAG,CAAE,UAAA,QAAQ;gBAEb,IAAI,QAAQ,CAAC,KAAK,KAAK,MAAM;oBAC5B,OAAO,QAAQ,GAAG,IAAI,CAAC;gBACxB,OAAO,QAAQ,GAAG,SAAS,CAAC;aAC5B,CAAE;iBACF,IAAI,CAAE,EAAE,CAAE,CAAC;YAEb,IAAI,IAAI,CAAC,WAAW;gBAAG,KAAK,IAAI,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAE,MAAM,CAAE,CAAC;YAEpE,IAAI,IAAI,CAAC,MAAM;gBAAG,KAAK,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAE,MAAM,CAAE,CAAC;YAEtE,OAAO,KAAK,CAAC;SACb;QACF,iBAAC;IAAD,CAtCA,IAsCC;;;QCfA,kBACC,mBAA4F,EAC5F,gBAAmF;YADnF,oCAAA,EAAA,sBAA4C,YAAY,CAAC,UAAmC;YAC5F,iCAAA,EAAA,mBAAsC,YAAY,CAAC,UAAgC;YAGnF,IAAM,SAAS,GAAmC,IAAI,kBAAkB,CAAE;gBACzE,WAAW,EAAE,IAAI,WAAW,EAAE;gBAC9B,WAAW,EAAE,IAAI,UAAU,CAAE,KAAK,CAAC,CAAE;gBACrC,yBAAyB,EAAE,mBAAmB;gBAC9C,sBAAsB,EAAE,gBAAgB;aACxC,CAAE,CAAC;YAEJ,OAAO,WAAW,CAAC,UAAU,CAAE,SAAS,EAAE,IAAI,CAAE,CAAC;SACjD;QAEF,eAAC;IAAD,CA3BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICdA;QAAoCA,kCAAsB;QAKzD;YAAA,YACC,iBAAO,SAGP;YARQ,WAAK,GAAe,WAAW,CAAC;YAOxC,KAAI,CAAC,OAAO,GAAG,EAAE,CAAC;;SAClB;QAGD,kCAAS,GAAT;YAAW,gBAAuB;iBAAvB,UAAuB,EAAvB,qBAAuB,EAAvB,IAAuB;gBAAvB,2BAAuB;;;YACjC,CAAA,KAAA,IAAI,CAAC,OAAO,EAAC,IAAI,WAAK,MAAM,EAAG;YAC/B,OAAO,IAAI,CAAC;SACZ;QAGD,iCAAQ,GAAR,UAAU,MAAc;YACvB,IAAM,OAAO,GAAU,uBAAuB,CAAE;gBAC/C,MAAM,QAAA;gBACN,IAAI,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG,EAAE;gBAC/B,eAAe,EAAE,GAAG;gBACpB,MAAM,EAAE,IAAI,CAAC,OAAO;aACpB,CAAE,CAAC;YAEJ,IAAM,SAAS,GAAU,YAAY,CAAE,MAAM,CAAE,CAAC;YAChD,IAAI,KAAK,GAAU,YAAY;gBAC9B,OAAO,GAAG,SAAS;gBACnB,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAE,MAAM,CAAE,CAAC;YAE/B,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM;gBAAG,KAAK,IAAI,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAE,SAAS,CAAE,CAAC;YAElF,OAAO,KAAK,CAAC;SACb;QACF,qBAAC;IAAD,CAAC,CAnCmC,sBAAsB,GAmCzD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}