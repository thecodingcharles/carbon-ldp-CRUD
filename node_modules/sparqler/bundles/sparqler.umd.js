(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define('sparqler', ['exports'], factory) :
    (factory((global.sparqler = {})));
}(this, (function (exports) { 'use strict';

    var FinishClause = {
        createFrom: function (container, object) {
            var toPrettyString = function () {
                return container.targetToken.toString(0);
            };
            var debug = function (debugFn) {
                debugFn.call(void 0, object, container);
                return object;
            };
            return Object.assign(object, {
                toCompactString: function () { return container.targetToken.toString(); },
                toPrettyString: toPrettyString,
                toString: toPrettyString,
                debug: debug,
            });
        }
    };

    var Factory = {
        createFrom: function () {
            var factories = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                factories[_i] = arguments[_i];
            }
            return function (container, object) {
                return factories
                    .reduce(function (target, factoryFn) { return factoryFn(container, target); }, object);
            };
        }
    };

    function isAbsolute(iri) {
        return iri.indexOf(":") !== -1;
    }
    function hasProtocol(iri) {
        return iri.indexOf("://") !== -1;
    }
    function isRelative(iri) {
        return !isAbsolute(iri);
    }
    function isIRI(iri) {
        return hasProtocol(iri) || !isAbsolute(iri);
    }
    function isBNodeLabel(label) {
        return /^_:/.test(label);
    }
    function isPrefixed(iri) {
        return /^(?!_:)[^]*?:/.test(iri) && !hasProtocol(iri);
    }

    var IRIRefToken = (function () {
        function IRIRefToken(value) {
            this.token = "iri";
            this.value = value;
        }
        IRIRefToken.prototype.toString = function (spaces) {
            return "<" + this.value + ">";
        };
        return IRIRefToken;
    }());

    var NAMESPACE_REGEX = /^([A-Za-z](([A-Za-z_\-0-9]|\.)*[A-Za-z_\-0-9])?)?$/;
    var PrefixedNameToken = (function () {
        function PrefixedNameToken(prefixedOrNamespace, localName) {
            var _a;
            this.token = "prefixedName";
            var namespace = prefixedOrNamespace;
            if (localName === void 0) {
                if (!isPrefixed(prefixedOrNamespace))
                    throw new Error("Invalid prefixed name.");
                _a = prefixedOrNamespace.split(/:(.*)/), namespace = _a[0], localName = _a[1];
            }
            if (!NAMESPACE_REGEX.test(namespace))
                throw new Error("Invalid prefixed namespace.");
            this.namespace = namespace;
            var _b = localName.split(/^(.)(?:(.*)?(.))?$/), ln1 = _b[1], ln2 = _b[2], ln3 = _b[3];
            var preSanitation = "";
            if (ln1)
                preSanitation += ln1.replace(/([\-.])/g, "\\$1");
            if (ln2)
                preSanitation += ln2;
            if (ln3)
                preSanitation += ln3.replace(/([.])/g, "\\$1");
            this.localName = preSanitation.replace(/([~!$&'|()*+,;=/?#@%])/g, "\\$1");
        }
        PrefixedNameToken.prototype.toString = function (spaces) {
            return this.namespace + ":" + this.localName;
        };
        return PrefixedNameToken;
    }());

    var IRIResolver = (function () {
        function IRIResolver(base, vocab) {
            var _newTarget = this.constructor;
            this.prefixes = base
                ? new Map(base.prefixes.entries())
                : new Map();
            this.vocab = vocab
                ? vocab
                : base && base.vocab;
            if (_newTarget === IRIResolver)
                Object.freeze(this);
        }
        IRIResolver.prototype.resolve = function (relativeIRI, vocab) {
            if (isPrefixed(relativeIRI))
                return this.resolvePrefixed(relativeIRI);
            return this.resolveIRIRef(relativeIRI, vocab);
        };
        IRIResolver.prototype.resolveIRIRef = function (relativeIRI, vocab) {
            if (vocab === void 0) { vocab = false; }
            if (vocab && this.vocab && isRelative(relativeIRI))
                relativeIRI = this.vocab + relativeIRI;
            return new IRIRefToken(relativeIRI);
        };
        IRIResolver.prototype.resolvePrefixed = function (prefixedName) {
            var token = new PrefixedNameToken(prefixedName);
            var used = this.prefixes.get(token.namespace);
            if (used === void 0)
                throw new Error("The prefix \"" + token.namespace + "\" has not been declared.");
            if (!used)
                this.prefixes.set(token.namespace, true);
            return token;
        };
        return IRIResolver;
    }());

    function cloneElement(element, newValues) {
        if (newValues === void 0) { newValues = {}; }
        var base = Object.create(Object.getPrototypeOf(element));
        var clone = Object
            .assign(base, element, newValues);
        return Object.freeze(clone);
    }

    var BaseToken = (function () {
        function BaseToken(iri) {
            this.token = "base";
            this.iri = iri;
        }
        BaseToken.prototype.toString = function () {
            return "BASE " + this.iri;
        };
        return BaseToken;
    }());

    var PrefixToken = (function () {
        function PrefixToken(namespace, iri) {
            this.token = "prefix";
            this.namespace = namespace;
            this.iri = iri;
        }
        PrefixToken.prototype.toString = function (spaces) {
            return "PREFIX " + this.namespace + ": " + this.iri;
        };
        return PrefixToken;
    }());

    var Container = (function () {
        function Container(data) {
            var _newTarget = this.constructor;
            this.iriResolver = data.iriResolver;
            this.targetToken = data.targetToken;
            if (_newTarget === Container)
                Object.freeze(this);
        }
        return Container;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    var INDENTATION_SPACES = 4;
    function getSeparator(spaces) {
        if (spaces === void 0)
            return " ";
        return "\n";
    }
    function getIndentation(spaces, extra) {
        if (spaces === void 0)
            return "";
        if (extra)
            spaces += extra;
        return " ".repeat(spaces);
    }
    function addSpaces(spaces, extra) {
        if (spaces === void 0)
            return spaces;
        return spaces + extra;
    }
    function getTokenContainerString(_a) {
        var spaces = _a.spaces, tags = _a.tags, tokensSeparator = _a.tokensSeparator, tokens = _a.tokens;
        if (!tokens.length)
            return tags.open + tags.close;
        var generalSeparator = getSeparator(spaces);
        var tokensSpaces = addSpaces(spaces, INDENTATION_SPACES);
        var strArrayTokens = tokens.map(function (token, index, array) {
            var strToken = token.toString(tokensSpaces);
            if (!tokensSeparator || index === array.length - 1)
                return strToken;
            if (tokensSeparator === "." && token.token !== "subject")
                return strToken;
            return strToken + tokensSeparator;
        });
        if (strArrayTokens.length === 1 && !strArrayTokens[0].includes("\n"))
            return tags.open + " " + strArrayTokens + " " + tags.close;
        var tokensIndent = getIndentation(tokensSpaces);
        var strTokens = strArrayTokens
            .map(function (x) { return tokensIndent + x; })
            .join(generalSeparator);
        var indent = getIndentation(spaces);
        return tags.open +
            generalSeparator + strTokens + generalSeparator +
            indent + tags.close;
    }

    var GroupPatternToken = (function () {
        function GroupPatternToken() {
            this.token = "groupPattern";
            this.patterns = [];
        }
        GroupPatternToken.prototype.addPattern = function () {
            var patterns = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                patterns[_i] = arguments[_i];
            }
            var _a;
            (_a = this.patterns).push.apply(_a, patterns);
            return this;
        };
        GroupPatternToken.prototype.toString = function (spaces) {
            return getTokenContainerString({
                spaces: spaces,
                tags: { open: "{", close: "}" },
                tokensSeparator: ".",
                tokens: this.patterns,
            });
        };
        return GroupPatternToken;
    }());

    var WhereToken = (function () {
        function WhereToken() {
            this.token = "where";
            this.groupPattern = new GroupPatternToken();
        }
        WhereToken.prototype.toString = function (spaces) {
            var identifier = spaces === void 0 ? "" : "WHERE ";
            return identifier + this.groupPattern.toString(spaces);
        };
        return WhereToken;
    }());

    var SharedQueryClauseToken = (function () {
        function SharedQueryClauseToken() {
            this.where = new WhereToken();
            this.modifiers = [];
        }
        SharedQueryClauseToken.prototype.addPattern = function () {
            var patterns = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                patterns[_i] = arguments[_i];
            }
            var _a;
            (_a = this.where.groupPattern.patterns).push.apply(_a, patterns);
            return this;
        };
        SharedQueryClauseToken.prototype.addModifier = function () {
            var modifier = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                modifier[_i] = arguments[_i];
            }
            var _a;
            (_a = this.modifiers).push.apply(_a, modifier);
            return this;
        };
        return SharedQueryClauseToken;
    }());

    var AskToken = (function (_super) {
        __extends(AskToken, _super);
        function AskToken() {
            var _this = _super.call(this) || this;
            _this.token = "ask";
            _this.datasets = [];
            return _this;
        }
        AskToken.prototype.toString = function (spaces) {
            var query = "ASK";
            var separator = getSeparator(spaces);
            if (this.datasets.length)
                query += separator + this.datasets.join(separator);
            query += separator + this.where.toString(spaces);
            if (this.modifiers.length)
                query += separator + this.modifiers.join(separator);
            return query;
        };
        return AskToken;
    }(SharedQueryClauseToken));

    var FromToken = (function () {
        function FromToken(source, named) {
            if (named === void 0) { named = false; }
            this.token = "from";
            this.source = source;
            this.named = named;
        }
        FromToken.prototype.toString = function (spaces) {
            var str = "FROM ";
            if (this.named)
                str += "NAMED ";
            return str + this.source;
        };
        return FromToken;
    }());

    var SharedSelectToken = (function (_super) {
        __extends(SharedSelectToken, _super);
        function SharedSelectToken(modifier) {
            var _this = _super.call(this) || this;
            _this.modifier = modifier;
            _this.variables = [];
            return _this;
        }
        SharedSelectToken.prototype.addVariable = function () {
            var variables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                variables[_i] = arguments[_i];
            }
            var _a;
            (_a = this.variables).push.apply(_a, variables);
            return this;
        };
        SharedSelectToken.prototype.toString = function (spaces) {
            var query = "SELECT";
            if (this.modifier)
                query += " " + this.modifier;
            query += this.variables.length ?
                " " + this.variables.join(" ") :
                " *";
            return query;
        };
        return SharedSelectToken;
    }(SharedQueryClauseToken));

    var SubSelectToken = (function (_super) {
        __extends(SubSelectToken, _super);
        function SubSelectToken(modifier, values) {
            var _this = _super.call(this, modifier) || this;
            _this.token = "subSelect";
            _this.values = values;
            return _this;
        }
        SubSelectToken.prototype.toString = function (spaces) {
            var subSpaces = addSpaces(spaces, INDENTATION_SPACES);
            var subIndent = getIndentation(subSpaces);
            var separator = getSeparator(spaces);
            var query = _super.prototype.toString.call(this, spaces) + separator +
                subIndent + this.where.toString(subSpaces);
            if (this.modifiers.length)
                query += separator + this.modifiers
                    .map(function (x) { return subIndent + x; })
                    .join(separator);
            if (this.values)
                query += separator + subIndent + this.values;
            var indent = getIndentation(spaces);
            return "{" + separator + subIndent +
                query + separator +
                indent + "}";
        };
        return SubSelectToken;
    }(SharedSelectToken));

    var NAME_REGEX = /^((?:[0-9A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF]))((?:[0-9A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF]))*$/;
    var VariableToken = (function () {
        function VariableToken(name) {
            this.token = "variable";
            if (!NAME_REGEX.test(name))
                throw new Error("Invalid variable name");
            this.name = name;
        }
        VariableToken.prototype.toString = function (spaces) {
            return "?" + this.name;
        };
        return VariableToken;
    }());

    var GroupToken = (function () {
        function GroupToken(rawCondition) {
            this.token = "group";
            this.rawCondition = rawCondition;
        }
        GroupToken.prototype.toString = function (spaces) {
            return "GROUP BY " + this.rawCondition;
        };
        return GroupToken;
    }());

    var HavingToken = (function () {
        function HavingToken(rawCondition) {
            this.token = "having";
            this.rawCondition = rawCondition;
        }
        HavingToken.prototype.toString = function (spaces) {
            return "HAVING " + this.rawCondition;
        };
        return HavingToken;
    }());

    var OrderToken = (function () {
        function OrderToken(condition, flow) {
            this.token = "order";
            this.condition = condition;
            if (flow)
                this.flow = flow;
        }
        OrderToken.prototype.toString = function (spaces) {
            return "ORDER BY " + (this.flow ?
                this.flow + "( " + this.condition + " )" :
                "" + this.condition);
        };
        return OrderToken;
    }());

    var LimitToken = (function () {
        function LimitToken(value) {
            this.token = "limit";
            this.value = value;
        }
        LimitToken.prototype.toString = function () {
            return "LIMIT " + this.value;
        };
        return LimitToken;
    }());

    function cloneSolutionModifierContainer(container, token) {
        var targetToken = container.targetToken.token === "query" ?
            _cloneFromQuery(container.targetToken, token) :
            _cloneFromClause(container.targetToken, token);
        return cloneElement(container, { targetToken: targetToken });
    }
    function _cloneFromClause(clauseToken, token) {
        var modifiers = clauseToken.modifiers.concat(token);
        return cloneElement(clauseToken, { modifiers: modifiers });
    }
    function _cloneFromQuery(queryToken, token) {
        var queryClause = _cloneFromClause(queryToken.queryClause, token);
        return cloneElement(queryToken, { queryClause: queryClause });
    }

    function getLimitFn(genericFactory, container) {
        return function (limit) {
            var token = new LimitToken(limit);
            var newContainer = cloneSolutionModifierContainer(container, token);
            return genericFactory(newContainer, {});
        };
    }
    var LimitClause = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                limit: getLimitFn(genericFactory, container),
            });
        },
    };

    var OffsetToken = (function () {
        function OffsetToken(value) {
            this.token = "offset";
            this.value = value;
        }
        OffsetToken.prototype.toString = function (spaces) {
            return "OFFSET " + this.value;
        };
        return OffsetToken;
    }());

    function getOffsetFn(genericFactory, container) {
        return function (offset) {
            var token = new OffsetToken(offset);
            var newContainer = cloneSolutionModifierContainer(container, token);
            return genericFactory(newContainer, {});
        };
    }
    var OffsetClause = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                offset: getOffsetFn(genericFactory, container),
            });
        },
    };

    function getIRIToken(iri) {
        if (isPrefixed(iri))
            return new PrefixedNameToken(iri);
        return new IRIRefToken(iri);
    }

    var LiteralToken = (function () {
        function LiteralToken(value) {
            this.token = "literal";
            this.value = value;
        }
        LiteralToken.prototype.toString = function (spaces) {
            return JSON.stringify(this.value);
        };
        return LiteralToken;
    }());

    var RDFLiteralToken = (function (_super) {
        __extends(RDFLiteralToken, _super);
        function RDFLiteralToken(value, typeOrLanguage) {
            var _this = _super.call(this, value) || this;
            if (!typeOrLanguage)
                return _this;
            if (typeOrLanguage.token === "language") {
                _this.language = typeOrLanguage;
            }
            else {
                _this.type = typeOrLanguage;
            }
            return _this;
        }
        RDFLiteralToken.prototype.toString = function (spaces) {
            var value = _super.prototype.toString.call(this);
            if (this.language)
                return value + this.language;
            if (this.type)
                return value + "^^" + this.type;
            return value;
        };
        return RDFLiteralToken;
    }(LiteralToken));

    var XSD = {
        namespace: "http://www.w3.org/2001/XMLSchema#",
        boolean: "http://www.w3.org/2001/XMLSchema#boolean",
        byte: "http://www.w3.org/2001/XMLSchema#byte",
        date: "http://www.w3.org/2001/XMLSchema#date",
        dateTime: "http://www.w3.org/2001/XMLSchema#dateTime",
        decimal: "http://www.w3.org/2001/XMLSchema#decimal",
        double: "http://www.w3.org/2001/XMLSchema#double",
        duration: "http://www.w3.org/2001/XMLSchema#duration",
        float: "http://www.w3.org/2001/XMLSchema#float",
        gDay: "http://www.w3.org/2001/XMLSchema#gDay",
        gMonth: "http://www.w3.org/2001/XMLSchema#gMonth",
        gMonthDay: "http://www.w3.org/2001/XMLSchema#gMonthDay",
        gYear: "http://www.w3.org/2001/XMLSchema#gYear",
        gYearMonth: "http://www.w3.org/2001/XMLSchema#gYearMonth",
        int: "http://www.w3.org/2001/XMLSchema#int",
        integer: "http://www.w3.org/2001/XMLSchema#integer",
        long: "http://www.w3.org/2001/XMLSchema#long",
        negativeInteger: "http://www.w3.org/2001/XMLSchema#negativeInteger",
        nonNegativeInteger: "http://www.w3.org/2001/XMLSchema#nonNegativeInteger",
        nonPositiveInteger: "http://www.w3.org/2001/XMLSchema#nonPositiveInteger",
        object: "http://www.w3.org/2001/XMLSchema#object",
        positiveInteger: "http://www.w3.org/2001/XMLSchema#positiveInteger",
        short: "http://www.w3.org/2001/XMLSchema#short",
        string: "http://www.w3.org/2001/XMLSchema#string",
        time: "http://www.w3.org/2001/XMLSchema#time",
        unsignedByte: "http://www.w3.org/2001/XMLSchema#unsignedByte",
        unsignedInt: "http://www.w3.org/2001/XMLSchema#unsignedInt",
        unsignedLong: "http://www.w3.org/2001/XMLSchema#unsignedLong",
        unsignedShort: "http://www.w3.org/2001/XMLSchema#unsignedShort",
    };

    function convertValue(value) {
        if (value instanceof Date)
            return new RDFLiteralToken(value.toISOString(), getIRIToken(XSD.dateTime));
        if (typeof value === "object")
            return value.getSubject();
        if (typeof value === "string") {
            if (value === "UNDEF")
                return value;
            return new LiteralToken(value);
        }
        return new LiteralToken(value);
    }

    var ValuesToken = (function () {
        function ValuesToken() {
            this.token = "values";
            this.variables = [];
            this.values = [];
        }
        ValuesToken.prototype.addVariables = function () {
            var variables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                variables[_i] = arguments[_i];
            }
            var _a;
            (_a = this.variables).push.apply(_a, variables);
            return this;
        };
        ValuesToken.prototype.addValues = function () {
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            this.values.push(values);
            return this;
        };
        ValuesToken.prototype.toString = function (spaces) {
            var variables = this._getVariablesStr();
            var values = this._getValuesStr(spaces);
            return "VALUES " + variables + " " + values;
        };
        ValuesToken.prototype._getVariablesStr = function () {
            if (!this.variables.length)
                return "()";
            var variables = this.variables.join(" ");
            if (this.variables.length === 1)
                return variables;
            return "( " + variables + " )";
        };
        ValuesToken.prototype._getValuesStr = function (spaces) {
            if (!this.values.length)
                return "{}";
            if (this.variables.length === 1) {
                var values = this.values
                    .filter(function (x) { return x.length; })
                    .map(function (x) { return x[0]; })
                    .join(" ");
                if (!values)
                    return "{}";
                return "{ " + values + " }";
            }
            var subIndent = getIndentation(spaces, INDENTATION_SPACES);
            var separator = getSeparator(spaces);
            var indent = getIndentation(spaces);
            return "{" + separator +
                this.values
                    .map(function (values) {
                    var valuesStr = values.length ?
                        "( " + values.join(" ") + " )" : "()";
                    return subIndent + valuesStr;
                })
                    .join(separator) + separator +
                indent + "}";
        };
        return ValuesToken;
    }());

    function _normalizeVariables(variableOrVariables) {
        var variables = Array.isArray(variableOrVariables) ? variableOrVariables : [variableOrVariables];
        return variables.map(function (x) { return new VariableToken(x); });
    }
    function _normalizeRawValues(valuesOrBuilder, iriResolver, isSingle) {
        var rawValues = typeof valuesOrBuilder === "function" ?
            valuesOrBuilder(PatternBuilder.create(iriResolver)) :
            valuesOrBuilder;
        if (!Array.isArray(rawValues))
            return [[rawValues]];
        if (isSingle)
            rawValues.map(function (value) { return [value]; });
        if (rawValues.some(Array.isArray))
            return rawValues;
        return [rawValues];
    }
    function createValuesFn(genericFactory, container) {
        return function (variableOrVariables, valuesOrBuilder) {
            var token = new ValuesToken();
            var variables = _normalizeVariables(variableOrVariables);
            token.addVariables.apply(token, variables);
            var isSingle = !Array.isArray(variableOrVariables);
            var iriResolver = new IRIResolver(container.iriResolver);
            var values = _normalizeRawValues(valuesOrBuilder, iriResolver, isSingle);
            values.forEach(function (valuesRow) { return token.addValues.apply(token, valuesRow.map(convertValue)); });
            var targetToken = cloneElement(container.targetToken, { values: token });
            var newContainer = cloneElement(container, { iriResolver: iriResolver, targetToken: targetToken });
            return genericFactory(newContainer, {});
        };
    }
    var ValuesClause = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                values: createValuesFn(genericFactory, container),
            });
        },
    };

    function _getLimitFactory(valuesFactory) {
        var offsetValuesFactory = OffsetClause
            .createFrom.bind(null, valuesFactory);
        return function (container1, object1) { return LimitClause
            .createFrom(Factory.createFrom(offsetValuesFactory, valuesFactory), container1, object1); };
    }
    function _getOffsetFactory(valuesFactory) {
        var limitValuesFactory = LimitClause
            .createFrom.bind(null, valuesFactory);
        return function (container1, object1) { return OffsetClause
            .createFrom(Factory.createFrom(valuesFactory, limitValuesFactory), container1, object1); };
    }
    var LimitOffsetClause = {
        createFrom: function (genericFactory, container, object) {
            var valuesFactory = ValuesClause
                .createFrom.bind(null, genericFactory);
            var genericAndValuesFactory = Factory.createFrom(genericFactory, valuesFactory);
            return Factory.createFrom(_getLimitFactory(genericAndValuesFactory), _getOffsetFactory(genericAndValuesFactory), valuesFactory)(container, object);
        },
    };

    function getOrderByFn(genericFactory, container) {
        return function (rawCondition) {
            var token = new OrderToken(rawCondition);
            var newContainer = cloneSolutionModifierContainer(container, token);
            var limitOffsetClause = LimitOffsetClause.createFrom(genericFactory, newContainer, {});
            return genericFactory(newContainer, limitOffsetClause);
        };
    }
    var OrderClause = {
        createFrom: function (genericFactory, container, object) {
            return LimitOffsetClause.createFrom(genericFactory, container, Object.assign(object, {
                orderBy: getOrderByFn(genericFactory, container),
            }));
        }
    };

    function getHavingFn(genericFactory, container) {
        return function (rawCondition) {
            var token = new HavingToken(rawCondition);
            var newContainer = cloneSolutionModifierContainer(container, token);
            var orderClause = OrderClause.createFrom(genericFactory, newContainer, {});
            return genericFactory(newContainer, orderClause);
        };
    }
    var HavingClause = {
        createFrom: function (genericFactory, container, object) {
            return OrderClause.createFrom(genericFactory, container, Object.assign(object, {
                having: getHavingFn(genericFactory, container),
            }));
        },
    };

    function getGroupByFn(genericFactory, container) {
        return function (rawCondition) {
            var token = new GroupToken(rawCondition);
            var newContainer = cloneSolutionModifierContainer(container, token);
            var havingClause = HavingClause.createFrom(genericFactory, newContainer, {});
            return genericFactory(newContainer, havingClause);
        };
    }
    var GroupClause = {
        createFrom: function (genericFactory, container, object) {
            return HavingClause.createFrom(genericFactory, container, Object.assign(object, {
                groupBy: getGroupByFn(genericFactory, container),
            }));
        },
    };

    var Pattern = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                getPattern: function () { return container.targetToken; },
            });
        },
    };

    var FinishPattern = {
        createFrom: function (container, object) {
            return Factory.createFrom(Pattern.createFrom, FinishClause.createFrom)(container, object);
        },
    };

    function getWhereFn(container) {
        return function (patterns) {
            var _a;
            var where = new WhereToken();
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            (_a = where.groupPattern.patterns).push.apply(_a, patterns.map(function (x) { return x.getPattern(); }));
            var targetToken = cloneElement(container.targetToken, { where: where });
            var newContainer = cloneElement(container, { targetToken: targetToken });
            var groupClause = GroupClause.createFrom(FinishPattern.createFrom, newContainer, {});
            return FinishPattern.createFrom(newContainer, groupClause);
        };
    }
    var WherePattern = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                where: getWhereFn(container),
            });
        },
    };

    function getSelectFn(container, modifier) {
        return function () {
            var variables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                variables[_i] = arguments[_i];
            }
            var targetToken = new SubSelectToken(modifier);
            if (variables.length)
                targetToken.addVariable.apply(targetToken, variables.map(function (x) { return new VariableToken(x); }));
            var newContainer = new Container({
                iriResolver: container.iriResolver,
                targetToken: targetToken
            });
            return WherePattern.createFrom(newContainer, {});
        };
    }
    var SubSelectPattern = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                select: getSelectFn(container),
                selectDistinct: getSelectFn(container, "DISTINCT"),
                selectReduced: getSelectFn(container, "REDUCED"),
                selectAll: function () { return getSelectFn(container)(); },
                selectAllDistinct: function () { return getSelectFn(container, "DISTINCT")(); },
                selectAllReduced: function () { return getSelectFn(container, "REDUCED")(); },
            });
        },
    };

    var BindToken = (function () {
        function BindToken(expression, variable) {
            this.token = "bind";
            this.expression = expression;
            this.variable = variable;
        }
        BindToken.prototype.toString = function (spaces) {
            return "BIND(" + this.expression + " AS " + this.variable + ")";
        };
        return BindToken;
    }());

    var FilterToken = (function () {
        function FilterToken(constraint) {
            this.token = "filter";
            this.constraint = constraint;
        }
        FilterToken.prototype.toString = function (spaces) {
            return "FILTER( " + this.constraint + " )";
        };
        return FilterToken;
    }());

    var GraphToken = (function () {
        function GraphToken(graph) {
            this.token = "graph";
            this.graph = graph;
            this.groupPattern = new GroupPatternToken();
        }
        GraphToken.prototype.addPattern = function () {
            var pattern = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                pattern[_i] = arguments[_i];
            }
            var _a;
            (_a = this.groupPattern.patterns).push.apply(_a, pattern);
            return this;
        };
        GraphToken.prototype.toString = function (spaces) {
            return "GRAPH " + this.graph + " " + this.groupPattern.toString(spaces);
        };
        return GraphToken;
    }());

    var MinusPatternToken = (function () {
        function MinusPatternToken() {
            this.token = "minusPattern";
            this.groupPattern = new GroupPatternToken();
        }
        MinusPatternToken.prototype.toString = function (spaces) {
            return "MINUS " + this.groupPattern.toString(spaces);
        };
        return MinusPatternToken;
    }());

    var OptionalToken = (function () {
        function OptionalToken() {
            this.token = "optional";
            this.groupPattern = new GroupPatternToken();
        }
        OptionalToken.prototype.addPattern = function () {
            var pattern = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                pattern[_i] = arguments[_i];
            }
            var _a;
            (_a = this.groupPattern.patterns).push.apply(_a, pattern);
            return this;
        };
        OptionalToken.prototype.toString = function (spaces) {
            return "OPTIONAL " + this.groupPattern.toString(spaces);
        };
        return OptionalToken;
    }());

    var ServicePatternToken = (function () {
        function ServicePatternToken(resource, modifier) {
            this.token = "servicePattern";
            this.modifier = modifier;
            this.resource = resource;
            this.groupPattern = new GroupPatternToken();
        }
        ServicePatternToken.prototype.toString = function (spaces) {
            var query = "SERVICE ";
            if (this.modifier)
                query += "SILENT ";
            query += this.resource + " " + this.groupPattern.toString(spaces);
            return query;
        };
        return ServicePatternToken;
    }());

    var UnionPatternToken = (function () {
        function UnionPatternToken() {
            this.token = "unionPattern";
            this.groupPatterns = [];
        }
        UnionPatternToken.prototype.toString = function (spaces) {
            return this
                .groupPatterns
                .map(function (x) { return x.toString(spaces); })
                .join(" UNION ");
        };
        return UnionPatternToken;
    }());

    var NotTriplePattern = {
        createFrom: Pattern.createFrom,
    };

    function getAndFn(container) {
        return function (patterns) {
            var _a;
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            var newGroupToken = new GroupPatternToken();
            (_a = newGroupToken.patterns).push.apply(_a, patterns.map(function (x) { return x.getPattern(); }));
            var groupPatterns = container.targetToken.groupPatterns.concat(newGroupToken);
            var unionToken = cloneElement(container.targetToken, { groupPatterns: groupPatterns });
            var newContainer = new Container({
                iriResolver: container.iriResolver,
                targetToken: unionToken,
            });
            return UnionPattern.createFrom(newContainer, {});
        };
    }
    var UnionPattern = {
        createFrom: function (container, object) {
            return NotTriplePattern.createFrom(container, Object.assign(object, {
                and: getAndFn(container),
            }));
        },
    };

    function getUnionFn(container) {
        return function (patterns) {
            var _a;
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            var newGroupToken = new GroupPatternToken();
            (_a = newGroupToken.patterns).push.apply(_a, patterns.map(function (x) { return x.getPattern(); }));
            var unionToken = new UnionPatternToken();
            unionToken.groupPatterns.push(container.targetToken, newGroupToken);
            var newContainer = new Container({
                iriResolver: container.iriResolver,
                targetToken: unionToken,
            });
            return UnionPattern.createFrom(newContainer, {});
        };
    }
    var GroupPattern = {
        createFrom: function (container, object) {
            return NotTriplePattern.createFrom(container, Object.assign(object, {
                union: getUnionFn(container),
            }));
        }
    };

    function getHasFn(container) {
        return function () {
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            var parsedValues = container.targetToken.values.slice();
            parsedValues.push(values.map(convertValue));
            var targetToken = cloneElement(container.targetToken, { values: parsedValues });
            var newContainer = cloneElement(container, { targetToken: targetToken });
            return MultipleValuesPatternMore.createFrom(newContainer, {});
        };
    }
    var MultipleValuesPattern = {
        createFrom: function (container, object) {
            return NotTriplePattern.createFrom(container, Object.assign(object, {
                has: getHasFn(container),
            }));
        },
    };
    var MultipleValuesPatternMore = {
        createFrom: function (container, object) {
            return NotTriplePattern.createFrom(container, Object.assign(object, {
                and: getHasFn(container),
            }));
        },
    };

    function getHasFn$1(container) {
        return function (value) {
            var values = container.targetToken.values.slice();
            if (!values.length)
                values.push([]);
            values[0] = values[0].concat(convertValue(value));
            var targetToken = cloneElement(container.targetToken, { values: values });
            var newContainer = cloneElement(container, { targetToken: targetToken });
            return SingleValuesPatternMore.createFrom(newContainer, {});
        };
    }
    var SingleValuesPattern = {
        createFrom: function (container, object) {
            return NotTriplePattern.createFrom(container, Object.assign(object, {
                has: getHasFn$1(container),
            }));
        },
    };
    var SingleValuesPatternMore = {
        createFrom: function (container, object) {
            return NotTriplePattern.createFrom(container, Object.assign(object, {
                and: getHasFn$1(container),
            }));
        },
    };

    function _getPatternContainer(container, targetToken) {
        return new Container({
            iriResolver: container.iriResolver,
            targetToken: targetToken,
        });
    }
    function _getPattern(container, token) {
        var patternContainer = _getPatternContainer(container, token);
        return NotTriplePattern.createFrom(patternContainer, {});
    }
    function getGraphFn(container) {
        return function (iriOrVariable, patterns) {
            var varOrIRI = typeof iriOrVariable === "string" ?
                container.iriResolver.resolve(iriOrVariable) :
                iriOrVariable.getSubject();
            var token = new GraphToken(varOrIRI);
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            token.addPattern.apply(token, patterns.map(function (x) { return x.getPattern(); }));
            return _getPattern(container, token);
        };
    }
    function getGroupFn(container) {
        return function (patterns) {
            var _a;
            var token = new GroupPatternToken();
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            (_a = token.patterns).push.apply(_a, patterns.map(function (x) { return x.getPattern(); }));
            var patternContainer = _getPatternContainer(container, token);
            return GroupPattern.createFrom(patternContainer, {});
        };
    }
    function getUnionFn$1(container) {
        return function (patterns) {
            var token = new UnionPatternToken();
            var patternContainer = _getPatternContainer(container, token);
            var unionPattern = UnionPattern
                .createFrom(patternContainer, {});
            return unionPattern.and(patterns);
        };
    }
    function getOptionalFn(container) {
        return function (patterns) {
            var token = new OptionalToken();
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            token.addPattern.apply(token, patterns.map(function (x) { return x.getPattern(); }));
            return _getPattern(container, token);
        };
    }
    function getMinusFn(container) {
        return function (patterns) {
            var _a;
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            var token = new MinusPatternToken();
            (_a = token.groupPattern.patterns).push.apply(_a, patterns.map(function (x) { return x.getPattern(); }));
            return _getPattern(container, token);
        };
    }
    function getServiceFn(container, modifier) {
        return function (resource, patterns) {
            var _a;
            var varOrIRI = typeof resource === "string" ?
                container.iriResolver.resolve(resource) :
                resource.getSubject();
            var token = new ServicePatternToken(varOrIRI, modifier);
            patterns = Array.isArray(patterns) ? patterns : [patterns];
            (_a = token.groupPattern.patterns).push.apply(_a, patterns.map(function (x) { return x.getPattern(); }));
            return _getPattern(container, token);
        };
    }
    function getFilterFn(container) {
        return function (rawConstraint) {
            var token = new FilterToken(rawConstraint);
            return _getPattern(container, token);
        };
    }
    function getBindFn(container) {
        return function (rawExpression, variable) {
            var parsedVar = typeof variable === "string" ?
                new VariableToken(variable) :
                variable.getSubject();
            var token = new BindToken(rawExpression, parsedVar);
            return _getPattern(container, token);
        };
    }
    function getValuesFn(container) {
        return function () {
            var variables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                variables[_i] = arguments[_i];
            }
            var _a;
            var token = new ValuesToken();
            (_a = token.variables).push.apply(_a, variables.map(function (x) { return x.getSubject(); }));
            var patternContainer = _getPatternContainer(container, token);
            if (variables.length === 1)
                return SingleValuesPattern
                    .createFrom(patternContainer, {});
            return MultipleValuesPattern
                .createFrom(patternContainer, {});
        };
    }
    var NotTriplePatternsBuilder = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                undefined: "UNDEF",
                graph: getGraphFn(container),
                group: getGroupFn(container),
                union: getUnionFn$1(container),
                optional: getOptionalFn(container),
                minus: getMinusFn(container),
                service: getServiceFn(container),
                serviceSilent: getServiceFn(container, "SILENT"),
                filter: getFilterFn(container),
                bind: getBindFn(container),
                values: getValuesFn(container),
            });
        },
    };

    var PathAlternativeToken = (function () {
        function PathAlternativeToken() {
            this.token = "pathAlternative";
            this.paths = [];
        }
        PathAlternativeToken.prototype.addPath = function (path) {
            this.paths.push(path);
            return this;
        };
        PathAlternativeToken.prototype.toString = function () {
            return this.paths
                .join("|");
        };
        return PathAlternativeToken;
    }());

    var FluentPathContainer = (function (_super) {
        __extends(FluentPathContainer, _super);
        function FluentPathContainer(data) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, data) || this;
            _this.fluentPathFactory = data.fluentPathFactory;
            _this.deniableFluentPathFactory = data.deniableFluentPathFactory;
            if (_newTarget === FluentPathContainer)
                Object.freeze(_this);
            return _this;
        }
        return FluentPathContainer;
    }(Container));

    function getPropertyToken(container, property) {
        if (property === "a")
            return property;
        if (typeof property === "string")
            return container.iriResolver.resolve(property, true);
        if ("token" in property)
            return property;
        if ("getSubject" in property)
            return property.getSubject();
        return property.getPath();
    }

    var SharedSubPathToken = (function () {
        function SharedSubPathToken(path) {
            this.token = "subPath";
            this.path = path;
        }
        SharedSubPathToken.prototype.toString = function () {
            if (!this.path)
                return "()";
            return "(" + this.path + ")";
        };
        return SharedSubPathToken;
    }());

    function _getTokenWrapper() {
        var symbols = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            symbols[_i] = arguments[_i];
        }
        return function (token) {
            if (token === "a")
                return token;
            if (symbols.indexOf(token.token) !== -1)
                return new SharedSubPathToken(token);
            return token;
        };
    }
    function _isBasePrimitive(token) {
        return token === "a"
            || token.token === "iri"
            || token.token === "prefixedName";
    }
    function _isPathInNegatedToken(token) {
        return _isBasePrimitive(token)
            || (token.token === "pathInverse"
                && _isBasePrimitive(token.path));
    }

    var _getInAlternativeToken = _getTokenWrapper("pathAlternative");
    function getAlternativeFn(container) {
        return function () {
            var paths = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paths[_i] = arguments[_i];
            }
            var _a;
            var tokensParams = paths
                .reduce(function (array, paths) { return array.concat(paths); }, [])
                .map(function (path) { return getPropertyToken(container, path); });
            if (container.targetToken && !(container.targetToken instanceof PathAlternativeToken))
                tokensParams.unshift(container.targetToken);
            var processedTokens = tokensParams
                .map(_getInAlternativeToken);
            if (container.targetToken instanceof PathAlternativeToken)
                processedTokens.unshift.apply(processedTokens, container.targetToken.paths);
            var targetToken = new PathAlternativeToken();
            (_a = targetToken.paths).push.apply(_a, processedTokens);
            var newContainer = new FluentPathContainer(__assign({}, container, { targetToken: targetToken }));
            if (processedTokens.every(_isPathInNegatedToken))
                return container.deniableFluentPathFactory(newContainer, {});
            return container.fluentPathFactory(newContainer, {});
        };
    }

    var PathInverseToken = (function () {
        function PathInverseToken(path) {
            this.token = "pathInverse";
            this.path = path;
        }
        PathInverseToken.prototype.toString = function () {
            return "^" + this.path;
        };
        return PathInverseToken;
    }());

    var _getInInverseToken = _getTokenWrapper("pathAlternative", "pathSequence", "pathInverse");
    function getInverseFn(container) {
        return function (path) {
            var token = container.targetToken
                ? container.targetToken
                : getPropertyToken(container, path);
            var inInverseToken = _getInInverseToken(token);
            var targetToken = new PathInverseToken(inInverseToken);
            var newContainer = new FluentPathContainer(__assign({}, container, { targetToken: targetToken }));
            if (_isBasePrimitive(token))
                return container.deniableFluentPathFactory(newContainer, {});
            return container.fluentPathFactory(newContainer, {});
        };
    }

    var PathModToken = (function () {
        function PathModToken(path, mod) {
            this.token = "pathMod";
            this.path = path;
            this.mod = mod;
        }
        PathModToken.prototype.toString = function () {
            return "" + this.path + this.mod;
        };
        return PathModToken;
    }());

    var _getInModToken = _getTokenWrapper("pathAlternative", "pathSequence", "pathInverse", "pathMod");
    function getModFn(container, mod) {
        return function (path) {
            var token = container.targetToken
                ? container.targetToken
                : getPropertyToken(container, path);
            var inModToken = _getInModToken(token);
            var targetToken = new PathModToken(inModToken, mod);
            var newContainer = new FluentPathContainer(__assign({}, container, { targetToken: targetToken }));
            return container.fluentPathFactory(newContainer, {});
        };
    }

    var PathSequenceToken = (function () {
        function PathSequenceToken() {
            this.token = "pathSequence";
            this.paths = [];
        }
        PathSequenceToken.prototype.addPath = function (path) {
            this.paths.push(path);
            return this;
        };
        PathSequenceToken.prototype.toString = function () {
            return this.paths
                .join("/");
        };
        return PathSequenceToken;
    }());

    var _getInSequenceToken = _getTokenWrapper("pathAlternative", "pathSequence");
    function getSequenceFn(container) {
        return function () {
            var paths = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paths[_i] = arguments[_i];
            }
            var _a;
            var tokensParams = paths
                .reduce(function (array, paths) { return array.concat(paths); }, [])
                .map(function (path) { return getPropertyToken(container, path); });
            if (container.targetToken && !(container.targetToken instanceof PathSequenceToken))
                tokensParams.unshift(container.targetToken);
            var processedTokens = tokensParams
                .map(_getInSequenceToken);
            if (container.targetToken instanceof PathSequenceToken)
                processedTokens.unshift.apply(processedTokens, container.targetToken.paths);
            var targetToken = new PathSequenceToken();
            (_a = targetToken.paths).push.apply(_a, processedTokens);
            var newContainer = new FluentPathContainer(__assign({}, container, { targetToken: targetToken }));
            return container.fluentPathFactory(newContainer, {});
        };
    }

    function _canBeNegated(token) {
        return !token
            || _isPathInNegatedToken(token)
            || (token.token === "pathAlternative" && token.paths.every(_isPathInNegatedToken));
    }
    function getSubPathFn(container) {
        return function (path) {
            var token = container.targetToken
                ? container.targetToken
                : path === void 0 ? path
                    : getPropertyToken(container, path);
            var targetToken = new SharedSubPathToken(token);
            var newContainer = new FluentPathContainer(__assign({}, container, { targetToken: targetToken }));
            if (_canBeNegated(token))
                return container.deniableFluentPathFactory(newContainer, {});
            return container.fluentPathFactory(newContainer, {});
        };
    }

    var Path = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                getPath: function () { return container.targetToken; },
            });
        }
    };

    var FluentPath = {
        createFrom: function (container, object) {
            return Path.createFrom(container, Object.assign(object, {
                subPath: getSubPathFn(container),
                or: getAlternativeFn(container),
                then: getSequenceFn(container),
                inverse: getInverseFn(container),
                oneOrNone: getModFn(container, "?"),
                zeroOrMore: getModFn(container, "*"),
                onceOrMore: getModFn(container, "+"),
            }));
        },
    };

    var PathNegatedToken = (function () {
        function PathNegatedToken(path) {
            this.token = "pathNegated";
            this.path = path;
        }
        PathNegatedToken.prototype.toString = function () {
            return "!" + this.path;
        };
        return PathNegatedToken;
    }());

    var _getInNegatedToken = _getTokenWrapper("pathAlternative");
    function getNegatedFn(container) {
        return function (path) {
            var token = container.targetToken
                ? container.targetToken
                : getPropertyToken(container, path);
            var inNegatedToken = _getInNegatedToken(token);
            var targetToken = new PathNegatedToken(inNegatedToken);
            var newContainer = new FluentPathContainer(__assign({}, container, { targetToken: targetToken }));
            return container.fluentPathFactory(newContainer, {});
        };
    }

    var DeniableFluentPath = {
        createFrom: function (container, object) {
            return FluentPath.createFrom(container, Object.assign(object, {
                negated: getNegatedFn(container),
            }));
        },
    };

    var PathBuilder = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                subPath: getSubPathFn(container),
                alternatives: getAlternativeFn(container),
                sequences: getSequenceFn(container),
                inverse: getInverseFn(container),
                negated: getNegatedFn(container),
                oneOrNone: getModFn(container, "?"),
                zeroOrMore: getModFn(container, "*"),
                onceOrMore: getModFn(container, "+"),
            });
        }
    };

    function _getContainer(container, targetToken) {
        return new FluentPathContainer(__assign({}, container, { targetToken: targetToken, fluentPathFactory: FluentPath.createFrom, deniableFluentPathFactory: DeniableFluentPath.createFrom }));
    }
    function _parseProperty(container, property) {
        var targetToken = getPropertyToken(container, property);
        var newContainer = _getContainer(container, targetToken);
        return DeniableFluentPath.createFrom(newContainer, {});
    }
    function getPathFn(container) {
        return function (propertyOrBuilderFn) {
            if (typeof propertyOrBuilderFn !== "function")
                return _parseProperty(container, propertyOrBuilderFn);
            var newContainer = _getContainer(container);
            var pathBuilder = PathBuilder.createFrom(newContainer, {});
            return propertyOrBuilderFn(pathBuilder);
        };
    }
    var PathsBuilder = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                path: getPathFn(container),
            });
        }
    };

    var BlankNodePropertyToken = (function () {
        function BlankNodePropertyToken() {
            this.token = "blankNodeProperty";
            this.properties = [];
        }
        BlankNodePropertyToken.prototype.addProperty = function (property) {
            this.properties.push(property);
            return this;
        };
        BlankNodePropertyToken.prototype.toString = function (spaces) {
            return getTokenContainerString({
                spaces: spaces,
                tags: { open: "[", close: "]" },
                tokensSeparator: ";",
                tokens: this.properties,
            });
        };
        return BlankNodePropertyToken;
    }());

    var LABEL_REGEX = /^_:[A-Za-z0-9_]([A-Za-z0-9_\-.]*[A-Za-z0-9_\-])?$/;
    var BlankNodeToken = (function () {
        function BlankNodeToken(label) {
            this.token = "blankNode";
            if (!label)
                return;
            if (!LABEL_REGEX.test(label))
                throw new Error("Invalid blank node label.");
            this.label = label;
        }
        BlankNodeToken.prototype.toString = function (spaces) {
            if (this.label)
                return this.label;
            return "[]";
        };
        return BlankNodeToken;
    }());

    var CollectionToken = (function () {
        function CollectionToken() {
            this.token = "collection";
            this.objects = [];
        }
        CollectionToken.prototype.addObject = function () {
            var object = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                object[_i] = arguments[_i];
            }
            var _a;
            (_a = this.objects).push.apply(_a, object);
            return this;
        };
        CollectionToken.prototype.toString = function (spaces) {
            return getTokenContainerString({
                spaces: spaces,
                tags: { open: "(", close: ")" },
                tokens: this.objects,
            });
        };
        return CollectionToken;
    }());

    var SubjectToken = (function () {
        function SubjectToken(subject) {
            this.token = "subject";
            this.subject = subject;
            this.properties = [];
        }
        SubjectToken.prototype.addProperty = function (property) {
            this.properties.push(property);
            return this;
        };
        SubjectToken.prototype.toString = function (spaces) {
            var query = this.subject.toString(spaces);
            var separator = !this.properties.length ? ""
                : (this.subject.token === "collection" || this.subject.token === "blankNodeProperty")
                    && query.includes("\n") ? "\n"
                    : " ";
            var subSpaces = separator === " " ?
                addSpaces(spaces, query.length + 1) :
                addSpaces(spaces, INDENTATION_SPACES);
            var subIndent = getIndentation(subSpaces);
            var properties = this.properties
                .map(function (property) { return property.toString(subSpaces); })
                .join(";" + getSeparator(spaces) + subIndent);
            if (separator === "\n")
                separator += subIndent;
            return query + separator + properties;
        };
        return SubjectToken;
    }());

    var PropertyToken = (function () {
        function PropertyToken(verb) {
            this.token = "property";
            this.verb = verb;
            this.objects = [];
        }
        PropertyToken.prototype.addObject = function () {
            var object = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                object[_i] = arguments[_i];
            }
            var _a;
            (_a = this.objects).push.apply(_a, object);
            return this;
        };
        PropertyToken.prototype.toString = function (spaces) {
            var separator = getSeparator(spaces);
            var verb = "" + this.verb;
            var objectSpaces = addSpaces(spaces, verb.length + 1);
            var objectIndent = getIndentation(objectSpaces);
            var objects = this.objects
                .map(function (object) {
                if (object.token === "collection" || object.token === "blankNodeProperty")
                    return object.toString(spaces);
                return object.toString(objectSpaces);
            })
                .join("," + separator + objectIndent);
            return verb + " " + objects;
        };
        return PropertyToken;
    }());

    function _cloneContainer(container, propertyToken) {
        var properties = container.targetToken.properties.concat(propertyToken);
        var targetToken = cloneElement(container.targetToken, { properties: properties });
        return cloneElement(container, { targetToken: targetToken });
    }
    function _updateContainer(container, propertyToken) {
        container.targetToken.properties.push(propertyToken);
        return container;
    }
    function getHasFn$2(genericFactory, container) {
        return function (property, objects) {
            var verbToken = getPropertyToken(container, property);
            var propertyToken = new PropertyToken(verbToken);
            objects = Array.isArray(objects) ? objects : [objects];
            propertyToken.addObject.apply(propertyToken, objects.map(convertValue));
            var newContainer = container.targetToken.token === "subject" ?
                _cloneContainer(container, propertyToken) :
                _updateContainer(container, propertyToken);
            var genericObject = genericFactory(newContainer, {});
            return PropertyBuilderMore.createFrom(genericFactory, newContainer, genericObject);
        };
    }
    var PropertyBuilder = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                has: getHasFn$2(genericFactory, container),
            });
        }
    };
    var PropertyBuilderMore = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                and: getHasFn$2(genericFactory, container),
            });
        }
    };

    var emptyGenericFactory = function (container, object) { return object; };
    var BlankNodeBuilder = {
        createFrom: function (container, object) {
            return PropertyBuilder.createFrom(emptyGenericFactory, container, object);
        }
    };

    var LANGUAGE_REGEX = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/;
    var LanguageToken = (function () {
        function LanguageToken(tag) {
            this.token = "language";
            if (!LANGUAGE_REGEX.test(tag))
                throw new Error("\"" + tag + "\" is an invalid language tag.");
            this.tag = tag;
        }
        LanguageToken.prototype.toString = function (spaces) {
            return "@" + this.tag;
        };
        return LanguageToken;
    }());

    var TriplePattern = {
        createFrom: Pattern.createFrom,
    };

    var TripleSubject = {
        createFrom: function (container, object) {
            var triplePatternFactory = TriplePattern.createFrom;
            return PropertyBuilder.createFrom(triplePatternFactory, container, Object.assign(object, {
                getSubject: function () { return container.targetToken.subject; },
            }));
        }
    };

    function getWithTypeFn(container) {
        return function (type) {
            if (type in XSD)
                type = XSD[type];
            var iriType = container.iriResolver.resolve(type, true);
            var subject = cloneElement(container.targetToken.subject, { type: iriType });
            var targetToken = cloneElement(container.targetToken, { subject: subject });
            var newContainer = cloneElement(container, { targetToken: targetToken });
            return TripleSubject.createFrom(newContainer, {});
        };
    }
    function getWithLanguageFn(container) {
        return function (language) {
            var langToken = new LanguageToken(language);
            var subject = cloneElement(container.targetToken.subject, { language: langToken });
            var targetToken = cloneElement(container.targetToken, { subject: subject });
            var newContainer = cloneElement(container, { targetToken: targetToken });
            return TripleSubject.createFrom(newContainer, {});
        };
    }
    var RDFLiteral = {
        createFrom: function (container, object) {
            return TripleSubject.createFrom(container, Object.assign(object, {
                withType: getWithTypeFn(container),
                withLanguage: getWithLanguageFn(container),
            }));
        },
    };

    function _getPatternContainer$1(container, token) {
        return new Container({
            iriResolver: container.iriResolver,
            targetToken: new SubjectToken(token),
        });
    }
    function _getTripleSubject(container, token) {
        var patternContainer = _getPatternContainer$1(container, token);
        return TripleSubject.createFrom(patternContainer, {});
    }
    function _getNodeSubject(container, token) {
        var patternContainer = _getPatternContainer$1(container, token);
        return Factory.createFrom(TripleSubject.createFrom, Pattern.createFrom)(patternContainer, {});
    }
    function getResourceFn(container) {
        return function (iri) {
            var token = container.iriResolver.resolve(iri);
            return _getTripleSubject(container, token);
        };
    }
    function getVarFn(container) {
        return function (name) {
            var token = new VariableToken(name);
            return _getTripleSubject(container, token);
        };
    }
    function getLiteralFn(container) {
        return function (value) {
            if (typeof value !== "string") {
                var token_1 = new LiteralToken(value);
                return _getTripleSubject(container, token_1);
            }
            var token = new RDFLiteralToken(value);
            var patternContainer = _getPatternContainer$1(container, token);
            return RDFLiteral.createFrom(patternContainer, {});
        };
    }
    function getCollectionFn(container) {
        return function () {
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            var _a;
            var token = (_a = new CollectionToken()).addObject.apply(_a, values.map(convertValue));
            return _getNodeSubject(container, token);
        };
    }
    function _getBlankNode(container, label) {
        if (label && !label.startsWith("_:"))
            label = "_:" + label;
        var token = new BlankNodeToken(label);
        return _getTripleSubject(container, token);
    }
    function _getBlankNodeProperty(container, builderFn) {
        var token = new BlankNodePropertyToken();
        var builderContainer = new Container({
            iriResolver: container.iriResolver,
            targetToken: token,
        });
        var builder = BlankNodeBuilder.createFrom(builderContainer, {});
        builderFn(builder);
        if (token.properties.length < 1)
            throw new Error("At least one property must be specified by the self builder.");
        return _getNodeSubject(container, token);
    }
    function getBlankNodeFn(container) {
        return function (labelOrBuilderFn) {
            if (typeof labelOrBuilderFn === "function")
                return _getBlankNodeProperty(container, labelOrBuilderFn);
            return _getBlankNode(container, labelOrBuilderFn);
        };
    }
    var TriplePatternsBuilder = {
        createFrom: function (container, object) {
            return Object.assign(object, {
                resource: getResourceFn(container),
                var: getVarFn(container),
                literal: getLiteralFn(container),
                collection: getCollectionFn(container),
                blankNode: getBlankNodeFn(container),
            });
        },
    };

    var PatternBuilder = {
        create: function (iriResolver) {
            var container = new Container({
                iriResolver: iriResolver,
                targetToken: void 0,
            });
            return PatternBuilder
                .createFrom(container, {});
        },
        createFrom: function (container, object) {
            return Factory.createFrom(TriplePatternsBuilder.createFrom, NotTriplePatternsBuilder.createFrom, SubSelectPattern.createFrom, PathsBuilder.createFrom)(container, object);
        },
    };

    function _getPatterns(iriResolver, patternFunction) {
        var patternOrPatterns = patternFunction(PatternBuilder.create(iriResolver));
        var patterns = Array.isArray(patternOrPatterns) ? patternOrPatterns : [patternOrPatterns];
        return patterns.map(function (x) { return x.getPattern(); });
    }
    function getWhereFn$1(genericFactory, container) {
        return function (patternFunction) {
            var _a;
            var iriResolver = new IRIResolver(container.iriResolver);
            var patterns = _getPatterns(iriResolver, patternFunction);
            var query = (_a = cloneElement(container.targetToken.queryClause, { where: new WhereToken() })).addPattern.apply(_a, patterns);
            var queryToken = cloneElement(container.targetToken, { queryClause: query });
            var newContainer = cloneElement(container, { iriResolver: iriResolver, targetToken: queryToken });
            var groupClause = GroupClause.createFrom(genericFactory, newContainer, {});
            return genericFactory(newContainer, groupClause);
        };
    }
    var WhereClause = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                where: getWhereFn$1(genericFactory, container),
            });
        },
    };

    function getFromFn(genericFactory, container, named) {
        return function (iri) {
            var iriResolver = new IRIResolver(container.iriResolver);
            var datasets = container.targetToken.queryClause.datasets
                .concat(new FromToken(iriResolver.resolve(iri), named));
            var queryClause = cloneElement(container.targetToken.queryClause, { datasets: datasets });
            var queryToken = cloneElement(container.targetToken, { queryClause: queryClause });
            var newContainer = cloneElement(container, {
                iriResolver: iriResolver,
                targetToken: queryToken,
            });
            return FromClause.createFrom(genericFactory, newContainer, {});
        };
    }
    var FromClause = {
        createFrom: function (genericFactory, container, object) {
            return WhereClause.createFrom(genericFactory, container, Object.assign(object, {
                from: getFromFn(genericFactory, container),
                fromNamed: getFromFn(genericFactory, container, true),
            }));
        },
    };

    function getSelectFn$1(genericFactory, container) {
        return function () {
            var queryClause = new AskToken();
            var queryToken = cloneElement(container.targetToken, { queryClause: queryClause });
            var newContainer = new Container({
                iriResolver: container.iriResolver,
                targetToken: queryToken,
            });
            return FromClause.createFrom(genericFactory, newContainer, {});
        };
    }
    var AskClause = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                ask: getSelectFn$1(genericFactory, container),
            });
        },
    };

    var SelectToken = (function (_super) {
        __extends(SelectToken, _super);
        function SelectToken(modifier) {
            var _this = _super.call(this, modifier) || this;
            _this.token = "select";
            _this.datasets = [];
            return _this;
        }
        SelectToken.prototype.toString = function (spaces) {
            var query = _super.prototype.toString.call(this, spaces);
            var separator = getSeparator(spaces);
            if (this.datasets.length)
                query += separator + this.datasets.join(separator);
            query += separator + this.where.toString(spaces);
            if (this.modifiers.length)
                query += separator + this.modifiers.join(separator);
            return query;
        };
        return SelectToken;
    }(SharedSelectToken));

    function getSelectFn$2(genericFactory, container, modifier) {
        return function () {
            var variables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                variables[_i] = arguments[_i];
            }
            var queryClause = new SelectToken(modifier);
            if (variables.length)
                queryClause.addVariable.apply(queryClause, variables.map(function (x) { return new VariableToken(x); }));
            var queryToken = cloneElement(container.targetToken, { queryClause: queryClause });
            var newContainer = new Container({
                iriResolver: container.iriResolver,
                targetToken: queryToken,
            });
            return FromClause.createFrom(genericFactory, newContainer, {});
        };
    }
    var SelectClause = {
        createFrom: function (genericFactory, container, object) {
            return Object.assign(object, {
                select: getSelectFn$2(genericFactory, container),
                selectDistinct: getSelectFn$2(genericFactory, container, "DISTINCT"),
                selectReduced: getSelectFn$2(genericFactory, container, "REDUCED"),
                selectAll: function () { return getSelectFn$2(genericFactory, container)(); },
                selectAllDistinct: function () { return getSelectFn$2(genericFactory, container, "DISTINCT")(); },
                selectAllReduced: function () { return getSelectFn$2(genericFactory, container, "REDUCED")(); },
            });
        },
    };

    function base(iri) {
        var token = new BaseToken(new IRIRefToken(iri));
        var prologues = this.targetToken
            .prologues.concat(token);
        var queryToken = cloneElement(this.targetToken, { prologues: prologues });
        var container = cloneElement(this, { targetToken: queryToken });
        return QueryClause.createFrom(container, {});
    }
    function vocab(iri) {
        var iriResolver = new IRIResolver(this.iriResolver, iri);
        var container = cloneElement(this, { iriResolver: iriResolver });
        return QueryClause.createFrom(container, {});
    }
    function prefix(name, iri) {
        var iriResolver = new IRIResolver(this.iriResolver);
        var prologues = this.targetToken.prologues.slice();
        if (iriResolver.prefixes.has(name)) {
            var index = prologues
                .findIndex(function (token) { return token.token === "prefix" && token.namespace === name; });
            if (index !== -1)
                prologues.splice(index, 1);
        }
        prologues.push(new PrefixToken(name, new IRIRefToken(iri)));
        iriResolver.prefixes.set(name, false);
        var queryToken = cloneElement(this.targetToken, { prologues: prologues });
        var container = cloneElement(this, {
            iriResolver: iriResolver,
            targetToken: queryToken,
        });
        return QueryClause.createFrom(container, {});
    }
    var QueryClause = {
        createFrom: function (container, object) {
            var selectFactory = SelectClause
                .createFrom.bind(null, container.selectFinishClauseFactory);
            var askFactory = AskClause
                .createFrom.bind(null, container.askFinishClauseFactory);
            return Factory.createFrom(selectFactory, askFactory)(container, Object.assign(object, {
                base: base.bind(container),
                vocab: vocab.bind(container),
                prefix: prefix.bind(container),
            }));
        },
    };

    var QueryUnitContainer = (function (_super) {
        __extends(QueryUnitContainer, _super);
        function QueryUnitContainer(data) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, data) || this;
            _this.selectFinishClauseFactory = data.selectFinishClauseFactory;
            _this.askFinishClauseFactory = data.askFinishClauseFactory;
            if (_newTarget === QueryUnitContainer)
                Object.freeze(_this);
            return _this;
        }
        return QueryUnitContainer;
    }(Container));

    var QueryToken = (function () {
        function QueryToken(query, values) {
            this.token = "query";
            this.prologues = [];
            this.queryClause = query;
            this.values = values;
        }
        QueryToken.prototype.addPrologues = function () {
            var prologues = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                prologues[_i] = arguments[_i];
            }
            var _a;
            (_a = this.prologues).push.apply(_a, prologues);
            return this;
        };
        QueryToken.prototype.toString = function (spaces) {
            var separator = getSeparator(spaces);
            var query = this.prologues
                .map(function (prologue) {
                if (prologue.token === "base")
                    return prologue + "\n";
                return prologue + separator;
            })
                .join("");
            if (this.queryClause)
                query += this.queryClause.toString(spaces);
            if (this.values)
                query += separator + this.values.toString(spaces);
            return query;
        };
        return QueryToken;
    }());

    var SPARQLER = (function () {
        function SPARQLER(finishSelectFactory, finishAskFactory) {
            if (finishSelectFactory === void 0) { finishSelectFactory = FinishClause.createFrom; }
            if (finishAskFactory === void 0) { finishAskFactory = FinishClause.createFrom; }
            var container = new QueryUnitContainer({
                iriResolver: new IRIResolver(),
                targetToken: new QueryToken(void 0),
                selectFinishClauseFactory: finishSelectFactory,
                askFinishClauseFactory: finishAskFactory,
            });
            return QueryClause.createFrom(container, this);
        }
        return SPARQLER;
    }());



    var index = /*#__PURE__*/Object.freeze({
        FinishClause: FinishClause,
        FromClause: FromClause,
        GroupClause: GroupClause,
        HavingClause: HavingClause,
        LimitClause: LimitClause,
        LimitOffsetClause: LimitOffsetClause,
        OffsetClause: OffsetClause,
        OrderClause: OrderClause,
        QueryClause: QueryClause,
        SelectClause: SelectClause,
        ValuesClause: ValuesClause,
        WhereClause: WhereClause
    });



    var index$1 = /*#__PURE__*/Object.freeze({
        Container: Container,
        Factory: Factory,
        IRIResolver: IRIResolver,
        QueryUnitContainer: QueryUnitContainer
    });



    var index$2 = /*#__PURE__*/Object.freeze({
        isAbsolute: isAbsolute,
        hasProtocol: hasProtocol,
        isRelative: isRelative,
        isIRI: isIRI,
        isBNodeLabel: isBNodeLabel,
        isPrefixed: isPrefixed
    });



    var index$3 = /*#__PURE__*/Object.freeze({
        FinishPattern: FinishPattern,
        SubSelectPattern: SubSelectPattern,
        WherePattern: WherePattern,
        NotTriplePattern: NotTriplePattern,
        GroupPattern: GroupPattern,
        MultipleValuesPattern: MultipleValuesPattern,
        SingleValuesPattern: SingleValuesPattern,
        UnionPattern: UnionPattern,
        DeniableFluentPath: DeniableFluentPath,
        FluentPath: FluentPath,
        FluentPathContainer: FluentPathContainer,
        Path: Path,
        PathBuilder: PathBuilder,
        TriplePattern: TriplePattern,
        TripleSubject: TripleSubject,
        BlankNodeBuilder: BlankNodeBuilder,
        RDFLiteral: RDFLiteral,
        Pattern: Pattern,
        PatternBuilder: PatternBuilder
    });

    var ConstructToken = (function (_super) {
        __extends(ConstructToken, _super);
        function ConstructToken() {
            var _this = _super.call(this) || this;
            _this.token = "construct";
            _this.triples = [];
            return _this;
        }
        ConstructToken.prototype.addTriple = function () {
            var triple = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                triple[_i] = arguments[_i];
            }
            var _a;
            (_a = this.triples).push.apply(_a, triple);
            return this;
        };
        ConstructToken.prototype.toString = function (spaces) {
            var triples = getTokenContainerString({
                spaces: spaces,
                tags: { open: "{", close: "}" },
                tokensSeparator: ".",
                tokens: this.triples,
            });
            var separator = getSeparator(spaces);
            var query = "CONSTRUCT " +
                triples + separator +
                this.where.toString(spaces);
            if (this.modifiers.length)
                query += separator + this.modifiers.join(separator);
            return query;
        };
        return ConstructToken;
    }(SharedQueryClauseToken));



    var index$4 = /*#__PURE__*/Object.freeze({
        BaseToken: BaseToken,
        BindToken: BindToken,
        BlankNodePropertyToken: BlankNodePropertyToken,
        BlankNodeToken: BlankNodeToken,
        CollectionToken: CollectionToken,
        ConstructToken: ConstructToken,
        FilterToken: FilterToken,
        FromToken: FromToken,
        GraphToken: GraphToken,
        GroupPatternToken: GroupPatternToken,
        GroupToken: GroupToken,
        HavingToken: HavingToken,
        IRIRefToken: IRIRefToken,
        LanguageToken: LanguageToken,
        LimitToken: LimitToken,
        LiteralToken: LiteralToken,
        MinusPatternToken: MinusPatternToken,
        OffsetToken: OffsetToken,
        OptionalToken: OptionalToken,
        OrderToken: OrderToken,
        PathAlternativeToken: PathAlternativeToken,
        PathInverseToken: PathInverseToken,
        PathModToken: PathModToken,
        PathNegatedToken: PathNegatedToken,
        PathSequenceToken: PathSequenceToken,
        PrefixedNameToken: PrefixedNameToken,
        PrefixToken: PrefixToken,
        PropertyToken: PropertyToken,
        QueryToken: QueryToken,
        RDFLiteralToken: RDFLiteralToken,
        SelectToken: SelectToken,
        ServicePatternToken: ServicePatternToken,
        SubjectToken: SubjectToken,
        SubSelectToken: SubSelectToken,
        UnionPatternToken: UnionPatternToken,
        ValuesToken: ValuesToken,
        VariableToken: VariableToken,
        WhereToken: WhereToken
    });



    var index$5 = /*#__PURE__*/Object.freeze({
        XSD: XSD
    });

    exports.clauses = index;
    exports.data = index$1;
    exports.iri = index$2;
    exports.patterns = index$3;
    exports.tokens = index$4;
    exports.utils = index$5;
    exports.SPARQLER = SPARQLER;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=sparqler.umd.js.map
