import { IRIResolver } from "../data/IRIResolver";
import { cloneElement } from "../data/utils";
import { PatternBuilder } from "../patterns/PatternBuilder";
import { convertValue } from "../patterns/utils";
import { ValuesToken } from "../tokens/ValuesToken";
import { VariableToken } from "../tokens/VariableToken";
function _normalizeVariables(variableOrVariables) {
    const variables = Array.isArray(variableOrVariables) ? variableOrVariables : [variableOrVariables];
    return variables.map(x => new VariableToken(x));
}
function _normalizeRawValues(valuesOrBuilder, iriResolver, isSingle) {
    let rawValues = typeof valuesOrBuilder === "function" ?
        valuesOrBuilder(PatternBuilder.create(iriResolver)) :
        valuesOrBuilder;
    if (!Array.isArray(rawValues))
        return [[rawValues]];
    if (isSingle)
        rawValues.map(value => [value]);
    if (rawValues.some(Array.isArray))
        return rawValues;
    return [rawValues];
}
function createValuesFn(genericFactory, container) {
    return (variableOrVariables, valuesOrBuilder) => {
        const token = new ValuesToken();
        const variables = _normalizeVariables(variableOrVariables);
        token.addVariables(...variables);
        const isSingle = !Array.isArray(variableOrVariables);
        const iriResolver = new IRIResolver(container.iriResolver);
        const values = _normalizeRawValues(valuesOrBuilder, iriResolver, isSingle);
        values.forEach((valuesRow) => token.addValues(...valuesRow.map(convertValue)));
        const targetToken = cloneElement(container.targetToken, { values: token });
        const newContainer = cloneElement(container, { iriResolver, targetToken });
        return genericFactory(newContainer, {});
    };
}
export const ValuesClause = {
    createFrom(genericFactory, container, object) {
        return Object.assign(object, {
            values: createValuesFn(genericFactory, container),
        });
    },
};

//# sourceMappingURL=ValuesClause.js.map
