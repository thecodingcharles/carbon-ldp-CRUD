{"version":3,"sources":["clauses/QueryClause.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,iBAAiB,CAAC;AAC1C,OAAO,EAAE,WAAW,EAAE,MAAM,qBAAqB,CAAC;AAElD,OAAO,EAAE,YAAY,EAAE,MAAM,eAAe,CAAC;AAE7C,OAAO,EAAE,SAAS,EAAE,MAAM,qBAAqB,CAAC;AAChD,OAAO,EAAE,WAAW,EAAE,MAAM,uBAAuB,CAAC;AACpD,OAAO,EAAE,WAAW,EAAE,MAAM,uBAAuB,CAAC;AAGpD,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AAExC,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAoD9C,SAAS,IAAI,CAA+F,GAAU;IACrH,MAAM,KAAK,GAAa,IAAI,SAAS,CAAE,IAAI,WAAW,CAAE,GAAG,CAAE,CAAE,CAAC;IAEhE,MAAM,SAAS,GAA6B,IAAI,CAAC,WAAW;SAC1D,SAAS,CAAC,MAAM,CAAE,KAAK,CAAE,CAAC;IAE5B,MAAM,UAAU,GAAc,YAAY,CAAE,IAAI,CAAC,WAAW,EAAE,EAAE,SAAS,EAAE,CAAE,CAAC;IAC9E,MAAM,SAAS,GAAmC,YAAY,CAAE,IAAI,EAAE,EAAE,WAAW,EAAE,UAAU,EAAE,CAAE,CAAC;IAEpG,OAAO,WAAW,CAAC,UAAU,CAAE,SAAS,EAAE,EAAE,CAAE,CAAC;AAChD,CAAC;AAKD,SAAS,KAAK,CAA+F,GAAU;IACtH,MAAM,WAAW,GAAe,IAAI,WAAW,CAAE,IAAI,CAAC,WAAW,EAAE,GAAG,CAAE,CAAC;IACzE,MAAM,SAAS,GAAmC,YAAY,CAAE,IAAI,EAAE,EAAE,WAAW,EAAE,CAAE,CAAC;IAExF,OAAO,WAAW,CAAC,UAAU,CAAE,SAAS,EAAE,EAAE,CAAE,CAAC;AAChD,CAAC;AAKD,SAAS,MAAM,CAA+F,IAAW,EAAE,GAAU;IACpI,MAAM,WAAW,GAAe,IAAI,WAAW,CAAE,IAAI,CAAC,WAAW,CAAE,CAAC;IAGpE,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;IAErD,IAAI,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAE,IAAI,CAAE,EAAG;QACtC,MAAM,KAAK,GAAU,SAAS;aAC5B,SAAS,CAAE,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,SAAS,KAAK,IAAI,CAAE,CAAC;QAE7E,IAAI,KAAK,KAAK,CAAE,CAAC;YAChB,SAAS,CAAC,MAAM,CAAE,KAAK,EAAE,CAAC,CAAE,CAAC;KAC9B;IAED,SAAS,CAAC,IAAI,CAAE,IAAI,WAAW,CAAE,IAAI,EAAE,IAAI,WAAW,CAAE,GAAG,CAAE,CAAE,CAAE,CAAC;IAClE,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAE,IAAI,EAAE,KAAK,CAAE,CAAC;IAGxC,MAAM,UAAU,GAAc,YAAY,CAAE,IAAI,CAAC,WAAW,EAAE,EAAE,SAAS,EAAE,CAAE,CAAC;IAC9E,MAAM,SAAS,GAAmC,YAAY,CAAE,IAAI,EAAE;QACrE,WAAW;QACX,WAAW,EAAE,UAAU;KACvB,CAAE,CAAC;IAEJ,OAAO,WAAW,CAAC,UAAU,CAAE,SAAS,EAAE,EAAE,CAAE,CAAC;AAChD,CAAC;AAMD,MAAM,CAAC,MAAM,WAAW,GAcpB;IACH,UAAU,CAAsH,SAAW,EAAE,MAAQ;QACpJ,MAAM,aAAa,GAAoC,YAAY;aACjE,UAAU,CAAC,IAAI,CAAE,IAAI,EAAE,SAAS,CAAC,yBAAyB,CAAE,CAAC;QAC/D,MAAM,UAAU,GAA8B,SAAS;aACrD,UAAU,CAAC,IAAI,CAAE,IAAI,EAAE,SAAS,CAAC,sBAAsB,CAAE,CAAC;QAE5D,OAAO,OAAO,CAAC,UAAU,CACxB,aAAa,EACb,UAAU,CACV,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YACpC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAE,SAAS,CAAE;YAC5B,KAAK,EAAE,KAAK,CAAC,IAAI,CAAE,SAAS,CAAE;YAC9B,MAAM,EAAE,MAAM,CAAC,IAAI,CAAE,SAAS,CAAE;SAChC,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC","file":"QueryClause.js","sourcesContent":["import { Factory } from \"../data/Factory\";\nimport { IRIResolver } from \"../data/IRIResolver\";\nimport { QueryUnitContainer } from \"../data/QueryUnitContainer\";\nimport { cloneElement } from \"../data/utils\";\n\nimport { BaseToken } from \"../tokens/BaseToken\";\nimport { IRIRefToken } from \"../tokens/IRIRefToken\";\nimport { PrefixToken } from \"../tokens/PrefixToken\";\nimport { QueryToken } from \"../tokens/QueryToken\";\n\nimport { AskClause } from \"./AskClause\";\nimport { FinishClause } from \"./FinishClause\";\nimport { SelectClause } from \"./SelectClause\";\n\n\n/**\n * Interface that describes the base entry of any query statement.\n *\n * It allows to add the prologues `BASE` and `PREFIX`.\n * And also add support for specify a `vocab` used to resolve\n * relative properties/predicates.\n *\n * The current query types supported are:\n * - `SELECT`, specified by the extension of {@link SelectClause}\n * - `ASK`, specified by the extension of {@link AskClause}\n */\nexport interface QueryClause<SELECT extends FinishClause, ASK extends FinishClause> extends SelectClause<SELECT>, AskClause<ASK> {\n\t/**\n\t * Add a base IRI the query uses to resolve any relative IRIs.\n\t *\n\t * If a default vocabulary is set with the {@link QueryClause.vocab}\n\t * method, the base is ignored for relative predicates.\n\t *\n\t * @param iri IRI to be used as the query BASE.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tbase( iri:string ):QueryClause<SELECT, ASK>;\n\n\t/**\n\t * Add a default vocabulary to be used to resolve relative IRIs when\n\t * used as a predicate in a triple pattern.\n\t *\n\t * @param iri IRI to append to prepend to any relative predicate.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tvocab( iri:string ):QueryClause<SELECT, ASK>;\n\n\t/**\n\t * Add a prefix to the query.\n\t *\n\t * If the prefix is not used in any part of the query it is not added\n\t * in the compact query string.\n\t *\n\t * @param name Name the prefix will be identified for.\n\t * @param iri The IRI of the current PREFIX.\n\t * @returns Object with the methods to keep constructing the query.\n\t */\n\tprefix( name:string, iri:string ):QueryClause<SELECT, ASK>;\n}\n\n\n/**\n * @see {@link QueryClause.base}\n */\nfunction base<SELECT extends FinishClause, ASK extends FinishClause>( this:QueryUnitContainer<SELECT, ASK>, iri:string ):QueryClause<SELECT, ASK> {\n\tconst token:BaseToken = new BaseToken( new IRIRefToken( iri ) );\n\n\tconst prologues:QueryToken[ \"prologues\" ] = this.targetToken\n\t\t.prologues.concat( token );\n\n\tconst queryToken:QueryToken = cloneElement( this.targetToken, { prologues } );\n\tconst container:QueryUnitContainer<SELECT, ASK> = cloneElement( this, { targetToken: queryToken } );\n\n\treturn QueryClause.createFrom( container, {} );\n}\n\n/**\n * @see {@link QueryClause.vocab}\n */\nfunction vocab<SELECT extends FinishClause, ASK extends FinishClause>( this:QueryUnitContainer<SELECT, ASK>, iri:string ):QueryClause<SELECT, ASK> {\n\tconst iriResolver:IRIResolver = new IRIResolver( this.iriResolver, iri );\n\tconst container:QueryUnitContainer<SELECT, ASK> = cloneElement( this, { iriResolver } );\n\n\treturn QueryClause.createFrom( container, {} );\n}\n\n/**\n * @see {@link QueryClause.prefix}\n */\nfunction prefix<SELECT extends FinishClause, ASK extends FinishClause>( this:QueryUnitContainer<SELECT, ASK>, name:string, iri:string ):QueryClause<SELECT, ASK> {\n\tconst iriResolver:IRIResolver = new IRIResolver( this.iriResolver );\n\n\n\tconst prologues = this.targetToken.prologues.slice();\n\n\tif( iriResolver.prefixes.has( name ) ) {\n\t\tconst index:number = prologues\n\t\t\t.findIndex( token => token.token === \"prefix\" && token.namespace === name );\n\n\t\tif( index !== - 1 )\n\t\t\tprologues.splice( index, 1 );\n\t}\n\n\tprologues.push( new PrefixToken( name, new IRIRefToken( iri ) ) );\n\tiriResolver.prefixes.set( name, false );\n\n\n\tconst queryToken:QueryToken = cloneElement( this.targetToken, { prologues } );\n\tconst container:QueryUnitContainer<SELECT, ASK> = cloneElement( this, {\n\t\tiriResolver,\n\t\ttargetToken: queryToken,\n\t} );\n\n\treturn QueryClause.createFrom( container, {} );\n}\n\n\n/**\n * Constant with the utils functions for {@link QueryClause} objects.\n */\nexport const QueryClause:{\n\t/**\n\t * Factory function that allows to crete a {@link QueryClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link QueryClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link QueryClause} statement.\n\t *\n\t * @return The {@link QueryClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends QueryUnitContainer<SELECT, ASK>, SELECT extends FinishClause, ASK extends FinishClause, T extends object>( container:C, object:T ):T & QueryClause<SELECT, ASK>;\n} = {\n\tcreateFrom<C extends QueryUnitContainer<SELECT, ASK>, SELECT extends FinishClause, ASK extends FinishClause, T extends object>( container:C, object:T ):T & QueryClause<SELECT, ASK> {\n\t\tconst selectFactory:Factory<C, SelectClause<SELECT>> = SelectClause\n\t\t\t.createFrom.bind( null, container.selectFinishClauseFactory );\n\t\tconst askFactory:Factory<C, AskClause<ASK>> = AskClause\n\t\t\t.createFrom.bind( null, container.askFinishClauseFactory );\n\n\t\treturn Factory.createFrom(\n\t\t\tselectFactory,\n\t\t\taskFactory,\n\t\t)( container, Object.assign( object, {\n\t\t\tbase: base.bind( container ),\n\t\t\tvocab: vocab.bind( container ),\n\t\t\tprefix: prefix.bind( container ),\n\t\t} ) );\n\t},\n};"],"sourceRoot":"../../src"}