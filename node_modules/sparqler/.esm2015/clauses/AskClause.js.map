{"version":3,"sources":["clauses/AskClause.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAC;AAE9C,OAAO,EAAE,YAAY,EAAE,MAAM,eAAe,CAAC;AAC7C,OAAO,EAAE,QAAQ,EAAE,MAAM,oBAAoB,CAAC;AAK9C,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAuB1C,SAAS,WAAW,CAA2D,cAA0D,EAAE,SAAW;IACrJ,OAAO,GAAG,EAAE;QACX,MAAM,WAAW,GAAY,IAAI,QAAQ,EAAE,CAAC;QAE5C,MAAM,UAAU,GAAwB,YAAY,CAAE,SAAS,CAAC,WAAW,EAAE,EAAE,WAAW,EAAE,CAAE,CAAC;QAC/F,MAAM,YAAY,GAAmC,IAAI,SAAS,CAAE;YACnE,WAAW,EAAE,SAAS,CAAC,WAAW;YAClC,WAAW,EAAE,UAAU;SACvB,CAAE,CAAC;QAEJ,OAAO,UAAU,CAAC,UAAU,CAAE,cAAc,EAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IAClE,CAAC,CAAC;AACH,CAAC;AAMD,MAAM,CAAC,MAAM,SAAS,GAgBlB;IACH,UAAU,CAA6E,cAA0D,EAAE,SAAW,EAAE,MAAQ;QACvK,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YAC7B,GAAG,EAAE,WAAW,CAAE,cAAc,EAAE,SAAS,CAAE;SAC7C,CAAE,CAAC;IACL,CAAC;CACD,CAAC","file":"AskClause.js","sourcesContent":["import { Container } from \"../data/Container\";\nimport { Factory } from \"../data/Factory\";\nimport { cloneElement } from \"../data/utils\";\nimport { AskToken } from \"../tokens/AskToken\";\n\nimport { QueryToken } from \"../tokens/QueryToken\";\n\nimport { FinishClause } from \"./FinishClause\";\nimport { FromClause } from \"./FromClause\";\n\n\n/**\n * Interface with the methods available to make a ASK query.\n */\nexport interface AskClause<T extends FinishClause> {\n\t/**\n\t * Set that the query will ask for a pattern matching.\n\t */\n\task():FromClause<T>;\n}\n\n\n/**\n * Function that creates a {@link AskClause.ask} function.\n *\n * @param genericFactory The factory for the generic {@link FinishClause}\n * that the {@link AskClause} receives.\n * @param container The container with the query data for the statement.\n *\n * @private\n */\nfunction getSelectFn<C extends Container<QueryToken>, T extends FinishClause>( genericFactory:Factory<Container<QueryToken<AskToken>>, T>, container:C ):AskClause<T>[ \"ask\" ] {\n\treturn () => {\n\t\tconst queryClause:AskToken = new AskToken();\n\n\t\tconst queryToken:QueryToken<AskToken> = cloneElement( container.targetToken, { queryClause } );\n\t\tconst newContainer:Container<QueryToken<AskToken>> = new Container( {\n\t\t\tiriResolver: container.iriResolver,\n\t\t\ttargetToken: queryToken,\n\t\t} );\n\n\t\treturn FromClause.createFrom( genericFactory, newContainer, {} );\n\t};\n}\n\n\n/**\n * Constant with the utils for {@link AskClause} objects.\n */\nexport const AskClause:{\n\t/**\n\t * Factory function that allows to crete a {@link AskClause}\n\t * from the {@param object} provided.\n\t *\n\t * @param genericFactory The factory to create the generic finish\n\t * of the {@link AskClause} statement.\n\t * @param container The related container with the data for the\n\t * {@link AskClause} statement.\n\t * @param object The base base from where to create the\n\t * {@link AskClause} statement.\n\t *\n\t * @return The {@link AskClause} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<C extends Container<QueryToken>, T extends FinishClause, O extends object>( genericFactory:Factory<Container<QueryToken<AskToken>>, T>, container:C, object:O ):O & AskClause<T>;\n} = {\n\tcreateFrom<C extends Container<QueryToken>, T extends FinishClause, O extends object>( genericFactory:Factory<Container<QueryToken<AskToken>>, T>, container:C, object:O ):O & AskClause<T> {\n\t\treturn Object.assign( object, {\n\t\t\task: getSelectFn( genericFactory, container ),\n\t\t} );\n\t},\n};"],"sourceRoot":"../../src"}