import { Container } from "../../data/Container";
import { BindToken } from "../../tokens/BindToken";
import { FilterToken } from "../../tokens/FilterToken";
import { GraphToken } from "../../tokens/GraphToken";
import { GroupPatternToken } from "../../tokens/GroupPatternToken";
import { MinusPatternToken } from "../../tokens/MinusPatternToken";
import { OptionalToken } from "../../tokens/OptionalToken";
import { ServicePatternToken } from "../../tokens/ServicePatternToken";
import { UnionPatternToken } from "../../tokens/UnionPatternToken";
import { ValuesToken } from "../../tokens/ValuesToken";
import { VariableToken } from "../../tokens/VariableToken";
import { GroupPattern } from "./GroupPattern";
import { MultipleValuesPattern } from "./MultipleValuesPattern";
import { NotTriplePattern } from "./NotTriplePattern";
import { SingleValuesPattern } from "./SingleValuesPattern";
import { UnionPattern } from "./UnionPattern";
function _getPatternContainer(container, targetToken) {
    return new Container({
        iriResolver: container.iriResolver,
        targetToken,
    });
}
function _getPattern(container, token) {
    const patternContainer = _getPatternContainer(container, token);
    return NotTriplePattern.createFrom(patternContainer, {});
}
function getGraphFn(container) {
    return (iriOrVariable, patterns) => {
        const varOrIRI = typeof iriOrVariable === "string" ?
            container.iriResolver.resolve(iriOrVariable) :
            iriOrVariable.getSubject();
        const token = new GraphToken(varOrIRI);
        patterns = Array.isArray(patterns) ? patterns : [patterns];
        token.addPattern(...patterns.map(x => x.getPattern()));
        return _getPattern(container, token);
    };
}
function getGroupFn(container) {
    return (patterns) => {
        const token = new GroupPatternToken();
        patterns = Array.isArray(patterns) ? patterns : [patterns];
        token.patterns.push(...patterns.map(x => x.getPattern()));
        const patternContainer = _getPatternContainer(container, token);
        return GroupPattern.createFrom(patternContainer, {});
    };
}
function getUnionFn(container) {
    return (patterns) => {
        const token = new UnionPatternToken();
        const patternContainer = _getPatternContainer(container, token);
        const unionPattern = UnionPattern
            .createFrom(patternContainer, {});
        return unionPattern.and(patterns);
    };
}
function getOptionalFn(container) {
    return (patterns) => {
        const token = new OptionalToken();
        patterns = Array.isArray(patterns) ? patterns : [patterns];
        token.addPattern(...patterns.map(x => x.getPattern()));
        return _getPattern(container, token);
    };
}
function getMinusFn(container) {
    return (patterns) => {
        patterns = Array.isArray(patterns) ? patterns : [patterns];
        const token = new MinusPatternToken();
        token.groupPattern.patterns
            .push(...patterns.map(x => x.getPattern()));
        return _getPattern(container, token);
    };
}
function getServiceFn(container, modifier) {
    return (resource, patterns) => {
        const varOrIRI = typeof resource === "string" ?
            container.iriResolver.resolve(resource) :
            resource.getSubject();
        const token = new ServicePatternToken(varOrIRI, modifier);
        patterns = Array.isArray(patterns) ? patterns : [patterns];
        token.groupPattern.patterns
            .push(...patterns.map(x => x.getPattern()));
        return _getPattern(container, token);
    };
}
function getFilterFn(container) {
    return (rawConstraint) => {
        const token = new FilterToken(rawConstraint);
        return _getPattern(container, token);
    };
}
function getBindFn(container) {
    return (rawExpression, variable) => {
        const parsedVar = typeof variable === "string" ?
            new VariableToken(variable) :
            variable.getSubject();
        const token = new BindToken(rawExpression, parsedVar);
        return _getPattern(container, token);
    };
}
function getValuesFn(container) {
    return (...variables) => {
        const token = new ValuesToken();
        token.variables.push(...variables.map(x => x.getSubject()));
        const patternContainer = _getPatternContainer(container, token);
        if (variables.length === 1)
            return SingleValuesPattern
                .createFrom(patternContainer, {});
        return MultipleValuesPattern
            .createFrom(patternContainer, {});
    };
}
export const NotTriplePatternsBuilder = {
    createFrom(container, object) {
        return Object.assign(object, {
            undefined: "UNDEF",
            graph: getGraphFn(container),
            group: getGroupFn(container),
            union: getUnionFn(container),
            optional: getOptionalFn(container),
            minus: getMinusFn(container),
            service: getServiceFn(container),
            serviceSilent: getServiceFn(container, "SILENT"),
            filter: getFilterFn(container),
            bind: getBindFn(container),
            values: getValuesFn(container),
        });
    },
};

//# sourceMappingURL=NotTriplePatternsBuilder.js.map
