import { PathAlternativeToken } from "../../../tokens/PathAlternativeToken";
import { FluentPathContainer } from "../FluentPathContainer";
import { getPropertyToken } from "../utils";
import { _getTokenWrapper, _isPathInNegatedToken } from "./utils";
const _getInAlternativeToken = _getTokenWrapper("pathAlternative");
export function getAlternativeFn(container) {
    return (...paths) => {
        const tokensParams = paths
            .reduce((array, paths) => array.concat(paths), [])
            .map(path => getPropertyToken(container, path));
        if (container.targetToken && !(container.targetToken instanceof PathAlternativeToken))
            tokensParams.unshift(container.targetToken);
        const processedTokens = tokensParams
            .map(_getInAlternativeToken);
        if (container.targetToken instanceof PathAlternativeToken)
            processedTokens.unshift(...container.targetToken.paths);
        const targetToken = new PathAlternativeToken();
        targetToken.paths.push(...processedTokens);
        const newContainer = new FluentPathContainer(Object.assign({}, container, { targetToken }));
        if (processedTokens.every(_isPathInNegatedToken))
            return container.deniableFluentPathFactory(newContainer, {});
        return container.fluentPathFactory(newContainer, {});
    };
}

//# sourceMappingURL=alternativeFn.js.map
