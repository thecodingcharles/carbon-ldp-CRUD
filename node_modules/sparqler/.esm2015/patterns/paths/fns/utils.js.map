{"version":3,"sources":["patterns/paths/fns/utils.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,kBAAkB,EAAE,MAAM,oCAAoC,CAAC;AAcxE,MAAM,UAAU,gBAAgB,CAAuB,GAAG,OAAgB;IACzE,OAAO,CAAE,KAAe,EAAO,EAAE;QAChC,IAAI,KAAK,KAAK,GAAG;YAAG,OAAO,KAAK,CAAC;QAEjC,IAAI,OAAO,CAAC,OAAO,CAAE,KAAK,CAAC,KAAK,CAAE,KAAK,CAAE,CAAC;YACzC,OAAO,IAAI,kBAAkB,CAAE,KAAK,CAAE,CAAC;QAExC,OAAO,KAAK,CAAC;IACd,CAAC,CAAA;AACF,CAAC;AAUD,MAAM,UAAU,gBAAgB,CAAE,KAAe;IAChD,OAAO,KAAK,KAAK,GAAG;WAChB,KAAK,CAAC,KAAK,KAAK,KAAK;WACrB,KAAK,CAAC,KAAK,KAAK,cAAc,CAChC;AACH,CAAC;AAQD,MAAM,UAAU,qBAAqB,CAAE,KAAe;IACrD,OAAO,gBAAgB,CAAE,KAAK,CAAE;WAC5B,CACF,KAAK,CAAC,KAAK,KAAK,aAAa;eAC1B,gBAAgB,CAAE,KAAK,CAAC,IAAI,CAAE,CACjC,CAAC;AACJ,CAAC","file":"utils.js","sourcesContent":["import { IRIToken } from \"../../../tokens/IRIToken\";\nimport { PathInNegatedToken } from \"../../../tokens/PathInNegatedToken\";\nimport { PathToken } from \"../../../tokens/PathToken\";\nimport { SharedSubPathToken } from \"../../../tokens/SharedSubPathToken\";\n\n\n/**\n * Create a function that will wrap into a sub-path any token\n * matched by the symbols provided.\n *\n * The match is calculated comparing a symbol provided with the\n * {@link TokenNode.token} property.\n *\n * @param symbols The name of the tokens to be wrapped.\n *\n * @private\n */\nexport function _getTokenWrapper<T extends PathToken>( ...symbols:string[] ):( token:PathToken ) => T {\n\treturn ( token:PathToken ):any => {\n\t\tif( token === \"a\" ) return token;\n\n\t\tif( symbols.indexOf( token.token ) !== - 1 )\n\t\t\treturn new SharedSubPathToken( token );\n\n\t\treturn token;\n\t}\n}\n\n\n/**\n * Verify the token provided is a base token primitive.\n * i.e. if the token is `\"a\"` or a {@link IRIToken}.\n *\n * @param token the token to be verified.\n * @private\n */\nexport function _isBasePrimitive( token:PathToken ):token is IRIToken | \"a\" {\n\treturn token === \"a\"\n\t\t|| token.token === \"iri\"\n\t\t|| token.token === \"prefixedName\"\n\t\t;\n}\n\n/**\n * Verify is the token provided is a {@link PathInNegatedToken}.\n *\n * @param token The token to be verified.\n * @private\n */\nexport function _isPathInNegatedToken( token:PathToken ):token is PathInNegatedToken {\n\treturn _isBasePrimitive( token )\n\t\t|| (\n\t\t\ttoken.token === \"pathInverse\"\n\t\t\t&& _isBasePrimitive( token.path )\n\t\t);\n}\n"],"sourceRoot":"../../../../src"}