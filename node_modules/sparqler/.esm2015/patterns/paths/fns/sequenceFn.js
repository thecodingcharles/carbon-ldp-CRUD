import { PathSequenceToken } from "../../../tokens/PathSequenceToken";
import { FluentPathContainer } from "../FluentPathContainer";
import { getPropertyToken } from "../utils";
import { _getTokenWrapper } from "./utils";
const _getInSequenceToken = _getTokenWrapper("pathAlternative", "pathSequence");
export function getSequenceFn(container) {
    return (...paths) => {
        const tokensParams = paths
            .reduce((array, paths) => array.concat(paths), [])
            .map(path => getPropertyToken(container, path));
        if (container.targetToken && !(container.targetToken instanceof PathSequenceToken))
            tokensParams.unshift(container.targetToken);
        const processedTokens = tokensParams
            .map(_getInSequenceToken);
        if (container.targetToken instanceof PathSequenceToken)
            processedTokens.unshift(...container.targetToken.paths);
        const targetToken = new PathSequenceToken();
        targetToken.paths.push(...processedTokens);
        const newContainer = new FluentPathContainer(Object.assign({}, container, { targetToken }));
        return container.fluentPathFactory(newContainer, {});
    };
}

//# sourceMappingURL=sequenceFn.js.map
