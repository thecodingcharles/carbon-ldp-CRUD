{"version":3,"sources":["patterns/paths/fns/sequenceFn.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,iBAAiB,EAAE,MAAM,mCAAmC,CAAC;AAMtE,OAAO,EAAE,mBAAmB,EAAE,MAAM,wBAAwB,CAAC;AAE7D,OAAO,EAAE,gBAAgB,EAAE,MAAM,UAAU,CAAC;AAE5C,OAAO,EAAE,gBAAgB,EAAE,MAAM,SAAS,CAAC;AAK3C,MAAM,mBAAmB,GAAG,gBAAgB,CAAuB,iBAAiB,EAAE,cAAc,CAAE,CAAC;AAMvG,MAAM,UAAU,aAAa,CAAE,SAAoD;IAClF,OAAO,CAAE,GAAG,KAAuC,EAAO,EAAE;QAC3D,MAAM,YAAY,GAAe,KAAK;aACpC,MAAM,CAAkB,CAAE,KAAK,EAAE,KAAK,EAAG,EAAE,CAAC,KAAK,CAAC,MAAM,CAAE,KAAK,CAAE,EAAE,EAAE,CAAE;aACvE,GAAG,CAAE,IAAI,CAAC,EAAE,CAAC,gBAAgB,CAAE,SAAS,EAAE,IAAI,CAAE,CAAE,CAAC;QAGrD,IAAI,SAAS,CAAC,WAAW,IAAI,CAAE,CAAC,SAAS,CAAC,WAAW,YAAY,iBAAiB,CAAC;YAClF,YAAY,CAAC,OAAO,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;QAE/C,MAAM,eAAe,GAAyB,YAAY;aACxD,GAAG,CAAE,mBAAmB,CAAE,CAAC;QAG7B,IAAI,SAAS,CAAC,WAAW,YAAY,iBAAiB;YACrD,eAAe,CAAC,OAAO,CAAE,GAAG,SAAS,CAAC,WAAW,CAAC,KAAK,CAAE,CAAC;QAG3D,MAAM,WAAW,GAAqB,IAAI,iBAAiB,EAAE,CAAC;QAC9D,WAAW,CAAC,KAAK,CAAC,IAAI,CAAE,GAAG,eAAe,CAAE,CAAC;QAE7C,MAAM,YAAY,GAA0C,IAAI,mBAAmB,mBAC/E,SAAS,IACZ,WAAW,IACT,CAAC;QAEJ,OAAO,SAAS,CAAC,iBAAiB,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IACxD,CAAC,CAAA;AACF,CAAC","file":"sequenceFn.js","sourcesContent":["import { PathInSequenceToken } from \"../../../tokens/PathInSequenceToken\";\nimport { PathSequenceToken } from \"../../../tokens/PathSequenceToken\";\nimport { PathToken } from \"../../../tokens/PathToken\";\n\nimport { Resource } from \"../../triplePatterns/Resource\";\n\nimport { FluentPath } from \"../FluentPath\";\nimport { FluentPathContainer } from \"../FluentPathContainer\";\nimport { Path } from \"../Path\";\nimport { getPropertyToken } from \"../utils\";\n\nimport { _getTokenWrapper } from \"./utils\";\n\n\ntype TargetParams = Resource | \"a\" | string | Path<PathToken>;\n\nconst _getInSequenceToken = _getTokenWrapper<PathInSequenceToken>( \"pathAlternative\", \"pathSequence\" );\n\n\nexport type SequenceFn = ( ...paths:((Resource | \"a\" | string | Path<PathToken>) | (Resource | \"a\" | string | Path<PathToken>)[])[] )\n\t=> FluentPath<PathSequenceToken>;\n\nexport function getSequenceFn( container:FluentPathContainer<undefined | PathToken> ):SequenceFn {\n\treturn ( ...paths:(TargetParams | TargetParams[])[] ):any => {\n\t\tconst tokensParams:PathToken[] = paths\n\t\t\t.reduce<TargetParams[]>( ( array, paths ) => array.concat( paths ), [] )\n\t\t\t.map( path => getPropertyToken( container, path ) );\n\n\t\t// [In FluentPath] Add to process when not sequence\n\t\tif( container.targetToken && ! (container.targetToken instanceof PathSequenceToken) )\n\t\t\ttokensParams.unshift( container.targetToken );\n\n\t\tconst processedTokens:PathInSequenceToken[] = tokensParams\n\t\t\t.map( _getInSequenceToken );\n\n\t\t// [In FluentPath] Extends if path alternative, not process needed\n\t\tif( container.targetToken instanceof PathSequenceToken )\n\t\t\tprocessedTokens.unshift( ...container.targetToken.paths );\n\n\n\t\tconst targetToken:PathSequenceToken = new PathSequenceToken();\n\t\ttargetToken.paths.push( ...processedTokens );\n\n\t\tconst newContainer:FluentPathContainer<PathSequenceToken> = new FluentPathContainer( {\n\t\t\t...container,\n\t\t\ttargetToken,\n\t\t} );\n\n\t\treturn container.fluentPathFactory( newContainer, {} );\n\t}\n}"],"sourceRoot":"../../../../src"}