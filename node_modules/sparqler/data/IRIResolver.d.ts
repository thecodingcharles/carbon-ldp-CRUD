import { IRIToken } from "../tokens/IRIToken";
/**
 * Map type of the stored prefixes used by {@link IRIResolver}.
 */
export declare type PrefixMap = Map<string, boolean>;
/**
 * Class to manage the resolution of IRIs in tokens
 */
export declare class IRIResolver {
    /**
     * Map to store prefixes and information of its usage
     */
    readonly prefixes: PrefixMap;
    /**
     * IRI to resolve relative RDF properties
     */
    readonly vocab?: string;
    /**
     * Creates a new empty instance of IRIResolver if no parameter is provided, but
     * if a base IRIResolver is specified, its information will be copied to the new instance.
     *
     * @param base IRIResolver to copy its data from.
     * @param vocab Absolute IRI to change the default vocab value.
     */
    constructor(base?: IRIResolver, vocab?: string);
    /**
     * Resolves (if necessary) and creates the respective tokens if the IRI provided.
     *
     * If vocab parameter is to `true`, the stored vocab IRI is used to resolve relative IRIs.
     *
     * @param relativeIRI The relative IRI to be resolved and tokenized.
     * @param vocab Optional parameter to specified if the relative IRIs will be resolved with the stored vocab IRI.
     * @returns An array of tokens representing the provided IRI to be used in the SPARQL query.
     */
    resolve(relativeIRI: string, vocab?: boolean): IRIToken;
    private resolveIRIRef;
    private resolvePrefixed;
}
