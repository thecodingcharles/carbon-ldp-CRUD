{"version":3,"sources":["patterns/paths/fns/subPathFn.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,kBAAkB,EAAE,MAAM,oCAAoC,CAAC;AAQxE,OAAO,EAAE,mBAAmB,EAAE,MAAM,wBAAwB,CAAC;AAG7D,OAAO,EAAE,gBAAgB,EAAE,MAAM,UAAU,CAAC;AAC5C,OAAO,EAAE,qBAAqB,EAAE,MAAM,SAAS,CAAC;AAKhD,SAAS,aAAa,CAAE,KAA2B;IAClD,OAAO,CAAE,KAAK;WACV,qBAAqB,CAAE,KAAK,CAAE;WAC9B,CAAC,KAAK,CAAC,KAAK,KAAK,iBAAiB,IAAI,KAAK,CAAC,KAAK,CAAC,KAAK,CAAE,qBAAqB,CAAE,CAAC,CACnF;AACH,CAAC;AAMD,MAAM,UAAU,YAAY,CAAuB,SAAoD;IACtG,OAAO,UAAE,IAA+C;QACvD,IAAM,KAAK,GAAyB,SAAS,CAAC,WAAW;YAExD,CAAC,CAAC,SAAS,CAAC,WAAW;YAEvB,CAAC,CAAC,IAAI,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI;gBACvB,CAAC,CAAC,gBAAgB,CAAE,SAAS,EAAE,IAAI,CAAE,CAAC;QAGxC,IAAM,WAAW,GAAkB,IAAI,kBAAkB,CAAE,KAAK,CAAoB,CAAC;QAErF,IAAM,YAAY,GAAuC,IAAI,mBAAmB,sBAC5E,SAAS,IACZ,WAAW,aAAA,IACT,CAAC;QAGJ,IAAI,aAAa,CAAE,KAAK,CAAE;YACzB,OAAO,SAAS,CAAC,yBAAyB,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;QAEhE,OAAO,SAAS,CAAC,iBAAiB,CAAE,YAAY,EAAE,EAAE,CAAS,CAAC;IAC/D,CAAC,CAAC;AACH,CAAC","file":"subPathFn.js","sourcesContent":["import { PathInNegatedToken } from \"../../../tokens/PathInNegatedToken\";\nimport { PathToken } from \"../../../tokens/PathToken\";\nimport { SharedSubPathToken } from \"../../../tokens/SharedSubPathToken\";\nimport { SubPathInNegatedToken } from \"../../../tokens/SubPathInNegatedToken\";\nimport { SubPathToken } from \"../../../tokens/SubPathToken\";\n\nimport { Resource } from \"../../triplePatterns/Resource\";\nimport { DeniableFluentPath } from \"../DeniableFluentPath\";\n\nimport { FluentPath } from \"../FluentPath\";\nimport { FluentPathContainer } from \"../FluentPathContainer\";\n\nimport { Path } from \"../Path\";\nimport { getPropertyToken } from \"../utils\";\nimport { _isPathInNegatedToken } from \"./utils\";\n\n\ntype TargetToken<T extends PathToken = PathToken> = SubPathToken<T> & SubPathInNegatedToken;\n\nfunction _canBeNegated( token:PathToken | undefined ):boolean {\n\treturn ! token\n\t\t|| _isPathInNegatedToken( token )\n\t\t|| (token.token === \"pathAlternative\" && token.paths.every( _isPathInNegatedToken ))\n\t\t;\n}\n\n\nexport type SubPathFn<T extends PathToken = PathToken> = ( path?:Resource | \"a\" | string | Path<PathToken> ) =>\n\t(T extends PathInNegatedToken ? DeniableFluentPath<SubPathToken<T>> : FluentPath<SubPathToken<T>>) & DeniableFluentPath<SubPathInNegatedToken>;\n\nexport function getSubPathFn<T extends PathToken>( container:FluentPathContainer<undefined | PathToken> ):SubPathFn<T> {\n\treturn ( path?:Resource | \"a\" | string | Path<PathToken> ) => {\n\t\tconst token:PathToken | undefined = container.targetToken\n\t\t\t// Is in FluentPath\n\t\t\t? container.targetToken\n\t\t\t// Is in PathBuilder\n\t\t\t: path === void 0 ? path\n\t\t\t\t: getPropertyToken( container, path );\n\n\n\t\tconst targetToken:TargetToken<T> = new SharedSubPathToken( token ) as TargetToken<T>;\n\n\t\tconst newContainer:FluentPathContainer<TargetToken<T>> = new FluentPathContainer( {\n\t\t\t...container,\n\t\t\ttargetToken,\n\t\t} );\n\n\n\t\tif( _canBeNegated( token ) )\n\t\t\treturn container.deniableFluentPathFactory( newContainer, {} );\n\n\t\treturn container.fluentPathFactory( newContainer, {} ) as any;\n\t};\n}\n"],"sourceRoot":"../../../../src"}