{"version":3,"sources":["patterns/paths/fns/inverseFn.ts"],"names":[],"mappings":";AAGA,OAAO,EAAE,gBAAgB,EAAE,MAAM,kCAAkC,CAAC;AAOpE,OAAO,EAAE,mBAAmB,EAAE,MAAM,wBAAwB,CAAC;AAE7D,OAAO,EAAE,gBAAgB,EAAE,MAAM,UAAU,CAAC;AAE5C,OAAO,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,MAAM,SAAS,CAAC;AAO7D,IAAM,kBAAkB,GAAG,gBAAgB,CAAgB,iBAAiB,EAAE,cAAc,EAAE,aAAa,CAAE,CAAC;AAM9G,MAAM,UAAU,YAAY,CAAuB,SAAoD;IACtG,OAAO,UAAE,IAAkB;QAC1B,IAAM,KAAK,GAAa,SAAS,CAAC,WAAW;YAE5C,CAAC,CAAC,SAAS,CAAC,WAAW;YAEvB,CAAC,CAAC,gBAAgB,CAAE,SAAS,EAAE,IAAK,CAAE,CAAC;QAExC,IAAM,cAAc,GAAgB,kBAAkB,CAAE,KAAK,CAAE,CAAC;QAChE,IAAM,WAAW,GAAe,IAAI,gBAAgB,CAAE,cAAc,CAAiB,CAAC;QAEtF,IAAM,YAAY,GAAoC,IAAI,mBAAmB,sBACzE,SAAS,IACZ,WAAW,aAAA,IACT,CAAC;QAGJ,IAAI,gBAAgB,CAAE,KAAK,CAAE;YAC5B,OAAO,SAAS,CAAC,yBAAyB,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;QAEhE,OAAO,SAAS,CAAC,iBAAiB,CAAE,YAAY,EAAE,EAAE,CAAS,CAAC;IAC/D,CAAC,CAAA;AACF,CAAC","file":"inverseFn.js","sourcesContent":["import { IRIToken } from \"../../../tokens/IRIToken\";\nimport { PathEltToken } from \"../../../tokens/PathEltToken\";\nimport { PathInNegatedToken } from \"../../../tokens/PathInNegatedToken\";\nimport { PathInverseToken } from \"../../../tokens/PathInverseToken\";\nimport { PathToken } from \"../../../tokens/PathToken\";\n\nimport { Resource } from \"../../triplePatterns/Resource\";\n\nimport { DeniableFluentPath } from \"../DeniableFluentPath\";\nimport { FluentPath } from \"../FluentPath\";\nimport { FluentPathContainer } from \"../FluentPathContainer\";\nimport { Path } from \"../Path\";\nimport { getPropertyToken } from \"../utils\";\n\nimport { _getTokenWrapper, _isBasePrimitive } from \"./utils\";\n\n\ntype TargetToken = PathInverseToken<IRIToken | \"a\"> & PathInverseToken;\n\ntype TargetParams = Resource | \"a\" | string | Path<PathToken>;\n\nconst _getInInverseToken = _getTokenWrapper<PathEltToken>( \"pathAlternative\", \"pathSequence\", \"pathInverse\" );\n\n\nexport type InverseFn<T extends PathToken> = ( path?:Resource | \"a\" | string | Path<PathToken> )\n\t=> DeniableFluentPath<PathInverseToken<IRIToken | \"a\">> & (T extends PathInNegatedToken ? DeniableFluentPath<PathInverseToken<IRIToken | \"a\">> : FluentPath<PathInverseToken>);\n\nexport function getInverseFn<T extends PathToken>( container:FluentPathContainer<undefined | PathToken> ):InverseFn<T> {\n\treturn ( path?:TargetParams ) => {\n\t\tconst token:PathToken = container.targetToken\n\t\t\t// In FluentPath\n\t\t\t? container.targetToken\n\t\t\t// In PathBuilder\n\t\t\t: getPropertyToken( container, path! );\n\n\t\tconst inInverseToken:PathEltToken = _getInInverseToken( token );\n\t\tconst targetToken:TargetToken = new PathInverseToken( inInverseToken ) as TargetToken;\n\n\t\tconst newContainer:FluentPathContainer<TargetToken> = new FluentPathContainer( {\n\t\t\t...container,\n\t\t\ttargetToken,\n\t\t} );\n\n\n\t\tif( _isBasePrimitive( token ) )\n\t\t\treturn container.deniableFluentPathFactory( newContainer, {} );\n\n\t\treturn container.fluentPathFactory( newContainer, {} ) as any;\n\t}\n}"],"sourceRoot":"../../../../src"}