import * as tslib_1 from "tslib";
import { PathAlternativeToken } from "../../../tokens/PathAlternativeToken";
import { FluentPathContainer } from "../FluentPathContainer";
import { getPropertyToken } from "../utils";
import { _getTokenWrapper, _isPathInNegatedToken } from "./utils";
var _getInAlternativeToken = _getTokenWrapper("pathAlternative");
export function getAlternativeFn(container) {
    return function () {
        var paths = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            paths[_i] = arguments[_i];
        }
        var _a;
        var tokensParams = paths
            .reduce(function (array, paths) { return array.concat(paths); }, [])
            .map(function (path) { return getPropertyToken(container, path); });
        if (container.targetToken && !(container.targetToken instanceof PathAlternativeToken))
            tokensParams.unshift(container.targetToken);
        var processedTokens = tokensParams
            .map(_getInAlternativeToken);
        if (container.targetToken instanceof PathAlternativeToken)
            processedTokens.unshift.apply(processedTokens, container.targetToken.paths);
        var targetToken = new PathAlternativeToken();
        (_a = targetToken.paths).push.apply(_a, processedTokens);
        var newContainer = new FluentPathContainer(tslib_1.__assign({}, container, { targetToken: targetToken }));
        if (processedTokens.every(_isPathInNegatedToken))
            return container.deniableFluentPathFactory(newContainer, {});
        return container.fluentPathFactory(newContainer, {});
    };
}

//# sourceMappingURL=alternativeFn.js.map
