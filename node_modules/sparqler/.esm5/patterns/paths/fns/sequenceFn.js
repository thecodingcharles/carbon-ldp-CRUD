import * as tslib_1 from "tslib";
import { PathSequenceToken } from "../../../tokens/PathSequenceToken";
import { FluentPathContainer } from "../FluentPathContainer";
import { getPropertyToken } from "../utils";
import { _getTokenWrapper } from "./utils";
var _getInSequenceToken = _getTokenWrapper("pathAlternative", "pathSequence");
export function getSequenceFn(container) {
    return function () {
        var paths = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            paths[_i] = arguments[_i];
        }
        var _a;
        var tokensParams = paths
            .reduce(function (array, paths) { return array.concat(paths); }, [])
            .map(function (path) { return getPropertyToken(container, path); });
        if (container.targetToken && !(container.targetToken instanceof PathSequenceToken))
            tokensParams.unshift(container.targetToken);
        var processedTokens = tokensParams
            .map(_getInSequenceToken);
        if (container.targetToken instanceof PathSequenceToken)
            processedTokens.unshift.apply(processedTokens, container.targetToken.paths);
        var targetToken = new PathSequenceToken();
        (_a = targetToken.paths).push.apply(_a, processedTokens);
        var newContainer = new FluentPathContainer(tslib_1.__assign({}, container, { targetToken: targetToken }));
        return container.fluentPathFactory(newContainer, {});
    };
}

//# sourceMappingURL=sequenceFn.js.map
