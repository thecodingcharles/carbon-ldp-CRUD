{"version":3,"sources":["patterns/paths/fns/alternativeFn.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,oBAAoB,EAAE,MAAM,sCAAsC,CAAC;AAS5E,OAAO,EAAE,mBAAmB,EAAE,MAAM,wBAAwB,CAAC;AAE7D,OAAO,EAAE,gBAAgB,EAAE,MAAM,UAAU,CAAC;AAE5C,OAAO,EAAE,gBAAgB,EAAE,qBAAqB,EAAE,MAAM,SAAS,CAAC;AAOlE,IAAM,sBAAsB,GAAG,gBAAgB,CAA0B,iBAAiB,CAAE,CAAC;AAM7F,MAAM,UAAU,gBAAgB,CAAuB,SAAoD;IAC1G,OAAO;QAAE,eAA0C;aAA1C,UAA0C,EAA1C,qBAA0C,EAA1C,IAA0C;YAA1C,0BAA0C;;;QAClD,IAAM,YAAY,GAAe,KAAK;aACpC,MAAM,CAAkB,UAAE,KAAK,EAAE,KAAK,IAAM,OAAA,KAAK,CAAC,MAAM,CAAE,KAAK,CAAE,EAArB,CAAqB,EAAE,EAAE,CAAE;aACvE,GAAG,CAAE,UAAA,IAAI,IAAI,OAAA,gBAAgB,CAAE,SAAS,EAAE,IAAI,CAAE,EAAnC,CAAmC,CAAE,CAAC;QAGrD,IAAI,SAAS,CAAC,WAAW,IAAI,CAAE,CAAC,SAAS,CAAC,WAAW,YAAY,oBAAoB,CAAC;YACrF,YAAY,CAAC,OAAO,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;QAE/C,IAAM,eAAe,GAA4B,YAAY;aAC3D,GAAG,CAAE,sBAAsB,CAAE,CAAC;QAGhC,IAAI,SAAS,CAAC,WAAW,YAAY,oBAAoB;YACxD,eAAe,CAAC,OAAO,OAAvB,eAAe,EAAa,SAAS,CAAC,WAAW,CAAC,KAAK,EAAG;QAG3D,IAAM,WAAW,GAAe,IAAI,oBAAoB,EAAE,CAAC;QAC3D,CAAA,KAAA,WAAW,CAAC,KAAK,CAAA,CAAC,IAAI,WAAK,eAAe,EAAG;QAE7C,IAAM,YAAY,GAAoC,IAAI,mBAAmB,sBACzE,SAAS,IACZ,WAAW,aAAA,IACT,CAAC;QAGJ,IAAI,eAAe,CAAC,KAAK,CAAE,qBAAqB,CAAE;YACjD,OAAO,SAAS,CAAC,yBAAyB,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;QAEhE,OAAO,SAAS,CAAC,iBAAiB,CAAE,YAAY,EAAE,EAAE,CAAS,CAAC;IAC/D,CAAC,CAAA;AACF,CAAC","file":"alternativeFn.js","sourcesContent":["import { PathAlternativeToken } from \"../../../tokens/PathAlternativeToken\";\nimport { PathInAlternativeToken } from \"../../../tokens/PathInAlternativeToken\";\nimport { PathInNegatedToken } from \"../../../tokens/PathInNegatedToken\";\nimport { PathToken } from \"../../../tokens/PathToken\";\n\nimport { Resource } from \"../../triplePatterns/Resource\";\n\nimport { DeniableFluentPath } from \"../DeniableFluentPath\";\nimport { FluentPath } from \"../FluentPath\";\nimport { FluentPathContainer } from \"../FluentPathContainer\";\nimport { Path } from \"../Path\";\nimport { getPropertyToken } from \"../utils\";\n\nimport { _getTokenWrapper, _isPathInNegatedToken } from \"./utils\";\n\n\ntype TargetToken = PathAlternativeToken & PathAlternativeToken<PathInNegatedToken>;\n\ntype TargetParams = Resource | \"a\" | string | Path<PathToken>;\n\nconst _getInAlternativeToken = _getTokenWrapper<PathInAlternativeToken>( \"pathAlternative\" );\n\n\nexport type AlternativeFn<T extends PathToken> = ( ...paths:((Resource | \"a\" | string | Path<PathToken>) | (Resource | \"a\" | string | Path<PathToken>)[])[] )\n\t=> (T extends PathInNegatedToken ? DeniableFluentPath<PathAlternativeToken<PathInNegatedToken>> : FluentPath<PathAlternativeToken>) & DeniableFluentPath<PathAlternativeToken<PathInNegatedToken>>;\n\nexport function getAlternativeFn<T extends PathToken>( container:FluentPathContainer<undefined | PathToken> ):AlternativeFn<T> {\n\treturn ( ...paths:(TargetParams | TargetParams[])[] ) => {\n\t\tconst tokensParams:PathToken[] = paths\n\t\t\t.reduce<TargetParams[]>( ( array, paths ) => array.concat( paths ), [] )\n\t\t\t.map( path => getPropertyToken( container, path ) );\n\n\t\t// [In FluentPath] Add to process when not alternative\n\t\tif( container.targetToken && ! (container.targetToken instanceof PathAlternativeToken) )\n\t\t\ttokensParams.unshift( container.targetToken );\n\n\t\tconst processedTokens:PathInAlternativeToken[] = tokensParams\n\t\t\t.map( _getInAlternativeToken );\n\n\t\t// [In FluentPath] Extends if path alternative, not process needed\n\t\tif( container.targetToken instanceof PathAlternativeToken )\n\t\t\tprocessedTokens.unshift( ...container.targetToken.paths );\n\n\n\t\tconst targetToken:TargetToken = new PathAlternativeToken();\n\t\ttargetToken.paths.push( ...processedTokens );\n\n\t\tconst newContainer:FluentPathContainer<TargetToken> = new FluentPathContainer( {\n\t\t\t...container,\n\t\t\ttargetToken,\n\t\t} );\n\n\n\t\tif( processedTokens.every( _isPathInNegatedToken ) )\n\t\t\treturn container.deniableFluentPathFactory( newContainer, {} );\n\n\t\treturn container.fluentPathFactory( newContainer, {} ) as any;\n\t}\n}"],"sourceRoot":"../../../../src"}