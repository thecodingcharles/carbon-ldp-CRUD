{"version":3,"sources":["patterns/paths/FluentPath.ts"],"names":[],"mappings":";;AAaA,qDAAuD;AACvD,6CAA+C;AAC/C,qCAAuC;AACvC,+CAAiD;AACjD,6CAA+C;AAE/C,+BAA8B;AA4DjB,QAAA,UAAU,GAcnB;IACH,UAAU,EAAV,UAAmD,SAAgC,EAAE,MAAQ;QAC5F,OAAO,WAAI,CAAC,UAAU,CAAE,SAAS,EAAE,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YACzD,OAAO,EAAE,wBAAY,CAAK,SAAS,CAAE;YAErC,EAAE,EAAE,gCAAgB,CAAK,SAAS,CAAE;YACpC,IAAI,EAAE,0BAAa,CAAE,SAAS,CAAE;YAEhC,OAAO,EAAE,wBAAY,CAAK,SAAS,CAAE;YAErC,SAAS,EAAE,gBAAQ,CAAE,SAAS,EAAE,GAAG,CAAE;YACrC,UAAU,EAAE,gBAAQ,CAAE,SAAS,EAAE,GAAG,CAAE;YACtC,UAAU,EAAE,gBAAQ,CAAE,SAAS,EAAE,GAAG,CAAE;SACtC,CAAE,CAAE,CAAC;IACP,CAAC;CACD,CAAC","file":"FluentPath.js","sourcesContent":["import { IRIToken } from \"../../tokens/IRIToken\";\nimport { PathAlternativeToken } from \"../../tokens/PathAlternativeToken\";\nimport { PathInNegatedToken } from \"../../tokens/PathInNegatedToken\";\nimport { PathInverseToken } from \"../../tokens/PathInverseToken\";\nimport { PathModToken } from \"../../tokens/PathModToken\";\nimport { PathSequenceToken } from \"../../tokens/PathSequenceToken\";\nimport { PathToken } from \"../../tokens/PathToken\";\nimport { SubPathToken } from \"../../tokens/SubPathToken\";\n\nimport { Resource } from \"../triplePatterns/Resource\";\nimport { DeniableFluentPath } from \"./DeniableFluentPath\";\n\nimport { FluentPathContainer } from \"./FluentPathContainer\";\nimport { getAlternativeFn } from \"./fns/alternativeFn\";\nimport { getInverseFn } from \"./fns/inverseFn\";\nimport { getModFn } from \"./fns/modFn\";\nimport { getSequenceFn } from \"./fns/sequenceFn\";\nimport { getSubPathFn } from \"./fns/subPathFn\";\n\nimport { Path } from \"./Path\";\n\n\n/**\n * The interface with the methods for constructing a path with in\n * a fluent mode.\n *\n * Example:\n * ```typescript\n * _.inverse( \"ex:path1\" ) // ^ex:path1\n *     .then( \"ex:path2\" ) // ^ex:path1 / ex:path2\n *     .onceOrMore()       // (^ex:path1 / ex:path2)+\n * ```\n */\nexport interface FluentPath<T extends PathToken = PathToken> extends Path<T> {\n\t/**\n\t * Wrap the current path as a sub-path.\n\t */\n\tsubPath():T extends PathInNegatedToken ? DeniableFluentPath<SubPathToken<T>> : FluentPath<SubPathToken<T>>;\n\n\n\t/**\n\t * Add alternative paths from the current one.\n\t * @param paths The to be added as alternatives.\n\t */\n\tor( ...paths:((Resource | \"a\" | string | Path<PathInNegatedToken>) | (Resource | \"a\" | string | Path<PathInNegatedToken>)[])[] ):T extends PathInNegatedToken ? DeniableFluentPath<PathAlternativeToken<PathInNegatedToken>> : FluentPath<PathAlternativeToken>;\n\tor( ...paths:((Resource | \"a\" | string | Path<PathToken>) | (Resource | \"a\" | string | Path<PathToken>)[])[] ):FluentPath<PathAlternativeToken>;\n\n\t/**\n\t * Add sequence paths from the current one.\n\t * @param paths The paths to be added as a sequence.\n\t */\n\tthen( ...paths:((Resource | \"a\" | string | Path<PathToken>) | (Resource | \"a\" | string | Path<PathToken>)[])[] ):FluentPath<PathSequenceToken>;\n\n\n\t/**\n\t * Change the current path to be an inverse path.\n\t */\n\tinverse():T extends PathInNegatedToken ? DeniableFluentPath<PathInverseToken<IRIToken | \"a\">> : FluentPath<PathInverseToken>;\n\n\n\t/**\n\t * Add the one or none mod (?) into the current path.\n\t */\n\toneOrNone():FluentPath<PathModToken>;\n\n\t/**\n\t * Add the zero or more mod (*) into the current path.\n\t */\n\tzeroOrMore():FluentPath<PathModToken>;\n\n\t/**\n\t * Add the once or more mod (+) into the current path.\n\t */\n\tonceOrMore():FluentPath<PathModToken>;\n}\n\n/**\n * Constant with the utils for {@link FluentPath} objects.\n */\nexport const FluentPath:{\n\t/**\n\t * Factory function that allows to crete a {@link FluentPath}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link FluentPath} statement.\n\t * @param object The base base from where to create the\n\t * {@link FluentPath} statement.\n\t *\n\t * @return The {@link FluentPath} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<T extends PathToken, O extends object>( container:FluentPathContainer<T>, object:O ):O & FluentPath<T>;\n} = {\n\tcreateFrom<T extends PathToken, O extends object>( container:FluentPathContainer<T>, object:O ):O & FluentPath<T> {\n\t\treturn Path.createFrom( container, Object.assign( object, {\n\t\t\tsubPath: getSubPathFn<T>( container ),\n\n\t\t\tor: getAlternativeFn<T>( container ),\n\t\t\tthen: getSequenceFn( container ),\n\n\t\t\tinverse: getInverseFn<T>( container ),\n\n\t\t\toneOrNone: getModFn( container, \"?\" ),\n\t\t\tzeroOrMore: getModFn( container, \"*\" ),\n\t\t\tonceOrMore: getModFn( container, \"+\" ),\n\t\t} ) );\n\t},\n};\n"],"sourceRoot":"../../../src"}