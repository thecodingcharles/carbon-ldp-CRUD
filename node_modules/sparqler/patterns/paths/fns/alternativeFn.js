"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var PathAlternativeToken_1 = require("../../../tokens/PathAlternativeToken");
var FluentPathContainer_1 = require("../FluentPathContainer");
var utils_1 = require("../utils");
var utils_2 = require("./utils");
var _getInAlternativeToken = utils_2._getTokenWrapper("pathAlternative");
function getAlternativeFn(container) {
    return function () {
        var paths = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            paths[_i] = arguments[_i];
        }
        var _a;
        var tokensParams = paths
            .reduce(function (array, paths) { return array.concat(paths); }, [])
            .map(function (path) { return utils_1.getPropertyToken(container, path); });
        if (container.targetToken && !(container.targetToken instanceof PathAlternativeToken_1.PathAlternativeToken))
            tokensParams.unshift(container.targetToken);
        var processedTokens = tokensParams
            .map(_getInAlternativeToken);
        if (container.targetToken instanceof PathAlternativeToken_1.PathAlternativeToken)
            processedTokens.unshift.apply(processedTokens, container.targetToken.paths);
        var targetToken = new PathAlternativeToken_1.PathAlternativeToken();
        (_a = targetToken.paths).push.apply(_a, processedTokens);
        var newContainer = new FluentPathContainer_1.FluentPathContainer(tslib_1.__assign({}, container, { targetToken: targetToken }));
        if (processedTokens.every(utils_2._isPathInNegatedToken))
            return container.deniableFluentPathFactory(newContainer, {});
        return container.fluentPathFactory(newContainer, {});
    };
}
exports.getAlternativeFn = getAlternativeFn;

//# sourceMappingURL=alternativeFn.js.map
