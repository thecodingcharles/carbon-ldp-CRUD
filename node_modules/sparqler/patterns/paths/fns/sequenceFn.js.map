{"version":3,"sources":["patterns/paths/fns/sequenceFn.ts"],"names":[],"mappings":";;;AACA,uEAAsE;AAMtE,8DAA6D;AAE7D,kCAA4C;AAE5C,iCAA2C;AAK3C,IAAM,mBAAmB,GAAG,wBAAgB,CAAuB,iBAAiB,EAAE,cAAc,CAAE,CAAC;AAMvG,SAAgB,aAAa,CAAE,SAAoD;IAClF,OAAO;QAAE,eAA0C;aAA1C,UAA0C,EAA1C,qBAA0C,EAA1C,IAA0C;YAA1C,0BAA0C;;;QAClD,IAAM,YAAY,GAAe,KAAK;aACpC,MAAM,CAAkB,UAAE,KAAK,EAAE,KAAK,IAAM,OAAA,KAAK,CAAC,MAAM,CAAE,KAAK,CAAE,EAArB,CAAqB,EAAE,EAAE,CAAE;aACvE,GAAG,CAAE,UAAA,IAAI,IAAI,OAAA,wBAAgB,CAAE,SAAS,EAAE,IAAI,CAAE,EAAnC,CAAmC,CAAE,CAAC;QAGrD,IAAI,SAAS,CAAC,WAAW,IAAI,CAAE,CAAC,SAAS,CAAC,WAAW,YAAY,qCAAiB,CAAC;YAClF,YAAY,CAAC,OAAO,CAAE,SAAS,CAAC,WAAW,CAAE,CAAC;QAE/C,IAAM,eAAe,GAAyB,YAAY;aACxD,GAAG,CAAE,mBAAmB,CAAE,CAAC;QAG7B,IAAI,SAAS,CAAC,WAAW,YAAY,qCAAiB;YACrD,eAAe,CAAC,OAAO,OAAvB,eAAe,EAAa,SAAS,CAAC,WAAW,CAAC,KAAK,EAAG;QAG3D,IAAM,WAAW,GAAqB,IAAI,qCAAiB,EAAE,CAAC;QAC9D,CAAA,KAAA,WAAW,CAAC,KAAK,CAAA,CAAC,IAAI,WAAK,eAAe,EAAG;QAE7C,IAAM,YAAY,GAA0C,IAAI,yCAAmB,sBAC/E,SAAS,IACZ,WAAW,aAAA,IACT,CAAC;QAEJ,OAAO,SAAS,CAAC,iBAAiB,CAAE,YAAY,EAAE,EAAE,CAAE,CAAC;IACxD,CAAC,CAAA;AACF,CAAC;AA5BD,sCA4BC","file":"sequenceFn.js","sourcesContent":["import { PathInSequenceToken } from \"../../../tokens/PathInSequenceToken\";\nimport { PathSequenceToken } from \"../../../tokens/PathSequenceToken\";\nimport { PathToken } from \"../../../tokens/PathToken\";\n\nimport { Resource } from \"../../triplePatterns/Resource\";\n\nimport { FluentPath } from \"../FluentPath\";\nimport { FluentPathContainer } from \"../FluentPathContainer\";\nimport { Path } from \"../Path\";\nimport { getPropertyToken } from \"../utils\";\n\nimport { _getTokenWrapper } from \"./utils\";\n\n\ntype TargetParams = Resource | \"a\" | string | Path<PathToken>;\n\nconst _getInSequenceToken = _getTokenWrapper<PathInSequenceToken>( \"pathAlternative\", \"pathSequence\" );\n\n\nexport type SequenceFn = ( ...paths:((Resource | \"a\" | string | Path<PathToken>) | (Resource | \"a\" | string | Path<PathToken>)[])[] )\n\t=> FluentPath<PathSequenceToken>;\n\nexport function getSequenceFn( container:FluentPathContainer<undefined | PathToken> ):SequenceFn {\n\treturn ( ...paths:(TargetParams | TargetParams[])[] ):any => {\n\t\tconst tokensParams:PathToken[] = paths\n\t\t\t.reduce<TargetParams[]>( ( array, paths ) => array.concat( paths ), [] )\n\t\t\t.map( path => getPropertyToken( container, path ) );\n\n\t\t// [In FluentPath] Add to process when not sequence\n\t\tif( container.targetToken && ! (container.targetToken instanceof PathSequenceToken) )\n\t\t\ttokensParams.unshift( container.targetToken );\n\n\t\tconst processedTokens:PathInSequenceToken[] = tokensParams\n\t\t\t.map( _getInSequenceToken );\n\n\t\t// [In FluentPath] Extends if path alternative, not process needed\n\t\tif( container.targetToken instanceof PathSequenceToken )\n\t\t\tprocessedTokens.unshift( ...container.targetToken.paths );\n\n\n\t\tconst targetToken:PathSequenceToken = new PathSequenceToken();\n\t\ttargetToken.paths.push( ...processedTokens );\n\n\t\tconst newContainer:FluentPathContainer<PathSequenceToken> = new FluentPathContainer( {\n\t\t\t...container,\n\t\t\ttargetToken,\n\t\t} );\n\n\t\treturn container.fluentPathFactory( newContainer, {} );\n\t}\n}"],"sourceRoot":"../../../../src"}