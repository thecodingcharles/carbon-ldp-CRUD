{"version":3,"sources":["patterns/paths/PathBuilder.ts"],"names":[],"mappings":";;AAiBA,qDAAuD;AACvD,6CAA+C;AAC/C,qCAAuC;AACvC,6CAA+C;AAC/C,+CAAiD;AACjD,6CAA+C;AA6ElC,QAAA,WAAW,GAcpB;IACH,UAAU,EAAV,UAA8B,SAAwC,EAAE,MAAQ;QAC/E,OAAO,MAAM,CAAC,MAAM,CAAE,MAAM,EAAE;YAC7B,OAAO,EAAE,wBAAY,CAAE,SAAS,CAAE;YAElC,YAAY,EAAE,gCAAgB,CAAE,SAAS,CAAE;YAC3C,SAAS,EAAE,0BAAa,CAAE,SAAS,CAAE;YAErC,OAAO,EAAE,wBAAY,CAAE,SAAS,CAAE;YAClC,OAAO,EAAE,wBAAY,CAAE,SAAS,CAAE;YAElC,SAAS,EAAE,gBAAQ,CAAE,SAAS,EAAE,GAAG,CAAE;YACrC,UAAU,EAAE,gBAAQ,CAAE,SAAS,EAAE,GAAG,CAAE;YACtC,UAAU,EAAE,gBAAQ,CAAE,SAAS,EAAE,GAAG,CAAE;SACtC,CAAE,CAAC;IACL,CAAC;CACD,CAAC","file":"PathBuilder.js","sourcesContent":["import { IRIToken } from \"../../tokens/IRIToken\";\nimport { PathAlternativeToken } from \"../../tokens/PathAlternativeToken\";\nimport { PathInNegatedToken } from \"../../tokens/PathInNegatedToken\";\nimport { PathInverseToken } from \"../../tokens/PathInverseToken\";\nimport { PathModToken } from \"../../tokens/PathModToken\";\nimport { PathNegatedToken } from \"../../tokens/PathNegatedToken\";\nimport { PathSequenceToken } from \"../../tokens/PathSequenceToken\";\nimport { PathToken } from \"../../tokens/PathToken\";\nimport { SubPathInNegatedToken } from \"../../tokens/SubPathInNegatedToken\";\nimport { SubPathToken } from \"../../tokens/SubPathToken\";\n\nimport { Resource } from \"../triplePatterns/Resource\";\n\nimport { DeniableFluentPath } from \"./DeniableFluentPath\";\nimport { FluentPath } from \"./FluentPath\";\n\nimport { FluentPathContainer } from \"./FluentPathContainer\";\nimport { getAlternativeFn } from \"./fns/alternativeFn\";\nimport { getInverseFn } from \"./fns/inverseFn\";\nimport { getModFn } from \"./fns/modFn\";\nimport { getNegatedFn } from \"./fns/negatedFn\";\nimport { getSequenceFn } from \"./fns/sequenceFn\";\nimport { getSubPathFn } from \"./fns/subPathFn\";\n\nimport { Path } from \"./Path\";\n\n\n/**\n * Builder with the methods that helps you to construct any path.\n *\n * See {@link https://www.w3.org/TR/sparql11-query/#propertypaths} for\n * more information.\n */\nexport interface PathBuilder {\n\t/**\n\t * Create a sub-path from a property or path.\n\t * @param path the path to be added as in the sub-path.\n\t */\n\tsubPath( path?:Resource | \"a\" | string | Path<PathInNegatedToken | PathAlternativeToken<PathInNegatedToken>> ):DeniableFluentPath<SubPathInNegatedToken>;\n\tsubPath( path:Path ):FluentPath<SubPathToken<PathToken>>;\n\n\n\t/**\n\t * Create a alternative path from the paths.\n\t * @param paths The paths to be added as alternate options.\n\t */\n\talternatives( ...paths:((Resource | \"a\" | string | Path<PathInNegatedToken>) | (Resource | \"a\" | string | Path<PathInNegatedToken>)[])[] ):DeniableFluentPath<PathAlternativeToken<PathInNegatedToken>>;\n\talternatives( ...paths:((Resource | \"a\" | string | Path<PathToken>) | (Resource | \"a\" | string | Path<PathToken>)[])[] ):FluentPath<PathAlternativeToken>;\n\n\t/**\n\t * Create a sequence path from the paths.\n\t * @param paths The paths to be added as path sequence.\n\t */\n\tsequences( ...paths:((Resource | \"a\" | string | Path<PathToken>) | (Resource | \"a\" | string | Path<PathToken>)[])[] ):FluentPath<PathSequenceToken>;\n\n\n\t/**\n\t * Create an inverse path from another one.\n\t * @param path The path to be inverted.\n\t */\n\tinverse( path:Resource | \"a\" | string | Path<IRIToken | \"a\"> ):DeniableFluentPath<PathInverseToken<IRIToken | \"a\">>;\n\tinverse( path:Resource | \"a\" | string | Path<PathToken> ):FluentPath<PathInverseToken>;\n\n\t/**\n\t * Create an negated path from the another one.\n\t * @param path The path to be negated.\n\t */\n\tnegated( path:Resource | \"a\" | string | Path<PathInNegatedToken | SubPathInNegatedToken | PathAlternativeToken<PathInNegatedToken>> ):FluentPath<PathNegatedToken>;\n\n\n\t/**\n\t * Set the path to be matched one or zero times.\n\t * i.e. the `?` mod.\n\t *\n\t * @param path The path to add the mod.\n\t */\n\toneOrNone( path:Resource | \"a\" | string | Path<PathToken> ):FluentPath<PathModToken>;\n\n\t/**\n\t * Set the path to be matched zero or more times.\n\t * i.e. the `*` mod.\n\t *\n\t * @param path The path to add the mod.\n\t */\n\tzeroOrMore( path:Resource | \"a\" | string | Path<PathToken> ):FluentPath<PathModToken>;\n\n\t/**\n\t * Set the path to be matched one or more times.\n\t * i.e. the `+` mod.\n\t *\n\t * @param path The path to add the mod.\n\t */\n\tonceOrMore( path:Resource | \"a\" | string | Path<PathToken> ):FluentPath<PathModToken>;\n}\n\n\n/**\n * Constant with the utils for {@link PathBuilder} objects.\n */\nexport const PathBuilder:{\n\t/**\n\t * Factory function that allows to crete a {@link PathBuilder}\n\t * from the {@param object} provided.\n\t *\n\t * @param container The related container with the data for the\n\t * {@link PathBuilder} statement.\n\t * @param object The base base from where to create the\n\t * {@link PathBuilder} statement.\n\t *\n\t * @return The {@link PathBuilder} statement created from the\n\t * {@param object} provided.\n\t */\n\tcreateFrom<O extends object>( container:FluentPathContainer<undefined>, object:O ):O & PathBuilder;\n} = {\n\tcreateFrom<O extends object>( container:FluentPathContainer<undefined>, object:O ):O & PathBuilder {\n\t\treturn Object.assign( object, {\n\t\t\tsubPath: getSubPathFn( container ),\n\n\t\t\talternatives: getAlternativeFn( container ),\n\t\t\tsequences: getSequenceFn( container ),\n\n\t\t\tinverse: getInverseFn( container ),\n\t\t\tnegated: getNegatedFn( container ),\n\n\t\t\toneOrNone: getModFn( container, \"?\" ),\n\t\t\tzeroOrMore: getModFn( container, \"*\" ),\n\t\t\tonceOrMore: getModFn( container, \"+\" ),\n\t\t} );\n\t}\n};\n"],"sourceRoot":"../../../src"}