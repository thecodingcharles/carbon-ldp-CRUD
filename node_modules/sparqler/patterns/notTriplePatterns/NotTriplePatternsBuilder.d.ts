import { Container } from "../../data/Container";
import { Pattern } from "../Pattern";
import { Resource } from "../triplePatterns/Resource";
import { Variable } from "../triplePatterns/Variable";
import { Undefined } from "../Undefined";
import { BindPattern } from "./BindPattern";
import { FilterPattern } from "./FilterPattern";
import { GraphPattern } from "./GraphPattern";
import { GroupPattern } from "./GroupPattern";
import { MinusPattern } from "./MinusPattern";
import { MultipleValuesPattern } from "./MultipleValuesPattern";
import { OptionalPattern } from "./OptionalPattern";
import { ServicePattern } from "./ServicePattern";
import { SingleValuesPattern } from "./SingleValuesPattern";
import { UnionPattern } from "./UnionPattern";
/**
 * Builder for non triple based patterns.
 */
export interface NotTriplePatternsBuilder {
    /**
     * Property por a quickly access to the `"UNDEF"` keyword.
     */
    undefined: Undefined;
    /**
     * Creates a {@link GraphPattern} for the target named graph
     * specified by {@param iri}, having the patterns specified.
     *
     * See {@link https://www.w3.org/TR/sparql11-query/#accessByLabel}
     * for more information.
     *
     * @param iri The target graph to have the patterns.
     * @param patterns The patterns to match for the target graph.
     */
    graph(iri: string | Resource | Variable, patterns: Pattern | Pattern[]): GraphPattern;
    /**
     * Creates a {@link GroupPattern} for the patterns specified,
     * where will group the patterns in a new pattern.
     *
     * See {@link https://www.w3.org/TR/sparql11-query/#GroupPatterns}
     * for more information.
     *
     * @param patterns The patterns to be enclosed in a group.
     */
    group(patterns: Pattern | Pattern[]): GroupPattern;
    /**
     * Creates a {@link UnionPattern} for the patterns specified,
     * where will group the pattern to be used as an alternative
     * matching for another group declared by the subsequents
     * {@link UnionPattern.and} methods.
     *
     * See {@link https://www.w3.org/TR/sparql11-query/#alternatives}
     * for more information.
     *
     * @param patterns The patterns to be enclosed in a group.
     */
    union(patterns: Pattern | Pattern[]): UnionPattern;
    /**
     * Creates an {@link OptionalPattern} for the patterns specified,
     * which will be considered as optional to match and retrieve.
     *
     * See {@link https://www.w3.org/TR/sparql11-query/#optionals}
     * for more information.
     *
     * @param patterns The patterns to be enclosed in a optional
     * group.
     */
    optional(patterns: Pattern | Pattern[]): OptionalPattern;
    /**
     * Creates a {@link MinusPattern} for the patterns specified
     * which will be excluded from the query.
     *
     * See {@link https://www.w3.org/TR/sparql11-query/#neg-minus}
     * for more information.
     *
     * @param patterns The patterns to be enclosed in a minus
     * group.
     */
    minus(patterns: Pattern | Pattern[]): MinusPattern;
    /**
     * Creates a {@link ServicePattern} for the target resource
     * service and the patterns specified.
     *
     * See {@link https://www.w3.org/TR/sparql11-federated-query/}
     * for more information.
     *
     * @param resource The service where to execute the federated
     * query.
     * @param patterns The patterns of the target service.
     */
    service(resource: string | Resource | Variable, patterns: Pattern | Pattern[]): ServicePattern;
    /**
     * Creates a silent {@link ServicePattern} for the target resource
     * service and the patterns specified.
     *
     * See {@link https://www.w3.org/TR/sparql11-federated-query/}
     * for more information.
     *
     * @param resource The service where to execute the federated
     * query.
     * @param patterns The patterns of the target service.
     */
    serviceSilent(resource: string | Resource | Variable, patterns: Pattern | Pattern[]): ServicePattern;
    /**
     * Create a {@link FilterPattern} for the raw constraint.
     *
     * This is used to exclude values or entire patterns.
     * See {@link https://www.w3.org/TR/sparql11-query/#termConstraint
     * and {@link https://www.w3.org/TR/sparql11-query/#negation} to
     * know more.
     *
     * @param rawConstraint The RAW constraint to filter.
     */
    filter(rawConstraint: string): FilterPattern;
    /**
     * Created a {@link BindPattern} for the raw expression
     * into the variable specified.
     *
     * See {@link https://www.w3.org/TR/sparql11-query/#bind}
     * for more information.
     *
     * @param rawExpression The RAW expression to assign.
     * @param variable The variable to be assigned.
     */
    bind(rawExpression: string, variable: string | Variable): BindPattern;
    /**
     * Create a {@link SingleValuesPattern} for the variable
     * specified.
     *
     * This is used to assign data to an specific variable.
     *
     * See {@link https://www.w3.org/TR/sparql11-query/#inline-data}
     * for more information.
     *
     * @param variable The variable to assign data.
     */
    values(variable: Variable): SingleValuesPattern;
    /**
     * Create a {@link MultipleValuesPattern} for the variables
     * specified.
     *
     * This is used to assign data to multiple variables.
     *
     * See {@link https://www.w3.org/TR/sparql11-query/#inline-data}
     * for more information.
     *
     * @param variables The variables to assign data.
     */
    values(...variables: Variable[]): MultipleValuesPattern;
}
/**
 * Constant with the utils for {@link NotTriplePatternsBuilder} objects.
 */
export declare const NotTriplePatternsBuilder: {
    /**
     * Factory function that allows to crete a {@link NotTriplePatternsBuilder}
     * from the {@param object} provided.
     *
     * @param container The related container with the data for the
     * {@link NotTriplePatternsBuilder} statement.
     * @param object The base base from where to create the
     * {@link NotTriplePatternsBuilder} statement.
     *
     * @return The {@link NotTriplePatternsBuilder} statement created from the
     * {@param object} provided.
     */
    createFrom<O extends object>(container: Container<undefined>, object: O): O & NotTriplePatternsBuilder;
};
