import { Container } from "../data/Container";
import { Factory } from "../data/Factory";
import { AskToken } from "../tokens/AskToken";
import { QueryToken } from "../tokens/QueryToken";
import { SelectToken } from "../tokens/SelectToken";
import { FinishClause } from "./FinishClause";
import { WhereClause } from "./WhereClause";
/**
 * Interface with the methods available to make a FROM statement.
 */
export interface FromClause<T extends FinishClause> extends WhereClause<T> {
    /**
     * Set a default graph to be included as the RDF Dataset where to
     * look for the query solutions.
     *
     * @param iri IRI of the default graph to be included.
     * @returns Object with the methods to keep constructing to query.
     */
    from(iri: string): FromClause<T>;
    /**
     * Set a named graph to be included as the RDF Dataset where to look for
     * the query solutions.
     *
     * @param iri IRI of the named graph to be included.
     * @returns Object with the methods to keep constructing the query.
     */
    fromNamed(iri: string): FromClause<T>;
}
/**
 * Constant with the utils for {@link FromClause} objects.
 */
export declare const FromClause: {
    /**
     * Factory function that allows to crete a {@link FromClause}
     * from the {@param object} provided.
     *
     * @param genericFactory The factory to create the generic finish
     * of the {@link FromClause} statement.
     * @param container The related container with the data for the
     * {@link FromClause} statement.
     * @param object The base base from where to create the
     * {@link FromClause} statement.
     *
     * @return The {@link FromClause} statement created from the
     * {@param object} provided.
     */
    createFrom<C extends Container<QueryToken<SelectToken | AskToken>>, T extends FinishClause, O extends object>(genericFactory: Factory<C, T>, container: C, object: O): O & FromClause<T>;
};
