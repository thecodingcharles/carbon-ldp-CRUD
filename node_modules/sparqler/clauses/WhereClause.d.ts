import { Container } from "../data/Container";
import { Factory } from "../data/Factory";
import { Pattern } from "../patterns/Pattern";
import { PatternBuilder } from "../patterns/PatternBuilder";
import { QueryClauseToken } from "../tokens/QueryClauseToken";
import { QueryToken } from "../tokens/QueryToken";
import { FinishClause } from "./FinishClause";
import { GroupClause } from "./GroupClause";
/**
 * Interface with the methods available to make a WHERE statement.
 */
export interface WhereClause<T extends FinishClause> {
    /**
     * Specifies the graph patterns the query should match to retrieve
     * the solutions results.
     *
     * This pattern are created by a pattern constructor function that
     * receives a {@link PatternBuilder} which is a class that exposes
     * the possible elements and configurations the patterns chan have.
     *
     * @param patternFunction Function that retrieves a pattern or an
     * array of patterns to match.
     * @returns Object with the methods to keep constructing the query.
     */
    where(patternFunction: (builder: PatternBuilder) => Pattern | Pattern[]): GroupClause<T> & T;
}
/**
 * Constant with the utils for {@link WhereClause} objects.
 */
export declare const WhereClause: {
    /**
     * Factory function that allows to crete a {@link WhereClause}
     * from the {@param object} provided.
     *
     * @param genericFactory The factory to create the generic finish
     * of the {@link WhereClause} statement.
     * @param container The related container with the data for the
     * {@link WhereClause} statement.
     * @param object The base base from where to create the
     * {@link WhereClause} statement.
     *
     * @return The {@link WhereClause} statement created from the
     * {@param object} provided.
     */
    createFrom<C extends Container<QueryToken<QueryClauseToken>>, T extends FinishClause, O extends object>(genericFactory: Factory<typeof container, T>, container: C, object: O): O & WhereClause<T>;
};
